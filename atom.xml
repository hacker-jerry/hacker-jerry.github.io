<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>M@tr1xの日常</title>
  
  
  <link href="https://www.blog.hackerjerry.top/atom.xml" rel="self"/>
  
  <link href="https://www.blog.hackerjerry.top/"/>
  <updated>2021-05-26T12:23:07.895Z</updated>
  <id>https://www.blog.hackerjerry.top/</id>
  
  <author>
    <name>M@tr1x</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>区块链账户地址相关问题</title>
    <link href="https://www.blog.hackerjerry.top/2021/05/20/%E5%8C%BA%E5%9D%97%E9%93%BE%E8%B4%A6%E6%88%B7%E5%9C%B0%E5%9D%80%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/05/20/%E5%8C%BA%E5%9D%97%E9%93%BE%E8%B4%A6%E6%88%B7%E5%9C%B0%E5%9D%80%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98_new/</id>
    <published>2021-05-20T07:11:35.000Z</published>
    <updated>2021-05-26T12:23:07.895Z</updated>
    
    <content type="html"><![CDATA[<p>tags: [区块链]<br>categories: [区块链]<br>cover: “”<br>​</p><hr><p>​</p><a id="more"></a><h1 id="私钥、公钥和地址是如何生成的？"><a href="#私钥、公钥和地址是如何生成的？" class="headerlink" title="私钥、公钥和地址是如何生成的？"></a>私钥、公钥和地址是如何生成的？</h1><p>以太坊地址生成的流程也是：私钥 -&gt; 公钥 -&gt; 地址。因此地址的生成需要三步：</p><ol><li>生成一个随机的私钥（32 字节）-64 位的 16 进制字符</li><li>通过私钥生成公钥（64 字节）</li><li>通过公钥得到地址（20 字节）</li></ol><h2 id="第一步：私钥-private-key"><a href="#第一步：私钥-private-key" class="headerlink" title="第一步：私钥 (private key)"></a>第一步：私钥 (private key)</h2><p>伪随机数产生的 256bit 私钥示例(256bit  16 进制 32 字节)<br><code>18e14a7b6a307f426a94f8114701e7c8e774e7f9a47e2c2035db29a206321725</code><br>​</p><h2 id="第二步：公钥-public-key"><a href="#第二步：公钥-public-key" class="headerlink" title="第二步：公钥 (public key)"></a>第二步：公钥 (public key)</h2><ol><li>采用椭圆曲线数字签名算法 ECDSA-secp256k1 将私钥（32 字节）映射成公钥（65 字节）（前缀 04+X 公钥+Y 公钥）：</li></ol><p><code>0450863ad64a87ae8a2fe83c1af1a8403cb53f53e486d8511dad8a04887e5b23522cd470243453a299fa9e77237716103abc11a1df38855ed6f2ee187e9c582ba6</code></p><ol start="2"><li>拿公钥（非压缩公钥）来 hash，计算公钥的<strong>Keccak-256</strong>哈希值（32bytes）：</li></ol><p><code>fc12ad814631ba689f7abe67**1016f75c54c607f082ae6b0881fac0abeda21781**</code></p><ol start="3"><li>取上一步结果取后 20bytes 即以太坊地址：</li></ol><p><code>1016f75c54c607f082ae6b0881fac0abeda21781</code><br>​</p><h2 id="第三步：地址-address"><a href="#第三步：地址-address" class="headerlink" title="第三步：地址 (address)"></a>第三步：地址 (address)</h2><p><code>0x1016f75c54c607f082ae6b0881fac0abeda21781</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;tags: [区块链]&lt;br&gt;categories: [区块链]&lt;br&gt;cover: “”&lt;br&gt;​&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;​&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>生活周报-May-17-to-23</title>
    <link href="https://www.blog.hackerjerry.top/2021/05/20/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-May-17-to-23_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/05/20/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-May-17-to-23_new/</id>
    <published>2021-05-20T07:01:13.000Z</published>
    <updated>2021-05-26T12:20:29.155Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时讯"><a href="#时讯" class="headerlink" title="时讯"></a>时讯</h1><ol><li>祝融号发回遥测图像，很棒，中国航天 NB！</li><li>华强北的赛格大厦发生摇晃，事故原因正在调查中。</li><li>新垣结衣结婚啦，虽然我没有看过她的作品，但的确是一位看起来非常舒服的女星呢！《逃避虽可耻但有用》是她和他老公主演的电视剧，感觉会很有意思呢，以后有空了一定要看一看！</li><li>比特币开启熊市，距离 6W 美元的高点，目前已经跌破 3W 美元。伴随其的，是整个加密货币市场的全线崩盘，国家机器开始干预这个疯狂的市场。</li><li>南极洲最大冰山脱落，相当于 60%的上海。</li><li>云南大理 6.4 级地震。</li><li>青海 7.4 级地震。</li><li>5 月 22 日，袁隆平院士去世，享年 91 岁。</li><li>吴孟超院士去世，享年 99 岁。</li><li>甘肃白银景泰超级山地马拉松发生突发性局部恶劣天气，导致 21 名马拉松选手遇难。</li><li>大连宝马撞死 5 人，时速达 195km/h，现场视频非常可怕，系投资失败报复社会。</li></ol><h1 id="小事"><a href="#小事" class="headerlink" title="小事"></a>小事</h1><ol><li>去和导师面基了，表现的不是很好，有不少问题问题回答都有点问题，提升自己的能力 up,up!还有一个半月，来得及！</li><li>西交好和谐，在里面走有种在青岛的感觉！起伏的道路，到处合抱粗的梧桐，简直无比舒服！虽然楼很旧，但是老师很 nice，真的真的希望可以保研成功到西交呀！</li><li>无线安全实验把我搞迷了，实验成功率不高，特别容易收到干扰，比如我们一直没有收到自己的基站信号，别的人也收不到他们自己的基站信号。</li></ol><h1 id="本周收藏"><a href="#本周收藏" class="headerlink" title="本周收藏"></a>本周收藏</h1><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><ol><li>fuzzingbook2</li><li><a href="https://xz.aliyun.com/t/2582">通过 how2heap 复习堆利用 (一）</a></li><li><a href="https://www.anquanke.com/post/id/192823">How2Heap 堆利用学习笔记（一）</a></li><li><a href="https://bbs.pediy.com/thread-259269.htm">堆入门攻略-how2heap 学习总结</a></li><li>patchelf</li><li><a href="https://www.anquanke.com/post/id/86808">how2heap 总结-上</a></li><li><a href="https://www.anquanke.com/post/id/86809">how2heap 总结-下</a></li><li><a href="https://juejin.cn/post/6844903829952004104">how2heap 之 glibc——2.26 版本</a></li><li><a href="https://a1ex.online/2020/08/30/PWN-%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84glibc/">PWN_使用不同版本的 glibc</a></li><li><a href="https://github.com/matrix1001/glibc-all-in-one">https://github.com/matrix1001/glibc-all-in-one</a></li></ol><h2 id="剧集"><a href="#剧集" class="headerlink" title="剧集"></a>剧集</h2><p>无</p><h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><p>深度思考</p><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><ol><li>冒泡排序及优化、快排、希尔排序、堆排序、归并排序</li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li>我逐渐理解了为什么现在的大部分女生都不再社交平台秀恩爱，或者是简单的展示自己的恋爱状态。</li><li>这周世界非常混乱，周末短短几天，大地震、袁老千古，真的让人心乱，就和做梦似的。记得那天，上午还晴空，过了中午就开始阴云密布，狂风卷集着乌云，冷雨一直下，后到中雨，直至午夜。</li><li>长亭外，古道边，芳草碧连天。我参与了袁老的网上吊唁活动，寄念哀思，希望袁老能在天上继续保佑着华夏大地。</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-May-17-to-23-1.jpeg#clientId=u737e3495-1e5b-4&from=drop&height=373&id=u7705954a&margin=%5Bobject%20Object%5D&name=mmexport1621741590095.jpg&originHeight=1920&originWidth=1080&originalType=binary&size=1086399&status=done&style=none&taskId=u80329fcb-efdd-4906-9ef7-3f52be9694e&width=210" alt="mmexport1621741590095.jpg"></p><ol start="4"><li>一定要眼观六路，耳听八方。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;时讯&quot;&gt;&lt;a href=&quot;#时讯&quot; class=&quot;headerlink&quot; title=&quot;时讯&quot;&gt;&lt;/a&gt;时讯&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;祝融号发回遥测图像，很棒，中国航天 NB！&lt;/li&gt;
&lt;li&gt;华强北的赛格大厦发生摇晃，事故原因正在调查中。&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="周报" scheme="https://www.blog.hackerjerry.top/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>PAT算法刷题（1）</title>
    <link href="https://www.blog.hackerjerry.top/2021/05/15/PAT%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%EF%BC%881%EF%BC%89_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/05/15/PAT%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%EF%BC%881%EF%BC%89_new/</id>
    <published>2021-05-15T15:56:55.000Z</published>
    <updated>2021-05-26T12:19:53.263Z</updated>
    
    <content type="html"><![CDATA[<p>tags: []<br>categories: []<br>cover: “”<br>​</p><hr><p>开始</p><a id="more"></a><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><ol><li>浮点型不要用 float 定义，而要用 double 定义，因为精度问题，float 只能有效精度为 6 位左右。</li><li>ASCII 码中，小写字母比大写字母的 ASCII 码大 32，具体是 A<del>Z：65</del>90，a<del>z：97</del>122</li><li>位运算符：<ol><li>A&lt;&lt;x 左移，整数 A 按照二进制左移 x 位</li><li>a &amp; b 位与，整数 a 和 b 按二进制对齐，按照位进行<strong>与运算</strong></li><li>a | b 位或，整数 a 和 b 按二进制对齐，按照位进行<strong>或运算</strong></li><li>a ^ b 位异或，按位进行异或运算</li><li>~a，取反，整数 a 的二进制每一位取反</li></ol></li><li>scanf 的格式化输入–只记录几种不常用的<ol><li>long long 的输入 ：%lld</li><li>double 的输入： %lf</li><li>字符串（char 数组）: %s，注意，字符串输入不需要加&amp;进行取址，即 scanf(“%s”,str)是正确的。（因为数组名称本身就代表这个数组第一个元素的地址，所以不需要加取地址）</li></ol></li><li>typedef 是给复杂的数据结构起别名的<ol><li>例 1： typedef long long LL;//给 long long 起别名 LL</li></ol></li><li>一些常用的 math 函数<ol><li>floor(double x)–向下取整</li><li>ceil(double x)–向上取整</li><li>log()–用于返回以自然对数为底的对数<ol><li>注意，c 里面没有对任意底数求对数的函数，必须用换底公式 log_a{b}=log_e{b}/log_e{a}</li></ol></li><li>sin,cos,tan–三角函数，必须是弧度制，即 pi/2 一类的</li><li>asin,acos–返回 double 的三角函数值</li></ol></li><li>switch</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">    <span class="keyword">case</span> 常量结果<span class="number">1</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 结果<span class="number">2</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>数组初始化<ol><li>比如 <code>int a[10] = &#123;0&#125;;</code>就可以把整个数组都赋值 0，或者<code>int a[10] = &#123;&#125;;</code>也可以做到</li><li>如果数组大小在 10 的 6 次方以上，需要将其定义在主函数之外，即静态存储区申请空间，如<code>int a[1000000];</code></li><li>memset-对数组中每个元素赋值相同值<ol><li>memset(数组名，值，sizeof(数组名))</li><li>建议只使用 memset 赋值 0 和-1，因为它是按字节赋值，比如 int 是 4 个字节</li><li>对于数组赋予其他值（比如 1），请使用 fill 函数</li></ol></li></ol></li><li>gets 识别\n 作为输入结束，因此使用 scanf 接收完之后，如果要使用 gets，需要先用 getchar()接收整数后的换行符</li><li>strlen()–字符串长度</li><li>strcmp(char a[].char b[])–字符串比较</li><li>strcpy(char a[].char b[])–把 b 字符串数组赋给 a 数组</li><li>字符串处理利器<ol><li>sscanf(char str[],”%d”,&amp; int n)–把字符串数组的内容以%d 的格式写到变量 n 中–从左到右</li><li>sprintf(char str[],”%d”,int n)–把整型变量 n 以%d 的格式写到 str 数组中，从右到左</li></ol></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;tags: []&lt;br&gt;categories: []&lt;br&gt;cover: “”&lt;br&gt;​&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;开始&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>生活周报-May-10-to-16</title>
    <link href="https://www.blog.hackerjerry.top/2021/05/15/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-May-10-to-16_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/05/15/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-May-10-to-16_new/</id>
    <published>2021-05-15T15:44:27.000Z</published>
    <updated>2021-05-26T12:23:10.855Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时讯"><a href="#时讯" class="headerlink" title="时讯"></a>时讯</h1><ol><li>成都 49 中跳楼案水落石出</li><li>比特币暴跌，20 万用户爆仓</li><li>盖茨被爆性丑闻</li><li>祝融火星探测器成功登录火星乌托邦平原</li></ol><h1 id="小事"><a href="#小事" class="headerlink" title="小事"></a>小事</h1><ol><li>又是暴雨，下的及时，下的巧妙，恰似那未曾萌芽的爱情。始于暴雨，终于暴雨。</li></ol><h1 id="本周收藏"><a href="#本周收藏" class="headerlink" title="本周收藏"></a>本周收藏</h1><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p>看到了哪些好文？</p><h2 id="剧集"><a href="#剧集" class="headerlink" title="剧集"></a>剧集</h2><p>追了哪些剧？</p><h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><p>深度思考</p><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><p>又学了哪些新知识?</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>关于人生，关于体验</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;时讯&quot;&gt;&lt;a href=&quot;#时讯&quot; class=&quot;headerlink&quot; title=&quot;时讯&quot;&gt;&lt;/a&gt;时讯&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;成都 49 中跳楼案水落石出&lt;/li&gt;
&lt;li&gt;比特币暴跌，20 万用户爆仓&lt;/li&gt;
&lt;li&gt;盖茨被爆性丑闻&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="周报" scheme="https://www.blog.hackerjerry.top/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>图搜索算法学习</title>
    <link href="https://www.blog.hackerjerry.top/2021/05/11/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/05/11/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0_new/</id>
    <published>2021-05-11T07:53:33.000Z</published>
    <updated>2021-05-26T12:21:58.647Z</updated>
    
    <content type="html"><![CDATA[<p>本文将从图搜索算法的基本流程入手，层层递进地介绍几种图搜索算法。首先是两种针对无权图的基本图搜索算法：<strong>深度优先搜索(Depth First Search, DFS)**、</strong>广度优先搜索(Breadth First Search, BFS)<strong>。它们的区别在于 openlist(后面介绍)所选用的数据结构类型不同，前者使用栈，后者使用队列；之后引入一种启发式搜索算法：</strong>贪婪最佳优先算法*<em>(<strong>Greedy Best First Search, GBFS</strong>)，用来提高搜索效率，但是不能确保找到最优路径；最后介绍两种在路径规划中非常经典的算法：<strong>Dijkstra 算法</strong>、**A\</em>算法**，前者是广度优先算法(BFS)在带权图中的扩展，后者则是在前者中加入启发函数得到的算法，兼顾效率和完备性。</p><a id="more"></a><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>下面切入正题，图搜索算法的基本流程如下：</p><ul><li>创建一个容器，一般称为<strong>openlist</strong>，用来存储将要访问的节点</li><li>将起点加入容器</li><li>开始循环：</li><li>—- 弹出：从容器中取出一个节点</li><li>—- 扩展：获取该节点周围的节点，将这些节点放入容器</li></ul><p>作者：鬼木士链接：<a href="https://zhuanlan.zhihu.com/p/346666812%E6%9D%A5%E6%BA%90%EF%BC%9A%E7%9F%A5%E4%B9%8E%E8%91%97%E4%BD%9C%E6%9D%83%E5%BD%92%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E5%95%86%E4%B8%9A%E8%BD%AC%E8%BD%BD%E8%AF%B7%E8%81%94%E7%B3%BB%E4%BD%9C%E8%80%85%E8%8E%B7%E5%BE%97%E6%8E%88%E6%9D%83%EF%BC%8C%E9%9D%9E%E5%95%86%E4%B8%9A%E8%BD%AC%E8%BD%BD%E8%AF%B7%E6%B3%A8%E6%98%8E%E5%87%BA%E5%A4%84%E3%80%82">https://zhuanlan.zhihu.com/p/346666812来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</a></p><h3 id="图结构的邻接矩阵表示法"><a href="#图结构的邻接矩阵表示法" class="headerlink" title="图结构的邻接矩阵表示法"></a>图结构的邻接矩阵表示法</h3><p><strong>邻接矩阵</strong>用来表示图的边集，即节点间的相邻关系集合。设 <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725276356-ada93f8f-d8ba-4f17-98ec-9af058cd477f.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=u4bc6664d&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=102&originalType=url&status=done&style=none&taskId=u8e0433de-cbce-4ed5-b260-4e2f71ad8c0&width=51"> 是一个具有 n 个节点的图，它的邻接矩阵是一个 n 阶矩阵，则其中的元素 <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725276341-89563210-0b27-48f5-992c-5bc26999cdaa.svg#clientId=u4512e8b3-315c-4&from=paste&height=11&id=udc2dd334&margin=%5Bobject%20Object%5D&originHeight=21&originWidth=24&originalType=url&status=done&style=none&taskId=u2df13e1a-f9b8-4281-823a-168ccdf6e50&width=12"> 满足：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-1.svg#clientId=u4512e8b3-315c-4&from=paste&height=34&id=ubaaea0f0&margin=%5Bobject%20Object%5D&originHeight=68&originWidth=432&originalType=url&status=done&style=none&taskId=ud90780c7-8c45-4351-afd3-b4a40e55462&width=216"><br>对于无向图，其邻接矩阵是对称矩阵，即 <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725276360-06638203-15d1-4db8-9832-91cda47c94af.svg#clientId=u4512e8b3-315c-4&from=paste&height=11&id=u782dacff&margin=%5Bobject%20Object%5D&originHeight=21&originWidth=77&originalType=url&status=done&style=none&taskId=u190fa9eb-a53b-4d83-b57a-bcaa10caa34&width=38.5"> ，而有向图的邻接矩阵不一定对称，其空间复杂度均为 <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725276368-54baba56-84e8-456e-9a3a-2228ee191d73.svg#clientId=u4512e8b3-315c-4&from=paste&height=15&id=u082a2bca&margin=%5Bobject%20Object%5D&originHeight=29&originWidth=54&originalType=url&status=done&style=none&taskId=u3f3f3403-8b0c-41d0-9d2a-a53d9cf6fb2&width=27"> 。以下为两个不带权图的邻接矩阵示例：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-2.jpg#clientId=u4512e8b3-315c-4&from=paste&height=146&id=u6d0c1531&margin=%5Bobject%20Object%5D&originHeight=291&originWidth=300&originalType=url&status=done&style=none&taskId=ua9947cb2-a6f0-4a06-b876-917c53e91ed&width=150"><br>对于<strong>带权图</strong>，设 <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725276919-e8f40e24-f907-48d0-9439-9c210e6637b7.svg#clientId=u4512e8b3-315c-4&from=paste&height=14&id=ucc327eee&margin=%5Bobject%20Object%5D&originHeight=27&originWidth=71&originalType=url&status=done&style=none&taskId=udc0d541f-3cdf-48fb-bd16-1da62d51156&width=35.5"> 或者 <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725276928-11917431-d782-4dbc-afcd-7d8bfe260858.svg#clientId=u4512e8b3-315c-4&from=paste&height=8&id=u386178d2&margin=%5Bobject%20Object%5D&originHeight=15&originWidth=10&originalType=url&status=done&style=none&taskId=uf489f51a-13af-43ec-ba53-deea1911e98&width=5"> 上的权值为 <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725277029-5536e091-2e54-43da-acfc-3aee813c2193.svg#clientId=u4512e8b3-315c-4&from=paste&height=11&id=uaf1ce0d4&margin=%5Bobject%20Object%5D&originHeight=21&originWidth=28&originalType=url&status=done&style=none&taskId=u0cdccce9-6f0a-43c0-87fe-f34571b4c94&width=14"> ，则带权图的邻接矩阵定义为：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-3.svg#clientId=u4512e8b3-315c-4&from=paste&height=48&id=u5b09c490&margin=%5Bobject%20Object%5D&originHeight=95&originWidth=452&originalType=url&status=done&style=none&taskId=u09279262-4765-43c1-8607-7946ed5add6&width=226"><br>以下为两个带权图的邻接矩阵示例：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-4.jpg#clientId=u4512e8b3-315c-4&from=paste&height=156&id=ue0476deb&margin=%5Bobject%20Object%5D&originHeight=312&originWidth=300&originalType=url&status=done&style=none&taskId=ub5290b0d-99b5-4ace-9bc6-458f46faf37&width=150"></p><h2 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索(DFS)"></a>深度优先搜索(DFS)</h2><p>深度优先，顾名思义即深度越大的节点会被优先扩展。在 DFS 中，使用<strong>栈(Stack)**数据结构来实现上述特性。<br>栈是一种</strong>后进先出(LIFO)<strong>的容器，如下图<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-5.jpg#clientId=u4512e8b3-315c-4&from=paste&height=187&id=ub038a80c&margin=%5Bobject%20Object%5D&originHeight=229&originWidth=252&originalType=url&status=done&style=none&taskId=u32928bb0-c0d9-4527-918f-e65db8c6619&width=206"><br>以在下面的</strong>无权图**中找到从节点 a 到节点 i 的路径为例，说明一下 DFS 算法的工作流程<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-6.jpg#clientId=u4512e8b3-315c-4&from=paste&height=137&id=u70b5387b&margin=%5Bobject%20Object%5D&originHeight=274&originWidth=368&originalType=url&status=done&style=none&taskId=u2ec2716b-c4cd-49e2-8c58-e23e99018da&width=184"><br>按照上节的图搜索算法的基本流程进行搜索，过程如下：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-7.jpg#clientId=u4512e8b3-315c-4&from=paste&height=118&id=ue3f3c139&margin=%5Bobject%20Object%5D&originHeight=236&originWidth=1277&originalType=url&status=done&style=none&taskId=u0dcdaa19-58a5-4b08-b306-9e472773c16&width=638.5"><br>从 i 回溯得到路径：a-&gt;b-&gt;c-&gt;g-&gt;i，如下：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-8.jpg#clientId=u4512e8b3-315c-4&from=paste&height=137&id=u449947f3&margin=%5Bobject%20Object%5D&originHeight=273&originWidth=367&originalType=url&status=done&style=none&taskId=u2b885412-dc7b-4b20-ac5a-b819ab82efd&width=183.5"></p><h2 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索(BFS)"></a>广度优先搜索(BFS)</h2><p>与 DFS 的“不撞南墙不回头”的个性不同，BFS 在搜索时呈<strong>波状推进</strong>形式，一路稳扎稳打，它是一种<strong>以时间换空间</strong>的方法，能够保证搜索到的路径是最优的。<br>为了实现波状推进搜索特性，BFS 采用<strong>队列(Queue)**作为 openlist 的数据结构。队列是一种</strong>先进先出(FIFO)**的容器，如下图<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-9.jpg#clientId=u4512e8b3-315c-4&from=paste&height=88&id=ud12a1bda&margin=%5Bobject%20Object%5D&originHeight=175&originWidth=643&originalType=url&status=done&style=none&taskId=u3a1b1346-f237-46b8-9d09-a3b4054e02d&width=321.5"><br>其流程与上节中 DFS 类似，继续以上节的图举例，过程如下，首先创建一个队列作为容器，将节点 a 加入队列</p><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-10.jpg#clientId=u4512e8b3-315c-4&from=paste&height=54&id=uac838178&margin=%5Bobject%20Object%5D&originHeight=108&originWidth=744&originalType=url&status=done&style=none&taskId=ufb837890-53a7-4c8a-b201-4f00e37582e&width=372"><br>接着将节点 a 弹出队列，将节点 a 周围没有访问过的节点加入队列<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-11.jpg#clientId=u4512e8b3-315c-4&from=paste&height=84&id=u1a3884c7&margin=%5Bobject%20Object%5D&originHeight=168&originWidth=752&originalType=url&status=done&style=none&taskId=u06bcf717-b733-4fe0-a0e8-e47485993d0&width=376"><br>按照上面的流程不断地<strong>弹出、扩展</strong>节点，直到找到节点 i 为止，完整流程如下图：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-12.jpg#clientId=u4512e8b3-315c-4&from=paste&height=384&id=u4b228bb6&margin=%5Bobject%20Object%5D&originHeight=768&originWidth=752&originalType=url&status=done&style=none&taskId=uf69ba2e0-88b1-4285-8540-21d9787fb80&width=376"><br>从终点回溯，i 的父节点为 f，f 的父节点为 e，e 的父节点为 a，这样就可以得到 a 到 i 的最短路径为：a-&gt;e-&gt;f-&gt;i，如下<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-13.jpeg#clientId=u4512e8b3-315c-4&from=paste&height=200&id=u9d7c5033&margin=%5Bobject%20Object%5D&originHeight=399&originWidth=720&originalType=url&status=done&style=none&taskId=ube00c3d7-c002-4c0a-9de2-74816c1441b&width=360"><br>显而易见，相较于 DFS，BFS 中使用了大量的入队、出队操作，耗时增加，但是能保证找到最优路径。</p><h2 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h2><p>上面的算法中，只有广度优先搜索(BFS)具有完备性，能够保证搜索到最优路径。但是可以看到 BFS 算法搜索到的路径只有向上/下/左/右移动这四个动作，它们是没有权值或者说权值都相同的，只能用于无权图的路径规划，无法实现能够对角移动的路径规划。因此下面介绍一种能用于带权图的图搜索算法——Dijkstra 算法(狄克斯特拉算法)。<br>Dijkstra 算法是从一个顶点到其余各顶点的最短路径算法，其流程仍然与上述算法基本一致，它也是用优先队列作为 openlist 的数据结构，它和 GBFS 的区别在于代价函数<img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620723691035-98fc7aa9-f863-4712-bac3-8f57411585e6.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=u28f910d0&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=40&originalType=url&status=done&style=none&taskId=uabd98f3e-5132-480c-8650-2d94afd29b4&width=20">的定义，Dijkstra 算的<img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620723691113-2bf1da8e-b611-4885-a7f1-04164c40d237.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=ubf3cbf54&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=40&originalType=url&status=done&style=none&taskId=ufbbe61e2-28bc-45d0-b633-061774a7863&width=20">定义为：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-14.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=uc782ed82&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=107&originalType=url&status=done&style=none&taskId=u79b0ef1e-5762-4b77-8b5b-162e6ba7aa0&width=53.5"><br>其中<img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620723690991-a4dc7fa7-b40f-4515-b86e-7febdfd73f37.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=u4bc7f663&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=39&originalType=url&status=done&style=none&taskId=u82673318-68cb-422c-b8b2-88439071c0e&width=19.5">表示<strong>从起点到当前点的移动代价</strong>。<br>作者：鬼木士链接：<a href="https://zhuanlan.zhihu.com/p/346666812%E6%9D%A5%E6%BA%90%EF%BC%9A%E7%9F%A5%E4%B9%8E%E8%91%97%E4%BD%9C%E6%9D%83%E5%BD%92%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E5%95%86%E4%B8%9A%E8%BD%AC%E8%BD%BD%E8%AF%B7%E8%81%94%E7%B3%BB%E4%BD%9C%E8%80%85%E8%8E%B7%E5%BE%97%E6%8E%88%E6%9D%83%EF%BC%8C%E9%9D%9E%E5%95%86%E4%B8%9A%E8%BD%AC%E8%BD%BD%E8%AF%B7%E6%B3%A8%E6%98%8E%E5%87%BA%E5%A4%84%E3%80%82">https://zhuanlan.zhihu.com/p/346666812来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</a><br>以下图为例，计算起点 a 到终点 i 的最短路径，箭头上的数值表示<strong>两个节点间的距离</strong><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-15.jpg#clientId=u4512e8b3-315c-4&from=paste&height=138&id=uce92bbd0&margin=%5Bobject%20Object%5D&originHeight=275&originWidth=369&originalType=url&status=done&style=none&taskId=u1b2110ca-eadb-4f25-8e5d-d5865274f54&width=184.5"><br>首先扩展第一个节点，计算其余节点与第一个节点的距离，用橙色标出已经扩展的节点，未扩展的节点仍用绿色标出，其中圆中的数值表示<strong>该节点的代价函数</strong>，字母则表示该节点没有直接到达此时已扩展节点的路径。从未扩展的节点(绿色节点)中选择代价函数最小的节点进行拓展，并更新其余节点的代价函数，如下图<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-16.jpg#clientId=u4512e8b3-315c-4&from=paste&height=137&id=uc0f1683a&margin=%5Bobject%20Object%5D&originHeight=274&originWidth=1124&originalType=url&status=done&style=none&taskId=u8a1450f1-79f9-4399-8f8d-e169c2c3ede&width=562"><br>重复进行上面的步骤，直到所有节点都已扩展。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-17.jpeg#clientId=u4512e8b3-315c-4&from=paste&height=270&id=u45e4071d&margin=%5Bobject%20Object%5D&originHeight=539&originWidth=720&originalType=url&status=done&style=none&taskId=ud51a5969-c955-4e39-8e84-4a846498db9&width=360"><br>最后标出起点到终点的最短路径<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-18.png#clientId=u4512e8b3-315c-4&from=paste&height=137&id=u56f0c87f&margin=%5Bobject%20Object%5D&originHeight=274&originWidth=369&originalType=url&status=done&style=none&taskId=ua013e2b8-7911-432c-a37e-57920b0aa19&width=184.5"></p><h2 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h2><p>对比 GBFS 和 Dijkstra 算法，两者都采用优先队列作为 openlist，而代价函数的不同导致两者具有不同的优点：GBFS 用节点到目标点的距离作为代价函数，将搜索方向引向目标点，搜索效率高；而 Dijkstra 算法采用起点到当前扩展节点的移动代价作为代价函数，能够确保路径最优。<br>那么可不可以将两者的代价函数进行融合，从而<strong>在保证路径最优的同时提高搜索效率</strong>？答案是肯定的，融合后的算法就是<strong>A*算法</strong>。<br>A<em>算法也是一种启发式算法，它的代价函数表示为：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-19.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=u5a11f40f&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=174&originalType=url&status=done&style=none&taskId=u6444210b-d148-4737-8444-6e7a899159f&width=87"><br>其中 <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725031612-4bb2e537-3a2a-43f0-9430-720081543412.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=ua1c55913&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=39&originalType=url&status=done&style=none&taskId=u81437d7e-75f3-4519-8ad2-3f4d8947340&width=19.5"> 为起点到当前扩展节点的移动代价函数， <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725031588-880c54fd-53e9-4a32-ae42-9b033a83bcc7.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=u2774a467&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=41&originalType=url&status=done&style=none&taskId=u26212a94-ede6-4884-b185-f79bf3560b3&width=20.5"> 是启发函数，用节点到目标点的距离函数来表示。<br>根据这个式子，可以得到 A</em>算法的几个特点：</p><ul><li>如果令 <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725031585-3ccd0531-4927-431f-bb82-79cc2f0029e8.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=u734ded48&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=79&originalType=url&status=done&style=none&taskId=u1854bd03-0452-47f9-9cb0-a773eb37eb7&width=39.5"> ，A<em>算法就退化为 Dijkstra 算法；如果令 <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725031585-161dbbd5-4e20-44d9-b575-43d61c553747.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=u1cba9235&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=77&originalType=url&status=done&style=none&taskId=u1149f333-b9a7-4bf2-a3f1-b93cd429b0c&width=38.5">_，_A</em>算法就退化为 GBFS 算法。</li><li>能否找到最优路径的关键是启发函数 <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725036315-f0c86fa9-aa76-4298-a880-bf792907b269.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=u2e57cf76&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=41&originalType=url&status=done&style=none&taskId=u2548ee5d-b15d-4954-9fe6-004bffcb214&width=20.5"> 的选取，如果 <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725036325-3ea21fc5-28b7-4eca-8740-e12dce2238c8.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=u7c5a7978&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=41&originalType=url&status=done&style=none&taskId=u0f640d4a-3324-49b1-8fee-a3ec3ce5d3e&width=20.5"> 在大部分情况下比从当前节点到目标点的移动代价小，则能找到最优路径。</li><li>由于 A* 算法的启发函数是位置上的距离，因此在不带位置信息的图数据中不适用。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将从图搜索算法的基本流程入手，层层递进地介绍几种图搜索算法。首先是两种针对无权图的基本图搜索算法：&lt;strong&gt;深度优先搜索(Depth First Search, DFS)**、&lt;/strong&gt;广度优先搜索(Breadth First Search, BFS)&lt;strong&gt;。它们的区别在于 openlist(后面介绍)所选用的数据结构类型不同，前者使用栈，后者使用队列；之后引入一种启发式搜索算法：&lt;/strong&gt;贪婪最佳优先算法*&lt;em&gt;(&lt;strong&gt;Greedy Best First Search, GBFS&lt;/strong&gt;)，用来提高搜索效率，但是不能确保找到最优路径；最后介绍两种在路径规划中非常经典的算法：&lt;strong&gt;Dijkstra 算法&lt;/strong&gt;、**A\&lt;/em&gt;算法**，前者是广度优先算法(BFS)在带权图中的扩展，后者则是在前者中加入启发函数得到的算法，兼顾效率和完备性。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://www.blog.hackerjerry.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="图论" scheme="https://www.blog.hackerjerry.top/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
    <category term="图搜索算法" scheme="https://www.blog.hackerjerry.top/tags/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>区块链性能测试</title>
    <link href="https://www.blog.hackerjerry.top/2021/05/06/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/05/06/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95_new/</id>
    <published>2021-05-06T12:58:59.000Z</published>
    <updated>2021-05-26T12:23:06.515Z</updated>
    
    <content type="html"><![CDATA[<p>对区块链进行性能测试</p><a id="more"></a><h1 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h1><p>目前，主流平台基本支持 Caliper 压力测试。<br>官方文档：<br>【1】<a href="https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/articles/4_tools/46_stresstest/caliper_stress_test_practice.html">性能压测工具 Caliper 在 FISCO BCOS 平台中的实践</a><br>【2】<a href="https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/tutorial/stress_testing.html#caliper">通过 Caliper 进行压力测试程序</a><br>其他个人业务 demo：<br>【1】<a href="https://blog.csdn.net/manok/article/details/82084852">基于区块链技术的性能测试</a><br>【2】<a href="https://bbs.huaweicloud.com/blogs/204653">基于 Fabric 的性能测试与调优实践</a><br>【3】<a href="https://www.infoq.cn/article/block-chain-practice">区块链性能测评实战案例</a></p><p>其他 web 服务器测压思路比如，Apachebench，redisbench，wrk</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li>网络配置</li><li>设备配置</li><li>redis 截图<ol><li>查询性能</li><li>共识性能</li></ol></li><li>见本子</li></ol><h1 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h1><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;test&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;blockchain&quot;</span>: <span class="string">&quot;block-dag&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;command&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;sh block-dag/stress-testing/start.sh&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;end&quot;</span>: <span class="string">&quot;sh block-dag/stress-testing/end.sh&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;minner&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;config&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;privateKey&quot;</span>: <span class="string">&quot;bcec428d5205abe0f0cc8a734083908d9eb8563e31f943d760786edf42ad67dd&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;account&quot;</span>: <span class="string">&quot;0x64fa644d2a694681bd6addd6c5e36cccd8dcdde3&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;network&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;nodes&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;ip&quot;</span>: <span class="string">&quot;192.168.1.1&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;rpcPort&quot;</span>: <span class="string">&quot;6001&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;channelPort&quot;</span>: <span class="string">&quot;9001&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;ip&quot;</span>: <span class="string">&quot;192.168.1.2&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;rpcPort&quot;</span>: <span class="string">&quot;6001&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;channelPort&quot;</span>: <span class="string">&quot;9001&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;ip&quot;</span>: <span class="string">&quot;192.168.1.3&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;rpcPort&quot;</span>: <span class="string">&quot;6001&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;channelPort&quot;</span>: <span class="string">&quot;9001&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;authentication&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;block-dag/stress-testing/sdk/node.key&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;cert&quot;</span>: <span class="string">&quot;block-dag/stress-testing/sdk/node.crt&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;ca&quot;</span>: <span class="string">&quot;block-dag/stress-testing/sdk/ca.crt&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;timeout&quot;</span>: <span class="number">900000</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>command.start</strong><br>首先执行 start 配置中指定的命令，主要用于使用 Docker 模式启动，启动 Caliper 时首先执行当前目录下的 start.sh 文件，其具体内容是：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker -H 192.168.1.1:6001 run -d --rm --name node0 -v /data/test/node0/:/data -p 8000:8000 -p 20914:20914 -p 9001:9001 -w=/data dag/blockdag:latest -c config.ini 1&gt; /dev/null</span><br><span class="line">docker -H 192.168.1.2:6001 run -d --rm --name node1 -v /data/test/node0/:/data -p 8000:8000 -p 20914:20914 -p 9001:9001 -w=/data dag/blockdag:latest -c config.ini 1&gt; /dev/null</span><br><span class="line">docker -H 192.168.1.3:6001 run -d --rm --name node2 -v /data/test/node0/:/data -p 8000:8000 -p 20914:20914 -p 9001:9001 -w=/data dag/blockdag:latest -c config.ini 1&gt; /dev/null</span><br></pre></td></tr></table></figure><p>即启动远程的 Docker 容器。<br><strong>command.end</strong><br>Caliper 在退出流程的最后会执行 end 配置指定的命令，主要用于清理环境。本例中在测试结束时会执行当前目录下的 end.sh 文件，其具体内容是：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker -H 192.168.1.1:6001 stop $(docker -H 192.168.1.1:6001 ps -a | grep node0 | cut -d &quot; &quot; -f 1) 1&gt; /dev/null &amp;&amp; echo -e &quot;\033[32mremote container node0 stopped\033[0m&quot;</span><br><span class="line">docker -H 192.168.1.2:6001 stop $(docker -H 192.168.1.2:6001 ps -a | grep node1 | cut -d &quot; &quot; -f 1) 1&gt; /dev/null &amp;&amp; echo -e &quot;\033[32mremote container node1 stopped\033[0m&quot;</span><br><span class="line">docker -H 192.168.1.3:6001 stop $(docker -H 192.168.1.3:6001 ps -a | grep node2 | cut -d &quot; &quot; -f 1) 1&gt; /dev/null &amp;&amp; echo -e &quot;\033[32mremote container node2 stopped\033[0m&quot;</span><br></pre></td></tr></table></figure><p>即停止并删除有所的远程容器。<br><strong>network.nodes</strong><br>一个包含了所有要连接节点的列表，列表中每一项需要指明被连接节点的 IP 地址、RPC 端口及 Channel 端口号，所有端口号需要和节点的配置文件保持一致。<br><strong>network.authentication</strong><br>适配器向节点的 Channel 端口发起请求时需要使用 CA 根证书等文件，这些文件已在 3.1.2 节中调用 build_chain.sh 脚本时已经生成好，使用任一节点配置下的 sdk 文件夹中的相应文件即可，需要在该配置中写上所有文件的路径。</p><h1 id="测试配置"><a href="#测试配置" class="headerlink" title="测试配置"></a>测试配置</h1><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">stress</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">description:</span> <span class="string">This</span> <span class="string">is</span> <span class="string">a</span> <span class="string">stress</span> <span class="string">testing</span> <span class="string">of</span> <span class="string">Block</span> <span class="string">DAG.</span></span><br><span class="line">  <span class="attr">clients:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">local</span></span><br><span class="line">    <span class="attr">number:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">rounds:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">label:</span> <span class="string">create</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">Test</span> <span class="string">performance</span> <span class="string">of</span> <span class="string">creating</span> <span class="string">txs</span></span><br><span class="line">      <span class="attr">txNumber:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">15000</span></span><br><span class="line">      <span class="attr">callback:</span> <span class="string">block-dag/stress-testing/create.js</span></span><br><span class="line"><span class="attr">monitor:</span></span><br><span class="line">  <span class="attr">type:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span></span><br><span class="line">  <span class="attr">docker:</span></span><br><span class="line">    <span class="attr">name:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">http://192.168.1.1:6001</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">http://192.168.1.2:6001</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">http://192.168.1.3:6001</span></span><br><span class="line">  <span class="attr">interval:</span> <span class="number">0.1</span></span><br></pre></td></tr></table></figure><p>测试文件中主要包括两部分：</p><ul><li>测试内容配置</li></ul><p>test 项负责对测试内容进行配置。配置主要集中在 round 字段中指定如何对区块链系统进行测试。每一个测试可以包含多轮，每一轮可以向区块链发起不同的测试请求。<br>本次测试是对系统的 createTx 接口进行测试。在测试中，可以通过 txNumber 字段指定测试的交易发送数量</p><ul><li>性能监视器配置</li></ul><p>monitor 项负责对测试所使用的性能监视器的进行配置。每项配置项的解释如下：</p><ol><li>monitor.type，需要指定为 docker，指对 docker 容器进行监控；</li><li>monitor.docker.name，一个包含所有要监视的节点的 docker 容器名称列表；</li><li>monitor.interval，监视器的采样间隔，单位为秒。</li></ol><h1 id="实际测试"><a href="#实际测试" class="headerlink" title="实际测试"></a>实际测试</h1><p>实际测试中，我选择类似 Apache 的测试结果。<br>全是正常交易</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Tx Length:</span> <span class="number">217088</span> <span class="string">bytes</span>       <span class="string">交易数据的长度</span></span><br><span class="line"><span class="attr">Total Txs Number:</span> <span class="number">15000</span></span><br><span class="line"><span class="attr">Time taken for tests:</span> <span class="number">5.919</span> <span class="string">seconds</span>    <span class="string">所有这些交易发送完所花费的时间</span></span><br><span class="line"><span class="attr">Complete requests:</span> <span class="number">15000</span>             <span class="string">完成请求数</span></span><br><span class="line"><span class="attr">Failed requests:</span> <span class="number">0</span>                <span class="string">失败请求数</span></span><br><span class="line"><span class="attr">Write errors:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">Total transferred:</span> <span class="number">3256320000</span> <span class="string">bytes</span>     <span class="string">网络总传输量</span></span><br><span class="line"><span class="attr">TPS:</span> <span class="number">2536.3</span> [<span class="comment">#/sec] (mean) 吞吐量-每秒交易数</span></span><br><span class="line"><span class="attr">Time per request:</span> <span class="number">1.513</span> [<span class="string">ms</span>] <span class="string">(mean</span>, <span class="string">across</span> <span class="string">all</span> <span class="string">concurrent</span> <span class="string">requests)</span> <span class="string">并发的每个请求平均消耗时间</span></span><br><span class="line"><span class="attr">Transfer rate:</span> <span class="number">67.15</span> [<span class="string">Mbytes/sec</span>] <span class="string">received</span> <span class="string">平均每秒网络上的流量，可以帮助排除是否存在网络流量过大导致响应时间延长的问题</span></span><br></pre></td></tr></table></figure><p>说明:<br>Tx 长度为 212 kb，换算为字节是 217088 bytes</p><blockquote><p>用 nodejs 打印上述结果</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-1.png#clientId=ue0d8159d-8879-4&from=paste&height=269&id=uf8e241e5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=538&originWidth=854&originalType=binary&size=66022&status=done&style=none&taskId=ua2f5d267-1fbc-46ce-a75d-7e48fa43834&width=427" alt="image.png"><br>打印区块<br>getMaxHeightBlock 接口–最高块<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-2.png#clientId=ue0d8159d-8879-4&from=paste&height=302&id=udab02a53&margin=%5Bobject%20Object%5D&name=image.png&originHeight=599&originWidth=978&originalType=binary&size=115789&status=done&style=none&taskId=u2ed02707-9654-4dfb-8fb5-77517ad6a23&width=493" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-3.png#clientId=ue0d8159d-8879-4&from=paste&height=348&id=ubdbcfa19&margin=%5Bobject%20Object%5D&name=image.png&originHeight=679&originWidth=909&originalType=binary&size=108543&status=done&style=none&taskId=u82ff9afe-2c69-4356-9d50-5d83d492427&width=465.5" alt="image.png"><br>这里注意到，每个块包含 60 个交易，60*95=5700&gt;3000（为平均每节点分配到的交易量），这里存在几种原因：<br>① 在并发生成块的时候，由于节点间的速率差异与网络延迟而导致当时观察到的 Tip 集不同，而导致的区块高度高于预期高度。<br>② 由于处理交易的时候对于放在交易缓存池中的未打包交易进行转发操作，并标记为未打包，导致其中的一些交易被不同的节点重复打包，而导致打包交易量大于预期。</p><p>解释各个字段的含义</p><p>再通过 rpc 端口查询每个节点中各自存储的交易量<br>（发送 GET 请求到 channel 端口进行查询）</p><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-4.png#clientId=ue0d8159d-8879-4&from=paste&height=85&id=u7c0e6c3b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=169&originWidth=808&originalType=binary&size=23484&status=done&style=none&taskId=u8db7b66d-e3cc-446c-ae3b-7416ee176a8&width=404" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-5.png#clientId=ue0d8159d-8879-4&from=paste&height=81&id=ud52b21b6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=162&originWidth=812&originalType=binary&size=23217&status=done&style=none&taskId=u0c59e8b2-326d-4414-b250-f3334c30c2e&width=406" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-6.png#clientId=ue0d8159d-8879-4&from=paste&height=85&id=ue659a490&margin=%5Bobject%20Object%5D&name=image.png&originHeight=169&originWidth=805&originalType=binary&size=24212&status=done&style=none&taskId=u667e9356-a241-4ac0-9ab5-3676f248e40&width=402.5" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对区块链进行性能测试&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>生活周报-May-3-to-10</title>
    <link href="https://www.blog.hackerjerry.top/2021/05/04/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-May-3-to-10_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/05/04/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-May-3-to-10_new/</id>
    <published>2021-05-04T02:43:45.000Z</published>
    <updated>2021-05-26T12:21:08.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时讯"><a href="#时讯" class="headerlink" title="时讯"></a>时讯</h1><ol><li>五四青年节，知乎发布微电影《重逢》，讲述了关于肖思远烈士的事，回答了这样一个时代问题——“当代年轻人还有没有不计生死的热血”，我没有看影片，只看了些许回答就已经泣不成声，酸楚涌上心头，豆大的眼泪滴落许久。是的，我在床上浏览着手机，这和平的岁月，都是这群最可爱的人为我们负重前行换来的。身为青年一代，我何曾忘记报国之志，家国之情溢于言表，流淌着的热血，奔涌的黄河，人民在召唤，时代在召唤，吾辈当不负重任，砥砺前行。</li><li>B 站发布了新的演讲，这次的演讲十分淳朴，也十分有感染力，下面是演讲全文：</li></ol><p>那些想从我们身上 看到中国未来的人<br>亲爱的父母 师长 前辈<br>其实我还不知道 想成为什么样的人<br>但能和你们分享的是<br>我不想做什么样的人<br>我不想做一个拿着锯子的人<br>随时随地 把人群锯成两半<br>这一半是女人 那一半是男人<br>这一半是盟友 那一半是对手<br>对手赞同的我们必须反对<br>对手反对的我们必须赞同<br>不论对错 只争输赢<br>我不想做一个浑身带刺的人<br>嘲讽别人的成功 嘲笑别人的失败<br>看不惯过得比他好的人<br>看不起过得没他好的人<br>一肚子抱怨和借口<br>凡事不是自己的错 都是别人的错<br>我不想做一个 流水线上制造出来的人<br>没有独立的人格 只有预定的人设<br>没有闪光的才华 只有抛光的流量<br>没有精彩的作品 只有热闹的八卦<br>我不想做一个隐身的人<br>需要挺身而出的时候 他藏在人群里<br>需要解决问题的时候 他消失在所有人的视线里<br>我不想做一个油腻的人<br>你吃亏的时候他说吃亏是福<br>该较真的时候他说难得糊涂<br>是的，我不想做这样的人<br>我不想做一个没有同情心的人<br>一个不讲义气的人<br>一个没有教养的人<br>一个半途而废的人<br>一个遗忘历史的人<br>我不想 做一个不爱国的人<br>我不想做一个 口口声声 “一代不如一代”的人<br>当我变成父母 师长 前辈的时候<br>希望 我的孩子会对我说<br>我想成为你这样的人。</p><ol start="3"><li>盖茨离婚</li><li>狗狗币暴涨 300 倍，炒币的世界我不懂。</li></ol><h1 id="小事"><a href="#小事" class="headerlink" title="小事"></a>小事</h1><ol><li>朋友送的糕点很好吃，在阳光天地的西木栗子有卖。</li><li>买了一只大吉岭的香水小样还不知道什么味道。–越闻越好闻，前调的烟草味有点大，中调很有感觉，是那种草木香气。</li><li>立夏了，气温开始在 30 度徘徊了。</li><li>买了嘉华鲜花饼，送给老妈当母亲节礼物，玫瑰馅的应该挺好吃的？</li><li>去看了牙，医生说智齿都要拔掉。</li><li>去咨询了一下正畸医生，不太敢正畸了。</li></ol><h1 id="本周收藏"><a href="#本周收藏" class="headerlink" title="本周收藏"></a>本周收藏</h1><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p>看知乎</p><h2 id="剧集"><a href="#剧集" class="headerlink" title="剧集"></a>剧集</h2><ol><li>伍六七第三季最后一集！《你是我想保护的人》，梅小姐这次选择拼尽全力保护阿柒，爱了爱了！而阿柒，用魔刀千刃给梅小姐的剑“续命”，真爱无疑！然而，剧情戛然而止了，挖了一堆坑，注意，是一堆坑！还要出大电影，还真就从一个爆款 IP 上面疯狂捞金呗。</li></ol><h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><blockquote><p>来自知乎：<strong>当代社会中，青年的五四精神会有哪些具体表现？</strong></p></blockquote><ul><li>第一点就是<strong>爱国</strong>，这一条都做不到也无从谈起。任何时候，爱国都是第一位，也是不能撼动的。</li><li>第二点就是<strong>敬业</strong>，做好本职工作，脚踏实地的工作，认认真真的工作，不要得陇望蜀，好高骛远。</li><li>第三点就是<strong>明志</strong>，志即志向或者理想，一个人要有自己的目标，不能得过且过，当一天和尚撞一天钟。作为青年，需要有自己的人生规划。</li><li>第四点就是<strong>静心</strong>，国家发展越来越快，社会节奏越来越快，快节奏的生活让人一夜暴富，一夜成名，这让许多人都变得越来越浮躁，内心静不下来，空中楼阁的繁华富贵让许多人迷失了自我。</li></ul><blockquote><p>这是从一篇 coolhash 测压的文章中看到的，作者说：“是存在差距，但是可以站着学习，而不是跪着膜拜，一味跟从只会丧失判断力和创新力，香港的年轻人曾经不相信大陆的 taobao 会比 eBay 强大，QQ 会比 MSN 强大，直到 MSN 垮了仍然不相信是真的，没有信心，没有努力，梦想只会变成做梦。”</p></blockquote><p>曾国藩：窃喜洋人之智巧，我中国人亦能为之，彼不能傲我以其所不知矣!</p><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><ol><li>如何对区块链系统测试。</li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li>又是一年青年节，在互联网多元文化的滋润下成长起来的新生代，给这个时代带来了新的课题，你不想成为一个什么样的人？</li></ol><p>我们总说，“君子有所为，有所不为”。年轻人何尝不是如此？<strong>那些非凡的勇气、思辨的精神、激扬的斗志，极尽人们对青春年华的无限想象；那些意志的消磨、生活的妥协、人生的沉沦，也在提醒人们对未老先衰的潜在担忧。</strong>从这个意义上来说，我们礼赞青年，不只是为了体现对青春年少的呵护，更是为了帮助青年扫除心灵的阴霾；我们歌颂青春，不只是为了了却人生苦短的遗憾，更是为了诠释时光荏苒的意义。要知道，青年人最大的资本，恰恰是最容易被自己忽视的青春；青春最值得的回忆，正是追逐梦想、成长奋斗的痕迹。<br>诗人塞缪尔·厄尔曼在《青春》中这样写道：“人人心中皆有一台天线，只要还能接受美好、希望、欢乐、勇气和力量的信号，就能青春永驻，风华常存。”<strong>架起这台心灵的“天线”，去感受日月星辰，去明辨是非曲直，去体悟人生百态，每一个成长的灵魂，就一定都能找到“你想成为怎样的人”和“我不想做这样的人”的完美答案。</strong><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-May-3-to-10-1.jpeg#clientId=ud5d56b56-b62c-4&from=paste&height=505&id=u6ef2f665&margin=%5Bobject%20Object%5D&originHeight=1009&originWidth=679&originalType=url&status=done&style=none&taskId=ub78ac62c-0766-4032-984a-851d51f1c7e&width=339.5"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;时讯&quot;&gt;&lt;a href=&quot;#时讯&quot; class=&quot;headerlink&quot; title=&quot;时讯&quot;&gt;&lt;/a&gt;时讯&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;五四青年节，知乎发布微电影《重逢》，讲述了关于肖思远烈士的事，回答了这样一个时代问题——“当代年轻人还有没有不计生死的热血”，我</summary>
      
    
    
    
    <category term="周报" scheme="https://www.blog.hackerjerry.top/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>区块链底层-状态机StateDB</title>
    <link href="https://www.blog.hackerjerry.top/2021/05/03/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E7%8A%B6%E6%80%81%E6%9C%BAStateDB_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/05/03/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E7%8A%B6%E6%80%81%E6%9C%BAStateDB_new/</id>
    <published>2021-05-03T08:22:12.000Z</published>
    <updated>2021-05-26T12:20:13.243Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h1><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E7%8A%B6%E6%80%81%E6%9C%BAStateDB-1.png#clientId=u1d1d90de-5c3e-4&from=paste&height=344&id=ub777611d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=688&originWidth=1306&originalType=binary&size=308117&status=done&style=none&taskId=u950bfa17-cd9c-4cde-b1d9-eb903342901&width=653" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E7%8A%B6%E6%80%81%E6%9C%BAStateDB-2.png#clientId=u1d1d90de-5c3e-4&from=paste&height=200&id=u4a6a08ef&margin=%5Bobject%20Object%5D&name=image.png&originHeight=399&originWidth=969&originalType=binary&size=146076&status=done&style=none&taskId=ude525437-624d-4812-952f-2b51a1576ff&width=484.5" alt="image.png"></p><h1 id="创建状态树"><a href="#创建状态树" class="headerlink" title="创建状态树"></a>创建状态树</h1><p>状态数据库的定义如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StateDB <span class="keyword">struct</span> &#123;</span><br><span class="line">db   Database  <span class="comment">//操作状态的底层数据库，在实例化 StateDB 时指定 ②。</span></span><br><span class="line">trie trie.Trie <span class="comment">//世界状态所在的树实例对象</span></span><br><span class="line">stateObjects      <span class="keyword">map</span>[account.Address]*account.StateObject <span class="comment">//已账户地址为键的账户状态对象，能够在内存中维护使用过的账户</span></span><br><span class="line">stateObjectsDirty <span class="keyword">map</span>[account.Address]<span class="keyword">struct</span>&#123;&#125;<span class="comment">//标记被修改过的账户</span></span><br><span class="line">    dbErr  error</span><br><span class="line">lock sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db: = state.NewDatabase(levelDB)</span><br><span class="line">statedb, err := state.New(block.Root(), db)</span><br></pre></td></tr></table></figure><p>这里的 New 函数为：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//state/statedb.go:27</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(root hash.Hash, db Database)</span> <span class="params">(*StateDB, error)</span></span> &#123;</span><br><span class="line">tr, err := db.OpenTrie(root)<span class="comment">//打开指定状态版本(root)的含世界状态的顶层树</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;StateDB&#123;</span><br><span class="line">db:                db,<span class="comment">//②</span></span><br><span class="line">trie:              tr,</span><br><span class="line">stateObjects:      <span class="built_in">make</span>(<span class="keyword">map</span>[account.Address]*stateObject),</span><br><span class="line">        stateObjectsDirty: <span class="built_in">make</span>(<span class="keyword">map</span>[account.Address]<span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">preimages:         <span class="built_in">make</span>(<span class="keyword">map</span>[hash.Hash][]<span class="keyword">byte</span>),</span><br><span class="line">journal:           newJournal(),</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>世界态中的所有状态都是已账户为基础单位存在的，因此为了便于账户隔离管理，使用不开放的 stateObject 来维护某个账户下的状态。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StateObject <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//账户哈希</span></span><br><span class="line">addrHash <span class="keyword">string</span></span><br><span class="line">data     User <span class="comment">//账户属性</span></span><br><span class="line"><span class="comment">//底层数据库</span></span><br><span class="line">db *state.StateDB</span><br><span class="line"><span class="comment">// 写缓存</span></span><br><span class="line">trie Trie <span class="comment">// 存储树，第一次访问时初始化</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//账户地址</span></span><br><span class="line">Address []<span class="keyword">byte</span></span><br><span class="line"><span class="comment">//账户余额</span></span><br><span class="line">Amount <span class="keyword">float64</span></span><br><span class="line"><span class="comment">//交易个数</span></span><br><span class="line">Nonce <span class="keyword">uint64</span></span><br><span class="line"><span class="comment">//storage树根哈希值</span></span><br><span class="line">Root <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 stateObject 中维护关于某个账户的所有信息，涉及账户地址、账户地址哈希、底层数据库、存储树等内容。<br>在区块中，将交易作为输入条件，来根据一系列动作修改状态。 在完成区块挖矿前，只是获得在内存中的状态树的 Root 值。 StateDB 可视为一个内存数据库，状态数据先在内存数据库中完成修改，所有关于状态的计算都在内存中完成。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将每个交易对应的的账户状态树进行修改</span></span><br><span class="line">usr := getUserByAddress(t.Address)</span><br><span class="line"><span class="keyword">if</span> usr.Amount - t.Fee &lt;<span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">usr.Nonce = usr.Nonce + <span class="number">1</span></span><br><span class="line">uMPT := getMPT(usr.Root)</span><br><span class="line">data := *(*[]<span class="keyword">byte</span>)(unsafe.Pointer(&amp;t))</span><br><span class="line">uMPT.Put([]<span class="keyword">byte</span>(t.Hash),data)</span><br><span class="line">usr.Root := uMPT.RootHash()</span><br></pre></td></tr></table></figure><p>在将区块持久化时完成有内存到数据库的更新存储，此更新属于增量更新，仅仅修改涉及到被修改部分。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// state/statedb.go:122</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span> <span class="title">Commit</span><span class="params">(deleteEmptyObjects <span class="keyword">bool</span>)</span> <span class="params">(root hash.Hash, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> addr := <span class="keyword">range</span> s.journal.dirties &#123;<span class="comment">//①⑧⑨⑩</span></span><br><span class="line">s.stateObjectsDirty[addr] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> addr, stateObject := <span class="keyword">range</span> s.stateObjects &#123;<span class="comment">//②</span></span><br><span class="line">_, isDirty := s.stateObjectsDirty[addr]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> isDirty&#123;</span><br><span class="line"><span class="comment">//如果集合中的账户有变更</span></span><br><span class="line"><span class="keyword">if</span> err := stateObject.CommitTrie(s.db); err != <span class="literal">nil</span> &#123;<span class="comment">//⑤</span></span><br><span class="line"><span class="keyword">return</span> common.Hash&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line">s.updateStateObject(stateObject)<span class="comment">//需要提交此账户</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">delete</span>(s.stateObjectsDirty, addr)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">root, err = s.trie.Commit(<span class="function"><span class="keyword">func</span><span class="params">(leaf []<span class="keyword">byte</span>, parent hash.Hash)</span> <span class="title">error</span></span> &#123;<span class="comment">//⑦</span></span><br><span class="line"><span class="keyword">var</span> account Account</span><br><span class="line"><span class="keyword">if</span> err := rlp.DecodeBytes(leaf, &amp;account); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> account.Root != emptyRoot &#123;</span><br><span class="line">s.db.TrieDB().Reference(account.Root, parent)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> root, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>因为在修改某账户信息是，将会记录变更流水（journal），因此在提交保存修改时只需要将在流水中存在的记录作为修改集 ①。</li><li>所有访问过的账户信息，均被记录在 stateObjects 中，只需要遍历此集合 ② 便可以提交所有修改。</li><li>处理完每个需要提交的账户内容外，最后需要将账户树提交 ⑦。在提交过程中涉及账户内容作为叶子节点，在发送变动时，将更新账户节点和父节点的关系。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;全局&quot;&gt;&lt;a href=&quot;#全局&quot; class=&quot;headerlink&quot; title=&quot;全局&quot;&gt;&lt;/a&gt;全局&lt;/h1&gt;&lt;p&gt;&lt;img src= &quot;/img/loading.gif&quot; data-lazy-src=&quot;https:/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>生活周报-April-26-to-May-2</title>
    <link href="https://www.blog.hackerjerry.top/2021/05/01/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-April-26-to-May-2_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/05/01/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-April-26-to-May-2_new/</id>
    <published>2021-05-01T09:59:24.000Z</published>
    <updated>2021-05-26T12:22:04.139Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="0e3e678ceddbdb6fe50f8326923f20e10a64eac2b1a71641530dc0b92ed34404">9de868b583bc49e754b3988b9080d7cff3617e4ea1f7484b7ff0f17d01b646576c7b1fa404195957a625f7cba00813ad0f5a3a245f9596dec846358c3ff153e134df321e20a5271e9e642351f6a4b3a7374e0b6065baf324118a410453fd2e9a59ab43d342b7729dba375b0f93faca53c81868b77858a98f5e864d6eebb06c17342f3b03b6821a3043638994f26f43df61eeec033d86c19075e726ae29d60f7f0043e7ea5f48f247978affd46a8d42a267b7d9207dd29d378a6e306b194e194654c92f0dddc9c245c1605a3dfdadbe914a3b763aebdd5e3dc2687687c9fcca9f16e7db904651cde8a65eb0b13074ce369bbe64a761e7a7019af1e6f2458f891f670cfc2659a673ddc63b9a08edbf8ee07b68a85357f76966b75c1dd9eb671054876736ca2bdd696aa00c6b9eff7da20bc3cc6b79aab2d35277d24aafc4188a81c4aec3689adb70b1d385447db4bd246d342767a24c61378a05e61c064d7b19d43e1c01954c8c782a4ae5fd81d0406a595faf7bfec808902e812888d6bc6a25b014615b98c42a3cd5b0b1e5438ff0d2bab5f3dd8aadd184c72ed07bd543ef614d2e107bbcd2d3bdf1585f4503a88d75e65f0f6726a8f52aff25f1216390a7f2f452d87950a05cadfb2d575e5d8d9f2eee2c857ae53aad51003600db64d375b3f287ebf45791e275e17ac8946ed861108c6ad256da9264544f15194d4dff3f824a71b6a3d88a7c6347f560d9cab7545b0fd969126f70e91ae00ed1a39c83f11aae0eb7ef78db77c70d1fd5ca95b90acd1d7b2cab308b8ae4626e399ca35fab714ebb593928a59a033d2c0e4ee178b7434b5a5e23f4a909998f96052ac5e02a6bc8981e3b1258c9984879ce25d32ddd3796b055673d3b7be17f80fe054c65a250bfe0b9b676e9d2a82d226d79853cc73d1516465a9857cc748e44eb51b46b2ae5442d9c57710c6ab11d238e72e8982c50e8f06bbe2dd753d028721b691f1e0536951e2262b6108b836f821fe31db3627efb4ea111cf70713b1dcab9908d86d3a24e16a52de6c3f5631c7cf4cd789966d6bc3758b1b56a0960d79226607626107a3080fb664441fa949efecdf95b248b7073072983cb64b319ca8cf57ccfebbf8f5d467c8546b84857b4a7c9dabfb57f3021436706dd7526e7ee202ae7930c2c782ce5194e991ee2046ff49d3d70423921e9794267596944ef240ecd775c0cadc732057152938220425d6e7bc8e5a28b5a264d46ecd6e4fc779f31696e687bdbf31cfb15849e7a5ccd9fa494370be2009da01eb5af1a0965eb613c04338698467f01de8e8de66e0a0b8b233ced4b38c85e909e32cb8808fe5b93770e47398aabdaaa7c25ca4c598d92144809bb9b95032aa479be8bb565e352b8a6d1d386899e7923cb71ea55a3110031f2739b46f3235b42df2a0dda6ba5974d93475c3a508228b60dbcabbc91736fa941d62d670dbef05a9a4ded06b8cbead672f90e269920a2ec5b056f10896cc001d0c99b31349a80d249d5cb56c4ece4ef3343e6f115e1163c5128353402cc87b1a47bb7bb618d3545715a2d6fdf476cf777913b3350c43ed510b2a3e2599c668f9cac5f6f1d2bf4076313b36cbc58a105e1358549e75981b6c6e6a3d129175827a6b0c504d1817ccb5fead7a7b8221a3c344fe8a44625e9ca0b62c6bf8559692fdfca02b0e3658c80805a2bba0dafb6d40d0dd5c87eea6e8fcbdf079cb3f1a8e05c67f3a9ef8e8aa0043ba40dd4124a13bf646c05e2972194cb3d2bdeb2793769c73a74da17f8f9e6f5c48aba0028413638fc9fa700e71d85c26bc2a2f72a8b065127eea415b0fabb468365cd03079f6ef24750539293520c0a10f2f74f4c72ab746845306a6b70936d08b81b55da0bcf851d67df64eeaed8e110fe04f2b90712cb48f7827f4c7f97275b8f52e4c27ebb0072d4a666bd350cc0c1a0545735a71618a71d3f40491cdf87caee73992ec3028979d4cb482aceabcc5e87a1dbe1b8542acccf08dc635402726cb5e6d108ef9e8870deecf5d36218ba58cde90fef4cadb2b7d1957abcc6cd47b6e42a1ac89e54570ab9cc37127bb08165961ddc4856ae887a04f1c0ee39a55a8d07af6d524d8b2c19c43f97b3a8164a36fe5caea264cc334ed2a96dae278d2b0a648fda1799afc4a04a4d6b09383b98a6a6752d0a2fc82dd6c608b5ab232dc563924c368111c832d2298db59f38b24d618f715f70d70f2386f97c096bfbb13d5ec802fe5a29679184fc06093fbf1cd561bea3b27d6ea0dcaabc80278aacadb4bde752925917462a24ea724f7d45ed0a9d964bb75f44d86a1fbe5c9f6a155219f68ac8595aedd5186353eb1ffbb475a5dbc282488047aa20a180eca270ae9a98262c0a3ce2fa402b7c0df777027d597c391e299bbf31f0759d570544bfe56af17aae2671eb71d153f8619f1fd6b7fe0600d6fa96e5c704d8730fee7d718737a6c12e741784d8519a2e2e7d89908c7bf9be755e930d15f9fa637b2a1d981262a4c4760fa00b10ad3f25fa5eab52e7951100fd745c672493020cf8309cb9deef770cd60fffad6313203aa332aa51069f1b19765a0a4bc2bd73ce76def3505debdb9f4375e42c1f3e13f32a22a3bdcbe8e846f0845fe3c761b5d922f4c4eb758cfcbbcec7e676cf7cba3cd73775005b6d7ce84832fd79ea0dd1b7c12e96bef6adafb9156ec7b6b6594d2b9b3e9be717332de814d2fe62e42065fe3cf2e80c777426b5d82327f3936a0a67235cfaeb01b67f4ec535286599ad8ce8b12e8bc7a6a9b4e539ffbcc255a3e9ec3e02431946db960fc1482473c8fadc76dfd3081d1fbd2af4f9dd9b8e3c7fc484e0e76145e1ede7a916671f812afdd53be67035fe41170e3c6007a1317d336b7e114e2d25ec355c087eb4e139af0a77213bdc8896dc056be69c5feab2dc1919def5197bd1e69bb1e46e6507c12fff3b1e18d767f9ec5a9b136d1565aba4f290a847e5004e9bf9b617fdc6f14e22dc84eccc4c8731b29feaa75823470778b070678da68ebcb02b555e16e7df22eae1131c5627c72dffdf9c15b7461cce8bf9d9f6715e69a2b297b3ef16b1240e77624613e1cc9d2d3b7586ea12a3381ba2cf72c1256a69f7b84258879a4544f3c5e71f7c909ec6e2cba3b1348436be33001076ba0b704416973fda637b2e2a1001582e2fbfbc059cf94539c760ef0031035e14a96e6976be1fa8898b707e14ae2cb5fa71c4101f654e65bbc02693451f5f91bdd17e8795292c07124d70764c2681cd1bc87cb6babdaf8e2d42e8891f14b5d5684d8e45b05fad6d133f93ce41339a2e90b6c31ee7ccd42306c79b30fdb424b2dce947963fc3d1ba72e425ab77502b46b97a1dad5b0b2fe3dafa66df995e64451bc77c6bfdc81ceca5702c65312dee9c68bccd38ed5f35e5273b5a3a3fa93cd61986dd18d2717e50015e50d5046052b018d50eb0898ad78b5df5e60cbb83fa314bd87ca60f79ccf3ab94ef5c35a4613267858273ac7f0424ad54398f5a1c6c12f489ad7aa0a6f5d353f6a0b291aa0a4b20b3b2a2e346ff3ccb79151f26e222d7520e0ac5365e7a10493a3c4c22d7a48230df0fee45004f91401e163181d2507acb9bb3f075093d96193cffce727ad026a2689998fa0c77a5a6dc6d2a10a7d007c325706dd6ef674003c83dc802c2033dd19c510f541acc7dd4e01385a377a2dd06769cbfc384297e260040dc82d904157ba0d569b42bb8c38145c065623ad30d9953615b71215a53190dbb93d1104faedaa5ffd338d8ba52c11ddabf217f1c28bf8135a8c00d9d2c00a9aa09f0c5be3692545c8d2c0fda30c503a94f633c56e989367ddabf8a4aedbda17e4676f40deb464e8cd1345cdaa4a17bb5f987470b7e4d1a9803a544e0ef8924cf2cdae6f8a8395116ad10c970500fac7e9d4f2327af47940a05b42dce9c6e0448e77b8902d893c797a363926176cefd8fd688f8428f2f7958079d7e234b16e824113317e5b8248db3fb9dead84fb915f5a196fb744c1628706f9073351caa8c36315a4a8e527f4905bfff636c6caecf2c02e35db50bac22404fe213a4c9b50d233347930fe7bd1df5b99827e478afdb0a67809934cd9b7129f868d1b3f6c5dab2f8ea66730c8b97deeeb11baef25ddf63de23fa051b76bf0aaf0470edbc9b2a815bd6bf339397646dffb9df8ab41a068001f829cfa440c3b5b163b948720dd599c69d33eff55ed28b3f4caf1404fd0dc01c29c90c6ba477634feb092bd76b8e70c98dbbc038c4997536003cf41afab766e2b31b27d0d91ff92d00d8792cf4892bedf5ac6e0ff6fdb8c2744ced3956b0fddccd8fdfc1d1773205d8f0fc79a9d5c58a5b2cb5ed5302ac70bb32af6f911edaa790bb7c646cf4c019ab5491a436c2357b8786ad9faf34b74ace2824d95f94163b8a375d7b367bbb4d645da8276b7ff174572886af0d84bb02c3810a286e9b0f90866c09ba3d02da75baa0c94d34f84f59b55fee8655e4f631087724507465d09e8536a2235a6f7ed5da6ac3aef45a3642d2ad3282ddb7bde8595884acdb03fdc7f7402afc0961c5f7c63d5487c89fdb33d669ddbd06009c0653411f514599f9431e4ae9f17eb4be283f7f64e0cbd98702533849bd2ff10cccae3b5ce918df52d6cf20dea8c02bdb701243f4ee963c7101e2d8e8fc22e9ccbcf107920b23e6ae1ab5d84bf6210c2c42ef4c9bfb71de1975c48a0a0e7c17806ba78b1cfff6270864aae369413931e3dc68831bc2bc044faeb0f8a7fd73f6578cdc418d4f11eaaad0223174711b42b125e1a0582788fe5bc38f2326596f3f21312b0031661794f9e7ca41d19337714310c162b4bf6de14d4d0222c0a2b6db2fac2d0e280e6d894d0f71a32e683e0b0d168b99673af1c54046c9187d6addce0c78d85745bc877f3c0fbb63cb2a7ab5077126ad3a16d2cd18db84e91070a87915743f155c483da0fbd1958dccdd27ba11b664386fb62dfaa934521c94f343f64c64373e887f29fa469d2de685e9205d44ea8983bc4088ce1d456d93111c77159722b89d6e2c5da08fa77ad0141725638e83a91a6da32cd4159976da69a4f88d50b12fa13de4d36fda27cbd4332488eac8bdd04d1cd81bb2afcb58043359d54f134a0a8922933ac6d199546a9d2c1d8b7bf60bdfe4872174965de57023f4e80ea181af106ebef2c3ab8c34612856a0467fddb762eaaae696000082d4f32082ec03754b39663ff8b5749fcd40e3072b2eddd1b2519e5c34e5cfbccd92420450f99ad599fedea9c4cd45e2231e7d3c8f31131680526345ca0222274462cf4e500262d833197cfaad4b82bc03249e7d7691ac04ffbd796a2bfe2b824a46fab54fc06b1daaaafe7ce1cd86600f95e6a54dc0cf23d7894c69e23eff34818938d24538e963ad03f69277b2b29aaad1dc5d428cf8fff90ebe3b0b8b50e9b262a3a87103cd003ec6d2da5daf960e5c69e78fcc02e98ad11ab643a3092d0be253ce2c6ac9a0ceee8d1a6153c929ffd5a097b75e0d7b0bae90d1b45e72279cddc58411a4d156656a7bcb03643fc1b2a9ed89773caf062f28da1885b560669e721b8601646bc6da8ce00c599325dac920f6385a386c899f30c89c482bdb8e409e667eece1047a5a64d73357945e408106f29dddbf6d1d4f063f75e9aad46d8420b9d1ad532a90dc6cf21ab5fa8040a5f461b35cd946c4b3886c8f57d4d9a8746aab901677c689817ece82ad60f395b8092d5e4d532bec15b23137e3ebce6baefbe9be13216df057e4df12d203facf355abacc5528f62b90833aa5dcf9bf556cb6208b497427e42fd0984a542f66ec3780e7d039414d1fa256c14649834f652a7a8454a66466f12cb2b71fe25b77b98e689e588c5e0d83f23cc1dccb85a55fb4f30335ec2ea5b7216e6b1a34be67d92bb84c1adc6e23da711d8a0bb275e5467f3179d80b596eeb7321d1cbec397144e5a52a07a4ad07dd55b63e51d2c9a900fdb15098c01e973acae09e1a397b9449da5d06ce9438297441d5aac6eb1e927fd89e93e948d2ed0a6ffeb611c23cbe1456d385e89b94b9f912f6be23b73f3d5b3655e43685424bee7dd9b287b98c436d3a3765ab38b827aa7013edb4389fd321cb65e69439bcefa54ab5178847d8af9c1fbc0e5be60c0664e2844ee71fd806bbdaa36fb77d4f79ec58d711beda2dc3a3be9f331be0acb3110babb2c0f734db85411549774221051676f40ce15161c9ca395f81ac2bc8d2ce1194b070416b85fe75f7f41338600f5c190ceba824c8038f0cccb0c14d7921a8c0b25d5e1f450825ce5399e1611eb06e4494967f482c3a71fd4f8ec49502a3e75a3fcf75b9206e41d2b2e93dec7defc5436736cf102c0d12c7043625f589584413ea29ce3a4d72e9fe695b0b3a1a6cced2ab3158223362b482e931cab55d9f61f88ae041403ef49dba693d97f5e15f3de8f77097696a075b9881d10510b2edd3972434933cac1964ab1c4b23f25a24c625b5935e0af9b505cc17bdd4a65bbb631b7e1ccd70375c765dd2db270584c9a70cb5bf3b05943a53d12d57bdd82c98e521367bc89d2e1cc44f5bb171650988884f20cf11e686e571338a1a418c9f5b2ad4b8ed764c5d868fdd5554313d48b5ac3c7e43ef5b5e1937f3b6f465af1323c8779a9ee58a4f3377ceebce5162de179e298fad69922e020a74afdebcdfaad6c43c9ebe420a2119da5ce979992745c05c9088e814fec15edc57f1bba853290961586d88e47fca04e4c1a9a1be90e118e64609e1ad1206c4aa811a4f0d6a4046eb60312eb9819bfe0327ec3d7e4bf3a45c09064b723552ca0de1308fb6009afb666eadb9eb67a24a8a2151fd2b5de827eef89bf7ddbb6892b1676147147fb23c81b2ca680a4b839ffad2e2d63eac0f5f973d1b0a3fcf24503db45c17cee1dccc29396e78f61f36ac29d0bea82022bc3e73cc4784ef5a72c8f14ce48d8764126f95bbb29cb03559a24214b9870f427d2c53566cb06b1988241a296a12e8bd5347e01814cdb0739d752c3a58e478e5f126e7dce9c37875ddfb66a6ed9a2ad1e3ee460ae01158001843cb33c8bb938abbbb396ff1d3e2dfd687b78982da24454596af6164f691d91f502dd4fb85e66fa54c7e5ac14740c1f83b491bc3d46f677782f48bc29922dc697328d61f106f44414898a9bf7eef65fe40691ea17cee7f72e76860fccebe41e9d4972cfa1f6d71abeac7e1cffd7f297f7244f2b9faa5577884b345dd4477e2874e7b669be0d462c068b37c6d2dee93b37dad3dbb23cfcb3e1860e184bc399e5d8c445c85be11268dd4fa6d15892e1499add07dcb44e259a10e4803ebbfdfcc57c1046391e42b8cc259e0cf291f6c55e8b2662ac80790de6e99220dbe7aec3787a6b98af05d093aa74ad9903528393a9c74b404fe8764968fd1a26309a2a632d6c30a8fd050105eb6fd4ce82b7c434c9ed1872c317d1134475ad97ec13e2001be1496830b58da42e4704b6602df15a1bff2eae99c2bda97f0430ecafc2965a21d9fd29f2b7f773bcae2debe618ce5604cae516f022c7e3ff330075df6affc9ddb9560ef6c407c7c901b0e82644097bd68852a07e12c1ee4c479b7c04739c074a91064773678aab79cf03525aa2074a6fba785f5201e875021ec81e8bd406ee692c01c686ac47db6f5330df924ecf1e6f5006af3fb381d4a42c50866c668e4132a9d20db86607fa3de5ea159e80982a11214ab5f494ef7230a12349cd9b9a2c30d008dd6cf6ca43b7d44f8b4c040da9951401b94717f684eeb5eeadb11090cebeafe59a1b29543dcecdce8de56b0b04f431161aa1732f39e935d584d5eda78134efb8d0579a87ed8b86c198cff0049840fde20942a579490cb0ce576f00c12c8f73510eb0b757b2176929a54b9dd18b223aa5bf58bbd45b9ce8078c551efc2ce8b3ba1d8f6bd247214ab3a550256f74b965b61f94d23d797bd19c6c429eac7da07e17c57ee2e14fef867907664b36121b1759d2cf3b6c699e5cdbf47f8d74c6415548a6453b9ba705caca0cdfd6c22d5b9720e1aa81296cafe206c7ed93d63bfa919da490258d7dd548302f816f39429e7198ef812ef62f4d3a98c808facff9a91d8befbe455254ec9fd1090fe87f768bc836f7592864c3596f3058b31582f5b5f1a992be5ae6af0532f7b6a58fcae2838d500cce3458f246c2f37db9070193910bee6d2287c51ce1db354e8c909f431099af8cec34b74347975b6a2664bb8deb9f6d9718481e5acbea9b91cec5fe671f40d45b17a9cc4190d2523284aaff3ff04f88d291547b74755a6886a587804cb3342f42b388f2a65b9da993fd4227b45eac1afbcb15a885e44e51f3d36cabd714dab2eddef9ffbb4ffbbdd03bc5fb4de193702a6e91bc34ee6c44a60229ffd0411b49ae97b02f771778ad4b07d10e4eacece8f11df8df80f8ebc1c64865d1cbea46b010aa69fd5c54fd9399034a12556f0b7e0a04a27575b35b0aa8977d5471bdc59c51ee97694f7b8b7c9e364a337f39f2315b95fa883f8ed51ccba2b6fc7c5537e2dc609c6188487bdbd137b185eb0b488d1b407780bd07baeaf20b86b682685604677f3005f0667edfd6a47cc574f4858eb3c2013a816e632829070d7678a92bf3048d5b58982e3a7ecc1023d374f125fccd81ac82347b0a682dc4ae8ae4585aff79957d7b1b118d4de3ebcf55d6cb70c967ab223cd749000754c73d8f20a894f7babd768550eba63967afd7d3dc6eefb2475ee74c9955aad0adfda7e60fee7c383539100125f504a2d9a9b1caf44232f758016d93cc156e82b7134aa20af39311e8c393aa8af030957b93c4b744d978e670009a958d9e9b536f29c6e41748ae3eb5af6409499536732a562f8debeeee558a73853d75237d197511a663a7c9c53a4f0b3770a84df6eded389a764dda6b5a5ac9cdca1a51c4ba7fc8bdf54413324867b0b924431900b097e8d09b4df1eaf9506f864c35296f5c6ea9edd87943d0b27fc675fd8b248017ebcee2e0bf11fc4b8a5b14be6a9db336dcac08dc202cc03fee44a312bbc064337f43856d2cf73726674bfed534c794632f3522f818f5af924b73284a4f160691d407193ae75db962c79a04e7fe62a1378469fce62ad727a0f8de75bc635b07707a4e3a047ea7c7fd3a5757a698e3b42bf8f9e911d26ef212b036eabdad3c3cff0fae6b032d0a5518ee9dbb25f5319c7dbf79427a86812368800f8d48ee6b947c9cca037444b0a822fca78f7db424dec3844e913aaaaedc8babc8e300f726de938ed2c67c0d8602a6e827345e1c0606442aa7ebbcc758e1248d2c59b6e7bcc2f712e42ef63392ad803c8f58366047bac73ba70cf90998dd39b9d636bc4a421b6efa548a28fe35736c8de11e73ad4e1f8ae15ab739db25ab116c5f849f9fb1c7fd35dca75cd5ab5a5a675fb27598a61b014c71637bdb4c8c0f31bf31e76bfdf41a59753703e23ad994995978efb2c4aed11c5f896df16b70e6e603fae8daa55c9533d216f33d6b2622e5c1a60150d2d8e9c4923efa30f2441ee9847735ae708ab615a366d0513532b3f40d4257015660c17320133a16bd724526f2d48223e9ab770f78e729005012b8d3d5e6518fb669a977eda9111e6db71c7da497be33d2891670c16037d20692d577c2aaba7eb4ac47acf1027fc797fb6663bd91dd4ed7aac131e145f1142529eecf95dd52fb6fd862de7cd05170eaa69ad7116304f2f99b66b9353dabe046ff815bab5d1f08cdb7f6c237101b380139366130dd5b15e97a8f8897baedfa6954db07a746c9d7864847b19152273d0583a6776228f4857199009dd8f690267e27fa3fe8659af48e9eaafdf4018d33b849523bb981b2f339e44e6672d253d61bc10a030b45e39f0e8468beb41da6bcc7721ea113e290a4cc3d331faf99250d624f09e5970a7282adca4639490918983a427e82bc65e7f3dbd3b1413a2b99eeda748bfa903609ef1d40ef6839f337fc784c56ae42b2408facc6923d6cd435c748d072bfd60729024227b5fd589dfbd3ddc61775c6bdd46ab6d0e44d7745f9ab45cc986dca0587ff45c83c3c2aff9abc6</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="周报" scheme="https://www.blog.hackerjerry.top/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
    <category term="生活周报" scheme="https://www.blog.hackerjerry.top/tags/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>QPSK信号调制</title>
    <link href="https://www.blog.hackerjerry.top/2021/04/27/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/04/27/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6_new/</id>
    <published>2021-04-27T13:46:38.000Z</published>
    <updated>2021-05-26T12:22:29.063Z</updated>
    
    <content type="html"><![CDATA[<p>b 测题目，由于学长写的代码有些步骤无法理解，而且代码不优雅，故重写之。</p><a id="more"></a><h1 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h1><ol><li>源码信号为周期 63bits 的 m 序列， 源码比特速率（kbps） 数值上= 载波频率（kHz），数值范围 5—100，在数值范围内任取整数；</li><li>在 MATLAB 环境中编写 M 代码搭建 QPSK 调制系统模型；</li><li>观测基带时域波形、已调信号时域波形；</li><li>观测基带发射星座图；</li><li>观测已调信号的功率谱（优先）或频谱；</li></ol><h1 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h1><h2 id="比特率"><a href="#比特率" class="headerlink" title="比特率"></a>比特率</h2><p>比特率(bit rate)又称传信率、信息传输速率(简称信息速率，information rate)。其定义是：<strong>通信线路(或系统)单位时间(每秒)内传输的信息量，即每秒能传输的二进制位</strong>数，通常用 Rb 表示，其单位是比特/秒(bit/s 或 b/s，英文缩略语为 bps)。　　<br>在二进制系统中，信息速率(比特率)与信号速率(波特率)相等，例如，当系统以每秒 50 个二进制符号传输时，信息速率为 50bit/s，信号速率也为 50Bd(波特)。在无调制的情况下，比特率等于波特率；采用调相技术时，比特率不等于波特率。通信系统的发送设备和接收设备必须在相同的波特率下工作，否则会出现帧同步错误。</p><h2 id="波特率"><a href="#波特率" class="headerlink" title="波特率"></a>波特率</h2><p>波特率(Baud rate)又称传码率、码元传输速率(简称码元速率)、信号传输速率(简称信号速率，signaling rate)或调制速率。其定义是：<strong>通信线路(或系统)单位时间(每秒)内传输的码元(脉冲)个数</strong>；或者表示信号调制过程中，单位时间内调制信号波形的变换次数，通常用 RB 表示，单位是波特(Bd 或 Baud，前者规范)。如果每秒传输 1 个码元就称为 1Bd；如果 1 码元的时间长短为 200ms，则每秒可传输 5 个码元，那么码元速率(波特率)就是 5Bd。　　<br>波特率(码元速率)并没有限定是何种进制的码元，所以给出波特率时必须说明这个码元的进制。对于 M 进制码元，比特率(信息速率)Rb 与波特率(码元速率)RB 的关系式为　　<br>Rb=RB·lbM 　　<br>式中：lbM=log2M，表示 M 的以 2 为底的对数。显然，对于二进制码元，由于 lb2=1，所以 Rb=RB，即波特率与比特率在数值上相等，但单位不同，也即二者代表的意义不同。　　<br>例如，波特率为 600Bd，则在二进制时，比特率也为 600bit/s；在四进制时，由于 lb4=2，所以比特率为 1200bit/s。可见，在一个码元中可以传送多个比特。</p><h2 id="数据传输率"><a href="#数据传输率" class="headerlink" title="数据传输率"></a>数据传输率</h2><p>数据传输率(data transfer rate)又称数据传输速率、数据传送率。其定义是：<strong>通信线路(或系统)单位时间(每秒)内传输的字符个数</strong>；或者单位时间(每秒)内传输的码组(字块)数或比特数。其单位是字符/秒；或者码组/秒、比特/秒(可见，当数据传输率用“bit/s”作单位时，即等于比特率)。 <strong>所以它的单位在不同的应用中是不同的。</strong>　<br>　例如，在某计算机异步串行通信系统中，数据传输率为 960 字符/s，每个字符包括 1 个起始位、8 个数据位、1 个停止位，则对应的比特率为 10×960 位/s=9600 位/s=9600bit/s；因为是二进制编码，所以对应的波特率也为 9600Bd。<strong>可见，在我们平时用的串口通信中，波特率是 9600Bd，其实比特率也是 9600bps，因为默认就是 2 进制，波特率和比特率就是 M 进制的差别。</strong></p><h2 id="采样频率-fs"><a href="#采样频率-fs" class="headerlink" title="采样频率 fs"></a>采样频率 fs</h2><p>定义：<strong>每秒从连续信号中提取并组成离散信号的采样个数。</strong><br>采样次数 Ns，每个码元被采样的次数，必须为 2 的幂。<br>fs=fb*Ns<br>其中 fb 为波特率，每秒能传输的二进制位数。</p><blockquote><p>实际中，要处理的为模拟信号，想要在数字系统中处理必须为数字信号，即采用抽样、量化、编码的处理方案。<br>处理的第一步为<strong>抽样</strong>，即模数转换。以电话为例，每秒 3000 次取样，每个取样是 7 比特，那么电话的比特率是 21000。而 CD 是每秒 44100 次取样，两个声道，每个取样是 13 位 PCM 编码，所以 CD 的比特率是 44100_2_13=1146600，这个参数也被称为数据带宽，它和 ADSL 中的带宽是一个概念。将码率除以 8,就可以得到这个它的数据速率，1146600/8=143325，也就是说 CD 每秒的数据量大约是 144KB，而一张 CD 的容量是 74 分等于 4440 秒，就是 639360KB ＝ 640MB。即刚好为一张 cd 的容量。</p></blockquote><h2 id="快速傅里叶变换-FFT"><a href="#快速傅里叶变换-FFT" class="headerlink" title="快速傅里叶变换 FFT"></a>快速傅里叶变换 FFT</h2><p>做 n 个点的 FFT，表示在时域上对原来的信号取了 n 个点来做频谱分析，n 点 FFT 变换的结果仍为 n 个点。<br>换句话说，就是将 2pi 数字频率 w 分成 n 份，而整个数字频率 w 的范围覆盖了从 0-2pi*fs 的模拟频率范围。这里的 fs 是<strong>采样频率</strong>。根据<strong>奈科斯特定律</strong>，只有 f=fs/2 范围内的信号才是被采样到的有效信号。<br>举例说，如果做了 16 个点的 FFT 分析，你原来的模拟信号的最高频率 f=32kHz，采样频率是 64kHz，n 的范围是 0,1,2…15。（注：这意味着已经将原来的模拟信号采样了 8 遍。）这时，64kHz 的模拟频率被分成了 16 分，每一份是 4kHz，这个叫<strong>频率分辨率</strong>（卢注：做 FFT 用的点越多，频率分辨率越高）。那么在横坐标中，n=1 时对应的 f 是 4kHz, n=2 对应的是 8kHz, n=15 时对应的是 60kHz，你的频谱是关于 n=8 对称的。你只需要关心 n=0 到 7 以内的频谱就足够了，因为，原来信号的最高模拟频率是 32kHz。<br><a href="https://blog.csdn.net/weixin_39591031/article/details/110392352">https://blog.csdn.net/weixin_39591031/article/details/110392352</a></p><h2 id="QPSK"><a href="#QPSK" class="headerlink" title="QPSK"></a>QPSK</h2><p>QPSK 又叫<strong>四相绝对相移调制（4PSK）</strong>，QPSK 利用载波的四种不同相位来表征数字信息。它的频带利用率高，是 BPSK(二相相移键控）的 2 倍。当数据码元速率相同时，QPSK 信号的传输波特率为 BPSK 信号的传输波特率的一半，所以 QPSK 的传输带宽是 BPSK 信号的一半。QPSK 调制技术的抗干扰能力强，采用相干检测时其误码性能与 BPSK 相同，故得到广泛应用。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6-1.png#clientId=u6d886849-8a59-4&from=paste&height=86&id=u40231118&margin=%5Bobject%20Object%5D&name=image.png&originHeight=172&originWidth=922&originalType=binary&size=45922&status=done&style=none&taskId=u80ca2014-1869-4d49-b7f8-d1456c86125&width=461" alt="image.png"><br>写成正交形式：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6-2.png#clientId=u6d886849-8a59-4&from=paste&height=149&id=u0c5731d0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=297&originWidth=1117&originalType=binary&size=83630&status=done&style=none&taskId=u3fd5ace3-945e-4eac-bc13-dac014e29e4&width=558.5" alt="image.png"><br>QPSK 调制是利用载波的 4 种不同相位来表征数字信息。每一种载波相位代表两个比特的信息。例如，若输入二进制数字信息，序列为 10011100，…，则应该先将其进行分组，每两个比特编为一组。可将它们分为 10，01，11，00 等，然后分别用四种不同的相位来表示。故每个四进制码元又称为双比特码元。把组成双比特码元的前一个信息比特用 a 表示，后一个信息比特用 b 表示。双比特码元中两个信息比特 ab 与载波相位的矢量关系如图 1 所示。图（a）表示 A 方式时 QPSK 信号矢量图，图（b）表示 B 方式时 QPSK 信号的矢量图。由于正弦和余弦的互补特性，对于载波相位的四种取值，在 A 方式中：0°、90°、180°、270°，则数据通过处理后输岀的成形波形幅度有三种取值；B 方式中：45°、135°、225°、315°，则数据通过处理后输出的成形波形幅度有两种取值。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6-3.png#clientId=u6d886849-8a59-4&from=paste&height=115&id=u633a436c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=230&originWidth=750&originalType=binary&size=26531&status=done&style=none&taskId=u44ca49f7-2450-4bb0-841f-6fa8556732d&width=375" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6-4.png#clientId=u6d886849-8a59-4&from=paste&height=185&id=uce77a3fe&margin=%5Bobject%20Object%5D&name=image.png&originHeight=185&originWidth=446&originalType=binary&size=14966&status=done&style=none&taskId=u3c682ff6-2ff7-415e-b46c-5a165526cd4&width=446" alt="image.png"><br>在本次实验中我们采取 B 方式进行调制。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6-5.png#clientId=u6d886849-8a59-4&from=paste&height=242&id=ucdfabb2a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=284&originWidth=676&originalType=binary&size=17711&status=done&style=none&taskId=u40e11ebc-b2ee-4601-b62f-71e844d08ee&width=576" alt="image.png"><br>原理图如上。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6-6.png#clientId=u6d886849-8a59-4&from=paste&height=185&id=u45ba068d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=370&originWidth=835&originalType=binary&size=66431&status=done&style=none&taskId=u3a4a4871-452c-400d-847a-470c345f1da&width=417.5" alt="image.png"></p><h2 id="QPSK-的功率谱"><a href="#QPSK-的功率谱" class="headerlink" title="QPSK 的功率谱"></a>QPSK 的功率谱</h2><p>由于 QPSK 信号可被理解为由同相支路和正交支路两路 2PSK 叠加而成，但是载波的幅度与码元速率不同，因此 QPSK 信号的功率谱密度相当于 2PSK 信号的功率谱密度的线性叠加：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6-7.png#clientId=u6d886849-8a59-4&from=paste&height=49&id=u60898145&margin=%5Bobject%20Object%5D&name=image.png&originHeight=98&originWidth=663&originalType=binary&size=21889&status=done&style=none&taskId=u7f7c99c7-14ab-4639-a548-05a3d1a2b02&width=331.5" alt="image.png"><br>因此 QPSK 信号的功率谱示意图如下：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6-8.png#clientId=u6d886849-8a59-4&from=paste&height=147&id=u8a6de52d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=294&originWidth=737&originalType=binary&size=35568&status=done&style=none&taskId=u57056394-5a0d-4c56-a71b-f833cbdb882&width=368.5" alt="image.png"><br>由上图可以看出其带宽等于基带码元速率，峰值频率为等于载波频率。</p><h2 id="星座图的基本概念"><a href="#星座图的基本概念" class="headerlink" title="星座图的基本概念"></a>星座图的基本概念</h2><p>在数字通信领域中，经常将数字信号在复平面上表示，以直观的表示信号以及信号之间的关系，这种图示就是星座图。星座图可以看成数字信号的一个“二维眼图”阵列，同时符号在图中所处的位置具有合理的限制或判决边界。如果要将数字信号发送出去，一般不会直接发 0 或 1，而是先将 0,1 信号（bit）按照一个或者几个组成一组，比如每两个 bit 组成一组，即有 00,01,10,11，总共四种状态，此时可以选择 QPSK 调制，QPSK 四个点组成一个 QPSK 的星座图，每个点与相邻的点相差 90 度（幅度是相同的），一个星座点对应一个调制符号。星座图的作用主要是在调制时用于映射，而接收时用于判断发送的到底是哪个点，从而正确解调数据。</p><h1 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h1><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all;clc;</span><br><span class="line"><span class="comment">%% 生成伪随机码</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">orderNum = <span class="number">6</span>;<span class="comment">%m序列为6阶</span></span><br><span class="line"></span><br><span class="line">xulie = idinput((<span class="number">2</span>^orderNum<span class="number">-1</span>),<span class="string">&#x27;prbs&#x27;</span>);<span class="comment">% 生成伪随机序列,长度为63</span></span><br><span class="line"></span><br><span class="line">fb = <span class="number">10</span>; <span class="comment">% 波特率10kHz ,比特率值=波特率值,每秒能传输的二进制位数</span></span><br><span class="line"></span><br><span class="line">Ns = <span class="number">64</span>; <span class="comment">% 采样次数</span></span><br><span class="line"></span><br><span class="line">fs=fb*Ns; <span class="comment">% 采样频率,每秒从连续信号中提取并组成离散信号的采样个数</span></span><br><span class="line"></span><br><span class="line">fc = fb; <span class="comment">%载波频率=比特率</span></span><br><span class="line"></span><br><span class="line">dt=<span class="number">1</span>/fs; <span class="comment">% 采样时间,又称时域采样间隔</span></span><br><span class="line"></span><br><span class="line">Ts = dt;</span><br><span class="line"></span><br><span class="line">N = Ns*<span class="built_in">length</span>(xulie); <span class="comment">% 总采样点个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 生成两路调制信号</span></span><br><span class="line"></span><br><span class="line">I_carrier = <span class="built_in">zeros</span>(<span class="number">1</span>,N);</span><br><span class="line">Q_carrier = <span class="built_in">zeros</span>(<span class="number">1</span>,N);</span><br><span class="line">I = <span class="built_in">zeros</span>(<span class="number">1</span>,N);</span><br><span class="line">Q = <span class="built_in">zeros</span>(<span class="number">1</span>,N);</span><br><span class="line"></span><br><span class="line"><span class="comment">%采用绘图比较I、Q比特流</span></span><br><span class="line">bit_data=<span class="built_in">zeros</span>(<span class="number">1</span>,N);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:len<span class="number">-1</span></span><br><span class="line">    bit_data(Ns*(<span class="built_in">i</span><span class="number">-1</span>)+<span class="number">1</span>:Ns*<span class="built_in">i</span>)=xulie(<span class="built_in">i</span>);<span class="comment">%在一个比特周期里面有Fs个1和采样点一模一样</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%对奇数抽样</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:len/<span class="number">2</span></span><br><span class="line">    I(<span class="number">2</span>*Ns*(<span class="built_in">i</span><span class="number">-1</span>)+<span class="number">1</span>:<span class="number">2</span>*Ns*<span class="built_in">i</span>) = xulie(<span class="number">2</span>*<span class="built_in">i</span><span class="number">-1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%对偶数采样</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:len/<span class="number">2</span><span class="number">-1</span></span><br><span class="line">    Q(<span class="number">2</span>*Ns*(<span class="built_in">i</span><span class="number">-1</span>)+<span class="number">1</span>:<span class="number">2</span>*Ns*<span class="built_in">i</span>) = xulie(<span class="number">2</span>*<span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:N</span><br><span class="line">    I_carrier(<span class="built_in">i</span>) = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fc*(<span class="built_in">i</span><span class="number">-1</span>)/(fs));</span><br><span class="line">    Q_carrier(<span class="built_in">i</span>) = -<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fc*(<span class="built_in">i</span><span class="number">-1</span>)/(fs));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%补充采样（最后一个采样点）</span></span><br><span class="line">I_carrier = [I_carrier,<span class="built_in">ones</span>(<span class="number">1</span>,<span class="number">64</span>)*<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fc*(<span class="built_in">i</span><span class="number">-1</span>)/(fs))];</span><br><span class="line">Q_carrier = [Q_carrier,<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">64</span>)];</span><br><span class="line">Q = [Q,<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">64</span>)];</span><br><span class="line"></span><br><span class="line">T = N*dt*fb; <span class="comment">% 截断时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%绘图</span></span><br><span class="line"><span class="built_in">figure</span>();</span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(bit_data,<span class="string">&#x27;color&#x27;</span>,[<span class="number">55</span>/<span class="number">255</span> <span class="number">108</span>/<span class="number">255</span> <span class="number">176</span>/<span class="number">255</span>]);<span class="built_in">legend</span>(<span class="string">&#x27;Bitstream&#x27;</span>)<span class="comment">%比特信息</span></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(I,<span class="string">&#x27;color&#x27;</span>,[<span class="number">55</span>/<span class="number">255</span> <span class="number">108</span>/<span class="number">255</span> <span class="number">176</span>/<span class="number">255</span>]);<span class="built_in">legend</span>(<span class="string">&#x27;I Bitstream&#x27;</span>)<span class="comment">%I路信息</span></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">plot</span>(Q,<span class="string">&#x27;color&#x27;</span>,[<span class="number">55</span>/<span class="number">255</span> <span class="number">108</span>/<span class="number">255</span> <span class="number">176</span>/<span class="number">255</span>]);<span class="built_in">legend</span>(<span class="string">&#x27;Q Bitstream&#x27;</span>)<span class="comment">%Q路信息</span></span><br><span class="line"><span class="comment">%% 调制</span></span><br><span class="line"></span><br><span class="line">I_data = I.*I_carrier;</span><br><span class="line">Q_data = Q.*Q_carrier;</span><br><span class="line">QPSK_data = (I_data + Q_data)/<span class="built_in">sqrt</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>();<span class="comment">%产生一个新图</span></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(I_data,<span class="string">&#x27;color&#x27;</span>,[<span class="number">55</span>/<span class="number">255</span> <span class="number">108</span>/<span class="number">255</span> <span class="number">176</span>/<span class="number">255</span>]);<span class="built_in">legend</span>(<span class="string">&#x27;I signal&#x27;</span>)<span class="comment">%I路信号</span></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(Q_data,<span class="string">&#x27;color&#x27;</span>,[<span class="number">55</span>/<span class="number">255</span> <span class="number">108</span>/<span class="number">255</span> <span class="number">176</span>/<span class="number">255</span>]);<span class="built_in">legend</span>(<span class="string">&#x27;Q signal&#x27;</span>)<span class="comment">%Q路信号</span></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">plot</span>(QPSK_data,<span class="string">&#x27;color&#x27;</span>,[<span class="number">55</span>/<span class="number">255</span> <span class="number">108</span>/<span class="number">255</span> <span class="number">176</span>/<span class="number">255</span>]);<span class="built_in">legend</span>(<span class="string">&#x27;QPSK signal&#x27;</span>)<span class="comment">%QPSK信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 频谱</span></span><br><span class="line">Bs =fs/<span class="number">2</span>; <span class="comment">% 系统带宽</span></span><br><span class="line">QPSK = <span class="built_in">abs</span>(fftshift(fft(QPSK_data,N)));</span><br><span class="line">ff = <span class="built_in">linspace</span>(-Bs,Bs,N); <span class="comment">% 频域横坐标</span></span><br><span class="line"><span class="built_in">figure</span>()</span><br><span class="line"><span class="built_in">plot</span>(ff,QPSK,<span class="string">&#x27;color&#x27;</span>,[<span class="number">55</span>/<span class="number">255</span> <span class="number">108</span>/<span class="number">255</span> <span class="number">176</span>/<span class="number">255</span>])</span><br><span class="line"><span class="comment">%axis([-50,50,0,60]);</span></span><br><span class="line">title(<span class="string">&#x27;QPSK调制信号频谱图&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;f/kHz&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;频谱&#x27;</span>);</span><br><span class="line"><span class="comment">%% 功率谱密度</span></span><br><span class="line">Bs =fs/<span class="number">2</span>; <span class="comment">% 系统带宽</span></span><br><span class="line">QPSK = <span class="number">10</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(fftshift(fft(QPSK_data,N))).^<span class="number">2</span>/T);</span><br><span class="line">ff = <span class="built_in">linspace</span>(-Bs,Bs,N); <span class="comment">% 频域横坐标</span></span><br><span class="line"><span class="built_in">figure</span>()</span><br><span class="line"><span class="built_in">plot</span>(ff,QPSK,<span class="string">&#x27;color&#x27;</span>,[<span class="number">55</span>/<span class="number">255</span> <span class="number">108</span>/<span class="number">255</span> <span class="number">176</span>/<span class="number">255</span>])</span><br><span class="line">axis([<span class="number">-50</span>,<span class="number">50</span>,<span class="number">0</span>,<span class="number">60</span>]);</span><br><span class="line">title(<span class="string">&#x27;QPSK调制信号功率谱图&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;f/kHz&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;功率谱密度/db&#x27;</span>);</span><br><span class="line"><span class="comment">%% 绘制星座图</span></span><br><span class="line"></span><br><span class="line">signal = <span class="built_in">cat</span>(<span class="number">2</span>, I&#x27;, Q&#x27;);         <span class="comment">% 将两路串行信号码元合并在一个length(xulie)*2的矩阵中</span></span><br><span class="line"></span><br><span class="line">[a1,~]=<span class="built_in">find</span>(signal(:,<span class="number">1</span>)==<span class="number">-1</span>&amp;signal(:,<span class="number">2</span>)==<span class="number">-1</span>);       <span class="comment">% 返回满足条件的矩阵元素对应的坐标</span></span><br><span class="line"></span><br><span class="line">xinzuotu(a1)=<span class="number">-1</span><span class="number">-1</span><span class="built_in">i</span>;</span><br><span class="line"></span><br><span class="line">[a2,~]=<span class="built_in">find</span>(signal(:,<span class="number">1</span>)==<span class="number">-1</span>&amp;signal(:,<span class="number">2</span>)==<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">xinzuotu(a2)=<span class="number">-1</span>+<span class="number">1</span><span class="built_in">i</span>;</span><br><span class="line"></span><br><span class="line">[a3,~]=<span class="built_in">find</span>(signal(:,<span class="number">1</span>)==<span class="number">1</span>&amp;signal(:,<span class="number">2</span>)==<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">xinzuotu(a3)=<span class="number">1</span><span class="number">-1</span><span class="built_in">i</span>;</span><br><span class="line"></span><br><span class="line">[a4,~]=<span class="built_in">find</span>(signal(:,<span class="number">1</span>)==<span class="number">1</span>&amp;signal(:,<span class="number">2</span>)==<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">xinzuotu(a4)=<span class="number">1</span>+<span class="number">1</span><span class="built_in">i</span>;</span><br><span class="line"></span><br><span class="line">scatterplot(xinzuotu)  <span class="comment">% 以散点图的形式画出星座图</span></span><br><span class="line"></span><br><span class="line">axis([<span class="number">-2</span> <span class="number">2</span> <span class="number">-2</span> <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">title(<span class="string">&#x27;理想情况基带发射星座图&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><p>基带时域波形图<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6-9.png#clientId=u6d886849-8a59-4&from=paste&height=185&id=u6306bebc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=200&originWidth=754&originalType=binary&size=34568&status=done&style=none&taskId=ude058ecc-602d-4822-b0c1-20e41b84afa&width=699" alt="image.png"><br>QPSK 调制信号波形图<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6-10.png#clientId=u6d886849-8a59-4&from=paste&height=191&id=u18365c2d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=210&originWidth=746&originalType=binary&size=128005&status=done&style=none&taskId=u5c2a400b-5220-4dcd-ad80-60844de7555&width=679" alt="image.png"><br>QPSK 调制信号功率谱图<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6-11.png#clientId=u6d886849-8a59-4&from=paste&height=332&id=uc862d20b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=332&originWidth=441&originalType=binary&size=51742&status=done&style=none&taskId=u90871b21-cec3-43ae-961b-35634aecd9e&width=441" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;b 测题目，由于学长写的代码有些步骤无法理解，而且代码不优雅，故重写之。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>区块链底层-区块与交易</title>
    <link href="https://www.blog.hackerjerry.top/2021/04/24/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%8C%BA%E5%9D%97%E4%B8%8E%E4%BA%A4%E6%98%93_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/04/24/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%8C%BA%E5%9D%97%E4%B8%8E%E4%BA%A4%E6%98%93_new/</id>
    <published>2021-04-24T07:32:07.000Z</published>
    <updated>2021-05-26T12:23:18.267Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="全局结构"><a href="#全局结构" class="headerlink" title="全局结构"></a>全局结构</h1><p>下图是以太坊区块数据结构与关系。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%8C%BA%E5%9D%97%E4%B8%8E%E4%BA%A4%E6%98%93-1.png#clientId=u9ae9216b-af72-4&from=paste&height=402&id=u321a8f97&margin=%5Bobject%20Object%5D&originHeight=644&originWidth=1228&originalType=url&status=done&style=none&taskId=u9f6b4a08-53f6-466b-bd87-bb0cb52dc50&width=766"><br>区块分为两部分：区块头(Header)和区块体(Body)。区块头信息量非常丰富，不但和上一个单元建立联系还记录了一些交易执行情况信息和矿工工作信息。</p><h1 id="定义代码"><a href="#定义代码" class="headerlink" title="定义代码"></a>定义代码</h1><p>下面是以太坊代码中定义的区块头和区块体结构定义代码，所有核心代码均在 core/types/block.go 文件中：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/types/block.go:70</span></span><br><span class="line"><span class="keyword">type</span> Header <span class="keyword">struct</span> &#123;</span><br><span class="line">   ParentHash  common.Hash    <span class="string">`json:&quot;parentHash&quot;       gencodec:&quot;required&quot;`</span></span><br><span class="line">   UncleHash   common.Hash    <span class="string">`json:&quot;sha3Uncles&quot;       gencodec:&quot;required&quot;`</span></span><br><span class="line">   Coinbase    common.Address <span class="string">`json:&quot;miner&quot;            gencodec:&quot;required&quot;`</span></span><br><span class="line">   Root        common.Hash    <span class="string">`json:&quot;stateRoot&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line">   TxHash      common.Hash    <span class="string">`json:&quot;transactionsRoot&quot; gencodec:&quot;required&quot;`</span></span><br><span class="line">   ReceiptHash common.Hash    <span class="string">`json:&quot;receiptsRoot&quot;     gencodec:&quot;required&quot;`</span></span><br><span class="line">   Bloom       Bloom          <span class="string">`json:&quot;logsBloom&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line">   Difficulty  *big.Int       <span class="string">`json:&quot;difficulty&quot;       gencodec:&quot;required&quot;`</span></span><br><span class="line">   Number      *big.Int       <span class="string">`json:&quot;number&quot;           gencodec:&quot;required&quot;`</span></span><br><span class="line">   GasLimit    <span class="keyword">uint64</span>         <span class="string">`json:&quot;gasLimit&quot;         gencodec:&quot;required&quot;`</span></span><br><span class="line">   GasUsed     <span class="keyword">uint64</span>         <span class="string">`json:&quot;gasUsed&quot;          gencodec:&quot;required&quot;`</span></span><br><span class="line">   Time        <span class="keyword">uint64</span>         <span class="string">`json:&quot;timestamp&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line">   Extra       []<span class="keyword">byte</span>         <span class="string">`json:&quot;extraData&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line">   MixDigest   common.Hash    <span class="string">`json:&quot;mixHash&quot;`</span></span><br><span class="line">   Nonce       BlockNonce     <span class="string">`json:&quot;nonce&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Body <span class="keyword">struct</span> &#123;</span><br><span class="line">Transactions []*Transaction</span><br><span class="line">Uncles       []*Header</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><h3 id="parentHash"><a href="#parentHash" class="headerlink" title="parentHash"></a>parentHash</h3><p>是一个哈希值，记录此区块直接引用的父区块哈希值。通过此记录，才能完整的将区块有序组织，形成一条区块链。并且可以防止父区块内容被修改，因为数据修改，区块哈希必然发生变化，因此一个区块直接或间接的强化了所有父辈区块，通过加密算法保证历史区块不可能被修改。</p><h3 id="miner"><a href="#miner" class="headerlink" title="miner"></a>miner</h3><p>是一个地址，表示区块是此账户的矿工挖出，挖矿奖励将下发到此账户。</p><h3 id="transactionsRoot"><a href="#transactionsRoot" class="headerlink" title="transactionsRoot"></a>transactionsRoot</h3><p>是一个哈希值，表示该区块中所有交易生成一颗默克尔树根节点哈希值。是一个密码学保证交易集合摘要。通过此 Root 可以直接校验某交易是否包含在此区块中。</p><h3 id="mixHash"><a href="#mixHash" class="headerlink" title="mixHash"></a>mixHash</h3><p>是一个哈希值。用于校验区块是否正确挖出。实际上是区块头数据不包含 nonce 时的一个哈希值。</p><h1 id="区块体"><a href="#区块体" class="headerlink" title="区块体"></a>区块体</h1><p>区块体 Body 中只有两项数据：<a href="https://learnblockchain.cn/books/geth/part1/transaction.html">交易</a>集合和叔辈区块头集合。是交易促使以太坊世界态进行转变。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%8C%BA%E5%9D%97%E4%B8%8E%E4%BA%A4%E6%98%93-2.png#clientId=u9ae9216b-af72-4&from=paste&height=203&id=u42b0fbbe&margin=%5Bobject%20Object%5D&originHeight=283&originWidth=969&originalType=url&status=done&style=none&taskId=u56a01b4b-366c-4bd6-976c-05606cea4e0&width=693.5"><br>从创世状态开始，每一个区块中的交易执行促使了以太坊世界态的转变。下一个状态是在上一个状态中执行交易或其他操作使得状态由 A 状态转变为 B 状态。<br>而交易则为状态转变的催化酶，<strong>一个区块中的所有交易执行完成后，将使得以太坊进入一个新的状态。</strong>状态转变过程中记录了一些起始变量和结果数据，分别是交易默克尔哈希值<strong>transactionsRoot</strong>、交易回执默克尔哈希值** receiptRoot<strong>、事件布隆值</strong>logsBloom<strong>、新状态的默克尔哈希值</strong>stateRoot**。</p><h1 id="交易回执"><a href="#交易回执" class="headerlink" title="交易回执"></a>交易回执</h1><p>在以太坊中一份交易回执记录了关于此笔交易的处理结果信息：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%8C%BA%E5%9D%97%E4%B8%8E%E4%BA%A4%E6%98%93-3.png#clientId=u9ae9216b-af72-4&from=paste&height=380&id=u3f9ff1a7&margin=%5Bobject%20Object%5D&originHeight=760&originWidth=652&originalType=url&status=done&style=none&taskId=u8eec5c7d-8f2e-41d5-9917-91e25564eb4&width=326"><br>回执信息分为三部分：共识信息、交易信息、区块信息。下面分别介绍各类信息。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%8C%BA%E5%9D%97%E4%B8%8E%E4%BA%A4%E6%98%93-4.png#clientId=u9ae9216b-af72-4&from=paste&height=359&id=u9d6c0d41&margin=%5Bobject%20Object%5D&originHeight=718&originWidth=642&originalType=url&status=done&style=none&taskId=u780e7386-1eaa-45c3-a6fc-2cdef063091&width=321"></p><h2 id="交易回执共识信息"><a href="#交易回执共识信息" class="headerlink" title="交易回执共识信息"></a>交易回执共识信息</h2><p>共识意味在在校验区块合法性时，这部分信息也参与校验。这些信息参与校验的原因是确保交易必须在区块中的固定顺序中执行，且记录了交易执行后的状态信息。这样可强化交易顺序。</p><ul><li>Status： 成功与否，1 表示成功，0 表示失败。</li><li>CumulativeGasUsed： 区块中已执行的交易累计消耗的 Gas，包含当前交易。</li><li>Logs: 当前交易执行所产生的智能合约事件列表。</li><li>Bloom：是从 Logs 中提取的事件布隆过滤器，用于快速检测某主题的事件是否存在于 Logs 中。</li></ul><p><strong>如何参与共识校验呢</strong>？<br>实际上<strong>参与校验</strong>的<strong>仅仅是回执哈希</strong>，而<strong>回执哈希</strong>计算<strong>只包含这些信息</strong>。<br>首先，在校验时获取整个区块回执信息的默克尔树的根哈希值。再判断此哈希值是否同区块头定义内容相同。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/block_validator.go:92</span></span><br><span class="line">receiptSha := types.DeriveSha(receipts)</span><br><span class="line"><span class="keyword">if</span> receiptSha != header.ReceiptHash &#123;</span><br><span class="line">   <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid receipt root hash (remote: %x local: %x)&quot;</span>,</span><br><span class="line">   header.ReceiptHash, receiptSha)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而函数 types.DeriveSha 中<strong>生成根哈希值</strong>，是将列表元素（这里是<strong>交易回执</strong>）的<strong>RLP 编码信息</strong>构成<strong>默克树</strong>，最终获得列表的哈希值。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/types/derive_sha.go:32</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeriveSha</span><span class="params">(list DerivableList)</span> <span class="title">common</span>.<span class="title">Hash</span></span> &#123;</span><br><span class="line">   keybuf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">   trie := <span class="built_in">new</span>(trie.Trie)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; list.Len(); i++ &#123;</span><br><span class="line">      keybuf.Reset()</span><br><span class="line">      rlp.Encode(keybuf, <span class="keyword">uint</span>(i))</span><br><span class="line">      trie.Update(keybuf.Bytes(), list.GetRlp(i))</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> trie.Hash()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// core/types/receipt.go:237</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Receipts)</span> <span class="title">GetRlp</span><span class="params">(i <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">   bytes, err := rlp.EncodeToBytes(r[i])</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> bytes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往下看，交易回执实现了 RLP 编码接口。在方法 EncodeRLP 中是构建了一个私有的 receiptRLP。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/types/receipt.go:119</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Receipt)</span> <span class="title">EncodeRLP</span><span class="params">(w io.Writer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> rlp.Encode(w,</span><br><span class="line">&amp;receiptRLP&#123;r.statusEncoding(), r.CumulativeGasUsed, r.Bloom, r.Logs&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出 receiptRLP 仅仅包含上面提到的参与共识校验的内容。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/types/receipt.go:78</span></span><br><span class="line"><span class="keyword">type</span> receiptRLP <span class="keyword">struct</span> &#123;</span><br><span class="line">   PostStateOrStatus []<span class="keyword">byte</span></span><br><span class="line">   CumulativeGasUsed <span class="keyword">uint64</span></span><br><span class="line">   Bloom             Bloom</span><br><span class="line">   Logs              []*Log</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="交易回执交易信息"><a href="#交易回执交易信息" class="headerlink" title="交易回执交易信息"></a>交易回执交易信息</h2><p>这部分信息记录的是关于回执所对应的交易信息，有：</p><ul><li>TxHash ： 交易回执所对应的交易哈希。</li><li>ContractAddress： 当这笔交易是部署新合约时，记录新合约的地址。</li><li>GasUsed: 这笔交易执行所消耗的<a href="https://learnblockchain.cn/books/geth/part1/gas.html">Gas 燃料</a>。</li></ul><p>这些信息不参与共识的原因是这三项信息已经在其他地方校验。</p><ul><li>TxHash: 区块有校验交易集的正确性。</li><li>ContractAddress： 如果是新合约，实际上已经提交到以太坊状态 State 中。</li><li>GasUsed： 已属于 CumulativeGasUsed 的一部分。</li></ul><h2 id="交易回执区块信息"><a href="#交易回执区块信息" class="headerlink" title="交易回执区块信息"></a>交易回执区块信息</h2><p>这部分信息完全是<strong>为了方便外部读取交易回执</strong>，不但知道交易执行情况，<strong>还能方便的指定该交易属于哪个区块中第几笔交易</strong>。</p><ul><li>BlockHash: <strong>交易所在区块哈希</strong>。</li><li>BlockNumber: <strong>交易所在区块高度</strong>。</li><li>TransactionIndex：<strong>交易在区块中的序号</strong>。</li></ul><p>这三项信息，主要是<strong>在数据库 Leveldb 中读取交易回执</strong>时，<strong>实时指定</strong>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/rawdb/accessors_chain.go:315</span></span><br><span class="line">receipts := <span class="built_in">make</span>(types.Receipts, <span class="built_in">len</span>(storageReceipts))</span><br><span class="line">logIndex := <span class="keyword">uint</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i, receipt := <span class="keyword">range</span> storageReceipts &#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   receipts[i] = (*types.Receipt)(receipt)</span><br><span class="line">   receipts[i].BlockHash = hash</span><br><span class="line">   receipts[i].BlockNumber = big.NewInt(<span class="number">0</span>).SetUint64(number)</span><br><span class="line">   receipts[i].TransactionIndex = <span class="keyword">uint</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="交易回执存储"><a href="#交易回执存储" class="headerlink" title="交易回执存储"></a>交易回执存储</h2><p><strong>交易回执</strong>作为<strong>交易执行中间产物</strong>，为了方便快速获取某笔交易的执行明细。以太坊中有跟随区块存储时实时存储交易回执。但为了降低存储量，只存储了必要内容。<br>首先，在<strong>存储</strong>时，将交易回执对象转换为<strong>精简内容</strong>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/rawdb/accessors_chain.go:338</span></span><br><span class="line">storageReceipts := <span class="built_in">make</span>([]*types.ReceiptForStorage, <span class="built_in">len</span>(receipts))</span><br><span class="line"><span class="keyword">for</span> i, receipt := <span class="keyword">range</span> receipts &#123;</span><br><span class="line">   storageReceipts[i] = (*types.ReceiptForStorage)(receipt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>精简内容是专门为存储定义的一个结构 ReceiptForStorage。存储时将交易回执集进行 RLP 编码存储。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/rawdb/accessors_chain.go:342</span></span><br><span class="line">bytes, err := rlp.EncodeToBytes(storageReceipts)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   log.Crit(<span class="string">&quot;Failed to encode block receipts&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := db.Put(blockReceiptsKey(number, hash), bytes); err != <span class="literal">nil</span> &#123;</span><br><span class="line">   log.Crit(<span class="string">&quot;Failed to store block receipts&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以看存储了哪些内容，只需要看 ReceiptForStorage 的 EncodeRLP 方法：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/types/receipt.go:179</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ReceiptForStorage)</span> <span class="title">EncodeRLP</span><span class="params">(w io.Writer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   enc := &amp;receiptStorageRLP&#123;</span><br><span class="line">      PostStateOrStatus: (*Receipt)(r).statusEncoding(),</span><br><span class="line">      CumulativeGasUsed: r.CumulativeGasUsed,</span><br><span class="line">      TxHash:            r.TxHash,</span><br><span class="line">      ContractAddress:   r.ContractAddress,</span><br><span class="line">      Logs:              <span class="built_in">make</span>([]*LogForStorage, <span class="built_in">len</span>(r.Logs)),</span><br><span class="line">      GasUsed:           r.GasUsed,</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> i, log := <span class="keyword">range</span> r.Logs &#123;</span><br><span class="line">      enc.Logs[i] = (*LogForStorage)(log)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> rlp.Encode(w, enc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%8C%BA%E5%9D%97%E4%B8%8E%E4%BA%A4%E6%98%93-5.png#clientId=u9ae9216b-af72-4&from=paste&height=482&id=u14eddb16&margin=%5Bobject%20Object%5D&originHeight=746&originWidth=854&originalType=url&status=done&style=none&taskId=ubb7522ff-0229-47a2-8673-79e407e628c&width=552"></p><h1 id="交易回执示例–文档参考"><a href="#交易回执示例–文档参考" class="headerlink" title="交易回执示例–文档参考"></a>交易回执示例–文档参考</h1><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%8C%BA%E5%9D%97%E4%B8%8E%E4%BA%A4%E6%98%93-6.png#clientId=u9ae9216b-af72-4&from=paste&height=737&id=u301c1b6f&margin=%5Bobject%20Object%5D&originHeight=1474&originWidth=1664&originalType=url&status=done&style=none&taskId=u1730403f-a93e-4126-920d-39990df7fdc&width=832"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;全局结构&quot;&gt;&lt;a href=&quot;#全局结构&quot; class=&quot;headerlink&quot; title=&quot;全局结构&quot;&gt;&lt;/a&gt;全局结构&lt;/h1&gt;&lt;p&gt;下图是以太坊区块数据结构与关系。&lt;br&gt;&lt;img src= &quot;/img/loading</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>流量在线识别系统demo</title>
    <link href="https://www.blog.hackerjerry.top/2021/04/20/%E6%B5%81%E9%87%8F%E5%9C%A8%E7%BA%BF%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9Fdemo_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/04/20/%E6%B5%81%E9%87%8F%E5%9C%A8%E7%BA%BF%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9Fdemo_new/</id>
    <published>2021-04-20T07:13:42.000Z</published>
    <updated>2021-05-26T12:19:53.263Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="9422fa806c25e7d58e0067bc1326e0a24a90816ece815c0b65b082a6e9b66385">7a27311b6b2cd1a21889c25f42783ffe4f9a32211aa3e3e4c19ef8ed59d1827283d5421fe472fe4b7f35f73b07945e464e34189aba4887343b0bbc49264ef710bf94373d34a783aa80f376a37cfaa4489a2ecb2c6343f4a296a02b275c45f13a5a28b93b0d2564f039bfcbfadf0bde518ab29fdaafa9e2cb94d6fdbe5e4cec62e4b72dd6f26966c8a288702c70679166cb169247e2b6bf99792238dd4a3619c5e788d529ad5e58bab285c0a32a4605bd2f43671f2a643f2dd5d994e20922cf09226ea850583b561b67fe9c59adbf0c8fd31a25a4fa6772a3149ad5044188540278e013247bd03ce1d6e8963977b91362fcef63d430eab09a0e70f6cba1284d84368e1647a00d3f1be3d665c80bb77f6ac5d6f6e719fc32bd29bca39ef84be2dc6c13f87a3699d457fdd6d16c03fc668132ade68839495f15b14273562aa8afd86c16696acfac72cf07796ef10dcf96686bbde3cd020b066d51e6c68ba6f1b1689ffd19d00484aa2b56fbe14394eb62927b987f355d8c2dbac2c184075ec77f61215df23a8ecfe06b239f8e955db3e3fc74fdea0aab51802ab4e9dbfe39dbc56c998f467fec59437af891bffe049d70379ffdb199a36689463b69a015bafff1df1af6b4e17202783fb70036a2d727dc0ea84c46d228f130a0488b5f3206cf4d71200716337a90d2831529617992f5cfb513dd5ec4dbb273001df911b1b65edbbe1fbdc0fb53950136a386efc3cf78866180740daf2be9c56b7102d480ee8662c596fc4bf8ffe806f96963bfdf74a79f1464648256744e3570e654b1530e9598908219055e6bbf0c36ec0bad029a777d7c7b1094f2f4cc7cd94033ffbec4915620c0e44fb6798300968c34c6decf3763c3afe65521b7d47999599621dc652f1467760b94308c5d457033344fa899674d60aa120099d5fc9a59bab1b1ec425e72356847b56583677c477b7366d3d56338e0396ff80f813f2278b4a8530d5172d13270591643199fbaf56dbcc5e2090de52d7466ad78271e330a8a075077dc30861ba3ed955dfb7faf4fe8196675b16a360fbf7664882638d1ee3eeb93cff517a20935ff238ea4a76f6c8e3ecdd00f4d041e4ba3f09e78b7df2872f2d137de061a0a599f3331469df053652de08f88c7372fb90073d4957a4b5af852ec3d9f615f42307df6bad8f9d1b1772012b36a248ea2ef646c0cca0e4270a7f6d6149d7a5c856c44042d7fa45377d10eaa9e82f2d9c2b02aff994a2707dc98a5580d4d106b3215181529734dddff3852d0eff9a9dd2b263ddf96d5eb6ec9784dbfebd09970fb164b9de9567a9438e0238044561fe6bcdc14ba0abd1e4f719555fdcdeaf3bf7ab0a03b5cdb9cde88d180dfa015803b7d89c0f5b84911ec2c34b2669fa12cf96de7396b84c1f3aedfd07f1e4d690ad540844348c8bd4efeaa67aedb7a4f44f50faf329f5bd152d9d911263f8fe71f18790c20e373d456345c31c517710ac61a02684d5a87fa45dfe0c0e9f2f333ecaee3ef668ee0a461d56894b0369fb20e3c259218a51deec0fec09f0eebae31b3fb86a35d1e23f9c5679788ed26613cd52f8d11dec1cadf604c867e697ec4bbf79ce459e1c9682487246ef5d154cc30e2e22d1d7a0ef400d60f664ffc77b789c451c2674e885c22d80180f926949ab8641e508861a0c1af4a80c790f99cbedb723289471b21e6cdd2211901b9abe26c04d2e07754ec4f3bf0533c76439c68b414bc1787f133fd8a41edf7727eda12879715446c406060fad90dcd11750c7523016c37f0bddd201bf704ea053f645ea00179503dba899b78dc79707f5e5e8be86d66b5c81f5cb51ed1a8762ca275c8885b73616349a710672425a5e0e50bbdd52d460330bd3fbff82fcbf350986a0c26678c7c97210e2ac84ca8648114d4a12ad157ec0ef21640f00c03151e4f256da814e932eea85fd98d2310a12b6731348de1fd1b0c4e79e97caf40deadb46ead8fcf2aed1ff661ce8e9d86051785e007331052e5376d67ca126881e1a369fb4cb5b32b4f1c8b320765966c8491a0d4a811d3982489aa378600136d91ee880622fa935abb7157b73f02f501a8198232bb938163601fb278e14acb7f5495ee266b90d13c70d904e51299e49de42bfa5438a77eaadd22d1fbce0c9ca4c90cac031714b9c7c12851e3247b8764a3a7aa1f5dd9e4595c8c1af2be9f24f80a59ed7ee089fc45225025fe7b12d657d58b96729a53180de7a6ae5f43c609b2a9fbf9d0e2e8d9b4f5e70aa9a7a628693d8c13e3676d984bbc05969d7a6e1116d0073727226b689fecbbf41d01c749d1dcba746fc29ac87dc48d0e83af30881d3742783fa46fc822042241461c069b26d582d597d87d7adfa480c0c1cd7035dcb641ab267fc995bf604fcb5b1b35344909f8be3904d69daebefc15ea18edfc27e441d729b38c24f79955d17d69195f4185dece33a64f6a95edd65e32a4efa721a9355378c5aa6f30e8200620ff1095acd000b4030e151a7b4e6e5f18524c28d618167b1b63a3ec0a8ace41156dc1194a0a95b4210f98451290f891fba0dcf8e9bfaa6d7dc80bbab0d608f81c38d4d21d9c4e55efe4fac2525602fde7832196ceab1b8c7d2ffd6de723190192430278e5f2187946dc94715540df5cfb01161ef55acf2628466bc051a424cf4c6a52404468a90c6a2998defa0a0bf708c8cfb7ab7a182f4d7714054d9234941db204e13cfa3490531e8ffe27d1461330999f0afbc57f2e6729c86f0f9117f838385c28e6914d261fc561c54057d8c111476f0bdd0487e4977b838110e287727f7b3d725c7d4fac0b5af5d01e8c2a86d61e2c22b145d156fe28e667e517cb4fd1dc9fc6ee601cf4f6a5e5fed7e88a2dfb52ec9d40004307866df2399e95db0332e12cbd37cbec98b8d242dfd2551c220fcb7cd5a187e56d8e7957290275456557d987cab1a0b80f33180f0064b776e2de65f51d9bd73bfdbfe6597c2593063d11af73b1c4d7ef7e5c69631358af42e5ac93b53c71da9caf14dd29d99e095ab5b87572a93c8c5556357507ca5f158bb94782f3166213e0c8e0bb42ccae1eefc69f75c5f9c4d775bc31ca7f419e74ef9e43243d8480ce934d83b9d80cc392a694b9239d978895472328407629a34d39000365796d2c8eecf86b67aeb14cfcd148e5235de8479200ff94f1724c411351cde7067319b8f3a6531b00f02968e4df856d89c13d3954adcf1a4b72074ea86bc2c644b6a2bb80ba8b961959b1e2c85d6e166d4bb096b995abe0f46c3cf367a6c1857fc030cfbf25dc6e2115f42a6fa3bf70fb605f28f37cbe4bcb23800ab6852f7a69ce1a16d94f2e85c6b57671488f0314726b3bd2c1e663fe11d6f675fcbcfb291cd299851a7e832df89ca42cd7b782ba93ccc78583850f2f644c1bc76d39e3e85aea821314c15dad2e40704011bcde9d529a557a6900dd0bb65eb88ec7f12af96696d0b61f7830fd15d40f1073eb41b30487c5ffa638489b29e43896475808139386ab18bc734a82b06e9b593347faa05ace68645a6c0f23c51ca0c65504a396c83a1a6f9c322472908c44f15bbc791654b0799c481c550a52e2f4ab067f2daa223d6bccab0ff8406de2207755b7fb20adf94bcb91cd4e65cc85d1df05afb80c44ceb094b72cc7998811f9216c90b945df7dc5a20091e602af1f5dfd66c10b823ffa1b479fd5a1caa2fe764adffda4719e8aa11ad7fe07224ea2eb4b984b5e68e968c96baeeed74ca40e58dd7b88af95921208b603cdabb9a401b7cb197a52d93a9fa690e2ba5e0c414cbcd6af99ee9cd214e7f9a051ba76fa6fb0e17297d249307c05411549bf8d83a7cd64c65c675b5857ec9453264ebd804c412059d6876f0ba6bed704ece6efa4b15da6a8d785d75c63580d474f9ca462ed167972127430a73154b68a777ebeb7e4a92ceadcd0bdc59479d5e2afb8309f0ed1faf36b77d3fd18206b23641337acb66d66ea9c459e5a4b3907d4d39662545839926c277db973a25d7cea9dc2738517c2db08727112061fd7c3090ab8a0e6e6af80abdcf635ff72a219cafd068c47a5248a5f62f878205b80a58d64eaa225533eafc49cad194c455c8a46f4475a6a9578cbf819f75d3b245ffff226349065d0d9a1848148bcb781b08f90122da8d9b6742ab1e3b74d7c6c6f275303db06233a63da1ba02577ef100fb374895ed88ec9b63f62b1c063563fb101ee4bd98776d3855c105a130c95386c8df277c66a7d0b7b9ee5e41d67016eb199b43bbf16a0de9d51abe22a8d19c7bef70a56704de22de6d0984d1cba8352bb9886e17ce716591c5906a9a63dca3b0e7bcde01de167f69ac66b68ce9d235abfc75d90c2f8e560e9ff41828d32d8607249f90ef5a9f2e0dbaa73a1326d72e1eeba39540c9c77a093b76165e118956ace6510771d02a5b8a5395d39f8b2abf1549a0dce1428c9f914f2f82184790f114daf1b85fe97c71443eb2006dd759c0da7d2925921d7757ea5d81311b83a2ffa057e276e5dfc61aff01405de03ad025ef25dd7f581d002739639aa2ca0b50538bbe33f5897f0fcce8575a72a04a7e775c620aa63eacefd9866fc4bb04ca62ec79f8e986826a5e34b801976cb5d3c4b7111b1c34674b1000a8a032eacba3649053b6c95530f1951796c54acaff28eb76cc1eda68133c377b591d741df6e2a6d79209d7c2bbbc830c8c953ffc8fb848163a7b1f43016cf4244688e62355eec880e1f4b73aa20a37110ddfccb7006c407f9b4930e623fad19b6ce965839f9d72fef106fd62f48dcd499e73d77a5cf037c752c537efa22086a0640b513776d5fb5ddebf8b8e1d616fa7c62ca1b00cb9424e621aa69398acdaf4e0c278079ba12bf18f35b69f419495b893542f897f292e47b4607995a087c4d506f2a931ec4d9a40f4fdd4a49b8e54ac54f9f1a5a777940fbd39ff4197e6abd2b65de4d7817049a65ff238436ae9f6a66c9302b33890e39ccb71dcd340b63bb682b0b72c9ecac843981c8941df1c62cebbb7d188312c6ab547717e74b76da16d266e2bcdb97070ae2ea596f8bb02c5afaf4d7ab8d4a8598e451e03cd89f371d06c1e996a516dc5f78e98016b802f836ed401b17a4bc622719b6ac79347b3b15e69dab2c5ad88b03cc3bb75f07921cdeba5cb961580d4f0e9789ca8a6feac5cd0189521380e4fa064dd9efee24a8ec08cf52ee304292208a5c73b17a7d6bd8c878831a8c2ff3b624d0e3d68238714835fbdf4a4547727e1cf1cb09ec1b044d5df531f030a5d62abc36c44ada5d9bad0a44ae558497eae8d57a4cd91b1595e88c1d26b9f8e526b24e782686a0b151708d7350df950980721b25bef892cd02fa2c8cbf13f6cc68dc74c8c9381c474f961e4c03e9218c7430ab9e63615b9d353e3886bdf5734aef0ce588740e7bcc9182fbec4b2031e17c488c9f8c896227f5d38ad6f6409b43c9eb09a568111eed2d78c28c853270a7466bbee19e4b26328f2eec728f5dbd821fdcbc9852845b9b24b912e4e417c574cd93dc487e9f3d3f43ec22b957ca3d6c58b0899dcb9a9da85ba89e8a572100562e8be03fbe30a79b1332b0bcbcf580846e5763dc59a51abfeaad21a5a90d2eec329c8e31b9806b32dd4157222cf963d8fa688830d2b90786492bf10cc97704405da0bd419897de80cda077166789e249017c0b1e4100889e02c5a48b9ffa9e9d52eeb2bde8c5035311b80f6860d3e911b1cbabd161c96af6c27e3fc4c59defbbd0c8ef26a1b022efbe04e0254db380aa7eded9277d0da974b50344bfa371852a66c13318213a0b24ca55f3cdd3fb6f2add424dc2d59ce360c80b490f03394df96ffb1b7aa530acc1feb53a72325e41a4e96b30632fc1724c0d0e8b9d24e31de921897c2bbf4ec1f31a873eac8cbc47d1374a86c90c8d53be917c9a7ac46c675a1d42b8c32e2fa17e0dba644bc2e7c5e22f23afbbcb04c05ec0ed269cc26a3ddbe846209ba09e6440301f0616bfaa61dad9be0efb538ad2d6c18f476cc447b922421fed0a62ac98a5c1b3350e50b4f42f4bb8685e3b78e0da7ec61529117b01b4a4444fd7e271a6c6c46e386ab1e4f16e7d0f29df767fb8428603c23e13f9d964fb5676ddd299f94303a49781562733c5aa7b00a0a28736e90313c45eb8581a8b80d1aad3347146398efe818dd41096256bc2b0a335e40737c51a1446108b42f7b59a6249098a12d009df5ee8238b6ff11bab46f949e4ab2740a3477a072ca6</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Life-Weekly-April-19-to-25</title>
    <link href="https://www.blog.hackerjerry.top/2021/04/20/Life-Weekly-April-19-to-25_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/04/20/Life-Weekly-April-19-to-25_new/</id>
    <published>2021-04-20T06:52:36.000Z</published>
    <updated>2021-05-26T12:21:03.783Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时讯"><a href="#时讯" class="headerlink" title="时讯"></a>时讯</h1><ol><li>特斯拉最近一直出事故，脚刹系统很有问题，怀疑是软件 bug，官方售后居然在发生事故后会清除事故数据和行车记录视频，这是一个负责任的大公司能干出的事吗？</li><li>特斯拉疑似提供事故数据，数据不规范，传感器数量明显不对，搁这儿欺骗消费者呢？</li><li>中国派巴基斯坦大使下榻酒店遭恐怖袭击，中方人员外出会谈，无人员受伤。</li></ol><h1 id="小事"><a href="#小事" class="headerlink" title="小事"></a>小事</h1><ol><li>周一：下雨，被学长鸽了，让我自己写在线系统，麻了。拖了一个月到比赛截至的时候说自己没写。行吧，我自己写。</li><li>周二：下雨，加油！</li><li>周三：校运会==放假，写完了！</li><li>周四：买了一把胜利 CHA-9500 球拍和尤尼克斯的手胶，开始准备认真打羽毛球了！</li><li>周五：通过考核，成为预备党员！美赛又是 M 奖，淦，再也不玩了！学校咋都 2O 19F，卷疯了。</li></ol><h1 id="本周收藏"><a href="#本周收藏" class="headerlink" title="本周收藏"></a>本周收藏</h1><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><ol><li>算法好文</li><li>羽毛球训练好文</li></ol><h2 id="剧集"><a href="#剧集" class="headerlink" title="剧集"></a>剧集</h2><ol><li>伍六七终于到主线了！！！！何导啊何导，有青山老贼那味了，希望别一部国漫画 10 年就行，追起来太费劲了。</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Life-Weekly-April-19-to-25-1.jpeg#clientId=u67cebdca-6850-4&from=drop&id=ufaa1c361&margin=%5Bobject%20Object%5D&name=IMG_20210421_225640.jpg&originHeight=1067&originWidth=1940&originalType=binary&size=344924&status=done&style=none&taskId=u7e240ddf-325a-4031-8b88-95b8b3a8a4f" alt="IMG_20210421_225640.jpg"><br><strong>只攻不守的剑，也能用来保护人</strong>。</p><h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><ol><li>关于恋爱观。</li></ol><p>「<strong>交往</strong>」这件事，不只是为了休息日能一起去哪玩，那只是附带的东西罢了。[<strong>互相支撑着对方的生活</strong>」才是交往的本质。<br>能互相给予对方“<strong>在看不见的地方让自己的生活变得丰富</strong>”这样的力量，这才是“交往”。就算不能时时刻刻在一起，但却能带给自己仿佛在一起时一般的存在感的人，这才是“恋人”。<br>真正的谈恋爱是两个人相处比我独处更有趣、更有意义，真正的谈恋爱是两个人为了未来而考虑、努力，真正的恋爱是我愿意支持你的想法，你愿意鼓励我主动追梦，真正的恋爱是时间沉淀感情后、冷静思考后的坚定选择。无关激素，无关冲动，不是想谈恋爱而找个人谈恋爱，而是我们经历了很多事情后，我们了解彼此后，选择了彼此。</p><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><ol><li>软件安全的 ret2libc 要自学一下了！</li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li>做人做事</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Life-Weekly-April-19-to-25-2.png#clientId=u67cebdca-6850-4&from=paste&height=1443&id=u062f504b&margin=%5Bobject%20Object%5D&originHeight=2885&originWidth=720&originalType=url&status=done&style=none&taskId=uc553a112-4017-49b5-b30d-b410852a388&width=360"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;时讯&quot;&gt;&lt;a href=&quot;#时讯&quot; class=&quot;headerlink&quot; title=&quot;时讯&quot;&gt;&lt;/a&gt;时讯&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;特斯拉最近一直出事故，脚刹系统很有问题，怀疑是软件 bug，官方售后居然在发生事故后会清除事故数据和行车记录视频，这是一个负责任</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>区块链底层-账户模型</title>
    <link href="https://www.blog.hackerjerry.top/2021/04/17/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E8%B4%A6%E6%88%B7%E6%A8%A1%E5%9E%8B_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/04/17/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E8%B4%A6%E6%88%B7%E6%A8%A1%E5%9E%8B_new/</id>
    <published>2021-04-17T14:32:44.000Z</published>
    <updated>2021-05-26T12:21:42.739Z</updated>
    
    <content type="html"><![CDATA[<p>我们采用和以太坊相似的账户模型。</p><a id="more"></a><h1 id="账户数据结构"><a href="#账户数据结构" class="headerlink" title="账户数据结构"></a>账户数据结构</h1><p>以太坊数据以账户为单位组织，账户数据的变更引起账户状态变化, 从而引起以太坊状态变化。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// core/state/state_object.go:100</span></span><br><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span> &#123;</span><br><span class="line">    Nonce    <span class="keyword">uint64</span></span><br><span class="line">    Balance  *big.Int</span><br><span class="line">    Root     common.Hash</span><br><span class="line">    CodeHash []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在密码学领域，Nonce 代表一个只使用一次的数字。它往往是一个随机或伪随机数，以避免重复。 以太坊账户中加入 Nonce，可避免重放攻击（不过不是随机产生）。账户 Nonce 起始值是 0，后续每触发一次账户执行则 Nonce 值计加一次。 其中一处的计数逻辑如下：</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// core/state_transition.go:212</span></span><br><span class="line">st.state.SetNonce(msg.From(), st.state.GetNonce(sender.Address())+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><ul><li>Balance 则记录该账户所拥有的以太（ETH）数量，称为账户余额.</li></ul><p>当然必须保证转账方余额充足，在转移前需要 CanTransfer 检查， 如果余额充足，则执行 Transfer 转移 Value 数量的以太。</p><ul><li>账户状态哈希值 StateRoot，是一颗默克尔压缩前缀树（Merkle Patricia Tree）的根值。可以直接利用 StateRoot 从 Leveldb 中快速读取具体的某个状态数据</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E8%B4%A6%E6%88%B7%E6%A8%A1%E5%9E%8B-1.png#clientId=u7a530312-f976-4&from=paste&height=318&id=uadb7d967&margin=%5Bobject%20Object%5D&originHeight=1006&originWidth=1062&originalType=url&status=done&style=none&taskId=u8125fdd8-2c02-4142-8ff6-2a5b708f249&width=336"><br>上图是以太坊账户数据存储结构，账户内部实际只存储关键数据，而合约代码以及合约自身数据则通过对应的哈希值关联。 因为每个账户对象，将作为一个以太坊账户树的一个叶子数据存储， 不能太大。<br>从以太坊作为一个世界态(World State)状态机视角看数据关系如下：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E8%B4%A6%E6%88%B7%E6%A8%A1%E5%9E%8B-2.png#clientId=u7a530312-f976-4&from=paste&height=125&id=ud8337454&margin=%5Bobject%20Object%5D&originHeight=174&originWidth=955&originalType=url&status=done&style=none&taskId=u96e7177e-6233-4ade-8cc1-94578d56711&width=686.5"><br>我们通过一段示例代码，感受下以太坊账户数据存储。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(...)</span><br><span class="line"><span class="keyword">var</span> toAddr =common.HexToAddress</span><br><span class="line"><span class="keyword">var</span> toHash =common.BytesToHash</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    statadb, _ := state.New(common.Hash&#123;&#125;,</span><br><span class="line">        state.NewDatabase(rawdb.NewMemoryDatabase()))<span class="comment">// ❶</span></span><br><span class="line"></span><br><span class="line">    acct1:=toAddr(<span class="string">&quot;0x0bB141C2F7d4d12B1D27E62F86254e6ccEd5FF9a&quot;</span>)<span class="comment">// ❷</span></span><br><span class="line">    acct2:=toAddr(<span class="string">&quot;0x77de172A492C40217e48Ebb7EEFf9b2d7dF8151B&quot;</span>)</span><br><span class="line"></span><br><span class="line">    statadb.AddBalance(acct1,big.NewInt(<span class="number">100</span>))</span><br><span class="line">    statadb.AddBalance(acct2,big.NewInt(<span class="number">888</span>))</span><br><span class="line"></span><br><span class="line">    contract:=crypto.CreateAddress(acct1,statadb.GetNonce(acct1))<span class="comment">// ❸</span></span><br><span class="line">    statadb.CreateAccount(contract)</span><br><span class="line">    statadb.SetCode(contract,[]<span class="keyword">byte</span>(<span class="string">&quot;contract code bytes&quot;</span>))<span class="comment">// ❹</span></span><br><span class="line"></span><br><span class="line">    statadb.SetNonce(contract,<span class="number">1</span>)</span><br><span class="line">    statadb.SetState(contract,toHash([]<span class="keyword">byte</span>(<span class="string">&quot;owner&quot;</span>)),toHash(acct1.Bytes()))<span class="comment">//❺</span></span><br><span class="line">    statadb.SetState(contract,toHash([]<span class="keyword">byte</span>(<span class="string">&quot;name&quot;</span>)),toHash([]<span class="keyword">byte</span>(<span class="string">&quot;ysqi&quot;</span>)))</span><br><span class="line"></span><br><span class="line">    statadb.SetState(contract,toHash([]<span class="keyword">byte</span>(<span class="string">&quot;online&quot;</span>)),toHash([]<span class="keyword">byte</span>&#123;<span class="number">1</span>&#125;)</span><br><span class="line">    statadb.SetState(contract,toHash([]<span class="keyword">byte</span>(<span class="string">&quot;online&quot;</span>)),toHash([]<span class="keyword">byte</span>&#123;&#125;))<span class="comment">//❻</span></span><br><span class="line"></span><br><span class="line">    statadb.Commit(<span class="literal">true</span>)<span class="comment">// ❼</span></span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(statadb.Dump()))<span class="comment">// ❽</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，我们创建了三个账户，并且提交到数据库中。最终打印出当前数据中所有账户的数据信息：</p><ul><li>❶ 一行代码涉及多个操作。首先是<strong>创建一个内存 KV 数据库</strong>，再<strong>包装为 stata 数据库实例</strong>， 最后<strong>利用一个空的 DB 级的 StateRoot，初始化一个以太坊 statadb</strong>。</li><li>❷ 定义两个账户 acct1 和 acct2，并分别添加 100 和 888 到账户余额。</li><li>❸ 模拟合约账户的创建过程，由外部账户 acct1 创建合约账户地址，并将此地址载入 statadb。</li><li>❹ 在将合约代码加入刚刚创建的合约账户中，在写入合约代码的同时， 会利用 crypto.Keccak256Hash(code)计算合约代码哈希，保留在账户数据中。</li><li>❺ 模拟合约执行过程，涉及修改合约状态，新增三项状态数据 owner,name 和 online，分别对应不同值。</li><li>❻ 这里和前面不同的是，是给状态 online 赋值为空[]byte{}，因为所有状态的默认值均是[]byte{}， 在提交到数据库时，如 Leveldb 认为这些状态无有效值，会从数据库文件中删除此记录。 因此，此操作实际是一个删除状态 online 操作。</li><li>❼ 上面所有操作，还都<strong>只是发生在 statdb 内存</strong>中，并未真正的写入数据库文件。 <strong>执行 Commit</strong>，才会<strong>将关于 statadb 的所有变更更新到数据库文件</strong>中。</li><li>❽ 一旦提交数据，则可以使用 Dump 命令从数据库中查找此 stata 相关的所有数据，包括所有账户。 并<strong>以 JSON 格式返还</strong>。这里，我们将返还结果直接打印输出。</li></ul><p>代码执行输出结果如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;root&quot;</span>: <span class="string">&quot;3a25b0816cf007c0b878ca7a62ba35ee0337fa53703f281c41a791a137519f00&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;accounts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;0bb141c2f7d4d12b1d27e62f86254e6cced5ff9a&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;balance&quot;</span>: <span class="string">&quot;100&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;nonce&quot;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;root&quot;</span>: <span class="string">&quot;56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;codeHash&quot;</span>: <span class="string">&quot;c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;storage&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;77de172a492c40217e48ebb7eeff9b2d7df8151b&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;balance&quot;</span>: <span class="string">&quot;888&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;nonce&quot;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;root&quot;</span>: <span class="string">&quot;56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;codeHash&quot;</span>: <span class="string">&quot;c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;storage&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;80580f576731dc1e1dcc53d80b261e228c447cdd&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;balance&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;nonce&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;root&quot;</span>: <span class="string">&quot;1f6d937817f2ac217d8b123c4983c45141e50bd0c358c07f3c19c7b526dd4267&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;codeHash&quot;</span>: <span class="string">&quot;c668dac8131a99c411450ba912234439ace20d1cc1084f8e198fee0a334bc592&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;636f6e747261637420636f6465206279746573&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;storage&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;000000000000000000000000000000000000000000000000000000006e616d65&quot;</span>: <span class="string">&quot;8479737169&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;0000000000000000000000000000000000000000000000000000006f776e6572&quot;</span>: <span class="string">&quot;940bb141c2f7d4d12b1d27e62f86254e6cced5ff9a&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们采用和以太坊相似的账户模型。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>区块链底层-存储</title>
    <link href="https://www.blog.hackerjerry.top/2021/04/16/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%AD%98%E5%82%A8_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/04/16/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%AD%98%E5%82%A8_new/</id>
    <published>2021-04-16T12:20:09.000Z</published>
    <updated>2021-05-26T12:22:35.183Z</updated>
    
    <content type="html"><![CDATA[<p>本文聚焦区块链底层技术–存储技术。主要包含世界状态、账户状态和 MPT 树。<br>参考：<a href="https://learnblockchain.cn/books/geth/part3/statedb.html">https://learnblockchain.cn/books/geth/part3/statedb.html</a></p><a id="more"></a><h1 id="StateDB-世界状态"><a href="#StateDB-世界状态" class="headerlink" title="StateDB-世界状态"></a>StateDB-世界状态</h1><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%AD%98%E5%82%A8-1.png#clientId=u34e3a6f1-8d42-4&from=paste&height=136&id=u29593524&margin=%5Bobject%20Object%5D&originHeight=174&originWidth=955&originalType=url&status=done&style=none&taskId=ud67f5524-9e0a-474e-8ebf-a18abeb618d&width=747.5"><br>从程序设计角度，StateDB 有多种用途：</p><ol><li>维护账户状态到世界状态的映射。</li><li>支持修改、回滚、提交状态。</li><li>支持持久化状态到数据库中。</li><li>是状态进出默克尔树的媒介。</li></ol><p>实际上** StateDB <strong>充当</strong>状态（数据）<strong>、</strong>Trie(树)<strong>、</strong>LevelDB（存储）**的协调者。</p><h2 id="实例化-StateDB"><a href="#实例化-StateDB" class="headerlink" title="实例化 StateDB"></a>实例化 StateDB</h2><p>在对状态的任何操作前，我们要先构建一个 StateDB 来操作状态。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db: = state.NewDatabase(levelDB)</span><br><span class="line">statedb, err := state.New(block.Root(), db)</span><br></pre></td></tr></table></figure><p>首先，我们要告诉 StateDB ，我们要使用哪个状态。因此<strong>需要提供 StateRoot 作为默克尔树根去构建树</strong>。StateRoot 值相当于数据版本号，根据版本号可以明确的知道要使用使用哪个版本的状态。当然，数据内容并没在树中，<strong>需要到一个数据库中读取</strong>。因此在构建 State DB 时需要提供 stateRoot 和 db 才能完成构建。<br>任何实现 state.Database 接口的 db 都可以使用</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// core/state/database.go:42</span></span><br><span class="line"><span class="keyword">type</span> Database <span class="keyword">interface</span> &#123;</span><br><span class="line">OpenTrie(root common.Hash) (Trie, error)</span><br><span class="line">OpenStorageTrie(addrHash, root common.Hash) (Trie, error)</span><br><span class="line">CopyTrie(Trie) Trie</span><br><span class="line">ContractCode(addrHash, codeHash common.Hash) ([]<span class="keyword">byte</span>, error)</span><br><span class="line">ContractCodeSize(addrHash, codeHash common.Hash) (<span class="keyword">int</span>, error)</span><br><span class="line"></span><br><span class="line"><span class="comment">// TrieDB retrieves the low level trie database used for data storage.</span></span><br><span class="line">TrieDB() *trie.Database</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 db 可以访问：</p><ol><li>OpenTrie: 打开指定状态版本(root)的含世界状态的顶层树。</li><li>OpenStorageTrie: <strong>打开账户(addrHash)下</strong>指定状态版本(root)的<strong>账户数据存储树</strong>。</li><li>CopyTrie: 深度拷贝树。</li><li>ContractCode：获取账户（addrHash）的合约，必须和合约哈希(codeHash)匹配。</li><li>ContractCodeSize 获取指定合约大小</li><li>TrieDB：<strong>获得 Trie 底层的数据驱动 DB</strong>，如:** levedDB** 、<strong>内存数据库</strong>、远程数据库</li></ol><p>当前有两种类型的 DB 实现了 Database 接口，轻节点使用的 odrDatabase ，和正常节点端使用的带有缓存的 cachingDB 。 因为轻节点并不存储数据，需要通过向其他节点查询来获得数据，而 odrDatabase 就是这种数据读取方式的封装。一个普通节点已内置 levelDB，为了提高读写性能，使用 cachingDB 对其进行一次封装。<br>在实例化 StateDB 时，需要立即打开含有世界状态的 Trie 树。如果 root 对应的树不存在，则会实例化失败 ①。实例化的 StateDB 中将记录多种信息。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/state/statedb.go:59</span></span><br><span class="line"><span class="keyword">type</span> StateDB <span class="keyword">struct</span> &#123;</span><br><span class="line">db   Database</span><br><span class="line">trie Trie</span><br><span class="line">stateObjects      <span class="keyword">map</span>[common.Address]*stateObject</span><br><span class="line">stateObjectsDirty <span class="keyword">map</span>[common.Address]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">dbErr error</span><br><span class="line">refund <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">thash, bhash common.Hash</span><br><span class="line">txIndex      <span class="keyword">int</span></span><br><span class="line">logs         <span class="keyword">map</span>[common.Hash][]*types.Log</span><br><span class="line">logSize      <span class="keyword">uint</span></span><br><span class="line"></span><br><span class="line">preimages <span class="keyword">map</span>[common.Hash][]<span class="keyword">byte</span></span><br><span class="line">journal        *journal</span><br><span class="line">validRevisions []revision</span><br><span class="line">nextRevisionId <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>db: 操作状态的<strong>底层数据库</strong>，在实例化 StateDB 时指定 ②。</li><li>trie: 世界状态所在的树实例对象，现在只有以太坊改进的默克尔前缀压缩树。</li><li>stateObjects: <strong>已账户地址为键的账户状态对象，能够在内存中维护使用过的账户</strong>。</li><li>stateObjectsDirty： 标记被修改过的账户。</li><li>journal： 是修改状态的日志流水，使用此日志流水可回滚状态。</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/state/statedb.go:92</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(root common.Hash, db Database)</span> <span class="params">(*StateDB, error)</span></span> &#123;</span><br><span class="line">tr, err := db.OpenTrie(root)<span class="comment">//①</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;StateDB&#123;</span><br><span class="line">db:                db,<span class="comment">//②</span></span><br><span class="line">trie:              tr,</span><br><span class="line">stateObjects:      <span class="built_in">make</span>(<span class="keyword">map</span>[common.Address]*stateObject),</span><br><span class="line">stateObjectsDirty: <span class="built_in">make</span>(<span class="keyword">map</span>[common.Address]<span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">logs:              <span class="built_in">make</span>(<span class="keyword">map</span>[common.Hash][]*types.Log),</span><br><span class="line">preimages:         <span class="built_in">make</span>(<span class="keyword">map</span>[common.Hash][]<span class="keyword">byte</span>),</span><br><span class="line">journal:           newJournal(),</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面对的代码实例化了一个 statedb。</p><h2 id="读写-StateDB-状态"><a href="#读写-StateDB-状态" class="headerlink" title="读写 StateDB 状态"></a>读写 StateDB 状态</h2><p>你所访问的任何数据必然属于某个账户下的状态，世界状态态仅仅是通过一颗树来建立安全的映射。因此你所访问的数据可以分为如下几种类型：</p><ol><li>访问账户基础属性：Balance、Nonce、Root、CodeHash</li><li>读取合约账户代码</li><li>读取合约账户中存储内容</li></ol><p>在代码实现中，为了便于账户隔离管理，使用不开放的 stateObject 来维护。 stateObject 注意代码如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> stateObject <span class="keyword">struct</span> &#123;</span><br><span class="line">address  common.Address<span class="comment">//对应的账户地址</span></span><br><span class="line">addrHash common.Hash <span class="comment">// 账户地址的哈希值</span></span><br><span class="line">data     Account <span class="comment">//账户属性</span></span><br><span class="line">db       *StateDB <span class="comment">//底层数据库</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="comment">// 写缓存</span></span><br><span class="line">trie Trie <span class="comment">// 存储树，第一次访问时初始化</span></span><br><span class="line">code Code <span class="comment">// contract bytecode, which gets set when code is loaded</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span> &#123;</span><br><span class="line">Nonce    <span class="keyword">uint64</span></span><br><span class="line">Balance  *big.Int</span><br><span class="line">Root     common.Hash <span class="comment">// merkle root of the storage trie</span></span><br><span class="line">CodeHash []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 stateObject 中维护关于某个账户的所有信息，涉及账户地址、账户地址哈希、账户属性、底层数据库、存储树等内容。<br>当你访问状态时，需要指定账户地址。比如获取账户合约，合约账户代码，均是通过账户地址，获得获得对应的账户的 stateObject。因此，当你访问某账户余额时，需要从世界状态树 Trie 中读取账户状态。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// core/state/statedb.go:408</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *StateDB)</span> <span class="title">getStateObject</span><span class="params">(addr common.Address)</span> <span class="params">(stateObject *stateObject)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> obj := self.stateObjects[addr]; obj != <span class="literal">nil</span> &#123;<span class="comment">//①</span></span><br><span class="line"><span class="keyword">if</span> obj.deleted &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enc, err := self.trie.TryGet(addr[:])<span class="comment">//②</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(enc) == <span class="number">0</span> &#123;</span><br><span class="line">self.setError(err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> data Account</span><br><span class="line"><span class="keyword">if</span> err := rlp.DecodeBytes(enc, &amp;data); err != <span class="literal">nil</span> &#123;<span class="comment">//③</span></span><br><span class="line">log.Error(<span class="string">&quot;Failed to decode state object&quot;</span>, <span class="string">&quot;addr&quot;</span>, addr, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">obj := newObject(self, addr, data)<span class="comment">//④</span></span><br><span class="line">self.setStateObject(obj)</span><br><span class="line"><span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>state.getStateObject(addr)方法，将返回指定账户的 StateObject，不存在时 nil。<br>state 的 stateObject Map 中记录这从实例化 State 到当下，所有访问过的账户的 StateObject。 因此，获取 StateObject 时先从 map 缓存中检查是否已打开 ①，如果存在则返回。** 如果是第一次使用，则以账户地址为 key 从树中查找读取账户状态数据<strong>②。读取到的数据，是被 RLP 序列化过的，因此，在读取到数据后，还需要进行反序列化 ③。为了降低 IO 和在内存中维护可能被修改的 Account 信息，会将其组装成 **StateObjec ④ 存储在 State 实例</strong>中。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/state/state_object.go:108</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newObject</span><span class="params">(db *StateDB, address common.Address, data Account)</span> *<span class="title">stateObject</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> data.Balance == <span class="literal">nil</span> &#123;</span><br><span class="line">data.Balance = <span class="built_in">new</span>(big.Int)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> data.CodeHash == <span class="literal">nil</span> &#123;</span><br><span class="line">data.CodeHash = emptyCodeHash</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;stateObject&#123;</span><br><span class="line">db:            db,</span><br><span class="line">address:       address,</span><br><span class="line">addrHash:      crypto.Keccak256Hash(address[:]),<span class="comment">//⑤</span></span><br><span class="line">data:          data,</span><br><span class="line">originStorage: <span class="built_in">make</span>(Storage),</span><br><span class="line">dirtyStorage:  <span class="built_in">make</span>(Storage),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newObject 就是将对 Account 的操作进行辅助，其中记录了账户地址、地址哈希 ⑤ 等内容，最终你读写状态都经过 stateObject 完成。</p><h2 id="StateDB-完成持久化"><a href="#StateDB-完成持久化" class="headerlink" title="StateDB 完成持久化"></a>StateDB 完成持久化</h2><p>在区块中，将交易作为输入条件，来根据一系列动作修改状态。<br>在完成区块挖矿前，只是获得在内存中的状态树的 Root 值。 StateDB 可视为一个内存数据库，状态数据先在内存数据库中完成修改，所有关于状态的计算都在内存中完成。 在将区块持久化时完成有内存到数据库的更新存储，此更新属于增量更新，仅仅修改涉及到被修改部分。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// core/state/statedb.go:680</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span> <span class="title">Commit</span><span class="params">(deleteEmptyObjects <span class="keyword">bool</span>)</span> <span class="params">(root common.Hash, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> s.clearJournalAndRefund()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> addr := <span class="keyword">range</span> s.journal.dirties &#123;<span class="comment">//①⑧⑨⑩</span></span><br><span class="line">s.stateObjectsDirty[addr] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> addr, stateObject := <span class="keyword">range</span> s.stateObjects &#123;<span class="comment">//②</span></span><br><span class="line">_, isDirty := s.stateObjectsDirty[addr]</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> stateObject.suicided || (isDirty &amp;&amp; deleteEmptyObjects &amp;&amp; stateObject.empty()):</span><br><span class="line"><span class="comment">//③</span></span><br><span class="line">s.deleteStateObject(stateObject)</span><br><span class="line"><span class="keyword">case</span> isDirty:</span><br><span class="line"><span class="keyword">if</span> stateObject.code != <span class="literal">nil</span> &amp;&amp; stateObject.dirtyCode &#123;<span class="comment">//④</span></span><br><span class="line">s.db.TrieDB().InsertBlob(common.BytesToHash(stateObject.CodeHash()), stateObject.code)</span><br><span class="line">stateObject.dirtyCode = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := stateObject.CommitTrie(s.db); err != <span class="literal">nil</span> &#123;<span class="comment">//⑤</span></span><br><span class="line"><span class="keyword">return</span> common.Hash&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line">s.updateStateObject(stateObject)<span class="comment">//⑥</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">delete</span>(s.stateObjectsDirty, addr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">root, err = s.trie.Commit(<span class="function"><span class="keyword">func</span><span class="params">(leaf []<span class="keyword">byte</span>, parent common.Hash)</span> <span class="title">error</span></span> &#123;<span class="comment">//⑦</span></span><br><span class="line"><span class="keyword">var</span> account Account</span><br><span class="line"><span class="keyword">if</span> err := rlp.DecodeBytes(leaf, &amp;account); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> account.Root != emptyRoot &#123;</span><br><span class="line">s.db.TrieDB().Reference(account.Root, parent)</span><br><span class="line">&#125;</span><br><span class="line">code := common.BytesToHash(account.CodeHash)</span><br><span class="line"><span class="keyword">if</span> code != emptyCode &#123;</span><br><span class="line">s.db.TrieDB().Reference(code, parent)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> root, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%AD%98%E5%82%A8-2.png#clientId=u34e3a6f1-8d42-4&from=paste&height=506&id=ufcde743f&margin=%5Bobject%20Object%5D&originHeight=1012&originWidth=936&originalType=url&status=done&style=none&taskId=u9036f292-bba3-41a2-a09a-3566a7f7e94&width=468"><br>如上图所示，上半部分均属于内存操作，仅仅在 stateDB.Commit()时才将状态通过树提交到 leveldb 中。</p><h1 id="MPT-默克尔压缩前缀树"><a href="#MPT-默克尔压缩前缀树" class="headerlink" title="MPT-默克尔压缩前缀树"></a>MPT-默克尔压缩前缀树</h1><p>是一种经过改良的、融合了默克尔树和前缀树两种树结构优点的数据结构，是以太坊中用来组织管理账户数据、生成交易集合哈希的重要数据结构。一个非叶节点存储在 leveldb 关系型数据库中，数据库中的 key 是节点的 RLP 编码的 sha3 哈希，value 是节点的 RLP 编码。想要获得一个非叶节点的子节点，只需要根据子节点的 hash 访问数据库获得节点的 RLP 编码，然后解码就行了。<br>以太坊有四种前缀树：</p><ol><li><strong>世界状态树包括了从地址到账户状态之间的映射。</strong> 世界状态树的根节点哈希值由区块保存（在 stateRoot 字段），它标示了区块创建时的当前状态。<strong>整个网络中只有一个世界状态树。</strong></li><li><strong>账户存储树保存了与某一智能合约相关的数据信息。</strong>由账户状态保存账户存储树的根节点哈希值（在 storageRoot 字段）。<strong>每个账户都有一个账户存储树。</strong></li><li><strong>交易树包含了一个区块中的所有交易信息。</strong>由区块头（在 transactionsRoot 区域）保存交易树的根节点哈希值。<strong>每个区块都有一棵交易树。</strong></li><li><strong>交易收据树包含了一个区块中所有交易的收据信息。</strong>同样由区块头（在 receiptsRoot 区域）保存交易收据树的根节点哈希值；<strong>每个区块都有对应的交易收据树。</strong></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文聚焦区块链底层技术–存储技术。主要包含世界状态、账户状态和 MPT 树。&lt;br&gt;参考：&lt;a href=&quot;https://learnblockchain.cn/books/geth/part3/statedb.html&quot;&gt;https://learnblockchain.cn/books/geth/part3/statedb.html&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>交易内存池底层实现</title>
    <link href="https://www.blog.hackerjerry.top/2021/04/15/%E4%BA%A4%E6%98%93%E5%86%85%E5%AD%98%E6%B1%A0%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/04/15/%E4%BA%A4%E6%98%93%E5%86%85%E5%AD%98%E6%B1%A0%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0_new/</id>
    <published>2021-04-15T12:29:00.000Z</published>
    <updated>2021-05-26T12:20:22.799Z</updated>
    
    <content type="html"><![CDATA[<p>既然要从头搭建一个区块链网络，交易池是绕不开的一个核心底层。对于它，以下几个问题是需要解决的：</p><ol><li>用户发起的交易请求（不论以何种方式）是如何转变为实际的交易的；</li><li>产生的交易如果不能被及时处理，是如何进入交易池的；</li><li>本地产生的交易和从网络中接收到的交易进入交易池是否有区别；</li><li>交易池的基本数据结构是怎么样的（优先队列？）</li><li>从交易池中提取交易进行打包时顺序是怎么样的（调度算法）<blockquote><p>网络中很多文章提到内存池，指的就是是 txpool</p></blockquote></li></ol><a id="more"></a><h1 id="交易形成"><a href="#交易形成" class="headerlink" title="交易形成"></a>交易形成</h1><p>以下均为作品赛项目的内容。<br>首先，我们的交易请求会赋值到 TxRaw 结构体的一个实例中。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于接收客户端发来的序列化post原始信息</span></span><br><span class="line"><span class="keyword">type</span> TxRaw <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//公钥hash</span></span><br><span class="line">Address []<span class="keyword">byte</span> <span class="string">`json:&quot;address&quot;`</span></span><br><span class="line"></span><br><span class="line">Fee <span class="keyword">int</span> <span class="string">`json:&quot;int&quot;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//交易核心</span></span><br><span class="line">RangeBloom bloom.RangeBloom <span class="string">`json:&quot;rbloom&quot;`</span></span><br><span class="line">TimeBloom  bloom.TimeBloom  <span class="string">`json:&quot;tbloom&quot;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//签名相关</span></span><br><span class="line">Pubkey sm2.PublicKey <span class="string">`json:&quot;pubkey&quot;`</span></span><br><span class="line">Sign   []<span class="keyword">byte</span>        <span class="string">`json:&quot;sign&quot;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//交易同态密文拼接，用于k-top查找</span></span><br><span class="line">Cipher <span class="keyword">string</span> <span class="string">`json:&quot;cipher&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后这个实例被传递到一个 SendTransaction 函数，用来创建一个交易 Tx。创建交易的过程如下：</p><ol><li>根据 Address 字段找到当前账户</li><li>设置交易默认参数</li><li>检查交易签名是否合法</li><li>检查交易是否冲突</li><li>对交易进行序列化，变为可存储和传输的形式。</li><li>提交交易到交易池</li></ol><h1 id="交易管理"><a href="#交易管理" class="headerlink" title="交易管理"></a>交易管理</h1><p>以太坊将交易按状态分为两部分：<strong>可执行交易</strong>和<strong>非可执行交易</strong>。分别记录在 pending 容器中和 queue 容器中。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E4%BA%A4%E6%98%93%E5%86%85%E5%AD%98%E6%B1%A0%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-1.png#clientId=u272c35f2-3d2a-4&from=paste&height=321&id=u5bf56761&margin=%5Bobject%20Object%5D&originHeight=538&originWidth=1160&originalType=binary&size=164987&status=done&style=none&taskId=u567ff6dc-553f-4a1c-af77-71fc9a19a73&width=693"><br>如上图所示，交易池先采用一个 txLookup (内部为 map）跟踪所有交易。同时将交易根据本地优先，价格优先原则将交易划分为两部分 queue 和 pending。而这两部交易则按账户分别跟踪。<br>为了不丢失未完成的本地交易，以太坊交易池通过 journal 文件存储和管理当前交易池中的本地交易，并定期更新存储。<br>下图是<strong>交易池对本地待处理交易的磁盘存储管理流程</strong>，涉及加载、实时写入和定期更新维护。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E4%BA%A4%E6%98%93%E5%86%85%E5%AD%98%E6%B1%A0%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-2.png#clientId=u272c35f2-3d2a-4&from=paste&height=826&id=ufc47fc0d&margin=%5Bobject%20Object%5D&originHeight=1356&originWidth=870&originalType=url&status=done&style=none&taskId=ubb8c227e-5868-49f4-b1ea-77abbe42349&width=530"></p><h2 id="存储交易"><a href="#存储交易" class="headerlink" title="存储交易"></a>存储交易</h2><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E4%BA%A4%E6%98%93%E5%86%85%E5%AD%98%E6%B1%A0%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-3.png#clientId=u272c35f2-3d2a-4&from=paste&height=317&id=uc114cf13&margin=%5Bobject%20Object%5D&originHeight=432&originWidth=826&originalType=url&status=done&style=none&taskId=u8fb70d54-24fd-45a9-880e-9b7951920f0&width=606"><br>当交易池新交易来自于本地账户时 ❶，如果已开启记录本地交易，则将此交易加入 journal ❷。到交易池时，将实时存储到 journal 文件中。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/tx_pool.go:757</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *TxPool)</span> <span class="title">journalTx</span><span class="params">(from common.Address, tx *types.Transaction)</span></span> &#123;</span><br><span class="line">   <span class="comment">// Only journal if it&#x27;s enabled and the transaction is local</span></span><br><span class="line">   <span class="keyword">if</span> pool.journal == <span class="literal">nil</span> || !pool.locals.contains(from) &#123;<span class="comment">//❶</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> err := pool.journal.insert(tx); err != <span class="literal">nil</span> &#123; <span class="comment">//❷</span></span><br><span class="line">      log.Warn(<span class="string">&quot;Failed to journal local transaction&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 journal.insert 则将交易实时写入文件流中 ❸，相当于实时存储到磁盘。而在写入时，是将交易进行 RLP 编码。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/tx_journal.go:120</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(journal *txJournal)</span> <span class="title">insert</span><span class="params">(tx *types.Transaction)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> journal.writer == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> errNoActiveJournal</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> err := rlp.Encode(journal.writer, tx); err != <span class="literal">nil</span> &#123;<span class="comment">//❸</span></span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>插一嘴，为什么要用 RLP 编码？</p></blockquote><h3 id="什么是-RLP"><a href="#什么是-RLP" class="headerlink" title="什么是 RLP"></a>什么是 RLP</h3><p>RLP(Recursive Length Prefix) 递归长度前缀编码是以太坊中最常使用的序列化格式方法。<br>RLP 旨在<strong>成为高度简约的序列化方法</strong>，<strong>唯一目标</strong>就是<strong>存储嵌套的字节数组</strong>。<br>RLP 只是以嵌套数组形式存储结构型数据，由上层协议来确定数组的含义。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E4%BA%A4%E6%98%93%E5%86%85%E5%AD%98%E6%B1%A0%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-4.png#clientId=u272c35f2-3d2a-4&from=paste&height=443&id=u3b9d54f1&margin=%5Bobject%20Object%5D&originHeight=886&originWidth=1716&originalType=url&status=done&style=none&taskId=u8fd870e4-dcb8-44b2-bd3b-a5ba9cd4ba8&width=858"><br>从图中可以看出，不同类型的数据，将有不同的前缀标识。 前缀也可以理解为报文头，通过报文头可准确获取报文内容。 图中灰色部分则为 RLP 编码输出前缀。</p><h2 id="加载已存储交易"><a href="#加载已存储交易" class="headerlink" title="加载已存储交易"></a>加载已存储交易</h2><p>在交易池首次启动 journal 时，将主动将该文件已存储的交易加载到交易池。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/tx_journal.go:61</span></span><br><span class="line"><span class="keyword">if</span> _, err := os.Stat(journal.path); os.IsNotExist(err) &#123; <span class="comment">//❶</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Open the journal for loading any past transactions</span></span><br><span class="line">input, err := os.Open(journal.path) <span class="comment">//❷</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> input.Close()</span><br></pre></td></tr></table></figure><p>处理时，如果文件不存在则退出 ❶，否则 Open 文件，获得 input 文件流 ❷。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/tx_journal.go:76</span></span><br><span class="line">stream := rlp.NewStream(input, <span class="number">0</span>)<span class="comment">//❸</span></span><br><span class="line">total, dropped := <span class="number">0</span>, <span class="number">0</span></span><br></pre></td></tr></table></figure><p>因为存储的内容格式是 rlp 编码内容，因此可以直接初始化 rlp 内容流 ❸，为连续解码做准备。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">   failure error</span><br><span class="line">   batch   types.Transactions</span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">   tx := <span class="built_in">new</span>(types.Transaction)</span><br><span class="line">   <span class="keyword">if</span> err = stream.Decode(tx); err != <span class="literal">nil</span> &#123; <span class="comment">//❹</span></span><br><span class="line">      <span class="keyword">if</span> err != io.EOF &#123;</span><br><span class="line">         failure = err</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> batch.Len() &gt; <span class="number">0</span> &#123;<span class="comment">//❼</span></span><br><span class="line">         loadBatch(batch)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">   &#125;</span><br><span class="line">   total++</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> batch = <span class="built_in">append</span>(batch, tx); batch.Len() &gt; <span class="number">1024</span> &#123;<span class="comment">//❺</span></span><br><span class="line">      loadBatch(batch)<span class="comment">//❻</span></span><br><span class="line">      batch = batch[:<span class="number">0</span>]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadBatch := <span class="function"><span class="keyword">func</span><span class="params">(txs types.Transactions)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> _, err := <span class="keyword">range</span> add(txs) &#123;</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         log.Debug(<span class="string">&quot;Failed to add journaled transaction&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">         dropped++ <span class="comment">//❽</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接进入 for 循环遍历，不断从 stream 中一笔笔地解码出交易 ❹。<br>但交易并非单笔直接载入交易池，而是采用批量提交模式，每 1024 笔交易提交一次 ❺。<br>批量写入，有利于降低交易池在每次写入交易后的更新。一个批次只需要更新（排序与超限处理等）一次。当然在遍历结束时（err==io.EOF）,也需要将当前批次中的交易载入 ❼。<br>loadBatch 就是将交易一批次加入到交易池，并获得交易池的每笔交易的处理情况。如果交易加入失败，则进行计数 ❽。最终在 load 方法执行完毕时，显示交易载入情况。</p><h1 id="交易添加到交易池"><a href="#交易添加到交易池" class="headerlink" title="交易添加到交易池"></a>交易添加到交易池</h1><p>SendTransaction 最后调用 SubmitTransaction 函数将交易提交到交易池，不过，更底层的调用是 AddLocals 函数。<br>这里需要注意，本地交易时调用 AddLocals，而从对等 p2p 节点发来的交易调用的是另一个函数，AddRemotes 函数。调用这两个函数之前都应该验证交易的有效性。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E4%BA%A4%E6%98%93%E5%86%85%E5%AD%98%E6%B1%A0%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-5.png#clientId=u272c35f2-3d2a-4&from=paste&height=264&id=ue6089192&margin=%5Bobject%20Object%5D&originHeight=528&originWidth=1174&originalType=binary&size=236384&status=done&style=none&taskId=uf8820385-fb3b-42bb-ab6f-9ae0571e933&width=587"></p><blockquote><p>因为交易时通过节点的 API 接收，因此此交易被视为一笔来自本地(local)（图中用红球表示），在经过一系列校验和处理后。交易成功进入交易池，随后向已连接的邻近节点发送此交易。<br>当邻近节点，如矿工节点从邻近节点接收到此交易时，在进入交易池之前。会将交易标记为来自远方（remote）的交易（图中用绿球表示）。也需要经过校验和处理后，进入矿工节点的交易池，等待矿工打包到区块中。<br>如果邻近节点，不是矿工，也无妨。因为任何节点会默认将接受到得合法交易及时发送给邻近节点。得益于 P2P 网络，一笔交易平均在 6s 内扩散到整个以太坊公链网络的各个节点中。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E4%BA%A4%E6%98%93%E5%86%85%E5%AD%98%E6%B1%A0%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-6.png#clientId=u272c35f2-3d2a-4&from=paste&height=254&id=u528314c1&margin=%5Bobject%20Object%5D&originHeight=373&originWidth=924&originalType=binary&size=74906&status=done&style=none&taskId=uae16074d-7e82-4415-a530-f8a271e0047&width=629"><br>下面我们来看一下交易池的结构：</p><blockquote><p>这是以太坊的</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TxPool contains all currently known transactions. Transactions</span></span><br><span class="line"><span class="comment">// enter the pool when they are received from the network or submitted</span></span><br><span class="line"><span class="comment">// locally. They exit the pool when they are included in the blockchain.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The pool separates processable transactions (which can be applied to the</span></span><br><span class="line"><span class="comment">// current state) and future transactions. Transactions move between those</span></span><br><span class="line"><span class="comment">// two states over time as they are received and processed.</span></span><br><span class="line"><span class="keyword">type</span> TxPool <span class="keyword">struct</span> &#123;</span><br><span class="line">config      TxPoolConfig</span><br><span class="line">chainconfig *params.ChainConfig</span><br><span class="line">chain       blockChain</span><br><span class="line">gasPrice    *big.Int</span><br><span class="line">txFeed      event.Feed</span><br><span class="line">scope       event.SubscriptionScope</span><br><span class="line">signer      types.Signer</span><br><span class="line">mu          sync.RWMutex</span><br><span class="line"></span><br><span class="line">istanbul <span class="keyword">bool</span> <span class="comment">// Fork indicator whether we are in the istanbul stage.</span></span><br><span class="line"></span><br><span class="line">currentState  *state.StateDB <span class="comment">// Current state in the blockchain head</span></span><br><span class="line">pendingNonces *txNoncer      <span class="comment">// Pending state tracking virtual nonces</span></span><br><span class="line">currentMaxGas <span class="keyword">uint64</span>         <span class="comment">// Current gas limit for transaction caps</span></span><br><span class="line"></span><br><span class="line">locals  *accountSet <span class="comment">// Set of local transaction to exempt from eviction rules</span></span><br><span class="line">journal *txJournal  <span class="comment">// Journal of local transaction to back up to disk</span></span><br><span class="line"></span><br><span class="line">pending <span class="keyword">map</span>[common.Address]*txList   <span class="comment">// All currently processable transactions</span></span><br><span class="line">queue   <span class="keyword">map</span>[common.Address]*txList   <span class="comment">// Queued but non-processable transactions</span></span><br><span class="line">beats   <span class="keyword">map</span>[common.Address]time.Time <span class="comment">// Last heartbeat from each known account</span></span><br><span class="line">all     *txLookup                    <span class="comment">// All transactions to allow lookups</span></span><br><span class="line">priced  *txPricedList                <span class="comment">// All transactions sorted by price</span></span><br><span class="line"></span><br><span class="line">chainHeadCh     <span class="keyword">chan</span> ChainHeadEvent</span><br><span class="line">chainHeadSub    event.Subscription</span><br><span class="line">reqResetCh      <span class="keyword">chan</span> *txpoolResetRequest</span><br><span class="line">reqPromoteCh    <span class="keyword">chan</span> *accountSet</span><br><span class="line">queueTxEventCh  <span class="keyword">chan</span> *types.Transaction</span><br><span class="line">reorgDoneCh     <span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">reorgShutdownCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;  <span class="comment">// requests shutdown of scheduleReorgLoop</span></span><br><span class="line">wg              sync.WaitGroup <span class="comment">// tracks loop, scheduleReorgLoop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中最核心的是两个字段，pending 和 queue<br><strong>queued 存放未来的、当前无法执行的交易</strong>。以太坊使用 nonce 值决定某个账户的交易顺序，多条交易值 nonce 值必须连续，如果和过去的交易不连续，则无法执行，我们不妨使用 nonce 值，标记交易的号码，nonce 为 10 的交易，称为第 10 号交易。举个例子，当前账户的 nonce 是 10，txpool 中有该账户的第 100 号交易，但 txpool 中没有第 11<del>99 号交易，这些交易的缺失，造成第 100 号交易无法执行，所以第 100 号交易就是未来的交易、不可执行的交易，存放在 queue 中。<br><strong>pending 存放可执行的交易</strong>。比如我们把上面的 11</del>99 号交易补全了，那么 11~100 号交易都可以进入到 pending，因为这些交易都是连续的，都可以打包进区块。<br>当节点收到交易（本地节点发起的或 peer 广播来的）时，会先存放到 queued，txpool 在某些情况下，把 queued 中可执行的交易，转移到 pending 中。<br>其中 config 的结构体为：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TxPoolConfig are the configuration parameters of the transaction pool.</span></span><br><span class="line"><span class="keyword">type</span> TxPoolConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">Locals    []common.Address <span class="comment">// Addresses that should be treated by default as local</span></span><br><span class="line">NoLocals  <span class="keyword">bool</span>             <span class="comment">// Whether local transaction handling should be disabled</span></span><br><span class="line">Journal   <span class="keyword">string</span>           <span class="comment">// Journal of local transactions to survive node restarts</span></span><br><span class="line">Rejournal time.Duration    <span class="comment">// Time interval to regenerate the local transaction journal</span></span><br><span class="line"></span><br><span class="line">PriceLimit <span class="keyword">uint64</span> <span class="comment">// Minimum gas price to enforce for acceptance into the pool</span></span><br><span class="line">PriceBump  <span class="keyword">uint64</span> <span class="comment">// Minimum price bump percentage to replace an already existing transaction (nonce)</span></span><br><span class="line"></span><br><span class="line">AccountSlots <span class="keyword">uint64</span> <span class="comment">// Number of executable transaction slots guaranteed per account</span></span><br><span class="line">GlobalSlots  <span class="keyword">uint64</span> <span class="comment">// Maximum number of executable transaction slots for all accounts</span></span><br><span class="line">AccountQueue <span class="keyword">uint64</span> <span class="comment">// Maximum number of non-executable transaction slots permitted per account</span></span><br><span class="line">GlobalQueue  <span class="keyword">uint64</span> <span class="comment">// Maximum number of non-executable transaction slots for all accounts</span></span><br><span class="line"></span><br><span class="line">Lifetime time.Duration <span class="comment">// Maximum amount of time non-executable transaction are queued</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Quorum</span></span><br><span class="line">TransactionSizeLimit <span class="keyword">uint64</span> <span class="comment">// Maximum size allowed for valid transaction (in KB)</span></span><br><span class="line">MaxCodeSize          <span class="keyword">uint64</span> <span class="comment">// Maximum size allowed of contract code that can be deployed (in KB)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DefaultTxPoolConfig = TxPoolConfig&#123;</span><br><span class="line">Journal:   <span class="string">&quot;transactions.rlp&quot;</span>,</span><br><span class="line">Rejournal: time.Hour,</span><br><span class="line"></span><br><span class="line">PriceLimit: <span class="number">1</span>,</span><br><span class="line">PriceBump:  <span class="number">10</span>,</span><br><span class="line"></span><br><span class="line">AccountSlots: <span class="number">16</span>,</span><br><span class="line">GlobalSlots:  <span class="number">4096</span>,</span><br><span class="line">AccountQueue: <span class="number">64</span>,</span><br><span class="line">GlobalQueue:  <span class="number">1024</span>,</span><br><span class="line"></span><br><span class="line">Lifetime: <span class="number">3</span> * time.Hour,</span><br><span class="line"></span><br><span class="line"><span class="comment">// Quorum</span></span><br><span class="line">TransactionSizeLimit: <span class="number">64</span>,</span><br><span class="line">MaxCodeSize:          <span class="number">24</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Locals: 定义了一组视为 local 交易的账户地址。任何来自此清单的交易均被视为 local 交易。</li><li>NoLocals: 是否禁止 local 交易处理。默认为 fasle,允许 local 交易。如果禁止，则来自 local 的交易均视为 remote 交易处理。</li><li>Journal： 存储 local 交易记录的文件名，默认是./transactions.rlp。</li><li>Rejournal：定期将 local 交易存储文件中的时间间隔。默认为每小时一次。</li><li>PriceLimit： remote 交易进入交易池的最低 Price 要求。此设置对 local 交易无效。默认值 1。</li><li>PriceBump：替换交易时所要求的价格上调涨幅比例最低要求。任何低于要求的替换交易均被拒绝。</li><li>AccountSlots： 当交易池中可执行交易（是已在等待矿工打包的交易）量超标时，允许每个账户可以保留在交易池最低交易数。默认值是 16 笔。</li><li>GlobalSlots： 交易池中所允许的可执行交易量上限，高于上限时将释放部分交易。默认是 4096 笔交易。</li><li>AccountQueue：交易池中单个账户非可执行交易上限，默认是 64 笔。</li><li>GlobalQueue： 交易池中所有非可执行交易上限，默认 1024 笔。</li><li>Lifetime： 允许 remote 的非可执行交易可在交易池存活的最长时间。交易池每分钟检查一次，一旦发现有超期的 remote 账户，则移除该账户下的所有非可执行交易。默认为 3 小时。<blockquote><p>参考：<a href="https://learnblockchain.cn/books/geth/part2/txpool/txpool.html">https://learnblockchain.cn/books/geth/part2/txpool/txpool.html</a></p></blockquote></li></ul><p>上面配置中，包含两个重要概念<strong>可执行交易</strong>和<strong>非可执行交易</strong>。可执行交易是指从交易池中择优选出的一部分交易可以被执行，打包到区块中。非可执行交易则相反，任何刚进入交易池的交易均属于非可执行状态，在某一个时刻才会提升为可执行状态。</p><blockquote><p>这是 dag 的</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TxPool <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// The following variables must only be used atomically.</span></span><br><span class="line">lastUpdated <span class="keyword">int64</span> <span class="comment">// last time pool was updated</span></span><br><span class="line"></span><br><span class="line">mtx           sync.RWMutex</span><br><span class="line">cfg           Config</span><br><span class="line">pool          <span class="keyword">map</span>[chainhash.Hash]*TxDesc</span><br><span class="line">orphans       <span class="keyword">map</span>[chainhash.Hash]*orphanTx</span><br><span class="line">orphansByPrev <span class="keyword">map</span>[wire.OutPoint]<span class="keyword">map</span>[chainhash.Hash]*soterutil.Tx</span><br><span class="line">outpoints     <span class="keyword">map</span>[wire.OutPoint]*soterutil.Tx</span><br><span class="line">pennyTotal    <span class="keyword">float64</span> <span class="comment">// exponentially decaying total for penny spends.</span></span><br><span class="line">lastPennyUnix <span class="keyword">int64</span>   <span class="comment">// unix time of last ``penny spend&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// nextExpireScan is the time after which the orphan pool will be</span></span><br><span class="line"><span class="comment">// scanned in order to evict orphans.  This is NOT a hard deadline as</span></span><br><span class="line"><span class="comment">// the scan will only run when an orphan is added to the pool as opposed</span></span><br><span class="line"><span class="comment">// to on an unconditional timer.</span></span><br><span class="line">nextExpireScan time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>交易提交到交易池还需要一个 add 函数，逻辑很简单：</p><ol><li>验证交易的有效性</li><li>如果 nonce 已存在，忽略。</li><li>如果 nonce 不存在，不可以替换 pending 中的任何交易，此时将新的交易插入 queue 的末尾</li></ol><p>注：交易中的 nonce 指的是 from 账户发出交易的次数, 从 0 开始递增，同一账户的交易会被依次确认，所以同一个 nonce 代表是同一个交易，会优先选择 price 更高的交易。</p><blockquote><p>这是我们的</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TxPool <span class="keyword">struct</span> &#123;</span><br><span class="line">    mtx           sync.RWMutex</span><br><span class="line">    config      TxPoolConfig</span><br><span class="line">    currentState  *state.StateDB <span class="comment">// 区块的当前状态</span></span><br><span class="line">    locals  *accountSet <span class="comment">//本地交易</span></span><br><span class="line">    journal *txJournal  <span class="comment">//  用于存储local交易记录的文件</span></span><br><span class="line"></span><br><span class="line">pending <span class="keyword">map</span>[common.Address]*txList   <span class="comment">// 存放可执行的交易</span></span><br><span class="line">queue   <span class="keyword">map</span>[common.Address]*txList   <span class="comment">// queued存放未来的、当前无法执行的交易</span></span><br><span class="line"></span><br><span class="line">    chainHeadSub    event.Subscription<span class="comment">//用于订阅区块</span></span><br><span class="line">    reqPromoteCh    <span class="keyword">chan</span> *accountSet<span class="comment">//账户集合</span></span><br><span class="line">queueTxEventCh  <span class="keyword">chan</span> *dag.Tx<span class="comment">//Tx队列事件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TxPoolConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">Locals    []common.Address</span><br><span class="line">Journal   <span class="keyword">string</span></span><br><span class="line">Rejournal time.Duration</span><br><span class="line"></span><br><span class="line">AccountSlots <span class="keyword">uint64</span></span><br><span class="line">GlobalSlots  <span class="keyword">uint64</span></span><br><span class="line">AccountQueue <span class="keyword">uint64</span></span><br><span class="line">GlobalQueue  <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">Lifetime time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DefaultTxPoolConfig = TxPoolConfig&#123;</span><br><span class="line">Journal:   <span class="string">&quot;transactions.rlp&quot;</span>,</span><br><span class="line">Rejournal: time.Hour,</span><br><span class="line"></span><br><span class="line">AccountSlots: <span class="number">16</span>,</span><br><span class="line">GlobalSlots:  <span class="number">8192</span>,</span><br><span class="line">AccountQueue: <span class="number">64</span>,</span><br><span class="line">GlobalQueue:  <span class="number">1024</span>,</span><br><span class="line"></span><br><span class="line">Lifetime: <span class="number">3</span> * time.Hour,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当节点收到交易（本地节点发起的或 peer 广播来的）时，会先存放到 queued，txpool 在某些情况下，把 queued 中可执行的交易，转移到 pending 中。</p><ul><li>Locals: 定义了一组视为 local 交易的账户地址。任何来自此清单的交易均被视为 local 交易。</li><li>Journal： 存储 local 交易记录的文件名，默认是./transactions.rlp。</li><li>Rejournal：定期将 local 交易存储文件中的时间间隔。默认为每小时一次。</li><li>AccountSlots： 当交易池中可执行交易（是已在等待矿工打包的交易）量超标时，允许每个账户可以保留在交易池最低交易数。默认值是 16 笔。</li><li>GlobalSlots： 交易池中所允许的可执行交易量上限，高于上限时将释放部分交易。默认是 8192 笔交易。</li><li>AccountQueue：交易池中单个账户非可执行交易上限，默认是 64 笔。</li><li>GlobalQueue： 交易池中所有非可执行交易上限，默认 1024 笔。</li><li>Lifetime： 允许 remote 的非可执行交易可在交易池存活的最长时间。交易池每分钟检查一次，一旦发现有超期的 remote 账户，则移除该账户下的所有非可执行交易。默认为 3 小时。</li></ul><h2 id="链状态"><a href="#链状态" class="headerlink" title="链状态"></a>链状态</h2><p>在交易池启动后，将订阅链的区块头事件：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/tx_pool.go:274</span></span><br><span class="line">pool.chainHeadSub = pool.chain.SubscribeChainHeadEvent(pool.chainHeadCh)</span><br></pre></td></tr></table></figure><p>并开始监听新事件：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/tx_pool.go:305</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="comment">// Handle ChainHeadEvent</span></span><br><span class="line">   <span class="keyword">case</span> ev := &lt;-pool.chainHeadCh:</span><br><span class="line">      <span class="keyword">if</span> ev.Block != <span class="literal">nil</span> &#123;</span><br><span class="line">         pool.mu.Lock()</span><br><span class="line">         <span class="keyword">if</span> pool.chainconfig.IsHomestead(ev.Block.Number()) &#123;</span><br><span class="line">            pool.homestead = <span class="literal">true</span></span><br><span class="line">         &#125;</span><br><span class="line">         pool.reset(head.Header(), ev.Block.Header())</span><br><span class="line">         head = ev.Block</span><br><span class="line"></span><br><span class="line">         pool.mu.Unlock()</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收到事件后，将执行 func (pool *TxPool) reset(oldHead, newHead *types.Header)方法更新 state 和处理交易。核心是将交易池中已经不符合要求的交易删除并更新整理交易</p><h2 id="本地交易"><a href="#本地交易" class="headerlink" title="本地交易"></a>本地交易</h2><p>在交易池中将交易标记为 local 的有多种用途：</p><ol><li>在本地磁盘存储已发送的交易。这样，本地交易不会丢失，重启节点时可以重新加载到交易池，实时广播出去。</li><li>可以作为外部程序和以太坊沟通的一个渠道。外部程序只需要监听文件内容变化，则可以获得交易清单。</li><li>local 交易可优先于 remote 交易。对交易量的限制等操作，不影响 local 下的账户和交易。</li></ol><p>对应本地交易存储，在启动交易池时根据配置开启本地交易存储能力：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/tx_pool.go:264</span></span><br><span class="line"><span class="keyword">if</span> !config.NoLocals &amp;&amp; config.Journal != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">pool.journal = newTxJournal(config.Journal)</span><br><span class="line"><span class="keyword">if</span> err := pool.journal.load(pool.AddLocals); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Warn(<span class="string">&quot;Failed to load transaction journal&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并从磁盘中加载已有交易到交易池。在新的 local 交易进入交易池时，将被实时写入 journal 文件。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// core/tx_pool.go:757</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *TxPool)</span> <span class="title">journalTx</span><span class="params">(from common.Address, tx *types.Transaction)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> pool.journal == <span class="literal">nil</span> || !pool.locals.contains(from) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> err := pool.journal.insert(tx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Warn(<span class="string">&quot;Failed to journal local transaction&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上可看到，<strong>只有属于 local 账户的交易才会被记录</strong>。你又没有注意到，如果仅仅是这样的话，journal 文件是否会跟随本地交易而无限增长？答案是否定的，<strong>虽然无法实时从 journal 中移除交易。但是支持定期更新 journal 文件</strong>。<br><strong>journal 并不是保存所有的本地交易以及历史</strong>，他<strong>仅仅是存储当前交易池中存在的本地交易</strong>。因此交易池会定期对 journal 文件执行 rotate，将交易池中的本地交易写入 journal 文件，并丢弃旧数据。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">journal := time.NewTicker(pool.config.Rejournal)</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//core/tx_pool.go:353</span></span><br><span class="line"><span class="keyword">case</span> &lt;-journal.C:</span><br><span class="line"><span class="keyword">if</span> pool.journal != <span class="literal">nil</span> &#123;</span><br><span class="line">pool.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> err := pool.journal.rotate(pool.local()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Warn(<span class="string">&quot;Failed to rotate local tx journal&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">pool.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="新交易信号"><a href="#新交易信号" class="headerlink" title="新交易信号"></a>新交易信号</h2><p>文章开头，有提到<strong>进入交易池的交易将被广播到网络</strong>中。这<strong>是依赖于交易池支持外部订阅新交易事件信号</strong>。任何<strong>订阅此事件的子模块</strong>，在交易池出现新的可执行交易时，均可实时接受到此事件通知，并获得新交易信息。</p><blockquote><p>需要注意的是并非所有进入交易池的交易均被通知外部，而是只有交易从非可执行状态变成可执行状态后才会发送信号。</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/tx_pool.go:705</span></span><br><span class="line"><span class="keyword">go</span> pool.txFeed.Send(NewTxsEvent&#123;types.Transactions&#123;tx&#125;&#125;)</span><br><span class="line"><span class="comment">//core/tx_pool.go:1022</span></span><br><span class="line"><span class="keyword">go</span> pool.txFeed.Send(NewTxsEvent&#123;promoted&#125;)</span><br></pre></td></tr></table></figure><p>在交易池中，有两处地方才会执行发送信号。<br>一是<strong>交易时用于替换已经存在的可执行交易</strong>时。<br>二是有<strong>新的一批交易从非可执行状态提升到可执行状态后</strong>。<br>外部只需要订阅 SubscribeNewTxsEvent(ch chan&lt;- NewTxsEvent)新可执行交易事件，则可实时接受交易。<br>在 geth 中网络层将<strong>订阅交易事件</strong>，以便实时广播。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eth/handler.go:213</span></span><br><span class="line">pm.txsCh = <span class="built_in">make</span>(<span class="keyword">chan</span> core.NewTxsEvent, txChanSize)</span><br><span class="line">pm.txsSub = pm.txpool.SubscribeNewTxsEvent(pm.txsCh)</span><br><span class="line"><span class="comment">//eth/handler.go:781</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *ProtocolManager)</span> <span class="title">txBroadcastLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> event := &lt;-pm.txsCh:</span><br><span class="line">         pm.BroadcastTxs(event.Txs)</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外是矿工实时订阅交易，以便将交易打包到区块中。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//miner/worker.go:207</span></span><br><span class="line">worker.txsSub = eth.TxPool().SubscribeNewTxsEvent(worker.txsCh)</span><br><span class="line"><span class="comment">//miner/worker.go:462</span></span><br><span class="line">txs := <span class="built_in">make</span>(<span class="keyword">map</span>[common.Address]types.Transactions)</span><br><span class="line"><span class="keyword">for</span> _, tx := <span class="keyword">range</span> ev.Txs &#123;</span><br><span class="line">acc, _ := types.Sender(w.current.signer, tx)</span><br><span class="line">   txs[acc] = <span class="built_in">append</span>(txs[acc], tx)</span><br><span class="line">&#125;</span><br><span class="line">txset := types.NewTransactionsByPriceAndNonce(w.current.signer, txs)</span><br><span class="line">w.commitTransactions(txset, coinbase, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><h1 id="清理交易池"><a href="#清理交易池" class="headerlink" title="清理交易池"></a>清理交易池</h1><p>交易池是完全存在内存中的，因此有大小限制，每当超过一定的阈值就需要清理。实际实现时，pending 的缓冲区容量默认为 4096，queue 的缓冲区容量默认为 1024。<br>清理的时机是交易池满的时候，清理的原则是价格较低的最先清理</p><blockquote><p>但是本项目没有设计要清理交易池</p></blockquote><h1 id="惩罚恶意账号"><a href="#惩罚恶意账号" class="headerlink" title="惩罚恶意账号"></a>惩罚恶意账号</h1><p>这也是 txpool 很重要的一个属性，可以防止恶意账户以发起大量垃圾交易。防止恶意用户造成：</p><ol><li>占用 txpool 空间</li><li>浪费节点大量内存和 CPU</li><li>降低打包性能</li></ol><p>** 只有当交易的总数量超过缓冲区大小时，txpool 才会认为有恶意账户发起大量交易。**pending 和 queued 缓冲区大小不同，但处理策略类似：</p><ol><li>pending 的缓冲区容量是 4096，当 pending 的交易数量多于此时，就会运行检查，每个账号的交易数量是否多于 16，把这些账号搜集出来，进行循环依次清理，什么意思呢？就是每轮只删除（移动到 queued）这些账号的每个账号 1 条交易，然后看数量是否降下来了，不满足再进行下一轮，直到满足。</li><li>queued 的缓冲区容量是 1024，超过之后清理策略和 pending 差不多，但这里可是真删除了。</li></ol><p>该部分功能未抽象成单独的函数，而是在 promoteExecutables()中，就是在每次把 queued 交易转移到 pending 后执行的。<br><strong>本地交易的特权</strong>，txpool 虽然对交易有诸多限制，但如果交易是本节点的账号发起的，以上数量限制等都对他无效。所以，如果你用本节点账号不停的发送交易，并不会被认为是攻击者</p><h1 id="回答问题"><a href="#回答问题" class="headerlink" title="回答问题"></a>回答问题</h1><ol><li>用户发起的交易请求（不论以何种方式）是如何转变为实际的交易的；</li></ol><p>所有与交易请求相关的参数被赋值到一个结构体中，然后进行序列化转变为可存储和传输的形式，最后生成交易并进行签名</p><ol start="2"><li>产生的交易如果不能被及时处理，是如何进入交易池的？</li></ol><p>最终是调用一个 add 函数，添加到了一个队列里</p><ol start="3"><li>本地产生的交易和从网络中接收到的交易进入交易池是否有区别？</li></ol><p>有区别，底层都是调用 add 函数</p><ol start="4"><li>交易池的基本数据结构是怎么样的（优先队列？）</li></ol><p>交易池是一个结构体，核心是 pending 和 queue 两个 map，map 的键是一个地址，值是一个交易链表形成的队列</p><ol start="5"><li>从交易池中提取交易进行打包时顺序是怎么样的（调度算法）</li></ol><p>本地优先级大于远程交易</p><p>我们可以理解为区块链底层利用交易池对并发产生的请求做了<strong>异步化</strong>，<strong>交易产生的时刻</strong>和<strong>交易被打包的时刻</strong>是<strong>随机</strong>的。</p><blockquote><p>在实现 TXpool 的时候为了保证数据的一致性会使用大量的锁</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;既然要从头搭建一个区块链网络，交易池是绕不开的一个核心底层。对于它，以下几个问题是需要解决的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户发起的交易请求（不论以何种方式）是如何转变为实际的交易的；&lt;/li&gt;
&lt;li&gt;产生的交易如果不能被及时处理，是如何进入交易池的；&lt;/li&gt;
&lt;li&gt;本地产生的交易和从网络中接收到的交易进入交易池是否有区别；&lt;/li&gt;
&lt;li&gt;交易池的基本数据结构是怎么样的（优先队列？）&lt;/li&gt;
&lt;li&gt;从交易池中提取交易进行打包时顺序是怎么样的（调度算法）&lt;blockquote&gt;
&lt;p&gt;网络中很多文章提到内存池，指的就是是 txpool&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Life-Weekly-April-12-to-18</title>
    <link href="https://www.blog.hackerjerry.top/2021/04/15/Life-Weekly-April-12-to-18_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/04/15/Life-Weekly-April-12-to-18_new/</id>
    <published>2021-04-15T11:14:09.000Z</published>
    <updated>2021-05-26T12:22:43.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时讯"><a href="#时讯" class="headerlink" title="时讯"></a>时讯</h1><ol><li>日本宣布将把福岛核废水排放入海，还恬不知耻的推出了一个“氚”的吉祥物。</li><li>中科大夏令营开始接收报名。</li></ol><h1 id="小事"><a href="#小事" class="headerlink" title="小事"></a>小事</h1><ol><li>无聊的时候（吃完饭）给自己测了一下十六型人格，结果是“守卫者 ISFJ-A”，看了一下这个结果其实是比较准确的。</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Life-Weekly-April-12-to-18-1.png#clientId=ud3d92086-9aed-4&from=paste&height=341&id=ue2cb8370&margin=%5Bobject%20Object%5D&originHeight=804&originWidth=890&originalType=binary&size=46588&status=done&style=none&taskId=ud08b7ea8-50e0-4be0-846f-ac42bda13b9&width=377"><br>根据报告，守卫者人格在群体中所占比重最大，为 13%，不过我记得之前也做过这个测试，但是忘记结果了，我记得自己截了图，但是怎么也找不到，也不知道发到哪个平台了。<br>不过它描述的和我的人格真的非常像，摘抄一点：</p><blockquote><p><em>“守卫者”是真正的利他主义者，非常善良，对相信的人和事物慷慨而富有激情。</em></p></blockquote><p>这种人格类型的人（尤其是性格不安定的那一部分）经常<strong>一丝不苟到完美主义</strong>的程度，虽然他们<strong>有拖延的习惯</strong>，但他们总能<strong>可靠地按时完成工作</strong>。 守卫者人格类型的人重视自己的责任，时刻<strong>尽最大努力超出预期</strong>地让别人满意，无论在家庭还是工作中。<br><strong>天生喜欢社交</strong>是内向者身上少见的特点，“守卫者”们不会把出色的记忆力用在数据和琐事上，而是<strong>记住人和他们生活中的细节</strong>。 他们最<strong>擅长赠送礼物</strong>，他们<strong>天生富有想象力</strong>且<strong>感情细腻</strong>，他们的礼物可以送到接收者的心坎里。 对于被“守卫者”们当作朋友的同事们来说是这样，而在家庭里守卫者们会<strong>尽情表达爱意</strong>。<br><strong>弱点：</strong></p><ol><li>谦卑和害羞</li><li>压抑他们的感情</li><li>他们强烈的责任感和完美主义，加上这种对情感冲突的厌恶，造成了一种情况，即捍卫者太容易超载自己</li><li>太利他主义了，他们的麻烦却在无人协助的情况下增加。</li></ol><p>恋爱：</p><ol><li>守卫者花费大量时间和精力寻找让伴侣保持关系满意的方法。</li><li>作为回报，他们要求的就是承诺、爱，也许最重要的是欣赏。</li></ol><h1 id="本周收藏"><a href="#本周收藏" class="headerlink" title="本周收藏"></a>本周收藏</h1><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p>看到了哪些好文？</p><ol><li><a href="https://mp.weixin.qq.com/s/aj6LKXdAekoFCoSrpEwbAQ">攻破 GitHub 私有页面</a></li></ol><p>利用一个前缀绕过进行 XSS，利用缓存投毒进行认证流的持久化破坏。</p><ol start="2"><li><a href="https://mp.weixin.qq.com/s/k1ZRhTmNMgfaLCqniBmuNA">一篇有参考意义的产品 PPT 制作</a></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Life-Weekly-April-12-to-18-2.png#clientId=u49d79466-a36b-4&from=paste&height=239&id=uebef2f08&margin=%5Bobject%20Object%5D&originHeight=478&originWidth=852&originalType=binary&size=426622&status=done&style=none&taskId=ue23c0b44-6f1e-4c86-90c5-b20e1e6bff1&width=426"></p><ol start="3"><li><a href="https://mp.weixin.qq.com/s/__-d28S1X6CfpgiB3TwrTw">一位博士学长在大厂做安全算法工程师的感悟</a></li><li><a href="https://mp.weixin.qq.com/s/wDMcm4Q_waE3twkI-oajYg">基于机器学习的 Web 应用入侵威胁检测</a></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Life-Weekly-April-12-to-18-3.png#clientId=u49d79466-a36b-4&from=paste&height=427&id=u7c7b4016&margin=%5Bobject%20Object%5D&originHeight=854&originWidth=338&originalType=binary&size=44182&status=done&style=none&taskId=u3fa9a8b8-057c-4d41-9333-36f34a4d393&width=169"></p><ol start="5"><li><a href="https://mp.weixin.qq.com/s/fqYbyKKAXCrR8ooE_jNFdA">一篇对于处理多文字的 PPT 范例</a></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Life-Weekly-April-12-to-18-4.png#clientId=u49d79466-a36b-4&from=paste&height=401&id=uaedf9eeb&margin=%5Bobject%20Object%5D&originHeight=479&originWidth=851&originalType=binary&size=550925&status=done&style=none&taskId=ueb2143a6-5ef6-475a-aaf5-e9d206c1886&width=712.5"></p><ol start="6"><li><a href="https://mp.weixin.qq.com/s/elKxcNiwW14ceJOWiek2Ww">一篇关于毛玻璃效果的 PPT</a></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Life-Weekly-April-12-to-18-5.png#clientId=u49d79466-a36b-4&from=paste&height=242&id=ub988f9f1&margin=%5Bobject%20Object%5D&originHeight=483&originWidth=862&originalType=binary&size=179871&status=done&style=none&taskId=u45a7c337-9928-4762-93a2-20bb7020f3b&width=431"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Life-Weekly-April-12-to-18-6.png#clientId=u49d79466-a36b-4&from=paste&height=241&id=u603599ae&margin=%5Bobject%20Object%5D&originHeight=482&originWidth=848&originalType=binary&size=311473&status=done&style=none&taskId=uf73bcf00-d57c-4f2a-9c25-5d3b17036a9&width=424"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Life-Weekly-April-12-to-18-7.png#clientId=u49d79466-a36b-4&from=paste&height=212&id=u907476e8&margin=%5Bobject%20Object%5D&originHeight=424&originWidth=854&originalType=binary&size=507600&status=done&style=none&taskId=u4abc5901-834f-464a-9dcd-5c065781745&width=427"></p><h2 id="剧集"><a href="#剧集" class="headerlink" title="剧集"></a>剧集</h2><ol><li>《人潮汹涌》</li></ol><p>刘德华和肖央出演的一部本土改编剧，情节和原著有了一些变动，也很有趣。不过戏剧性冲突比韩国的原片还是要差一点，那个曾九蓉更是看的我云里雾里的，没看懂她存在的意义。笑点是比不上原著的，毕竟刘德华太帅了，很难表现出原著中“丑杀手”的一些搞笑的地方。 2.《 伍六七》第七集<br>伍六七终于到玄武国了，但是这都第七集了！！！一共就十集看个寂寞，估计这一季他连掌门的影子都见不到，还又挖了一堆坑，又是可乐，又是悬赏令，又是陈年旧账，何导可以的啊！！</p><h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><ol><li>踏实一点，不要着急，你想要的岁月都会给你。</li><li>寂寞会发慌，孤独则是饱满的。–蒋勋</li><li>人间忽晚，山河已秋。</li></ol><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><ol><li>面试的技巧–见 flomo</li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li>从朋友圈看到的：如果有人一开始就对你表示出超乎寻常的喜爱，那么他也一定会在某天返给你极其的恨意。他心里曾经爱慕的和现在痛恨的，都和你没有关系，那只是他的想象。很有道理，值得反复思考和践行。</li><li>毛姆的《巨匠与杰作》中有这样一段话：<strong>不对别人期待太多</strong>，从一开始就应该认识到，每个人的主要兴趣都是他自身；无论在哪方面，付出才有回报，不管是地位、财富、荣誉、爱情，皆为如此。而且所谓智慧，很大程度上是，<strong>对某个事物的付出不要超出其真正价值</strong>。</li></ol><p>由于平时（白天）交流较少，经常性出现情感溢出的现象，即对特定的人付出超过其身份的感情，但依旧很难表现出来，就这样憋在心里，造成不必要的情绪波动。需要改正。</p><ol start="3"><li>“你的心意过头了，反而会让人为难。”敲不开的门，一直敲是不礼貌的。感情中尤为如此，本就是你情我愿，遇见了，感谢，错过了，坦然。毕竟离开是常态，彼此喜欢是上天恩赐。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;时讯&quot;&gt;&lt;a href=&quot;#时讯&quot; class=&quot;headerlink&quot; title=&quot;时讯&quot;&gt;&lt;/a&gt;时讯&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;日本宣布将把福岛核废水排放入海，还恬不知耻的推出了一个“氚”的吉祥物。&lt;/li&gt;
&lt;li&gt;中科大夏令营开始接收报名。&lt;/li&gt;
</summary>
      
    
    
    
    <category term="周报" scheme="https://www.blog.hackerjerry.top/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
    <category term="周报" scheme="https://www.blog.hackerjerry.top/tags/%E5%91%A8%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Basic-scientific-research-series-1-Pseudo-code-specifications</title>
    <link href="https://www.blog.hackerjerry.top/2021/04/15/Basic-scientific-research-series-1-Pseudo-code-specifications_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/04/15/Basic-scientific-research-series-1-Pseudo-code-specifications_new/</id>
    <published>2021-04-15T09:21:58.000Z</published>
    <updated>2021-05-26T12:22:01.911Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下科研论文中的伪代码。<br>转自：<a href="https://shuzang.github.io/2021/pseudocode-specification/">https://shuzang.github.io/2021/pseudocode-specification/</a></p><a id="more"></a><h2 id="伪代码规范"><a href="#伪代码规范" class="headerlink" title="伪代码规范"></a>伪代码规范</h2><p>伪代码是一种接近自然语言的算法描述形式，其目的是在不涉及具体实现（各种编程语言）的情况下将算法的流程和含义清楚的表达出来，因此它没有一个统一的规范，有的仅仅是在长期的实践过程中形成的一些约定俗成的表达样式。下图是一个简单的例子<a href="https://shuzang.github.io/2021/pseudocode-specification/#fn:1">1</a>，但已经包含了大多数主要元素<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Basic-scientific-research-series-1-Pseudo-code-specifications-1.png#clientId=u7f037a6a-77db-4&from=paste&height=380&id=u70552d91&margin=%5Bobject%20Object%5D&originHeight=759&originWidth=668&originalType=url&status=done&style=none&taskId=uef2d862d-a2fb-4d0c-9f58-61f5f43f3ea&width=334"><br>首先需要一个<strong>标题</strong>来描述整个算法，一般还会有一个与之一起的编号。在上图中，算法的标题为「Acesscontrol algorithm flow」，编号为「Algorithm 1」。标题与编号一般位于算法顶部，但也有人放在底部，编号多按全文的算法总数进行索引，但也可以按章节分别进行索引。<br>其次，在正式的算法流之前需要声明<strong>输入和输出</strong>。通常使用关键字 Input 和 Output 来声明，但也有人使用关键字 Data 和 Result。<br>顺序、选择与循环结构是算法的主体。通常，不同的程序块使用缩进来保持结构清晰，但也有不少人使用垂直连接线进行进一步划分，如上图。另外，和编程语言类似，伪代码中的选择和循环使用 if-then-else、while-do 和 for-do 等关键字和结构来描述<a href="https://shuzang.github.io/2021/pseudocode-specification/#fn:2">2</a>，举例如下，其中，每个程序块结束的 end 关键字有人选择写，也有人选择不写。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Basic-scientific-research-series-1-Pseudo-code-specifications-2.png#clientId=u7f037a6a-77db-4&from=paste&height=461&id=u980d4514&margin=%5Bobject%20Object%5D&originHeight=922&originWidth=1121&originalType=url&status=done&style=none&taskId=uebf9d8c3-b7d5-4640-bb35-d608225f8f0&width=560.5"><br>算法流程结构<br>赋值操作一般使用左箭头「&lt;—」表示。A[i] 用来表示数组 A 的第 i 个元素，A[1…j] 则表示下标从 1 到 j 的子数组；函数调用使用函数名+传入参数的形式；返回值使用 return 关键字，这些都和常规编程语言相同。需要注意的是，未声明而使用的变量都可以视为算法内的局部变量，如果是全局变量则需要进行解释，可以在上下文中，也可以使用注释；注释的形式也和传统语言相同，使用 // 或 /<em>……</em>/。<br>算法整体通常使用三线框包围，但也有少部分人使用一个完整的框。<br>伪代码的语句一般不需要在末尾使用分号，但行首通常会添加行号。</p><h2 id="2-LaTeX-包"><a href="#2-LaTeX-包" class="headerlink" title="2. LaTeX 包"></a>2. LaTeX 包</h2><p>latex 书写伪代码主要有三种排版格式：algorithm+algorithmic、algorithm+algorithmicx 以及 algorithm2e<a href="https://shuzang.github.io/2021/pseudocode-specification/#fn:3">3</a>。我们使用<a href="https://www.ctan.org/pkg/algorithm2e">algorithm2e</a>，它提供了垂直连接线，可以去掉 end 关键字，而且写起来更像编程语言，用着非常舒服。<br>引入 algorithm2e 包使用如下语句</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">[options]</span><span class="string">&#123;algorithm2e&#125;</span></span></span><br></pre></td></tr></table></figure><p>几个重要的 options 如下</p><ol><li>ruled：让标题显示在上面，默认会显示到最下面；</li><li>vlined：默认启用垂直连接线；</li><li>linesnumbered：让算法显示行号，不包括 input 和 output 部分；</li><li>noend：程序块结束不打印 end。</li></ol><p>常用命令如下<a href="https://shuzang.github.io/2021/pseudocode-specification/#fn:4">4</a><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Basic-scientific-research-series-1-Pseudo-code-specifications-3.png#clientId=u7f037a6a-77db-4&from=paste&height=372&id=u452ff8fa&margin=%5Bobject%20Object%5D&originHeight=743&originWidth=974&originalType=binary&size=52982&status=done&style=none&taskId=u7814261f-55f6-48b7-b9ab-bede03ce98b&width=487"><br>一个官方的例子如下</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;algorithm&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">SetKwData</span><span class="string">&#123;Left&#125;</span><span class="string">&#123;left&#125;</span></span><span class="tag">\<span class="name">SetKwData</span><span class="string">&#123;This&#125;</span><span class="string">&#123;this&#125;</span></span><span class="tag">\<span class="name">SetKwData</span><span class="string">&#123;Up&#125;</span><span class="string">&#123;up&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">SetKwFunction</span><span class="string">&#123;Union&#125;</span><span class="string">&#123;Union&#125;</span></span><span class="tag">\<span class="name">SetKwFunction</span><span class="string">&#123;FindCompress&#125;</span><span class="string">&#123;FindCompress&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">SetKwInOut</span><span class="string">&#123;Input&#125;</span><span class="string">&#123;input&#125;</span></span><span class="tag">\<span class="name">SetKwInOut</span><span class="string">&#123;Output&#125;</span><span class="string">&#123;output&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">Input</span><span class="string">&#123;A bitmap $Im$ of size $w\times l$&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">Output</span><span class="string">&#123;A partition of the bitmap&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">BlankLine</span></span></span><br><span class="line"><span class="tag">\<span class="name">emph</span><span class="string">&#123;special treatment of the first line&#125;</span></span><span class="tag">\<span class="name">;</span></span></span><br><span class="line"><span class="tag">\<span class="name">For</span><span class="string">&#123;$i\leftarrow 2$ \KwTo $l$&#125;</span><span class="string">&#123;</span></span></span><br><span class="line"><span class="tag"><span class="string">\emph&#123;special treatment of the first element of line $i$&#125;</span></span><span class="tag">\<span class="name">;</span></span></span><br><span class="line"><span class="tag">\<span class="name">For</span><span class="string">&#123;$j\leftarrow 2$ \KwTo $w$&#125;</span><span class="string">&#123;\label&#123;forins&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">Left</span></span><span class="formula">$<span class="tag">\<span class="name">leftarrow</span></span>$</span> <span class="tag">\<span class="name">FindCompress</span><span class="string">&#123;$Im[i,j-1]$&#125;</span></span><span class="tag">\<span class="name">;</span></span></span><br><span class="line"><span class="tag">\<span class="name">Up</span></span><span class="formula">$<span class="tag">\<span class="name">leftarrow</span></span>$</span> <span class="tag">\<span class="name">FindCompress</span><span class="string">&#123;$Im[i-1,]$&#125;</span></span><span class="tag">\<span class="name">;</span></span></span><br><span class="line"><span class="tag">\<span class="name">This</span></span><span class="formula">$<span class="tag">\<span class="name">leftarrow</span></span>$</span> <span class="tag">\<span class="name">FindCompress</span><span class="string">&#123;$Im[i,j]$&#125;</span></span><span class="tag">\<span class="name">;</span></span></span><br><span class="line"><span class="tag">\<span class="name">If</span></span>(<span class="tag">\<span class="name">tcp*</span><span class="string">[h]</span><span class="string">&#123;O(\Left,\This)==1&#125;</span></span>)&#123;<span class="tag">\<span class="name">Left</span></span> compatible with <span class="tag">\<span class="name">This</span></span>&#125;&#123;<span class="tag">\<span class="name">label</span><span class="string">&#123;lt&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">lIf</span><span class="string">&#123;\Left $&lt;$ \This&#125;</span><span class="string">&#123;\Union&#123;\Left,\This&#125;</span></span>&#125;</span><br><span class="line"><span class="tag">\<span class="name">lElse</span><span class="string">&#123;\Union&#123;\This,\Left&#125;</span></span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">\<span class="name">If</span></span>(<span class="tag">\<span class="name">tcp*</span><span class="string">[f]</span><span class="string">&#123;O(\Up,\This)==1&#125;</span></span>)&#123;<span class="tag">\<span class="name">Up</span></span> compatible with <span class="tag">\<span class="name">This</span></span>&#125;&#123;<span class="tag">\<span class="name">label</span><span class="string">&#123;ut&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">lIf</span><span class="string">&#123;\Up $&lt;$ \This&#125;</span><span class="string">&#123;\Union&#123;\Up,\This&#125;</span></span>&#125;</span><br><span class="line"><span class="tag">\<span class="name">tcp</span><span class="string">&#123;\This is put under \Up to keep tree as flat as possible&#125;</span></span><span class="tag">\<span class="name">label</span><span class="string">&#123;cmt&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">lElse</span><span class="string">&#123;\Union&#123;\This,\Up&#125;</span></span>&#125;<span class="tag">\<span class="name">tcp*</span><span class="string">[h]</span><span class="string">&#123;\This linked to \Up&#125;</span></span><span class="tag">\<span class="name">label</span><span class="string">&#123;lelse&#125;</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">\<span class="name">lForEach</span><span class="string">&#123;element $e$ of the line $i$&#125;</span><span class="string">&#123;\FindCompress&#123;p&#125;</span></span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">\<span class="name">caption</span><span class="string">&#123;disjoint decomposition&#125;</span></span><span class="tag">\<span class="name">label</span><span class="string">&#123;algo_disjdecomp&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;algorithm&#125;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>渲染后的样式如下<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Basic-scientific-research-series-1-Pseudo-code-specifications-4.png#clientId=u7f037a6a-77db-4&from=paste&height=310&id=u6b501371&margin=%5Bobject%20Object%5D&originHeight=619&originWidth=911&originalType=url&status=done&style=none&taskId=u55db2441-adb1-4199-95e7-79ec5ef27e2&width=455.5"><br>注：当前算法选然后条件语句会带有下划线，主要是因为同时使用了 \ulem 包，产生了冲突，去掉该包即可</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一下科研论文中的伪代码。&lt;br&gt;转自：&lt;a href=&quot;https://shuzang.github.io/2021/pseudocode-specification/&quot;&gt;https://shuzang.github.io/2021/pseudocode-specification/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>SPECTRE-Coding</title>
    <link href="https://www.blog.hackerjerry.top/2021/04/11/SPECTRE-Coding_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/04/11/SPECTRE-Coding_new/</id>
    <published>2021-04-11T09:46:39.000Z</published>
    <updated>2021-05-26T12:21:44.103Z</updated>
    
    <content type="html"><![CDATA[<p>虽然这个 paper 可能不是个能 work 的（有很多地方比较牵强，不稳定，且无任何项目声明实现了它），但既然老师要求了，只好硬着头皮上了。</p><a id="more"></a><h1 id="借鉴"><a href="#借鉴" class="headerlink" title="借鉴"></a>借鉴</h1><p>根据经验，我决定先学习一下现有项目中各种共识协议的编写。<br>pow-原理很简单，就是工作量证明，故不用看。<br>pos-选举人制度，具体原理还是可以了解一下的。</p><h2 id="pos–账本共识"><a href="#pos–账本共识" class="headerlink" title="pos–账本共识"></a>pos–账本共识</h2><p>切记，PoS 不是一种确定的定义（算法)，而是一种概念，因此对于不同的平台来说，可以有不同的 PoS 实现。<br>以太坊使用 GHOST，贪婪最重可观察子树协议，作为其分叉选择规则。在 GHOST 协议中，获得投票数最高的分叉将被选为链头（将每个分叉区块及其各自子区块的所有票数计入考虑）。<br>与最长链规则相比， <strong>GHOST 的优点在于能够在网络延迟较高时降低攻击效率，同时最小化链重组的深度</strong>。原因是即使攻击者能够高效地在其分叉链上继续产生区块，尝试使该链成为最长链，GHOST 也会选择另一条票数更高的分叉链。</p><h2 id="pow–挖矿共识"><a href="#pow–挖矿共识" class="headerlink" title="pow–挖矿共识"></a>pow–挖矿共识</h2><p><a href="https://www.yuque.com/docs/share/f47edbdb-8ca4-411b-b78c-1f0ea772ac2c#O7vbh">https://www.yuque.com/docs/share/f47edbdb-8ca4-411b-b78c-1f0ea772ac2c#O7vbh</a><br>挖矿可以设计一个动态调整难度的函数<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/SPECTRE-Coding-1.png#height=790&id=CCHi2&originHeight=790&originWidth=930&originalType=binary&status=done&style=none&width=930"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/SPECTRE-Coding-2.png#height=448&id=Lw1nX&originHeight=448&originWidth=836&originalType=binary&status=done&style=none&width=836"></p><h1 id="SPECTRE"><a href="#SPECTRE" class="headerlink" title="SPECTRE"></a>SPECTRE</h1><p>根据它的伪代码我写了一个 demo,看起来还不错。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Vote</span><span class="params">(node1 *dag.Blocknode, node2 *dag.Blocknode, graph *Graph)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">voteOfnode1 := <span class="number">0</span></span><br><span class="line">voteOfnode2 := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历全局图</span></span><br><span class="line">Graph := graph</span><br><span class="line"><span class="comment">//这里graph一开始要传dag.Graph这个全局图，之后可以传past集或者future集</span></span><br><span class="line"><span class="keyword">for</span> k, z := <span class="keyword">range</span> Graph.nodes &#123;</span><br><span class="line">_, ok1 := Graph.getFuture(node1)[k]</span><br><span class="line">_, ok2 := Graph.getFuture(node2)[k]</span><br><span class="line"><span class="keyword">if</span> ok1 &amp;&amp; !ok2 &#123;</span><br><span class="line">voteOfnode1 += <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> !ok1 &amp;&amp; ok2 &#123;</span><br><span class="line">voteOfnode2 += <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ok1 &amp;&amp; ok2 &#123;</span><br><span class="line"><span class="comment">//取决于past(z)的投票结果</span></span><br><span class="line">tem1, tem2 := Vote(node1, node2, Graph.getPast(z))</span><br><span class="line"><span class="keyword">if</span> tem1 &gt; tem2 &#123;</span><br><span class="line">voteOfnode1 += <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">voteOfnode2 += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> !ok1 &amp;&amp; !ok2 &#123;</span><br><span class="line"><span class="comment">//z的投票结果取决于future(z)的投票结果</span></span><br><span class="line">tem1, tem2 := Vote(node1, node2, getFutureToGraph(Graph.getFuture(z)))</span><br><span class="line"><span class="keyword">if</span> tem1 &gt; tem2 &#123;</span><br><span class="line">voteOfnode1 += <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">voteOfnode2 += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> z == node1 &#123;</span><br><span class="line">voteOfnode1 += <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> z == node2 &#123;</span><br><span class="line">voteOfnode2 += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> voteOfnode1, voteOfnode2</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;虽然这个 paper 可能不是个能 work 的（有很多地方比较牵强，不稳定，且无任何项目声明实现了它），但既然老师要求了，只好硬着头皮上了。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>wireshark抓包原理</title>
    <link href="https://www.blog.hackerjerry.top/2021/04/10/wireshark%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/04/10/wireshark%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86_new/</id>
    <published>2021-04-10T02:43:22.000Z</published>
    <updated>2021-05-26T12:20:55.687Z</updated>
    
    <content type="html"><![CDATA[<p>这几天学院研究生复试，院长出了这道题，就是问了 wireshark 的抓包原理，由于我并不太清楚，所以特此记录。</p><a id="more"></a><h2 id="Wireshark"><a href="#Wireshark" class="headerlink" title="Wireshark"></a>Wireshark</h2><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/wireshark%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86-1.jpeg#align=left&display=inline&height=463&margin=%5Bobject%20Object%5D&originHeight=463&originWidth=1102&size=0&status=done&style=none&width=1102"></p><p>网络上传输的数据包<strong>通过网卡进入到网络协议分析器系统</strong>。即<strong>Wireshark 使用的网卡数据复制，只要是经过指定网卡都会被抓取</strong>。<br>  每一个协议分析器内部都维护有一个“<strong>跟踪缓冲区</strong>”内存空间区域。它用于<strong>暂存从网络上面复制而来的数据包流</strong>。数据包流从“捕获过滤器”流入到协议分析器的跟踪缓存区中，该缓冲区中的数据包能够在被捕获之后立即查看或是以其他文件格式保持到磁盘上面。比如 Wireshark 协议分析器工具，打开之后，点击[开始捕获]， 然后便可立刻查看捕获到的数据包信息。此时的这些数据包就是放在协议分析器的“跟踪缓冲区”中的。<br>协议分析器所使用的网卡和网卡驱动程序必须能够支持“<strong>混杂模式操作</strong>（Promiscuous Mode Operation）”。因为<strong>只有运行在混杂模式下的网卡才能够捕获到网络中传输到其他设备的“广播数据包、多播数据包、单播数据包以及错误数据包等等”（</strong>支持 VLAN ,单播，多播等），两者一起协同工作。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/wireshark%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86-2.png#align=left&display=inline&height=375&margin=%5Bobject%20Object%5D&name=image.png&originHeight=461&originWidth=814&size=234125&status=done&style=none&width=662" alt="image.png"></p><h3 id="混杂模式与监视模式区别"><a href="#混杂模式与监视模式区别" class="headerlink" title="混杂模式与监视模式区别"></a>混杂模式与监视模式区别</h3><p>要弄清混杂模式和监视模式之间的区别：<strong>监视模式仅用于无线卡</strong>，<strong>混杂模式用于无线和有线</strong>。 监控模式使卡无需关联接入点即可侦听无线数据包。 混杂模式使卡可以侦听所有数据包，即使不是针对特定的数据包。</p><blockquote><p>作者：圣手书生黎公子<br>链接：<a href="https://zhuanlan.zhihu.com/p/267640786">https://zhuanlan.zhihu.com/p/267640786</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><h1 id="ping-流程"><a href="#ping-流程" class="headerlink" title="ping 流程"></a>ping 流程</h1><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/wireshark%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86-3.png#align=left&display=inline&height=265&margin=%5Bobject%20Object%5D&name=image.png&originHeight=265&originWidth=642&size=114805&status=done&style=none&width=642" alt="image.png"><br>在这里，我们搭建了一个 PC+交换机+路由器（文中又称网关）的本地网络</p><p>在一开始，所有机器的 arp 表其实都是空的。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/wireshark%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86-4.png#align=left&display=inline&height=429&margin=%5Bobject%20Object%5D&name=image.png&originHeight=523&originWidth=828&size=203088&status=done&style=none&width=679" alt="image.png"><br>而此时，让 PC 去进行 ping（使用 ICMP 协议）自己的网关 192.168.1.1，是可以通的。<br>为什么呢？<br>我们分析一下流程。</p><ol><li>PC 首先封装这个 ICMP 数据包，最里面是 ICMP 的数据，数据外面封装 IPV4 包头，IPV4 包头外面是帧头。格式如下：</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/wireshark%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86-5.png#align=left&display=inline&height=219&margin=%5Bobject%20Object%5D&name=image.png&originHeight=438&originWidth=1550&size=714203&status=done&style=none&width=775" alt="image.png"></p><ol start="2"><li>有个问题是，刚开始 ping 的时候，PC 的 ARP 表项是不知道目的 IP 所对应的 MAC 是多少，那么他怎么获取的呢。</li></ol><p>仔细看数据抓包，有一对 ARP 包：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/wireshark%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86-6.png#align=left&display=inline&height=215&margin=%5Bobject%20Object%5D&name=image.png&originHeight=430&originWidth=1547&size=653510&status=done&style=none&width=773.5" alt="image.png"><br>就是在发 ICMP 包之前，系统先发了一个 ARP 包！<br>上面的 ARP 请求包大概意思是：我是 192.168.1.99，我的 MAC 是 aabb.cc00.3000，我想问 192.168.1.1 你的 MAC 是多少，收到请回复收到请回复。<br>在 ARP 请求的过程中，SW 已经学到了 PC 和 R1 的接口 MAC 地址，MAC 地址表项已经形成。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/wireshark%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86-7.png#align=left&display=inline&height=148&margin=%5Bobject%20Object%5D&name=image.png&originHeight=295&originWidth=747&size=233011&status=done&style=none&width=373.5" alt="image.png"><br>那么，他是怎么形成的呢？<br>第一步：<br>当 SW 通过 e0/0 端口收到 PC 发来的 ARP 广播包，PC 首先查看自己的 MAC 地址表项，看看数据帧的源 MAC 是否存在于我的 MAC 地址表中，如果没有，那么就直接把 ARP 广播包的源 MAC（aabb.cc00.3000）和接收端口 e0/0 对应起来，形成第一个 MAC 地址表的条目。如果有对应的 MAC 地址条目，SW 就看已经存在的条目和当前的收包端口是否一致，如果不一致就更新 MAC 地址表里面的条目，如果一致就直接泛洪转发这个广播数据帧。<br>第二步：SW 通过 e0/1 端口把这个数据帧发给 R1，R1 收到之后，形成 ARP 表项。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/wireshark%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86-8.png#align=left&display=inline&height=62&margin=%5Bobject%20Object%5D&name=image.png&originHeight=124&originWidth=1131&size=180774&status=done&style=none&width=565.5" alt="image.png"><br>R1 拆开外面帧头看到目的 MAC 是自己（广播包本网段内所有人均可接收），R1 就继续拆包，拆开 ARP 头部，看到请求的 MAC 是自己的 IP 地址对应的 MAC，所以 R1 就响应这个 ARP 得请求包。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/wireshark%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86-9.png#align=left&display=inline&height=150&margin=%5Bobject%20Object%5D&name=image.png&originHeight=299&originWidth=1066&size=320679&status=done&style=none&width=533" alt="image.png"><br>第三步：响应的 ARP Reply 包发送到 SW 的 e0/1 口，SW1 把单播响应包源 MAC（aabb.cc00.1000）和自己的接收端口 e0/1 口对应起来，形成另外一条 MAC 地址表条目，然后查看到数据帧的目的 MAC 是 aabb.cc00.3000，SW 直接查找自己的 MAC 地址表，发现有对应的条目，直接通过 e0/0 口转发，PC 就收到了响应，获取到了 R1 的 e0/0 接口，也就是 PC 网关的 MAC。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这几天学院研究生复试，院长出了这道题，就是问了 wireshark 的抓包原理，由于我并不太清楚，所以特此记录。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
