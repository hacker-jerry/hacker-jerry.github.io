<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>M@tr1xの日常</title>
  
  
  <link href="https://www.blog.hackerjerry.top/atom.xml" rel="self"/>
  
  <link href="https://www.blog.hackerjerry.top/"/>
  <updated>2021-05-06T13:12:10.015Z</updated>
  <id>https://www.blog.hackerjerry.top/</id>
  
  <author>
    <name>M@tr1x</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>生活周报-May-3-to-10</title>
    <link href="https://www.blog.hackerjerry.top/2021/05/04/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-May-3-to-10_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/05/04/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-May-3-to-10_new/</id>
    <published>2021-05-04T02:43:45.000Z</published>
    <updated>2021-05-06T13:12:10.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时讯"><a href="#时讯" class="headerlink" title="时讯"></a>时讯</h1><ol><li>五四青年节，知乎发布微电影《重逢》，讲述了关于肖思远烈士的事，回答了这样一个时代问题——“当代年轻人还有没有不计生死的热血”，我没有看影片，只看了些许回答就已经泣不成声，酸楚涌上心头，豆大的眼泪滴落许久。是的，我在床上浏览着手机，这和平的岁月，都是这群最可爱的人为我们负重前行换来的。身为青年一代，我何曾忘记报国之志，家国之情溢于言表，流淌着的热血，奔涌的黄河，人民在召唤，时代在召唤，吾辈当不负重任，砥砺前行。</li><li>B 站发布了新的演讲，这次的演讲十分淳朴，也十分有感染力，下面是演讲全文：</li></ol><p>那些想从我们身上 看到中国未来的人<br>亲爱的父母 师长 前辈<br>其实我还不知道 想成为什么样的人<br>但能和你们分享的是<br>我不想做什么样的人<br>我不想做一个拿着锯子的人<br>随时随地 把人群锯成两半<br>这一半是女人 那一半是男人<br>这一半是盟友 那一半是对手<br>对手赞同的我们必须反对<br>对手反对的我们必须赞同<br>不论对错 只争输赢<br>我不想做一个浑身带刺的人<br>嘲讽别人的成功 嘲笑别人的失败<br>看不惯过得比他好的人<br>看不起过得没他好的人<br>一肚子抱怨和借口<br>凡事不是自己的错 都是别人的错<br>我不想做一个 流水线上制造出来的人<br>没有独立的人格 只有预定的人设<br>没有闪光的才华 只有抛光的流量<br>没有精彩的作品 只有热闹的八卦<br>我不想做一个隐身的人<br>需要挺身而出的时候 他藏在人群里<br>需要解决问题的时候 他消失在所有人的视线里<br>我不想做一个油腻的人<br>你吃亏的时候他说吃亏是福<br>该较真的时候他说难得糊涂<br>是的，我不想做这样的人<br>我不想做一个没有同情心的人<br>一个不讲义气的人<br>一个没有教养的人<br>一个半途而废的人<br>一个遗忘历史的人<br>我不想 做一个不爱国的人<br>我不想做一个 口口声声 “一代不如一代”的人<br>当我变成父母 师长 前辈的时候<br>希望 我的孩子会对我说<br>我想成为你这样的人。</p><ol start="3"><li>盖茨离婚</li></ol><h1 id="小事"><a href="#小事" class="headerlink" title="小事"></a>小事</h1><ol><li>雷姑娘送的糕点很好吃，在阳光天地的西木栗子有卖。</li><li>买了一只大吉岭的香水小样还不知道什么味道。</li><li>立夏了，气温开始在 30 度徘徊了。</li><li>买了云南的嘉华鲜花饼，送给老妈当母亲节礼物，玫瑰馅的应该挺好吃的？</li></ol><h1 id="本周收藏"><a href="#本周收藏" class="headerlink" title="本周收藏"></a>本周收藏</h1><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p>看到了哪些好文？</p><h2 id="剧集"><a href="#剧集" class="headerlink" title="剧集"></a>剧集</h2><ol><li>伍六七第三季最后一集！《你是我想保护的人》，梅小姐这次选择拼尽全力保护阿柒，爱了爱了！而阿柒，用魔刀千刃给梅小姐的剑“续命”，真爱无疑！然而，剧情戛然而止了，挖了一堆坑，注意，是一堆坑！还要出大电影，还真就从一个爆款 IP 上面疯狂捞金呗。</li></ol><h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><blockquote><p>来自知乎：<strong>当代社会中，青年的五四精神会有哪些具体表现？</strong></p></blockquote><ul><li>第一点就是<strong>爱国</strong>，这一条都做不到也无从谈起。任何时候，爱国都是第一位，也是不能撼动的。</li><li>第二点就是<strong>敬业</strong>，做好本职工作，脚踏实地的工作，认认真真的工作，不要得陇望蜀，好高骛远。</li><li>第三点就是<strong>明志</strong>，志即志向或者理想，一个人要有自己的目标，不能得过且过，当一天和尚撞一天钟。作为青年，需要有自己的人生规划。</li><li>第四点就是<strong>静心</strong>，国家发展越来越快，社会节奏越来越快，快节奏的生活让人一夜暴富，一夜成名，这让许多人都变得越来越浮躁，内心静不下来，空中楼阁的繁华富贵让许多人迷失了自我。</li></ul><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><ol><li>如何对区块链系统测试。</li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li>又是一年青年节，在互联网多元文化的滋润下成长起来的新生代，给这个时代带来了新的课题，你不想成为一个什么样的人？</li></ol><p>我们总说，“君子有所为，有所不为”。年轻人何尝不是如此？<strong>那些非凡的勇气、思辨的精神、激扬的斗志，极尽人们对青春年华的无限想象；那些意志的消磨、生活的妥协、人生的沉沦，也在提醒人们对未老先衰的潜在担忧。</strong>从这个意义上来说，我们礼赞青年，不只是为了体现对青春年少的呵护，更是为了帮助青年扫除心灵的阴霾；我们歌颂青春，不只是为了了却人生苦短的遗憾，更是为了诠释时光荏苒的意义。要知道，青年人最大的资本，恰恰是最容易被自己忽视的青春；青春最值得的回忆，正是追逐梦想、成长奋斗的痕迹。<br>诗人塞缪尔·厄尔曼在《青春》中这样写道：“人人心中皆有一台天线，只要还能接受美好、希望、欢乐、勇气和力量的信号，就能青春永驻，风华常存。”<strong>架起这台心灵的“天线”，去感受日月星辰，去明辨是非曲直，去体悟人生百态，每一个成长的灵魂，就一定都能找到“你想成为怎样的人”和“我不想做这样的人”的完美答案。</strong><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-May-3-to-10-1.jpeg#clientId=ud5d56b56-b62c-4&from=paste&height=505&id=u6ef2f665&margin=%5Bobject%20Object%5D&originHeight=1009&originWidth=679&originalType=url&status=done&style=none&taskId=ub78ac62c-0766-4032-984a-851d51f1c7e&width=339.5"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;时讯&quot;&gt;&lt;a href=&quot;#时讯&quot; class=&quot;headerlink&quot; title=&quot;时讯&quot;&gt;&lt;/a&gt;时讯&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;五四青年节，知乎发布微电影《重逢》，讲述了关于肖思远烈士的事，回答了这样一个时代问题——“当代年轻人还有没有不计生死的热血”，我</summary>
      
    
    
    
    <category term="周报" scheme="https://www.blog.hackerjerry.top/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>区块链底层-状态机StateDB</title>
    <link href="https://www.blog.hackerjerry.top/2021/05/03/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E7%8A%B6%E6%80%81%E6%9C%BAStateDB_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/05/03/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E7%8A%B6%E6%80%81%E6%9C%BAStateDB_new/</id>
    <published>2021-05-03T08:22:12.000Z</published>
    <updated>2021-05-06T13:05:07.180Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h1><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E7%8A%B6%E6%80%81%E6%9C%BAStateDB-1.png#clientId=u1d1d90de-5c3e-4&from=paste&height=344&id=ub777611d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=688&originWidth=1306&originalType=binary&size=308117&status=done&style=none&taskId=u950bfa17-cd9c-4cde-b1d9-eb903342901&width=653" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E7%8A%B6%E6%80%81%E6%9C%BAStateDB-2.png#clientId=u1d1d90de-5c3e-4&from=paste&height=200&id=u4a6a08ef&margin=%5Bobject%20Object%5D&name=image.png&originHeight=399&originWidth=969&originalType=binary&size=146076&status=done&style=none&taskId=ude525437-624d-4812-952f-2b51a1576ff&width=484.5" alt="image.png"></p><h1 id="创建状态树"><a href="#创建状态树" class="headerlink" title="创建状态树"></a>创建状态树</h1><p>状态数据库的定义如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StateDB <span class="keyword">struct</span> &#123;</span><br><span class="line">db   Database  <span class="comment">//操作状态的底层数据库，在实例化 StateDB 时指定 ②。</span></span><br><span class="line">trie trie.Trie <span class="comment">//世界状态所在的树实例对象</span></span><br><span class="line">stateObjects      <span class="keyword">map</span>[account.Address]*account.StateObject <span class="comment">//已账户地址为键的账户状态对象，能够在内存中维护使用过的账户</span></span><br><span class="line">stateObjectsDirty <span class="keyword">map</span>[account.Address]<span class="keyword">struct</span>&#123;&#125;<span class="comment">//标记被修改过的账户</span></span><br><span class="line">    dbErr  error</span><br><span class="line">lock sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db: = state.NewDatabase(levelDB)</span><br><span class="line">statedb, err := state.New(block.Root(), db)</span><br></pre></td></tr></table></figure><p>这里的 New 函数为：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//state/statedb.go:27</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(root hash.Hash, db Database)</span> <span class="params">(*StateDB, error)</span></span> &#123;</span><br><span class="line">tr, err := db.OpenTrie(root)<span class="comment">//打开指定状态版本(root)的含世界状态的顶层树</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;StateDB&#123;</span><br><span class="line">db:                db,<span class="comment">//②</span></span><br><span class="line">trie:              tr,</span><br><span class="line">stateObjects:      <span class="built_in">make</span>(<span class="keyword">map</span>[account.Address]*stateObject),</span><br><span class="line">        stateObjectsDirty: <span class="built_in">make</span>(<span class="keyword">map</span>[account.Address]<span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">preimages:         <span class="built_in">make</span>(<span class="keyword">map</span>[hash.Hash][]<span class="keyword">byte</span>),</span><br><span class="line">journal:           newJournal(),</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>世界态中的所有状态都是已账户为基础单位存在的，因此为了便于账户隔离管理，使用不开放的 stateObject 来维护某个账户下的状态。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StateObject <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//账户哈希</span></span><br><span class="line">addrHash <span class="keyword">string</span></span><br><span class="line">data     User <span class="comment">//账户属性</span></span><br><span class="line"><span class="comment">//底层数据库</span></span><br><span class="line">db *state.StateDB</span><br><span class="line"><span class="comment">// 写缓存</span></span><br><span class="line">trie Trie <span class="comment">// 存储树，第一次访问时初始化</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//账户地址</span></span><br><span class="line">Address []<span class="keyword">byte</span></span><br><span class="line"><span class="comment">//账户余额</span></span><br><span class="line">Amount <span class="keyword">float64</span></span><br><span class="line"><span class="comment">//交易个数</span></span><br><span class="line">Nonce <span class="keyword">uint64</span></span><br><span class="line"><span class="comment">//storage树根哈希值</span></span><br><span class="line">Root <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 stateObject 中维护关于某个账户的所有信息，涉及账户地址、账户地址哈希、底层数据库、存储树等内容。<br>在区块中，将交易作为输入条件，来根据一系列动作修改状态。 在完成区块挖矿前，只是获得在内存中的状态树的 Root 值。 StateDB 可视为一个内存数据库，状态数据先在内存数据库中完成修改，所有关于状态的计算都在内存中完成。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将每个交易对应的的账户状态树进行修改</span></span><br><span class="line">usr := getUserByAddress(t.Address)</span><br><span class="line"><span class="keyword">if</span> usr.Amount - t.Fee &lt;<span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">usr.Nonce = usr.Nonce + <span class="number">1</span></span><br><span class="line">uMPT := getMPT(usr.Root)</span><br><span class="line">data := *(*[]<span class="keyword">byte</span>)(unsafe.Pointer(&amp;t))</span><br><span class="line">uMPT.Put([]<span class="keyword">byte</span>(t.Hash),data)</span><br><span class="line">usr.Root := uMPT.RootHash()</span><br></pre></td></tr></table></figure><p>在将区块持久化时完成有内存到数据库的更新存储，此更新属于增量更新，仅仅修改涉及到被修改部分。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// state/statedb.go:122</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span> <span class="title">Commit</span><span class="params">(deleteEmptyObjects <span class="keyword">bool</span>)</span> <span class="params">(root hash.Hash, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> addr := <span class="keyword">range</span> s.journal.dirties &#123;<span class="comment">//①⑧⑨⑩</span></span><br><span class="line">s.stateObjectsDirty[addr] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> addr, stateObject := <span class="keyword">range</span> s.stateObjects &#123;<span class="comment">//②</span></span><br><span class="line">_, isDirty := s.stateObjectsDirty[addr]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> isDirty&#123;</span><br><span class="line"><span class="comment">//如果集合中的账户有变更</span></span><br><span class="line"><span class="keyword">if</span> err := stateObject.CommitTrie(s.db); err != <span class="literal">nil</span> &#123;<span class="comment">//⑤</span></span><br><span class="line"><span class="keyword">return</span> common.Hash&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line">s.updateStateObject(stateObject)<span class="comment">//需要提交此账户</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">delete</span>(s.stateObjectsDirty, addr)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">root, err = s.trie.Commit(<span class="function"><span class="keyword">func</span><span class="params">(leaf []<span class="keyword">byte</span>, parent hash.Hash)</span> <span class="title">error</span></span> &#123;<span class="comment">//⑦</span></span><br><span class="line"><span class="keyword">var</span> account Account</span><br><span class="line"><span class="keyword">if</span> err := rlp.DecodeBytes(leaf, &amp;account); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> account.Root != emptyRoot &#123;</span><br><span class="line">s.db.TrieDB().Reference(account.Root, parent)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> root, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>因为在修改某账户信息是，将会记录变更流水（journal），因此在提交保存修改时只需要将在流水中存在的记录作为修改集 ①。</li><li>所有访问过的账户信息，均被记录在 stateObjects 中，只需要遍历此集合 ② 便可以提交所有修改。</li><li>处理完每个需要提交的账户内容外，最后需要将账户树提交 ⑦。在提交过程中涉及账户内容作为叶子节点，在发送变动时，将更新账户节点和父节点的关系。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;全局&quot;&gt;&lt;a href=&quot;#全局&quot; class=&quot;headerlink&quot; title=&quot;全局&quot;&gt;&lt;/a&gt;全局&lt;/h1&gt;&lt;p&gt;&lt;img src= &quot;/img/loading.gif&quot; data-lazy-src=&quot;https:/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>生活周报-April-26-to-May-2</title>
    <link href="https://www.blog.hackerjerry.top/2021/05/01/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-April-26-to-May-2_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/05/01/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-April-26-to-May-2_new/</id>
    <published>2021-05-01T09:59:24.000Z</published>
    <updated>2021-05-06T13:01:24.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时讯"><a href="#时讯" class="headerlink" title="时讯"></a>时讯</h1><ol><li>天和核心舱发射成功</li><li>郑爽阴阳合同被查</li><li>熟蛋返生论文</li><li>印度单日确诊超过 40 万</li></ol><h1 id="小事"><a href="#小事" class="headerlink" title="小事"></a>小事</h1><ol><li>导师请课题组的小伙伴一起吃了个饭，感觉老师真年轻，和现在的大学生也没啥区别，人很 nice，灌了好多啤酒哈哈哈哈哈，我也喝了两瓶，啥感觉也没有，可能我也挺能喝哈哈哈哈哈。</li><li>这周 b 测，搞了一天代码（学长的没有用，重写之），还友情帮助了小伙伴，感觉实验水的很。</li><li>这周气温上来了，中午太阳很大，要开始防晒了！</li><li>舍友欧皇附体，卖游戏账户赚了 800 块，太酸了。</li><li>5.2 日出游，品美食，玩游戏，看电影，逛街，游人如织，入夜暴雨，落汤鸡。</li></ol><h1 id="本周收藏"><a href="#本周收藏" class="headerlink" title="本周收藏"></a>本周收藏</h1><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><ol><li>python 沙箱逃逸详解</li><li>fuzzingbook 学习指南</li><li>带牙套/正畸有什么好用物推荐？–知乎</li></ol><h2 id="剧集"><a href="#剧集" class="headerlink" title="剧集"></a>剧集</h2><ol><li>刺客伍六七第九集！意识流的国创，很小清新，虽然网上褒贬不一，但是我还是很喜欢滴，阿柒可能要黑化了（大概率，因为记忆中美好的事物都消散了），不过最后出现的琵琶女，居然曾经追求过阿柒！然后刚刚！发预告了！神医果然是坏的，打了阿柒一拳，琵琶女求而不得欲将阿柒毁灭之，好虐，不过这一季看样子和首领是不可能见面了，尬住。</li><li>五一趁着浪费时间没有罪恶感，看了一部高分电影《闻香识女人》。影片讲述了一个陆军退伍盲人中校与穷人家的优秀小伙子之间的故事，故事大多发生在老兵的感恩节旅途中，主角演技十分到位，刻画出一个十分有自尊心的老兵，在失明之后的易怒、自暴自弃又肆意的情感宣泄，同时对待女人十分的绅士，有着很深的阅历和极其敏锐的嗅觉，能够十分准确地说出对方香气的来历，以及不错的推理能力。这次旅途，是他早早规划好的自杀之旅，但是很庆幸，他遇到了查理，一个正值又善良的男孩，他最终感动了老兵，打消了自杀的念头，找回了自我，重拾了前进的动力，与曾经的自己和解。</li></ol><p>影片有两段十分经典的片段，一段是他邀请一位年轻的漂亮姑娘去跳探戈，很有风度，女演员也超好看，青春的那种喜悦和羞涩表现的淋漓尽致。另一段则是他在风纪委员会上作的即兴演讲，什么叫正直，什么人才能成为领袖。对于查理保持缄默的事他并没有做出评价，但他认为，查理绝不会在将来成为一个出卖朋友换取前途的人。没有什么比丑陋的灵魂更加可怕，因为灵魂没有义肢。人生的十字路口，查理选择了正确的那一条，尽管那条路很难走，时常会碰壁，但他义无反顾。</p><ol start="3"><li>《悬崖之上》和雷姑娘一起看的第一部电影，影片的基调极冷，全部外场都在下雪，很冷，演员的脸都冻得通红，老戏骨们演技很棒，但是因为内容太多，放在电影里稍显仓促，剧情推进太快。但影片很真实的反映出敌人其实很聪明，坏人也可以装好人装得很像，真实的战场比这残酷得更多，我们要相信黎明最终到来，要相信天亮了就好了。向所有战斗在隐蔽战线的英雄致敬，你们的名字无人知晓，你们的功绩永垂青史。</li></ol><h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><ol><li>罔谈彼短，靡恃己长；容止若思，言辞安定。</li></ol><p>不要谈论别人的短处，也不没必要将自己的长处一直挂在嘴边，给别人面子，给自己留后路。<br>常常表现出自己在思考，说话谈吐也要镇定平静，有条不紊，不慌不忙，不要轻易责怪别人，也不要迁怒于人。</p><ol start="2"><li>如何废掉一个大学生？<ol><li>只接受碎片信息，拒绝深度思考。</li><li>沉迷于迅速获得成就感的事。</li><li>无法专注做一件事–眼高手低。</li><li>想得太多，做的太少。</li></ol></li><li>失落的时候悄悄伸出手和风击个掌。</li><li>在光明之处，共赴前方。</li><li>好好等，会晚些，但会更好些。</li></ol><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><ol><li>如何写出一份打动人的简历？</li><li>TCP 反射的原理</li><li>如何判断一个自然数 N 是否是质数？</li></ol><p>提出的许多快速算法，例如费马素性检测，米勒-拉宾素性检测，这些都是基于随机数的算法。<br>而 AKS 算法，是第一个解决这个问题的确定性算法，无需依靠随机数。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-April-26-to-May-2-1.jpeg#clientId=ue9575d9f-ed7c-4&from=drop&height=272&id=ue001c27c&margin=%5Bobject%20Object%5D&name=1620026735691.jpg&originHeight=1036&originWidth=1080&originalType=binary&size=241285&status=done&style=none&taskId=u855f4a92-f876-44fb-8a96-101805efc94&width=284" alt="1620026735691.jpg"></p><ol><li>关于自律和自省。<ol><li>虽然我知道我和她此生不会相见，这一生的过客太多，感谢你曾经对我着迷，但我依旧会努力，至少我想证明给我自己看，我希望自己能打破阶级壁垒，将来回想起来也能浅浅一笑。</li></ol></li><li>关于异性相处<ol><li>绝不要当舔狗，绝不要做无谓的感情付出，感动自己，让别人看笑话。</li><li>你要接收不断的优秀和长久的孤独，直到遇到那个你等待很久的人，直到你认为你所有的等待都值得。</li><li>你要做一个善良的人，一个有智慧的人，一个既能接收自己的平凡，又能坚持自己的理想和兴趣，并对生活报以美好的期待和长久的耐心的人。</li><li>最清澈的爱，要留给最值得的人。</li><li>不要给别人压力，也没必要让别人觉得你在追她，她就不好意思和其他异性一起玩了。这大可不必，咱也不是那种人对不对，你也没资格评价别人怎样，毕竟这世上有趣的事情有很多，大家聚在一起就是为了乐子，搞得相处起来紧张兮兮的好讨厌人。</li></ol></li><li>阶级鸿沟只有靠自己跨越。</li><li>多一点善意，少一点刻薄。</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-April-26-to-May-2-2.jpeg#clientId=ue9575d9f-ed7c-4&from=drop&height=328&id=uac7448db&margin=%5Bobject%20Object%5D&name=1620027231878.jpg&originHeight=673&originWidth=580&originalType=binary&size=65606&status=done&style=none&taskId=uc2cec5b3-9779-41a2-b635-fbb4cdec518&width=283" alt="1620027231878.jpg"></p><h1 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h1><p>我是一个很敏感的人，小心翼翼地表露爱意，生怕吓着对方。又是一个很专一的人（俗称固执），喜欢上一个姑娘如果她没有太大变化，我可能会一直喜欢下去。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;时讯&quot;&gt;&lt;a href=&quot;#时讯&quot; class=&quot;headerlink&quot; title=&quot;时讯&quot;&gt;&lt;/a&gt;时讯&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;天和核心舱发射成功&lt;/li&gt;
&lt;li&gt;郑爽阴阳合同被查&lt;/li&gt;
&lt;li&gt;熟蛋返生论文&lt;/li&gt;
&lt;li&gt;印度单日确诊超过 40</summary>
      
    
    
    
    <category term="周报" scheme="https://www.blog.hackerjerry.top/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
    <category term="生活周报" scheme="https://www.blog.hackerjerry.top/tags/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>QPSK信号调制</title>
    <link href="https://www.blog.hackerjerry.top/2021/04/27/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/04/27/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6_new/</id>
    <published>2021-04-27T13:46:38.000Z</published>
    <updated>2021-05-06T13:12:18.167Z</updated>
    
    <content type="html"><![CDATA[<p>b 测题目，由于学长写的代码有些步骤无法理解，而且代码不优雅，故重写之。</p><a id="more"></a><h1 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h1><ol><li>源码信号为周期 63bits 的 m 序列， 源码比特速率（kbps） 数值上= 载波频率（kHz），数值范围 5—100，在数值范围内任取整数；</li><li>在 MATLAB 环境中编写 M 代码搭建 QPSK 调制系统模型；</li><li>观测基带时域波形、已调信号时域波形；</li><li>观测基带发射星座图；</li><li>观测已调信号的功率谱（优先）或频谱；</li></ol><h1 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h1><h2 id="比特率"><a href="#比特率" class="headerlink" title="比特率"></a>比特率</h2><p>比特率(bit rate)又称传信率、信息传输速率(简称信息速率，information rate)。其定义是：<strong>通信线路(或系统)单位时间(每秒)内传输的信息量，即每秒能传输的二进制位</strong>数，通常用 Rb 表示，其单位是比特/秒(bit/s 或 b/s，英文缩略语为 bps)。　　<br>在二进制系统中，信息速率(比特率)与信号速率(波特率)相等，例如，当系统以每秒 50 个二进制符号传输时，信息速率为 50bit/s，信号速率也为 50Bd(波特)。在无调制的情况下，比特率等于波特率；采用调相技术时，比特率不等于波特率。通信系统的发送设备和接收设备必须在相同的波特率下工作，否则会出现帧同步错误。</p><h2 id="波特率"><a href="#波特率" class="headerlink" title="波特率"></a>波特率</h2><p>波特率(Baud rate)又称传码率、码元传输速率(简称码元速率)、信号传输速率(简称信号速率，signaling rate)或调制速率。其定义是：<strong>通信线路(或系统)单位时间(每秒)内传输的码元(脉冲)个数</strong>；或者表示信号调制过程中，单位时间内调制信号波形的变换次数，通常用 RB 表示，单位是波特(Bd 或 Baud，前者规范)。如果每秒传输 1 个码元就称为 1Bd；如果 1 码元的时间长短为 200ms，则每秒可传输 5 个码元，那么码元速率(波特率)就是 5Bd。　　<br>波特率(码元速率)并没有限定是何种进制的码元，所以给出波特率时必须说明这个码元的进制。对于 M 进制码元，比特率(信息速率)Rb 与波特率(码元速率)RB 的关系式为　　<br>Rb=RB·lbM 　　<br>式中：lbM=log2M，表示 M 的以 2 为底的对数。显然，对于二进制码元，由于 lb2=1，所以 Rb=RB，即波特率与比特率在数值上相等，但单位不同，也即二者代表的意义不同。　　<br>例如，波特率为 600Bd，则在二进制时，比特率也为 600bit/s；在四进制时，由于 lb4=2，所以比特率为 1200bit/s。可见，在一个码元中可以传送多个比特。</p><h2 id="数据传输率"><a href="#数据传输率" class="headerlink" title="数据传输率"></a>数据传输率</h2><p>数据传输率(data transfer rate)又称数据传输速率、数据传送率。其定义是：<strong>通信线路(或系统)单位时间(每秒)内传输的字符个数</strong>；或者单位时间(每秒)内传输的码组(字块)数或比特数。其单位是字符/秒；或者码组/秒、比特/秒(可见，当数据传输率用“bit/s”作单位时，即等于比特率)。 <strong>所以它的单位在不同的应用中是不同的。</strong>　<br>　例如，在某计算机异步串行通信系统中，数据传输率为 960 字符/s，每个字符包括 1 个起始位、8 个数据位、1 个停止位，则对应的比特率为 10×960 位/s=9600 位/s=9600bit/s；因为是二进制编码，所以对应的波特率也为 9600Bd。<strong>可见，在我们平时用的串口通信中，波特率是 9600Bd，其实比特率也是 9600bps，因为默认就是 2 进制，波特率和比特率就是 M 进制的差别。</strong></p><h2 id="采样频率-fs"><a href="#采样频率-fs" class="headerlink" title="采样频率 fs"></a>采样频率 fs</h2><p>定义：<strong>每秒从连续信号中提取并组成离散信号的采样个数。</strong><br>采样次数 Ns，每个码元被采样的次数，必须为 2 的幂。<br>fs=fb*Ns<br>其中 fb 为波特率，每秒能传输的二进制位数。</p><blockquote><p>实际中，要处理的为模拟信号，想要在数字系统中处理必须为数字信号，即采用抽样、量化、编码的处理方案。<br>处理的第一步为<strong>抽样</strong>，即模数转换。以电话为例，每秒 3000 次取样，每个取样是 7 比特，那么电话的比特率是 21000。而 CD 是每秒 44100 次取样，两个声道，每个取样是 13 位 PCM 编码，所以 CD 的比特率是 44100_2_13=1146600，这个参数也被称为数据带宽，它和 ADSL 中的带宽是一个概念。将码率除以 8,就可以得到这个它的数据速率，1146600/8=143325，也就是说 CD 每秒的数据量大约是 144KB，而一张 CD 的容量是 74 分等于 4440 秒，就是 639360KB ＝ 640MB。即刚好为一张 cd 的容量。</p></blockquote><h2 id="快速傅里叶变换-FFT"><a href="#快速傅里叶变换-FFT" class="headerlink" title="快速傅里叶变换 FFT"></a>快速傅里叶变换 FFT</h2><p>做 n 个点的 FFT，表示在时域上对原来的信号取了 n 个点来做频谱分析，n 点 FFT 变换的结果仍为 n 个点。<br>换句话说，就是将 2pi 数字频率 w 分成 n 份，而整个数字频率 w 的范围覆盖了从 0-2pi*fs 的模拟频率范围。这里的 fs 是<strong>采样频率</strong>。根据<strong>奈科斯特定律</strong>，只有 f=fs/2 范围内的信号才是被采样到的有效信号。<br>举例说，如果做了 16 个点的 FFT 分析，你原来的模拟信号的最高频率 f=32kHz，采样频率是 64kHz，n 的范围是 0,1,2…15。（注：这意味着已经将原来的模拟信号采样了 8 遍。）这时，64kHz 的模拟频率被分成了 16 分，每一份是 4kHz，这个叫<strong>频率分辨率</strong>（卢注：做 FFT 用的点越多，频率分辨率越高）。那么在横坐标中，n=1 时对应的 f 是 4kHz, n=2 对应的是 8kHz, n=15 时对应的是 60kHz，你的频谱是关于 n=8 对称的。你只需要关心 n=0 到 7 以内的频谱就足够了，因为，原来信号的最高模拟频率是 32kHz。<br><a href="https://blog.csdn.net/weixin_39591031/article/details/110392352">https://blog.csdn.net/weixin_39591031/article/details/110392352</a></p><h2 id="QPSK"><a href="#QPSK" class="headerlink" title="QPSK"></a>QPSK</h2><p>QPSK 又叫<strong>四相绝对相移调制（4PSK）</strong>，QPSK 利用载波的四种不同相位来表征数字信息。它的频带利用率高，是 BPSK(二相相移键控）的 2 倍。当数据码元速率相同时，QPSK 信号的传输波特率为 BPSK 信号的传输波特率的一半，所以 QPSK 的传输带宽是 BPSK 信号的一半。QPSK 调制技术的抗干扰能力强，采用相干检测时其误码性能与 BPSK 相同，故得到广泛应用。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6-1.png#clientId=u6d886849-8a59-4&from=paste&height=86&id=u40231118&margin=%5Bobject%20Object%5D&name=image.png&originHeight=172&originWidth=922&originalType=binary&size=45922&status=done&style=none&taskId=u80ca2014-1869-4d49-b7f8-d1456c86125&width=461" alt="image.png"><br>写成正交形式：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6-2.png#clientId=u6d886849-8a59-4&from=paste&height=149&id=u0c5731d0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=297&originWidth=1117&originalType=binary&size=83630&status=done&style=none&taskId=u3fd5ace3-945e-4eac-bc13-dac014e29e4&width=558.5" alt="image.png"><br>QPSK 调制是利用载波的 4 种不同相位来表征数字信息。每一种载波相位代表两个比特的信息。例如，若输入二进制数字信息，序列为 10011100，…，则应该先将其进行分组，每两个比特编为一组。可将它们分为 10，01，11，00 等，然后分别用四种不同的相位来表示。故每个四进制码元又称为双比特码元。把组成双比特码元的前一个信息比特用 a 表示，后一个信息比特用 b 表示。双比特码元中两个信息比特 ab 与载波相位的矢量关系如图 1 所示。图（a）表示 A 方式时 QPSK 信号矢量图，图（b）表示 B 方式时 QPSK 信号的矢量图。由于正弦和余弦的互补特性，对于载波相位的四种取值，在 A 方式中：0°、90°、180°、270°，则数据通过处理后输岀的成形波形幅度有三种取值；B 方式中：45°、135°、225°、315°，则数据通过处理后输出的成形波形幅度有两种取值。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6-3.png#clientId=u6d886849-8a59-4&from=paste&height=115&id=u633a436c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=230&originWidth=750&originalType=binary&size=26531&status=done&style=none&taskId=u44ca49f7-2450-4bb0-841f-6fa8556732d&width=375" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6-4.png#clientId=u6d886849-8a59-4&from=paste&height=185&id=uce77a3fe&margin=%5Bobject%20Object%5D&name=image.png&originHeight=185&originWidth=446&originalType=binary&size=14966&status=done&style=none&taskId=u3c682ff6-2ff7-415e-b46c-5a165526cd4&width=446" alt="image.png"><br>在本次实验中我们采取 B 方式进行调制。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6-5.png#clientId=u6d886849-8a59-4&from=paste&height=242&id=ucdfabb2a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=284&originWidth=676&originalType=binary&size=17711&status=done&style=none&taskId=u40e11ebc-b2ee-4601-b62f-71e844d08ee&width=576" alt="image.png"><br>原理图如上。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6-6.png#clientId=u6d886849-8a59-4&from=paste&height=185&id=u45ba068d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=370&originWidth=835&originalType=binary&size=66431&status=done&style=none&taskId=u3a4a4871-452c-400d-847a-470c345f1da&width=417.5" alt="image.png"></p><h2 id="QPSK-的功率谱"><a href="#QPSK-的功率谱" class="headerlink" title="QPSK 的功率谱"></a>QPSK 的功率谱</h2><p>由于 QPSK 信号可被理解为由同相支路和正交支路两路 2PSK 叠加而成，但是载波的幅度与码元速率不同，因此 QPSK 信号的功率谱密度相当于 2PSK 信号的功率谱密度的线性叠加：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6-7.png#clientId=u6d886849-8a59-4&from=paste&height=49&id=u60898145&margin=%5Bobject%20Object%5D&name=image.png&originHeight=98&originWidth=663&originalType=binary&size=21889&status=done&style=none&taskId=u7f7c99c7-14ab-4639-a548-05a3d1a2b02&width=331.5" alt="image.png"><br>因此 QPSK 信号的功率谱示意图如下：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6-8.png#clientId=u6d886849-8a59-4&from=paste&height=147&id=u8a6de52d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=294&originWidth=737&originalType=binary&size=35568&status=done&style=none&taskId=u57056394-5a0d-4c56-a71b-f833cbdb882&width=368.5" alt="image.png"><br>由上图可以看出其带宽等于基带码元速率，峰值频率为等于载波频率。</p><h2 id="星座图的基本概念"><a href="#星座图的基本概念" class="headerlink" title="星座图的基本概念"></a>星座图的基本概念</h2><p>在数字通信领域中，经常将数字信号在复平面上表示，以直观的表示信号以及信号之间的关系，这种图示就是星座图。星座图可以看成数字信号的一个“二维眼图”阵列，同时符号在图中所处的位置具有合理的限制或判决边界。如果要将数字信号发送出去，一般不会直接发 0 或 1，而是先将 0,1 信号（bit）按照一个或者几个组成一组，比如每两个 bit 组成一组，即有 00,01,10,11，总共四种状态，此时可以选择 QPSK 调制，QPSK 四个点组成一个 QPSK 的星座图，每个点与相邻的点相差 90 度（幅度是相同的），一个星座点对应一个调制符号。星座图的作用主要是在调制时用于映射，而接收时用于判断发送的到底是哪个点，从而正确解调数据。</p><h1 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h1><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all;clc;</span><br><span class="line"><span class="comment">%% 生成伪随机码</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">orderNum = <span class="number">6</span>;<span class="comment">%m序列为6阶</span></span><br><span class="line"></span><br><span class="line">xulie = idinput((<span class="number">2</span>^orderNum<span class="number">-1</span>),<span class="string">&#x27;prbs&#x27;</span>);<span class="comment">% 生成伪随机序列,长度为63</span></span><br><span class="line"></span><br><span class="line">fb = <span class="number">10</span>; <span class="comment">% 波特率10kHz ,比特率值=波特率值,每秒能传输的二进制位数</span></span><br><span class="line"></span><br><span class="line">Ns = <span class="number">64</span>; <span class="comment">% 采样次数</span></span><br><span class="line"></span><br><span class="line">fs=fb*Ns; <span class="comment">% 采样频率,每秒从连续信号中提取并组成离散信号的采样个数</span></span><br><span class="line"></span><br><span class="line">fc = fb; <span class="comment">%载波频率=比特率</span></span><br><span class="line"></span><br><span class="line">dt=<span class="number">1</span>/fs; <span class="comment">% 采样时间,又称时域采样间隔</span></span><br><span class="line"></span><br><span class="line">Ts = dt;</span><br><span class="line"></span><br><span class="line">N = Ns*<span class="built_in">length</span>(xulie); <span class="comment">% 总采样点个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 生成两路调制信号</span></span><br><span class="line"></span><br><span class="line">I_carrier = <span class="built_in">zeros</span>(<span class="number">1</span>,N);</span><br><span class="line">Q_carrier = <span class="built_in">zeros</span>(<span class="number">1</span>,N);</span><br><span class="line">I = <span class="built_in">zeros</span>(<span class="number">1</span>,N);</span><br><span class="line">Q = <span class="built_in">zeros</span>(<span class="number">1</span>,N);</span><br><span class="line"></span><br><span class="line"><span class="comment">%采用绘图比较I、Q比特流</span></span><br><span class="line">bit_data=<span class="built_in">zeros</span>(<span class="number">1</span>,N);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:len<span class="number">-1</span></span><br><span class="line">    bit_data(Ns*(<span class="built_in">i</span><span class="number">-1</span>)+<span class="number">1</span>:Ns*<span class="built_in">i</span>)=xulie(<span class="built_in">i</span>);<span class="comment">%在一个比特周期里面有Fs个1和采样点一模一样</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%对奇数抽样</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:len/<span class="number">2</span></span><br><span class="line">    I(<span class="number">2</span>*Ns*(<span class="built_in">i</span><span class="number">-1</span>)+<span class="number">1</span>:<span class="number">2</span>*Ns*<span class="built_in">i</span>) = xulie(<span class="number">2</span>*<span class="built_in">i</span><span class="number">-1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%对偶数采样</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:len/<span class="number">2</span><span class="number">-1</span></span><br><span class="line">    Q(<span class="number">2</span>*Ns*(<span class="built_in">i</span><span class="number">-1</span>)+<span class="number">1</span>:<span class="number">2</span>*Ns*<span class="built_in">i</span>) = xulie(<span class="number">2</span>*<span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:N</span><br><span class="line">    I_carrier(<span class="built_in">i</span>) = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fc*(<span class="built_in">i</span><span class="number">-1</span>)/(fs));</span><br><span class="line">    Q_carrier(<span class="built_in">i</span>) = -<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fc*(<span class="built_in">i</span><span class="number">-1</span>)/(fs));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%补充采样（最后一个采样点）</span></span><br><span class="line">I_carrier = [I_carrier,<span class="built_in">ones</span>(<span class="number">1</span>,<span class="number">64</span>)*<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fc*(<span class="built_in">i</span><span class="number">-1</span>)/(fs))];</span><br><span class="line">Q_carrier = [Q_carrier,<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">64</span>)];</span><br><span class="line">Q = [Q,<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">64</span>)];</span><br><span class="line"></span><br><span class="line">T = N*dt*fb; <span class="comment">% 截断时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%绘图</span></span><br><span class="line"><span class="built_in">figure</span>();</span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(bit_data,<span class="string">&#x27;color&#x27;</span>,[<span class="number">55</span>/<span class="number">255</span> <span class="number">108</span>/<span class="number">255</span> <span class="number">176</span>/<span class="number">255</span>]);<span class="built_in">legend</span>(<span class="string">&#x27;Bitstream&#x27;</span>)<span class="comment">%比特信息</span></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(I,<span class="string">&#x27;color&#x27;</span>,[<span class="number">55</span>/<span class="number">255</span> <span class="number">108</span>/<span class="number">255</span> <span class="number">176</span>/<span class="number">255</span>]);<span class="built_in">legend</span>(<span class="string">&#x27;I Bitstream&#x27;</span>)<span class="comment">%I路信息</span></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">plot</span>(Q,<span class="string">&#x27;color&#x27;</span>,[<span class="number">55</span>/<span class="number">255</span> <span class="number">108</span>/<span class="number">255</span> <span class="number">176</span>/<span class="number">255</span>]);<span class="built_in">legend</span>(<span class="string">&#x27;Q Bitstream&#x27;</span>)<span class="comment">%Q路信息</span></span><br><span class="line"><span class="comment">%% 调制</span></span><br><span class="line"></span><br><span class="line">I_data = I.*I_carrier;</span><br><span class="line">Q_data = Q.*Q_carrier;</span><br><span class="line">QPSK_data = (I_data + Q_data)/<span class="built_in">sqrt</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>();<span class="comment">%产生一个新图</span></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(I_data,<span class="string">&#x27;color&#x27;</span>,[<span class="number">55</span>/<span class="number">255</span> <span class="number">108</span>/<span class="number">255</span> <span class="number">176</span>/<span class="number">255</span>]);<span class="built_in">legend</span>(<span class="string">&#x27;I signal&#x27;</span>)<span class="comment">%I路信号</span></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(Q_data,<span class="string">&#x27;color&#x27;</span>,[<span class="number">55</span>/<span class="number">255</span> <span class="number">108</span>/<span class="number">255</span> <span class="number">176</span>/<span class="number">255</span>]);<span class="built_in">legend</span>(<span class="string">&#x27;Q signal&#x27;</span>)<span class="comment">%Q路信号</span></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">plot</span>(QPSK_data,<span class="string">&#x27;color&#x27;</span>,[<span class="number">55</span>/<span class="number">255</span> <span class="number">108</span>/<span class="number">255</span> <span class="number">176</span>/<span class="number">255</span>]);<span class="built_in">legend</span>(<span class="string">&#x27;QPSK signal&#x27;</span>)<span class="comment">%QPSK信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 频谱</span></span><br><span class="line">Bs =fs/<span class="number">2</span>; <span class="comment">% 系统带宽</span></span><br><span class="line">QPSK = <span class="built_in">abs</span>(fftshift(fft(QPSK_data,N)));</span><br><span class="line">ff = <span class="built_in">linspace</span>(-Bs,Bs,N); <span class="comment">% 频域横坐标</span></span><br><span class="line"><span class="built_in">figure</span>()</span><br><span class="line"><span class="built_in">plot</span>(ff,QPSK,<span class="string">&#x27;color&#x27;</span>,[<span class="number">55</span>/<span class="number">255</span> <span class="number">108</span>/<span class="number">255</span> <span class="number">176</span>/<span class="number">255</span>])</span><br><span class="line"><span class="comment">%axis([-50,50,0,60]);</span></span><br><span class="line">title(<span class="string">&#x27;QPSK调制信号频谱图&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;f/kHz&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;频谱&#x27;</span>);</span><br><span class="line"><span class="comment">%% 功率谱密度</span></span><br><span class="line">Bs =fs/<span class="number">2</span>; <span class="comment">% 系统带宽</span></span><br><span class="line">QPSK = <span class="number">10</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(fftshift(fft(QPSK_data,N))).^<span class="number">2</span>/T);</span><br><span class="line">ff = <span class="built_in">linspace</span>(-Bs,Bs,N); <span class="comment">% 频域横坐标</span></span><br><span class="line"><span class="built_in">figure</span>()</span><br><span class="line"><span class="built_in">plot</span>(ff,QPSK,<span class="string">&#x27;color&#x27;</span>,[<span class="number">55</span>/<span class="number">255</span> <span class="number">108</span>/<span class="number">255</span> <span class="number">176</span>/<span class="number">255</span>])</span><br><span class="line">axis([<span class="number">-50</span>,<span class="number">50</span>,<span class="number">0</span>,<span class="number">60</span>]);</span><br><span class="line">title(<span class="string">&#x27;QPSK调制信号功率谱图&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;f/kHz&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;功率谱密度/db&#x27;</span>);</span><br><span class="line"><span class="comment">%% 绘制星座图</span></span><br><span class="line"></span><br><span class="line">signal = <span class="built_in">cat</span>(<span class="number">2</span>, I&#x27;, Q&#x27;);         <span class="comment">% 将两路串行信号码元合并在一个length(xulie)*2的矩阵中</span></span><br><span class="line"></span><br><span class="line">[a1,~]=<span class="built_in">find</span>(signal(:,<span class="number">1</span>)==<span class="number">-1</span>&amp;signal(:,<span class="number">2</span>)==<span class="number">-1</span>);       <span class="comment">% 返回满足条件的矩阵元素对应的坐标</span></span><br><span class="line"></span><br><span class="line">xinzuotu(a1)=<span class="number">-1</span><span class="number">-1</span><span class="built_in">i</span>;</span><br><span class="line"></span><br><span class="line">[a2,~]=<span class="built_in">find</span>(signal(:,<span class="number">1</span>)==<span class="number">-1</span>&amp;signal(:,<span class="number">2</span>)==<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">xinzuotu(a2)=<span class="number">-1</span>+<span class="number">1</span><span class="built_in">i</span>;</span><br><span class="line"></span><br><span class="line">[a3,~]=<span class="built_in">find</span>(signal(:,<span class="number">1</span>)==<span class="number">1</span>&amp;signal(:,<span class="number">2</span>)==<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">xinzuotu(a3)=<span class="number">1</span><span class="number">-1</span><span class="built_in">i</span>;</span><br><span class="line"></span><br><span class="line">[a4,~]=<span class="built_in">find</span>(signal(:,<span class="number">1</span>)==<span class="number">1</span>&amp;signal(:,<span class="number">2</span>)==<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">xinzuotu(a4)=<span class="number">1</span>+<span class="number">1</span><span class="built_in">i</span>;</span><br><span class="line"></span><br><span class="line">scatterplot(xinzuotu)  <span class="comment">% 以散点图的形式画出星座图</span></span><br><span class="line"></span><br><span class="line">axis([<span class="number">-2</span> <span class="number">2</span> <span class="number">-2</span> <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">title(<span class="string">&#x27;理想情况基带发射星座图&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><p>基带时域波形图<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6-9.png#clientId=u6d886849-8a59-4&from=paste&height=185&id=u6306bebc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=200&originWidth=754&originalType=binary&size=34568&status=done&style=none&taskId=ude058ecc-602d-4822-b0c1-20e41b84afa&width=699" alt="image.png"><br>QPSK 调制信号波形图<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6-10.png#clientId=u6d886849-8a59-4&from=paste&height=191&id=u18365c2d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=210&originWidth=746&originalType=binary&size=128005&status=done&style=none&taskId=u5c2a400b-5220-4dcd-ad80-60844de7555&width=679" alt="image.png"><br>QPSK 调制信号功率谱图<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/QPSK%E4%BF%A1%E5%8F%B7%E8%B0%83%E5%88%B6-11.png#clientId=u6d886849-8a59-4&from=paste&height=332&id=uc862d20b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=332&originWidth=441&originalType=binary&size=51742&status=done&style=none&taskId=u90871b21-cec3-43ae-961b-35634aecd9e&width=441" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;b 测题目，由于学长写的代码有些步骤无法理解，而且代码不优雅，故重写之。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>区块链底层-区块与交易</title>
    <link href="https://www.blog.hackerjerry.top/2021/04/24/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%8C%BA%E5%9D%97%E4%B8%8E%E4%BA%A4%E6%98%93_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/04/24/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%8C%BA%E5%9D%97%E4%B8%8E%E4%BA%A4%E6%98%93_new/</id>
    <published>2021-04-24T07:32:07.000Z</published>
    <updated>2021-05-06T13:04:07.985Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="全局结构"><a href="#全局结构" class="headerlink" title="全局结构"></a>全局结构</h1><p>下图是以太坊区块数据结构与关系。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%8C%BA%E5%9D%97%E4%B8%8E%E4%BA%A4%E6%98%93-1.png#clientId=u9ae9216b-af72-4&from=paste&height=402&id=u321a8f97&margin=%5Bobject%20Object%5D&originHeight=644&originWidth=1228&originalType=url&status=done&style=none&taskId=u9f6b4a08-53f6-466b-bd87-bb0cb52dc50&width=766"><br>区块分为两部分：区块头(Header)和区块体(Body)。区块头信息量非常丰富，不但和上一个单元建立联系还记录了一些交易执行情况信息和矿工工作信息。</p><h1 id="定义代码"><a href="#定义代码" class="headerlink" title="定义代码"></a>定义代码</h1><p>下面是以太坊代码中定义的区块头和区块体结构定义代码，所有核心代码均在 core/types/block.go 文件中：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/types/block.go:70</span></span><br><span class="line"><span class="keyword">type</span> Header <span class="keyword">struct</span> &#123;</span><br><span class="line">   ParentHash  common.Hash    <span class="string">`json:&quot;parentHash&quot;       gencodec:&quot;required&quot;`</span></span><br><span class="line">   UncleHash   common.Hash    <span class="string">`json:&quot;sha3Uncles&quot;       gencodec:&quot;required&quot;`</span></span><br><span class="line">   Coinbase    common.Address <span class="string">`json:&quot;miner&quot;            gencodec:&quot;required&quot;`</span></span><br><span class="line">   Root        common.Hash    <span class="string">`json:&quot;stateRoot&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line">   TxHash      common.Hash    <span class="string">`json:&quot;transactionsRoot&quot; gencodec:&quot;required&quot;`</span></span><br><span class="line">   ReceiptHash common.Hash    <span class="string">`json:&quot;receiptsRoot&quot;     gencodec:&quot;required&quot;`</span></span><br><span class="line">   Bloom       Bloom          <span class="string">`json:&quot;logsBloom&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line">   Difficulty  *big.Int       <span class="string">`json:&quot;difficulty&quot;       gencodec:&quot;required&quot;`</span></span><br><span class="line">   Number      *big.Int       <span class="string">`json:&quot;number&quot;           gencodec:&quot;required&quot;`</span></span><br><span class="line">   GasLimit    <span class="keyword">uint64</span>         <span class="string">`json:&quot;gasLimit&quot;         gencodec:&quot;required&quot;`</span></span><br><span class="line">   GasUsed     <span class="keyword">uint64</span>         <span class="string">`json:&quot;gasUsed&quot;          gencodec:&quot;required&quot;`</span></span><br><span class="line">   Time        <span class="keyword">uint64</span>         <span class="string">`json:&quot;timestamp&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line">   Extra       []<span class="keyword">byte</span>         <span class="string">`json:&quot;extraData&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line">   MixDigest   common.Hash    <span class="string">`json:&quot;mixHash&quot;`</span></span><br><span class="line">   Nonce       BlockNonce     <span class="string">`json:&quot;nonce&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Body <span class="keyword">struct</span> &#123;</span><br><span class="line">Transactions []*Transaction</span><br><span class="line">Uncles       []*Header</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><h3 id="parentHash"><a href="#parentHash" class="headerlink" title="parentHash"></a>parentHash</h3><p>是一个哈希值，记录此区块直接引用的父区块哈希值。通过此记录，才能完整的将区块有序组织，形成一条区块链。并且可以防止父区块内容被修改，因为数据修改，区块哈希必然发生变化，因此一个区块直接或间接的强化了所有父辈区块，通过加密算法保证历史区块不可能被修改。</p><h3 id="miner"><a href="#miner" class="headerlink" title="miner"></a>miner</h3><p>是一个地址，表示区块是此账户的矿工挖出，挖矿奖励将下发到此账户。</p><h3 id="transactionsRoot"><a href="#transactionsRoot" class="headerlink" title="transactionsRoot"></a>transactionsRoot</h3><p>是一个哈希值，表示该区块中所有交易生成一颗默克尔树根节点哈希值。是一个密码学保证交易集合摘要。通过此 Root 可以直接校验某交易是否包含在此区块中。</p><h3 id="mixHash"><a href="#mixHash" class="headerlink" title="mixHash"></a>mixHash</h3><p>是一个哈希值。用于校验区块是否正确挖出。实际上是区块头数据不包含 nonce 时的一个哈希值。</p><h1 id="区块体"><a href="#区块体" class="headerlink" title="区块体"></a>区块体</h1><p>区块体 Body 中只有两项数据：<a href="https://learnblockchain.cn/books/geth/part1/transaction.html">交易</a>集合和叔辈区块头集合。是交易促使以太坊世界态进行转变。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%8C%BA%E5%9D%97%E4%B8%8E%E4%BA%A4%E6%98%93-2.png#clientId=u9ae9216b-af72-4&from=paste&height=203&id=u42b0fbbe&margin=%5Bobject%20Object%5D&originHeight=283&originWidth=969&originalType=url&status=done&style=none&taskId=u56a01b4b-366c-4bd6-976c-05606cea4e0&width=693.5"><br>从创世状态开始，每一个区块中的交易执行促使了以太坊世界态的转变。下一个状态是在上一个状态中执行交易或其他操作使得状态由 A 状态转变为 B 状态。<br>而交易则为状态转变的催化酶，<strong>一个区块中的所有交易执行完成后，将使得以太坊进入一个新的状态。</strong>状态转变过程中记录了一些起始变量和结果数据，分别是交易默克尔哈希值<strong>transactionsRoot</strong>、交易回执默克尔哈希值** receiptRoot<strong>、事件布隆值</strong>logsBloom<strong>、新状态的默克尔哈希值</strong>stateRoot**。</p><h1 id="交易回执"><a href="#交易回执" class="headerlink" title="交易回执"></a>交易回执</h1><p>在以太坊中一份交易回执记录了关于此笔交易的处理结果信息：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%8C%BA%E5%9D%97%E4%B8%8E%E4%BA%A4%E6%98%93-3.png#clientId=u9ae9216b-af72-4&from=paste&height=380&id=u3f9ff1a7&margin=%5Bobject%20Object%5D&originHeight=760&originWidth=652&originalType=url&status=done&style=none&taskId=u8eec5c7d-8f2e-41d5-9917-91e25564eb4&width=326"><br>回执信息分为三部分：共识信息、交易信息、区块信息。下面分别介绍各类信息。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%8C%BA%E5%9D%97%E4%B8%8E%E4%BA%A4%E6%98%93-4.png#clientId=u9ae9216b-af72-4&from=paste&height=359&id=u9d6c0d41&margin=%5Bobject%20Object%5D&originHeight=718&originWidth=642&originalType=url&status=done&style=none&taskId=u780e7386-1eaa-45c3-a6fc-2cdef063091&width=321"></p><h2 id="交易回执共识信息"><a href="#交易回执共识信息" class="headerlink" title="交易回执共识信息"></a>交易回执共识信息</h2><p>共识意味在在校验区块合法性时，这部分信息也参与校验。这些信息参与校验的原因是确保交易必须在区块中的固定顺序中执行，且记录了交易执行后的状态信息。这样可强化交易顺序。</p><ul><li>Status： 成功与否，1 表示成功，0 表示失败。</li><li>CumulativeGasUsed： 区块中已执行的交易累计消耗的 Gas，包含当前交易。</li><li>Logs: 当前交易执行所产生的智能合约事件列表。</li><li>Bloom：是从 Logs 中提取的事件布隆过滤器，用于快速检测某主题的事件是否存在于 Logs 中。</li></ul><p><strong>如何参与共识校验呢</strong>？<br>实际上<strong>参与校验</strong>的<strong>仅仅是回执哈希</strong>，而<strong>回执哈希</strong>计算<strong>只包含这些信息</strong>。<br>首先，在校验时获取整个区块回执信息的默克尔树的根哈希值。再判断此哈希值是否同区块头定义内容相同。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/block_validator.go:92</span></span><br><span class="line">receiptSha := types.DeriveSha(receipts)</span><br><span class="line"><span class="keyword">if</span> receiptSha != header.ReceiptHash &#123;</span><br><span class="line">   <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid receipt root hash (remote: %x local: %x)&quot;</span>,</span><br><span class="line">   header.ReceiptHash, receiptSha)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而函数 types.DeriveSha 中<strong>生成根哈希值</strong>，是将列表元素（这里是<strong>交易回执</strong>）的<strong>RLP 编码信息</strong>构成<strong>默克树</strong>，最终获得列表的哈希值。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/types/derive_sha.go:32</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeriveSha</span><span class="params">(list DerivableList)</span> <span class="title">common</span>.<span class="title">Hash</span></span> &#123;</span><br><span class="line">   keybuf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">   trie := <span class="built_in">new</span>(trie.Trie)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; list.Len(); i++ &#123;</span><br><span class="line">      keybuf.Reset()</span><br><span class="line">      rlp.Encode(keybuf, <span class="keyword">uint</span>(i))</span><br><span class="line">      trie.Update(keybuf.Bytes(), list.GetRlp(i))</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> trie.Hash()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// core/types/receipt.go:237</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Receipts)</span> <span class="title">GetRlp</span><span class="params">(i <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">   bytes, err := rlp.EncodeToBytes(r[i])</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> bytes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往下看，交易回执实现了 RLP 编码接口。在方法 EncodeRLP 中是构建了一个私有的 receiptRLP。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/types/receipt.go:119</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Receipt)</span> <span class="title">EncodeRLP</span><span class="params">(w io.Writer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> rlp.Encode(w,</span><br><span class="line">&amp;receiptRLP&#123;r.statusEncoding(), r.CumulativeGasUsed, r.Bloom, r.Logs&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出 receiptRLP 仅仅包含上面提到的参与共识校验的内容。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/types/receipt.go:78</span></span><br><span class="line"><span class="keyword">type</span> receiptRLP <span class="keyword">struct</span> &#123;</span><br><span class="line">   PostStateOrStatus []<span class="keyword">byte</span></span><br><span class="line">   CumulativeGasUsed <span class="keyword">uint64</span></span><br><span class="line">   Bloom             Bloom</span><br><span class="line">   Logs              []*Log</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="交易回执交易信息"><a href="#交易回执交易信息" class="headerlink" title="交易回执交易信息"></a>交易回执交易信息</h2><p>这部分信息记录的是关于回执所对应的交易信息，有：</p><ul><li>TxHash ： 交易回执所对应的交易哈希。</li><li>ContractAddress： 当这笔交易是部署新合约时，记录新合约的地址。</li><li>GasUsed: 这笔交易执行所消耗的<a href="https://learnblockchain.cn/books/geth/part1/gas.html">Gas 燃料</a>。</li></ul><p>这些信息不参与共识的原因是这三项信息已经在其他地方校验。</p><ul><li>TxHash: 区块有校验交易集的正确性。</li><li>ContractAddress： 如果是新合约，实际上已经提交到以太坊状态 State 中。</li><li>GasUsed： 已属于 CumulativeGasUsed 的一部分。</li></ul><h2 id="交易回执区块信息"><a href="#交易回执区块信息" class="headerlink" title="交易回执区块信息"></a>交易回执区块信息</h2><p>这部分信息完全是<strong>为了方便外部读取交易回执</strong>，不但知道交易执行情况，<strong>还能方便的指定该交易属于哪个区块中第几笔交易</strong>。</p><ul><li>BlockHash: <strong>交易所在区块哈希</strong>。</li><li>BlockNumber: <strong>交易所在区块高度</strong>。</li><li>TransactionIndex：<strong>交易在区块中的序号</strong>。</li></ul><p>这三项信息，主要是<strong>在数据库 Leveldb 中读取交易回执</strong>时，<strong>实时指定</strong>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/rawdb/accessors_chain.go:315</span></span><br><span class="line">receipts := <span class="built_in">make</span>(types.Receipts, <span class="built_in">len</span>(storageReceipts))</span><br><span class="line">logIndex := <span class="keyword">uint</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i, receipt := <span class="keyword">range</span> storageReceipts &#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   receipts[i] = (*types.Receipt)(receipt)</span><br><span class="line">   receipts[i].BlockHash = hash</span><br><span class="line">   receipts[i].BlockNumber = big.NewInt(<span class="number">0</span>).SetUint64(number)</span><br><span class="line">   receipts[i].TransactionIndex = <span class="keyword">uint</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="交易回执存储"><a href="#交易回执存储" class="headerlink" title="交易回执存储"></a>交易回执存储</h2><p><strong>交易回执</strong>作为<strong>交易执行中间产物</strong>，为了方便快速获取某笔交易的执行明细。以太坊中有跟随区块存储时实时存储交易回执。但为了降低存储量，只存储了必要内容。<br>首先，在<strong>存储</strong>时，将交易回执对象转换为<strong>精简内容</strong>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/rawdb/accessors_chain.go:338</span></span><br><span class="line">storageReceipts := <span class="built_in">make</span>([]*types.ReceiptForStorage, <span class="built_in">len</span>(receipts))</span><br><span class="line"><span class="keyword">for</span> i, receipt := <span class="keyword">range</span> receipts &#123;</span><br><span class="line">   storageReceipts[i] = (*types.ReceiptForStorage)(receipt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>精简内容是专门为存储定义的一个结构 ReceiptForStorage。存储时将交易回执集进行 RLP 编码存储。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/rawdb/accessors_chain.go:342</span></span><br><span class="line">bytes, err := rlp.EncodeToBytes(storageReceipts)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   log.Crit(<span class="string">&quot;Failed to encode block receipts&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := db.Put(blockReceiptsKey(number, hash), bytes); err != <span class="literal">nil</span> &#123;</span><br><span class="line">   log.Crit(<span class="string">&quot;Failed to store block receipts&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以看存储了哪些内容，只需要看 ReceiptForStorage 的 EncodeRLP 方法：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/types/receipt.go:179</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ReceiptForStorage)</span> <span class="title">EncodeRLP</span><span class="params">(w io.Writer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   enc := &amp;receiptStorageRLP&#123;</span><br><span class="line">      PostStateOrStatus: (*Receipt)(r).statusEncoding(),</span><br><span class="line">      CumulativeGasUsed: r.CumulativeGasUsed,</span><br><span class="line">      TxHash:            r.TxHash,</span><br><span class="line">      ContractAddress:   r.ContractAddress,</span><br><span class="line">      Logs:              <span class="built_in">make</span>([]*LogForStorage, <span class="built_in">len</span>(r.Logs)),</span><br><span class="line">      GasUsed:           r.GasUsed,</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> i, log := <span class="keyword">range</span> r.Logs &#123;</span><br><span class="line">      enc.Logs[i] = (*LogForStorage)(log)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> rlp.Encode(w, enc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%8C%BA%E5%9D%97%E4%B8%8E%E4%BA%A4%E6%98%93-5.png#clientId=u9ae9216b-af72-4&from=paste&height=482&id=u14eddb16&margin=%5Bobject%20Object%5D&originHeight=746&originWidth=854&originalType=url&status=done&style=none&taskId=ubb7522ff-0229-47a2-8673-79e407e628c&width=552"></p><h1 id="交易回执示例–文档参考"><a href="#交易回执示例–文档参考" class="headerlink" title="交易回执示例–文档参考"></a>交易回执示例–文档参考</h1><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%8C%BA%E5%9D%97%E4%B8%8E%E4%BA%A4%E6%98%93-6.png#clientId=u9ae9216b-af72-4&from=paste&height=737&id=u301c1b6f&margin=%5Bobject%20Object%5D&originHeight=1474&originWidth=1664&originalType=url&status=done&style=none&taskId=u1730403f-a93e-4126-920d-39990df7fdc&width=832"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;全局结构&quot;&gt;&lt;a href=&quot;#全局结构&quot; class=&quot;headerlink&quot; title=&quot;全局结构&quot;&gt;&lt;/a&gt;全局结构&lt;/h1&gt;&lt;p&gt;下图是以太坊区块数据结构与关系。&lt;br&gt;&lt;img src= &quot;/img/loading</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>流量在线识别系统demo</title>
    <link href="https://www.blog.hackerjerry.top/2021/04/20/%E6%B5%81%E9%87%8F%E5%9C%A8%E7%BA%BF%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9Fdemo_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/04/20/%E6%B5%81%E9%87%8F%E5%9C%A8%E7%BA%BF%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9Fdemo_new/</id>
    <published>2021-04-20T07:13:42.000Z</published>
    <updated>2021-05-06T13:00:22.142Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="9422fa806c25e7d58e0067bc1326e0a24a90816ece815c0b65b082a6e9b66385">7a27311b6b2cd1a21889c25f42783ffe4f9a32211aa3e3e4c19ef8ed59d1827283d5421fe472fe4b7f35f73b07945e464e34189aba4887343b0bbc49264ef710bf94373d34a783aa80f376a37cfaa4489a2ecb2c6343f4a296a02b275c45f13a5a28b93b0d2564f039bfcbfadf0bde518ab29fdaafa9e2cb94d6fdbe5e4cec62e4b72dd6f26966c8a288702c70679166cb169247e2b6bf99792238dd4a3619c5e788d529ad5e58bab285c0a32a4605bd2f43671f2a643f2dd5d994e20922cf09226ea850583b561b67fe9c59adbf0c8fd31a25a4fa6772a3149ad5044188540278e013247bd03ce1d6e8963977b91362fcef63d430eab09a0e70f6cba1284d84368e1647a00d3f1be3d665c80bb77f6ac5d6f6e719fc32bd29bca39ef84be2dc6c13f87a3699d457fdd6d16c03fc668132ade68839495f15b14273562aa8afd86c16696acfac72cf07796ef10dcf96686bbde3cd020b066d51e6c68ba6f1b1689ffd19d00484aa2b56fbe14394eb62927b987f355d8c2dbac2c184075ec77f61215df23a8ecfe06b239f8e955db3e3fc74fdea0aab51802ab4e9dbfe39dbc56c998f467fec59437af891bffe049d70379ffdb199a36689463b69a015bafff1df1af6b4e17202783fb70036a2d727dc0ea84c46d228f130a0488b5f3206cf4d71200716337a90d2831529617992f5cfb513dd5ec4dbb273001df911b1b65edbbe1fbdc0fb53950136a386efc3cf78866180740daf2be9c56b7102d480ee8662c596fc4bf8ffe806f96963bfdf74a79f1464648256744e3570e654b1530e9598908219055e6bbf0c36ec0bad029a777d7c7b1094f2f4cc7cd94033ffbec4915620c0e44fb6798300968c34c6decf3763c3afe65521b7d47999599621dc652f1467760b94308c5d457033344fa899674d60aa120099d5fc9a59bab1b1ec425e72356847b56583677c477b7366d3d56338e0396ff80f813f2278b4a8530d5172d13270591643199fbaf56dbcc5e2090de52d7466ad78271e330a8a075077dc30861ba3ed955dfb7faf4fe8196675b16a360fbf7664882638d1ee3eeb93cff517a20935ff238ea4a76f6c8e3ecdd00f4d041e4ba3f09e78b7df2872f2d137de061a0a599f3331469df053652de08f88c7372fb90073d4957a4b5af852ec3d9f615f42307df6bad8f9d1b1772012b36a248ea2ef646c0cca0e4270a7f6d6149d7a5c856c44042d7fa45377d10eaa9e82f2d9c2b02aff994a2707dc98a5580d4d106b3215181529734dddff3852d0eff9a9dd2b263ddf96d5eb6ec9784dbfebd09970fb164b9de9567a9438e0238044561fe6bcdc14ba0abd1e4f719555fdcdeaf3bf7ab0a03b5cdb9cde88d180dfa015803b7d89c0f5b84911ec2c34b2669fa12cf96de7396b84c1f3aedfd07f1e4d690ad540844348c8bd4efeaa67aedb7a4f44f50faf329f5bd152d9d911263f8fe71f18790c20e373d456345c31c517710ac61a02684d5a87fa45dfe0c0e9f2f333ecaee3ef668ee0a461d56894b0369fb20e3c259218a51deec0fec09f0eebae31b3fb86a35d1e23f9c5679788ed26613cd52f8d11dec1cadf604c867e697ec4bbf79ce459e1c9682487246ef5d154cc30e2e22d1d7a0ef400d60f664ffc77b789c451c2674e885c22d80180f926949ab8641e508861a0c1af4a80c790f99cbedb723289471b21e6cdd2211901b9abe26c04d2e07754ec4f3bf0533c76439c68b414bc1787f133fd8a41edf7727eda12879715446c406060fad90dcd11750c7523016c37f0bddd201bf704ea053f645ea00179503dba899b78dc79707f5e5e8be86d66b5c81f5cb51ed1a8762ca275c8885b73616349a710672425a5e0e50bbdd52d460330bd3fbff82fcbf350986a0c26678c7c97210e2ac84ca8648114d4a12ad157ec0ef21640f00c03151e4f256da814e932eea85fd98d2310a12b6731348de1fd1b0c4e79e97caf40deadb46ead8fcf2aed1ff661ce8e9d86051785e007331052e5376d67ca126881e1a369fb4cb5b32b4f1c8b320765966c8491a0d4a811d3982489aa378600136d91ee880622fa935abb7157b73f02f501a8198232bb938163601fb278e14acb7f5495ee266b90d13c70d904e51299e49de42bfa5438a77eaadd22d1fbce0c9ca4c90cac031714b9c7c12851e3247b8764a3a7aa1f5dd9e4595c8c1af2be9f24f80a59ed7ee089fc45225025fe7b12d657d58b96729a53180de7a6ae5f43c609b2a9fbf9d0e2e8d9b4f5e70aa9a7a628693d8c13e3676d984bbc05969d7a6e1116d0073727226b689fecbbf41d01c749d1dcba746fc29ac87dc48d0e83af30881d3742783fa46fc822042241461c069b26d582d597d87d7adfa480c0c1cd7035dcb641ab267fc995bf604fcb5b1b35344909f8be3904d69daebefc15ea18edfc27e441d729b38c24f79955d17d69195f4185dece33a64f6a95edd65e32a4efa721a9355378c5aa6f30e8200620ff1095acd000b4030e151a7b4e6e5f18524c28d618167b1b63a3ec0a8ace41156dc1194a0a95b4210f98451290f891fba0dcf8e9bfaa6d7dc80bbab0d608f81c38d4d21d9c4e55efe4fac2525602fde7832196ceab1b8c7d2ffd6de723190192430278e5f2187946dc94715540df5cfb01161ef55acf2628466bc051a424cf4c6a52404468a90c6a2998defa0a0bf708c8cfb7ab7a182f4d7714054d9234941db204e13cfa3490531e8ffe27d1461330999f0afbc57f2e6729c86f0f9117f838385c28e6914d261fc561c54057d8c111476f0bdd0487e4977b838110e287727f7b3d725c7d4fac0b5af5d01e8c2a86d61e2c22b145d156fe28e667e517cb4fd1dc9fc6ee601cf4f6a5e5fed7e88a2dfb52ec9d40004307866df2399e95db0332e12cbd37cbec98b8d242dfd2551c220fcb7cd5a187e56d8e7957290275456557d987cab1a0b80f33180f0064b776e2de65f51d9bd73bfdbfe6597c2593063d11af73b1c4d7ef7e5c69631358af42e5ac93b53c71da9caf14dd29d99e095ab5b87572a93c8c5556357507ca5f158bb94782f3166213e0c8e0bb42ccae1eefc69f75c5f9c4d775bc31ca7f419e74ef9e43243d8480ce934d83b9d80cc392a694b9239d978895472328407629a34d39000365796d2c8eecf86b67aeb14cfcd148e5235de8479200ff94f1724c411351cde7067319b8f3a6531b00f02968e4df856d89c13d3954adcf1a4b72074ea86bc2c644b6a2bb80ba8b961959b1e2c85d6e166d4bb096b995abe0f46c3cf367a6c1857fc030cfbf25dc6e2115f42a6fa3bf70fb605f28f37cbe4bcb23800ab6852f7a69ce1a16d94f2e85c6b57671488f0314726b3bd2c1e663fe11d6f675fcbcfb291cd299851a7e832df89ca42cd7b782ba93ccc78583850f2f644c1bc76d39e3e85aea821314c15dad2e40704011bcde9d529a557a6900dd0bb65eb88ec7f12af96696d0b61f7830fd15d40f1073eb41b30487c5ffa638489b29e43896475808139386ab18bc734a82b06e9b593347faa05ace68645a6c0f23c51ca0c65504a396c83a1a6f9c322472908c44f15bbc791654b0799c481c550a52e2f4ab067f2daa223d6bccab0ff8406de2207755b7fb20adf94bcb91cd4e65cc85d1df05afb80c44ceb094b72cc7998811f9216c90b945df7dc5a20091e602af1f5dfd66c10b823ffa1b479fd5a1caa2fe764adffda4719e8aa11ad7fe07224ea2eb4b984b5e68e968c96baeeed74ca40e58dd7b88af95921208b603cdabb9a401b7cb197a52d93a9fa690e2ba5e0c414cbcd6af99ee9cd214e7f9a051ba76fa6fb0e17297d249307c05411549bf8d83a7cd64c65c675b5857ec9453264ebd804c412059d6876f0ba6bed704ece6efa4b15da6a8d785d75c63580d474f9ca462ed167972127430a73154b68a777ebeb7e4a92ceadcd0bdc59479d5e2afb8309f0ed1faf36b77d3fd18206b23641337acb66d66ea9c459e5a4b3907d4d39662545839926c277db973a25d7cea9dc2738517c2db08727112061fd7c3090ab8a0e6e6af80abdcf635ff72a219cafd068c47a5248a5f62f878205b80a58d64eaa225533eafc49cad194c455c8a46f4475a6a9578cbf819f75d3b245ffff226349065d0d9a1848148bcb781b08f90122da8d9b6742ab1e3b74d7c6c6f275303db06233a63da1ba02577ef100fb374895ed88ec9b63f62b1c063563fb101ee4bd98776d3855c105a130c95386c8df277c66a7d0b7b9ee5e41d67016eb199b43bbf16a0de9d51abe22a8d19c7bef70a56704de22de6d0984d1cba8352bb9886e17ce716591c5906a9a63dca3b0e7bcde01de167f69ac66b68ce9d235abfc75d90c2f8e560e9ff41828d32d8607249f90ef5a9f2e0dbaa73a1326d72e1eeba39540c9c77a093b76165e118956ace6510771d02a5b8a5395d39f8b2abf1549a0dce1428c9f914f2f82184790f114daf1b85fe97c71443eb2006dd759c0da7d2925921d7757ea5d81311b83a2ffa057e276e5dfc61aff01405de03ad025ef25dd7f581d002739639aa2ca0b50538bbe33f5897f0fcce8575a72a04a7e775c620aa63eacefd9866fc4bb04ca62ec79f8e986826a5e34b801976cb5d3c4b7111b1c34674b1000a8a032eacba3649053b6c95530f1951796c54acaff28eb76cc1eda68133c377b591d741df6e2a6d79209d7c2bbbc830c8c953ffc8fb848163a7b1f43016cf4244688e62355eec880e1f4b73aa20a37110ddfccb7006c407f9b4930e623fad19b6ce965839f9d72fef106fd62f48dcd499e73d77a5cf037c752c537efa22086a0640b513776d5fb5ddebf8b8e1d616fa7c62ca1b00cb9424e621aa69398acdaf4e0c278079ba12bf18f35b69f419495b893542f897f292e47b4607995a087c4d506f2a931ec4d9a40f4fdd4a49b8e54ac54f9f1a5a777940fbd39ff4197e6abd2b65de4d7817049a65ff238436ae9f6a66c9302b33890e39ccb71dcd340b63bb682b0b72c9ecac843981c8941df1c62cebbb7d188312c6ab547717e74b76da16d266e2bcdb97070ae2ea596f8bb02c5afaf4d7ab8d4a8598e451e03cd89f371d06c1e996a516dc5f78e98016b802f836ed401b17a4bc622719b6ac79347b3b15e69dab2c5ad88b03cc3bb75f07921cdeba5cb961580d4f0e9789ca8a6feac5cd0189521380e4fa064dd9efee24a8ec08cf52ee304292208a5c73b17a7d6bd8c878831a8c2ff3b624d0e3d68238714835fbdf4a4547727e1cf1cb09ec1b044d5df531f030a5d62abc36c44ada5d9bad0a44ae558497eae8d57a4cd91b1595e88c1d26b9f8e526b24e782686a0b151708d7350df950980721b25bef892cd02fa2c8cbf13f6cc68dc74c8c9381c474f961e4c03e9218c7430ab9e63615b9d353e3886bdf5734aef0ce588740e7bcc9182fbec4b2031e17c488c9f8c896227f5d38ad6f6409b43c9eb09a568111eed2d78c28c853270a7466bbee19e4b26328f2eec728f5dbd821fdcbc9852845b9b24b912e4e417c574cd93dc487e9f3d3f43ec22b957ca3d6c58b0899dcb9a9da85ba89e8a572100562e8be03fbe30a79b1332b0bcbcf580846e5763dc59a51abfeaad21a5a90d2eec329c8e31b9806b32dd4157222cf963d8fa688830d2b90786492bf10cc97704405da0bd419897de80cda077166789e249017c0b1e4100889e02c5a48b9ffa9e9d52eeb2bde8c5035311b80f6860d3e911b1cbabd161c96af6c27e3fc4c59defbbd0c8ef26a1b022efbe04e0254db380aa7eded9277d0da974b50344bfa371852a66c13318213a0b24ca55f3cdd3fb6f2add424dc2d59ce360c80b490f03394df96ffb1b7aa530acc1feb53a72325e41a4e96b30632fc1724c0d0e8b9d24e31de921897c2bbf4ec1f31a873eac8cbc47d1374a86c90c8d53be917c9a7ac46c675a1d42b8c32e2fa17e0dba644bc2e7c5e22f23afbbcb04c05ec0ed269cc26a3ddbe846209ba09e6440301f0616bfaa61dad9be0efb538ad2d6c18f476cc447b922421fed0a62ac98a5c1b3350e50b4f42f4bb8685e3b78e0da7ec61529117b01b4a4444fd7e271a6c6c46e386ab1e4f16e7d0f29df767fb8428603c23e13f9d964fb5676ddd299f94303a49781562733c5aa7b00a0a28736e90313c45eb8581a8b80d1aad3347146398efe818dd41096256bc2b0a335e40737c51a1446108b42f7b59a6249098a12d009df5ee8238b6ff11bab46f949e4ab2740a3477a072ca6</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Life-Weekly-April-19-to-25</title>
    <link href="https://www.blog.hackerjerry.top/2021/04/20/Life-Weekly-April-19-to-25_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/04/20/Life-Weekly-April-19-to-25_new/</id>
    <published>2021-04-20T06:52:36.000Z</published>
    <updated>2021-05-06T13:02:05.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时讯"><a href="#时讯" class="headerlink" title="时讯"></a>时讯</h1><ol><li>特斯拉最近一直出事故，脚刹系统很有问题，怀疑是软件 bug，官方售后居然在发生事故后会清除事故数据和行车记录视频，这是一个负责任的大公司能干出的事吗？</li><li>特斯拉疑似提供事故数据，数据不规范，传感器数量明显不对，搁这儿欺骗消费者呢？</li><li>中国派巴基斯坦大使下榻酒店遭恐怖袭击，中方人员外出会谈，无人员受伤。</li></ol><h1 id="小事"><a href="#小事" class="headerlink" title="小事"></a>小事</h1><ol><li>周一：下雨，被学长鸽了，让我自己写在线系统，麻了。拖了一个月到比赛截至的时候说自己没写。行吧，我自己写。</li><li>周二：下雨，加油！</li><li>周三：校运会==放假，写完了！</li><li>周四：买了一把胜利 CHA-9500 球拍和尤尼克斯的手胶，开始准备认真打羽毛球了！</li><li>周五：通过考核，成为预备党员！美赛又是 M 奖，淦，再也不玩了！学校咋都 2O 19F，卷疯了。</li></ol><h1 id="本周收藏"><a href="#本周收藏" class="headerlink" title="本周收藏"></a>本周收藏</h1><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><ol><li>算法好文</li><li>羽毛球训练好文</li></ol><h2 id="剧集"><a href="#剧集" class="headerlink" title="剧集"></a>剧集</h2><ol><li>伍六七终于到主线了！！！！何导啊何导，有青山老贼那味了，希望别一部国漫画 10 年就行，追起来太费劲了。</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Life-Weekly-April-19-to-25-1.jpeg#clientId=u67cebdca-6850-4&from=drop&id=ufaa1c361&margin=%5Bobject%20Object%5D&name=IMG_20210421_225640.jpg&originHeight=1067&originWidth=1940&originalType=binary&size=344924&status=done&style=none&taskId=u7e240ddf-325a-4031-8b88-95b8b3a8a4f" alt="IMG_20210421_225640.jpg"><br><strong>只攻不守的剑，也能用来保护人</strong>。</p><h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><ol><li>关于恋爱观。</li></ol><p>「<strong>交往</strong>」这件事，不只是为了休息日能一起去哪玩，那只是附带的东西罢了。[<strong>互相支撑着对方的生活</strong>」才是交往的本质。<br>能互相给予对方“<strong>在看不见的地方让自己的生活变得丰富</strong>”这样的力量，这才是“交往”。就算不能时时刻刻在一起，但却能带给自己仿佛在一起时一般的存在感的人，这才是“恋人”。<br>真正的谈恋爱是两个人相处比我独处更有趣、更有意义，真正的谈恋爱是两个人为了未来而考虑、努力，真正的恋爱是我愿意支持你的想法，你愿意鼓励我主动追梦，真正的恋爱是时间沉淀感情后、冷静思考后的坚定选择。无关激素，无关冲动，不是想谈恋爱而找个人谈恋爱，而是我们经历了很多事情后，我们了解彼此后，选择了彼此。</p><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><ol><li>软件安全的 ret2libc 要自学一下了！</li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li>做人做事</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Life-Weekly-April-19-to-25-2.png#clientId=u67cebdca-6850-4&from=paste&height=1443&id=u062f504b&margin=%5Bobject%20Object%5D&originHeight=2885&originWidth=720&originalType=url&status=done&style=none&taskId=uc553a112-4017-49b5-b30d-b410852a388&width=360"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;时讯&quot;&gt;&lt;a href=&quot;#时讯&quot; class=&quot;headerlink&quot; title=&quot;时讯&quot;&gt;&lt;/a&gt;时讯&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;特斯拉最近一直出事故，脚刹系统很有问题，怀疑是软件 bug，官方售后居然在发生事故后会清除事故数据和行车记录视频，这是一个负责任</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>区块链底层-账户模型</title>
    <link href="https://www.blog.hackerjerry.top/2021/04/17/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E8%B4%A6%E6%88%B7%E6%A8%A1%E5%9E%8B_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/04/17/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E8%B4%A6%E6%88%B7%E6%A8%A1%E5%9E%8B_new/</id>
    <published>2021-04-17T14:32:44.000Z</published>
    <updated>2021-05-06T13:02:09.518Z</updated>
    
    <content type="html"><![CDATA[<p>我们采用和以太坊相似的账户模型。</p><a id="more"></a><h1 id="账户数据结构"><a href="#账户数据结构" class="headerlink" title="账户数据结构"></a>账户数据结构</h1><p>以太坊数据以账户为单位组织，账户数据的变更引起账户状态变化, 从而引起以太坊状态变化。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// core/state/state_object.go:100</span></span><br><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span> &#123;</span><br><span class="line">    Nonce    <span class="keyword">uint64</span></span><br><span class="line">    Balance  *big.Int</span><br><span class="line">    Root     common.Hash</span><br><span class="line">    CodeHash []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在密码学领域，Nonce 代表一个只使用一次的数字。它往往是一个随机或伪随机数，以避免重复。 以太坊账户中加入 Nonce，可避免重放攻击（不过不是随机产生）。账户 Nonce 起始值是 0，后续每触发一次账户执行则 Nonce 值计加一次。 其中一处的计数逻辑如下：</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// core/state_transition.go:212</span></span><br><span class="line">st.state.SetNonce(msg.From(), st.state.GetNonce(sender.Address())+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><ul><li>Balance 则记录该账户所拥有的以太（ETH）数量，称为账户余额.</li></ul><p>当然必须保证转账方余额充足，在转移前需要 CanTransfer 检查， 如果余额充足，则执行 Transfer 转移 Value 数量的以太。</p><ul><li>账户状态哈希值 StateRoot，是一颗默克尔压缩前缀树（Merkle Patricia Tree）的根值。可以直接利用 StateRoot 从 Leveldb 中快速读取具体的某个状态数据</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E8%B4%A6%E6%88%B7%E6%A8%A1%E5%9E%8B-1.png#clientId=u7a530312-f976-4&from=paste&height=318&id=uadb7d967&margin=%5Bobject%20Object%5D&originHeight=1006&originWidth=1062&originalType=url&status=done&style=none&taskId=u8125fdd8-2c02-4142-8ff6-2a5b708f249&width=336"><br>上图是以太坊账户数据存储结构，账户内部实际只存储关键数据，而合约代码以及合约自身数据则通过对应的哈希值关联。 因为每个账户对象，将作为一个以太坊账户树的一个叶子数据存储， 不能太大。<br>从以太坊作为一个世界态(World State)状态机视角看数据关系如下：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E8%B4%A6%E6%88%B7%E6%A8%A1%E5%9E%8B-2.png#clientId=u7a530312-f976-4&from=paste&height=125&id=ud8337454&margin=%5Bobject%20Object%5D&originHeight=174&originWidth=955&originalType=url&status=done&style=none&taskId=u96e7177e-6233-4ade-8cc1-94578d56711&width=686.5"><br>我们通过一段示例代码，感受下以太坊账户数据存储。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(...)</span><br><span class="line"><span class="keyword">var</span> toAddr =common.HexToAddress</span><br><span class="line"><span class="keyword">var</span> toHash =common.BytesToHash</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    statadb, _ := state.New(common.Hash&#123;&#125;,</span><br><span class="line">        state.NewDatabase(rawdb.NewMemoryDatabase()))<span class="comment">// ❶</span></span><br><span class="line"></span><br><span class="line">    acct1:=toAddr(<span class="string">&quot;0x0bB141C2F7d4d12B1D27E62F86254e6ccEd5FF9a&quot;</span>)<span class="comment">// ❷</span></span><br><span class="line">    acct2:=toAddr(<span class="string">&quot;0x77de172A492C40217e48Ebb7EEFf9b2d7dF8151B&quot;</span>)</span><br><span class="line"></span><br><span class="line">    statadb.AddBalance(acct1,big.NewInt(<span class="number">100</span>))</span><br><span class="line">    statadb.AddBalance(acct2,big.NewInt(<span class="number">888</span>))</span><br><span class="line"></span><br><span class="line">    contract:=crypto.CreateAddress(acct1,statadb.GetNonce(acct1))<span class="comment">// ❸</span></span><br><span class="line">    statadb.CreateAccount(contract)</span><br><span class="line">    statadb.SetCode(contract,[]<span class="keyword">byte</span>(<span class="string">&quot;contract code bytes&quot;</span>))<span class="comment">// ❹</span></span><br><span class="line"></span><br><span class="line">    statadb.SetNonce(contract,<span class="number">1</span>)</span><br><span class="line">    statadb.SetState(contract,toHash([]<span class="keyword">byte</span>(<span class="string">&quot;owner&quot;</span>)),toHash(acct1.Bytes()))<span class="comment">//❺</span></span><br><span class="line">    statadb.SetState(contract,toHash([]<span class="keyword">byte</span>(<span class="string">&quot;name&quot;</span>)),toHash([]<span class="keyword">byte</span>(<span class="string">&quot;ysqi&quot;</span>)))</span><br><span class="line"></span><br><span class="line">    statadb.SetState(contract,toHash([]<span class="keyword">byte</span>(<span class="string">&quot;online&quot;</span>)),toHash([]<span class="keyword">byte</span>&#123;<span class="number">1</span>&#125;)</span><br><span class="line">    statadb.SetState(contract,toHash([]<span class="keyword">byte</span>(<span class="string">&quot;online&quot;</span>)),toHash([]<span class="keyword">byte</span>&#123;&#125;))<span class="comment">//❻</span></span><br><span class="line"></span><br><span class="line">    statadb.Commit(<span class="literal">true</span>)<span class="comment">// ❼</span></span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(statadb.Dump()))<span class="comment">// ❽</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，我们创建了三个账户，并且提交到数据库中。最终打印出当前数据中所有账户的数据信息：</p><ul><li>❶ 一行代码涉及多个操作。首先是<strong>创建一个内存 KV 数据库</strong>，再<strong>包装为 stata 数据库实例</strong>， 最后<strong>利用一个空的 DB 级的 StateRoot，初始化一个以太坊 statadb</strong>。</li><li>❷ 定义两个账户 acct1 和 acct2，并分别添加 100 和 888 到账户余额。</li><li>❸ 模拟合约账户的创建过程，由外部账户 acct1 创建合约账户地址，并将此地址载入 statadb。</li><li>❹ 在将合约代码加入刚刚创建的合约账户中，在写入合约代码的同时， 会利用 crypto.Keccak256Hash(code)计算合约代码哈希，保留在账户数据中。</li><li>❺ 模拟合约执行过程，涉及修改合约状态，新增三项状态数据 owner,name 和 online，分别对应不同值。</li><li>❻ 这里和前面不同的是，是给状态 online 赋值为空[]byte{}，因为所有状态的默认值均是[]byte{}， 在提交到数据库时，如 Leveldb 认为这些状态无有效值，会从数据库文件中删除此记录。 因此，此操作实际是一个删除状态 online 操作。</li><li>❼ 上面所有操作，还都<strong>只是发生在 statdb 内存</strong>中，并未真正的写入数据库文件。 <strong>执行 Commit</strong>，才会<strong>将关于 statadb 的所有变更更新到数据库文件</strong>中。</li><li>❽ 一旦提交数据，则可以使用 Dump 命令从数据库中查找此 stata 相关的所有数据，包括所有账户。 并<strong>以 JSON 格式返还</strong>。这里，我们将返还结果直接打印输出。</li></ul><p>代码执行输出结果如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;root&quot;</span>: <span class="string">&quot;3a25b0816cf007c0b878ca7a62ba35ee0337fa53703f281c41a791a137519f00&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;accounts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;0bb141c2f7d4d12b1d27e62f86254e6cced5ff9a&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;balance&quot;</span>: <span class="string">&quot;100&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;nonce&quot;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;root&quot;</span>: <span class="string">&quot;56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;codeHash&quot;</span>: <span class="string">&quot;c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;storage&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;77de172a492c40217e48ebb7eeff9b2d7df8151b&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;balance&quot;</span>: <span class="string">&quot;888&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;nonce&quot;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;root&quot;</span>: <span class="string">&quot;56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;codeHash&quot;</span>: <span class="string">&quot;c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;storage&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;80580f576731dc1e1dcc53d80b261e228c447cdd&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;balance&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;nonce&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;root&quot;</span>: <span class="string">&quot;1f6d937817f2ac217d8b123c4983c45141e50bd0c358c07f3c19c7b526dd4267&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;codeHash&quot;</span>: <span class="string">&quot;c668dac8131a99c411450ba912234439ace20d1cc1084f8e198fee0a334bc592&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;636f6e747261637420636f6465206279746573&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;storage&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;000000000000000000000000000000000000000000000000000000006e616d65&quot;</span>: <span class="string">&quot;8479737169&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;0000000000000000000000000000000000000000000000000000006f776e6572&quot;</span>: <span class="string">&quot;940bb141c2f7d4d12b1d27e62f86254e6cced5ff9a&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们采用和以太坊相似的账户模型。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>区块链底层-存储</title>
    <link href="https://www.blog.hackerjerry.top/2021/04/16/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%AD%98%E5%82%A8_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/04/16/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%AD%98%E5%82%A8_new/</id>
    <published>2021-04-16T12:20:09.000Z</published>
    <updated>2021-05-06T13:01:50.438Z</updated>
    
    <content type="html"><![CDATA[<p>本文聚焦区块链底层技术–存储技术。主要包含世界状态、账户状态和 MPT 树。<br>参考：<a href="https://learnblockchain.cn/books/geth/part3/statedb.html">https://learnblockchain.cn/books/geth/part3/statedb.html</a></p><a id="more"></a><h1 id="StateDB-世界状态"><a href="#StateDB-世界状态" class="headerlink" title="StateDB-世界状态"></a>StateDB-世界状态</h1><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%AD%98%E5%82%A8-1.png#clientId=u34e3a6f1-8d42-4&from=paste&height=136&id=u29593524&margin=%5Bobject%20Object%5D&originHeight=174&originWidth=955&originalType=url&status=done&style=none&taskId=ud67f5524-9e0a-474e-8ebf-a18abeb618d&width=747.5"><br>从程序设计角度，StateDB 有多种用途：</p><ol><li>维护账户状态到世界状态的映射。</li><li>支持修改、回滚、提交状态。</li><li>支持持久化状态到数据库中。</li><li>是状态进出默克尔树的媒介。</li></ol><p>实际上** StateDB <strong>充当</strong>状态（数据）<strong>、</strong>Trie(树)<strong>、</strong>LevelDB（存储）**的协调者。</p><h2 id="实例化-StateDB"><a href="#实例化-StateDB" class="headerlink" title="实例化 StateDB"></a>实例化 StateDB</h2><p>在对状态的任何操作前，我们要先构建一个 StateDB 来操作状态。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db: = state.NewDatabase(levelDB)</span><br><span class="line">statedb, err := state.New(block.Root(), db)</span><br></pre></td></tr></table></figure><p>首先，我们要告诉 StateDB ，我们要使用哪个状态。因此<strong>需要提供 StateRoot 作为默克尔树根去构建树</strong>。StateRoot 值相当于数据版本号，根据版本号可以明确的知道要使用使用哪个版本的状态。当然，数据内容并没在树中，<strong>需要到一个数据库中读取</strong>。因此在构建 State DB 时需要提供 stateRoot 和 db 才能完成构建。<br>任何实现 state.Database 接口的 db 都可以使用</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// core/state/database.go:42</span></span><br><span class="line"><span class="keyword">type</span> Database <span class="keyword">interface</span> &#123;</span><br><span class="line">OpenTrie(root common.Hash) (Trie, error)</span><br><span class="line">OpenStorageTrie(addrHash, root common.Hash) (Trie, error)</span><br><span class="line">CopyTrie(Trie) Trie</span><br><span class="line">ContractCode(addrHash, codeHash common.Hash) ([]<span class="keyword">byte</span>, error)</span><br><span class="line">ContractCodeSize(addrHash, codeHash common.Hash) (<span class="keyword">int</span>, error)</span><br><span class="line"></span><br><span class="line"><span class="comment">// TrieDB retrieves the low level trie database used for data storage.</span></span><br><span class="line">TrieDB() *trie.Database</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 db 可以访问：</p><ol><li>OpenTrie: 打开指定状态版本(root)的含世界状态的顶层树。</li><li>OpenStorageTrie: <strong>打开账户(addrHash)下</strong>指定状态版本(root)的<strong>账户数据存储树</strong>。</li><li>CopyTrie: 深度拷贝树。</li><li>ContractCode：获取账户（addrHash）的合约，必须和合约哈希(codeHash)匹配。</li><li>ContractCodeSize 获取指定合约大小</li><li>TrieDB：<strong>获得 Trie 底层的数据驱动 DB</strong>，如:** levedDB** 、<strong>内存数据库</strong>、远程数据库</li></ol><p>当前有两种类型的 DB 实现了 Database 接口，轻节点使用的 odrDatabase ，和正常节点端使用的带有缓存的 cachingDB 。 因为轻节点并不存储数据，需要通过向其他节点查询来获得数据，而 odrDatabase 就是这种数据读取方式的封装。一个普通节点已内置 levelDB，为了提高读写性能，使用 cachingDB 对其进行一次封装。<br>在实例化 StateDB 时，需要立即打开含有世界状态的 Trie 树。如果 root 对应的树不存在，则会实例化失败 ①。实例化的 StateDB 中将记录多种信息。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/state/statedb.go:59</span></span><br><span class="line"><span class="keyword">type</span> StateDB <span class="keyword">struct</span> &#123;</span><br><span class="line">db   Database</span><br><span class="line">trie Trie</span><br><span class="line">stateObjects      <span class="keyword">map</span>[common.Address]*stateObject</span><br><span class="line">stateObjectsDirty <span class="keyword">map</span>[common.Address]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">dbErr error</span><br><span class="line">refund <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">thash, bhash common.Hash</span><br><span class="line">txIndex      <span class="keyword">int</span></span><br><span class="line">logs         <span class="keyword">map</span>[common.Hash][]*types.Log</span><br><span class="line">logSize      <span class="keyword">uint</span></span><br><span class="line"></span><br><span class="line">preimages <span class="keyword">map</span>[common.Hash][]<span class="keyword">byte</span></span><br><span class="line">journal        *journal</span><br><span class="line">validRevisions []revision</span><br><span class="line">nextRevisionId <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>db: 操作状态的<strong>底层数据库</strong>，在实例化 StateDB 时指定 ②。</li><li>trie: 世界状态所在的树实例对象，现在只有以太坊改进的默克尔前缀压缩树。</li><li>stateObjects: <strong>已账户地址为键的账户状态对象，能够在内存中维护使用过的账户</strong>。</li><li>stateObjectsDirty： 标记被修改过的账户。</li><li>journal： 是修改状态的日志流水，使用此日志流水可回滚状态。</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/state/statedb.go:92</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(root common.Hash, db Database)</span> <span class="params">(*StateDB, error)</span></span> &#123;</span><br><span class="line">tr, err := db.OpenTrie(root)<span class="comment">//①</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;StateDB&#123;</span><br><span class="line">db:                db,<span class="comment">//②</span></span><br><span class="line">trie:              tr,</span><br><span class="line">stateObjects:      <span class="built_in">make</span>(<span class="keyword">map</span>[common.Address]*stateObject),</span><br><span class="line">stateObjectsDirty: <span class="built_in">make</span>(<span class="keyword">map</span>[common.Address]<span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">logs:              <span class="built_in">make</span>(<span class="keyword">map</span>[common.Hash][]*types.Log),</span><br><span class="line">preimages:         <span class="built_in">make</span>(<span class="keyword">map</span>[common.Hash][]<span class="keyword">byte</span>),</span><br><span class="line">journal:           newJournal(),</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面对的代码实例化了一个 statedb。</p><h2 id="读写-StateDB-状态"><a href="#读写-StateDB-状态" class="headerlink" title="读写 StateDB 状态"></a>读写 StateDB 状态</h2><p>你所访问的任何数据必然属于某个账户下的状态，世界状态态仅仅是通过一颗树来建立安全的映射。因此你所访问的数据可以分为如下几种类型：</p><ol><li>访问账户基础属性：Balance、Nonce、Root、CodeHash</li><li>读取合约账户代码</li><li>读取合约账户中存储内容</li></ol><p>在代码实现中，为了便于账户隔离管理，使用不开放的 stateObject 来维护。 stateObject 注意代码如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> stateObject <span class="keyword">struct</span> &#123;</span><br><span class="line">address  common.Address<span class="comment">//对应的账户地址</span></span><br><span class="line">addrHash common.Hash <span class="comment">// 账户地址的哈希值</span></span><br><span class="line">data     Account <span class="comment">//账户属性</span></span><br><span class="line">db       *StateDB <span class="comment">//底层数据库</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="comment">// 写缓存</span></span><br><span class="line">trie Trie <span class="comment">// 存储树，第一次访问时初始化</span></span><br><span class="line">code Code <span class="comment">// contract bytecode, which gets set when code is loaded</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span> &#123;</span><br><span class="line">Nonce    <span class="keyword">uint64</span></span><br><span class="line">Balance  *big.Int</span><br><span class="line">Root     common.Hash <span class="comment">// merkle root of the storage trie</span></span><br><span class="line">CodeHash []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 stateObject 中维护关于某个账户的所有信息，涉及账户地址、账户地址哈希、账户属性、底层数据库、存储树等内容。<br>当你访问状态时，需要指定账户地址。比如获取账户合约，合约账户代码，均是通过账户地址，获得获得对应的账户的 stateObject。因此，当你访问某账户余额时，需要从世界状态树 Trie 中读取账户状态。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// core/state/statedb.go:408</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *StateDB)</span> <span class="title">getStateObject</span><span class="params">(addr common.Address)</span> <span class="params">(stateObject *stateObject)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> obj := self.stateObjects[addr]; obj != <span class="literal">nil</span> &#123;<span class="comment">//①</span></span><br><span class="line"><span class="keyword">if</span> obj.deleted &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enc, err := self.trie.TryGet(addr[:])<span class="comment">//②</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(enc) == <span class="number">0</span> &#123;</span><br><span class="line">self.setError(err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> data Account</span><br><span class="line"><span class="keyword">if</span> err := rlp.DecodeBytes(enc, &amp;data); err != <span class="literal">nil</span> &#123;<span class="comment">//③</span></span><br><span class="line">log.Error(<span class="string">&quot;Failed to decode state object&quot;</span>, <span class="string">&quot;addr&quot;</span>, addr, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">obj := newObject(self, addr, data)<span class="comment">//④</span></span><br><span class="line">self.setStateObject(obj)</span><br><span class="line"><span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>state.getStateObject(addr)方法，将返回指定账户的 StateObject，不存在时 nil。<br>state 的 stateObject Map 中记录这从实例化 State 到当下，所有访问过的账户的 StateObject。 因此，获取 StateObject 时先从 map 缓存中检查是否已打开 ①，如果存在则返回。** 如果是第一次使用，则以账户地址为 key 从树中查找读取账户状态数据<strong>②。读取到的数据，是被 RLP 序列化过的，因此，在读取到数据后，还需要进行反序列化 ③。为了降低 IO 和在内存中维护可能被修改的 Account 信息，会将其组装成 **StateObjec ④ 存储在 State 实例</strong>中。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/state/state_object.go:108</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newObject</span><span class="params">(db *StateDB, address common.Address, data Account)</span> *<span class="title">stateObject</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> data.Balance == <span class="literal">nil</span> &#123;</span><br><span class="line">data.Balance = <span class="built_in">new</span>(big.Int)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> data.CodeHash == <span class="literal">nil</span> &#123;</span><br><span class="line">data.CodeHash = emptyCodeHash</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;stateObject&#123;</span><br><span class="line">db:            db,</span><br><span class="line">address:       address,</span><br><span class="line">addrHash:      crypto.Keccak256Hash(address[:]),<span class="comment">//⑤</span></span><br><span class="line">data:          data,</span><br><span class="line">originStorage: <span class="built_in">make</span>(Storage),</span><br><span class="line">dirtyStorage:  <span class="built_in">make</span>(Storage),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newObject 就是将对 Account 的操作进行辅助，其中记录了账户地址、地址哈希 ⑤ 等内容，最终你读写状态都经过 stateObject 完成。</p><h2 id="StateDB-完成持久化"><a href="#StateDB-完成持久化" class="headerlink" title="StateDB 完成持久化"></a>StateDB 完成持久化</h2><p>在区块中，将交易作为输入条件，来根据一系列动作修改状态。<br>在完成区块挖矿前，只是获得在内存中的状态树的 Root 值。 StateDB 可视为一个内存数据库，状态数据先在内存数据库中完成修改，所有关于状态的计算都在内存中完成。 在将区块持久化时完成有内存到数据库的更新存储，此更新属于增量更新，仅仅修改涉及到被修改部分。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// core/state/statedb.go:680</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span> <span class="title">Commit</span><span class="params">(deleteEmptyObjects <span class="keyword">bool</span>)</span> <span class="params">(root common.Hash, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> s.clearJournalAndRefund()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> addr := <span class="keyword">range</span> s.journal.dirties &#123;<span class="comment">//①⑧⑨⑩</span></span><br><span class="line">s.stateObjectsDirty[addr] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> addr, stateObject := <span class="keyword">range</span> s.stateObjects &#123;<span class="comment">//②</span></span><br><span class="line">_, isDirty := s.stateObjectsDirty[addr]</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> stateObject.suicided || (isDirty &amp;&amp; deleteEmptyObjects &amp;&amp; stateObject.empty()):</span><br><span class="line"><span class="comment">//③</span></span><br><span class="line">s.deleteStateObject(stateObject)</span><br><span class="line"><span class="keyword">case</span> isDirty:</span><br><span class="line"><span class="keyword">if</span> stateObject.code != <span class="literal">nil</span> &amp;&amp; stateObject.dirtyCode &#123;<span class="comment">//④</span></span><br><span class="line">s.db.TrieDB().InsertBlob(common.BytesToHash(stateObject.CodeHash()), stateObject.code)</span><br><span class="line">stateObject.dirtyCode = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := stateObject.CommitTrie(s.db); err != <span class="literal">nil</span> &#123;<span class="comment">//⑤</span></span><br><span class="line"><span class="keyword">return</span> common.Hash&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line">s.updateStateObject(stateObject)<span class="comment">//⑥</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">delete</span>(s.stateObjectsDirty, addr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">root, err = s.trie.Commit(<span class="function"><span class="keyword">func</span><span class="params">(leaf []<span class="keyword">byte</span>, parent common.Hash)</span> <span class="title">error</span></span> &#123;<span class="comment">//⑦</span></span><br><span class="line"><span class="keyword">var</span> account Account</span><br><span class="line"><span class="keyword">if</span> err := rlp.DecodeBytes(leaf, &amp;account); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> account.Root != emptyRoot &#123;</span><br><span class="line">s.db.TrieDB().Reference(account.Root, parent)</span><br><span class="line">&#125;</span><br><span class="line">code := common.BytesToHash(account.CodeHash)</span><br><span class="line"><span class="keyword">if</span> code != emptyCode &#123;</span><br><span class="line">s.db.TrieDB().Reference(code, parent)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> root, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82-%E5%AD%98%E5%82%A8-2.png#clientId=u34e3a6f1-8d42-4&from=paste&height=506&id=ufcde743f&margin=%5Bobject%20Object%5D&originHeight=1012&originWidth=936&originalType=url&status=done&style=none&taskId=u9036f292-bba3-41a2-a09a-3566a7f7e94&width=468"><br>如上图所示，上半部分均属于内存操作，仅仅在 stateDB.Commit()时才将状态通过树提交到 leveldb 中。</p><h1 id="MPT-默克尔压缩前缀树"><a href="#MPT-默克尔压缩前缀树" class="headerlink" title="MPT-默克尔压缩前缀树"></a>MPT-默克尔压缩前缀树</h1><p>是一种经过改良的、融合了默克尔树和前缀树两种树结构优点的数据结构，是以太坊中用来组织管理账户数据、生成交易集合哈希的重要数据结构。一个非叶节点存储在 leveldb 关系型数据库中，数据库中的 key 是节点的 RLP 编码的 sha3 哈希，value 是节点的 RLP 编码。想要获得一个非叶节点的子节点，只需要根据子节点的 hash 访问数据库获得节点的 RLP 编码，然后解码就行了。<br>以太坊有四种前缀树：</p><ol><li><strong>世界状态树包括了从地址到账户状态之间的映射。</strong> 世界状态树的根节点哈希值由区块保存（在 stateRoot 字段），它标示了区块创建时的当前状态。<strong>整个网络中只有一个世界状态树。</strong></li><li><strong>账户存储树保存了与某一智能合约相关的数据信息。</strong>由账户状态保存账户存储树的根节点哈希值（在 storageRoot 字段）。<strong>每个账户都有一个账户存储树。</strong></li><li><strong>交易树包含了一个区块中的所有交易信息。</strong>由区块头（在 transactionsRoot 区域）保存交易树的根节点哈希值。<strong>每个区块都有一棵交易树。</strong></li><li><strong>交易收据树包含了一个区块中所有交易的收据信息。</strong>同样由区块头（在 receiptsRoot 区域）保存交易收据树的根节点哈希值；<strong>每个区块都有对应的交易收据树。</strong></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文聚焦区块链底层技术–存储技术。主要包含世界状态、账户状态和 MPT 树。&lt;br&gt;参考：&lt;a href=&quot;https://learnblockchain.cn/books/geth/part3/statedb.html&quot;&gt;https://learnblockchain.cn/books/geth/part3/statedb.html&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>交易内存池底层实现</title>
    <link href="https://www.blog.hackerjerry.top/2021/04/15/%E4%BA%A4%E6%98%93%E5%86%85%E5%AD%98%E6%B1%A0%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/04/15/%E4%BA%A4%E6%98%93%E5%86%85%E5%AD%98%E6%B1%A0%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0_new/</id>
    <published>2021-04-15T12:29:00.000Z</published>
    <updated>2021-05-06T13:00:59.863Z</updated>
    
    <content type="html"><![CDATA[<p>既然要从头搭建一个区块链网络，交易池是绕不开的一个核心底层。对于它，以下几个问题是需要解决的：</p><ol><li>用户发起的交易请求（不论以何种方式）是如何转变为实际的交易的；</li><li>产生的交易如果不能被及时处理，是如何进入交易池的；</li><li>本地产生的交易和从网络中接收到的交易进入交易池是否有区别；</li><li>交易池的基本数据结构是怎么样的（优先队列？）</li><li>从交易池中提取交易进行打包时顺序是怎么样的（调度算法）<blockquote><p>网络中很多文章提到内存池，指的就是是 txpool</p></blockquote></li></ol><a id="more"></a><h1 id="交易形成"><a href="#交易形成" class="headerlink" title="交易形成"></a>交易形成</h1><p>以下均为作品赛项目的内容。<br>首先，我们的交易请求会赋值到 TxRaw 结构体的一个实例中。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于接收客户端发来的序列化post原始信息</span></span><br><span class="line"><span class="keyword">type</span> TxRaw <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//公钥hash</span></span><br><span class="line">Address []<span class="keyword">byte</span> <span class="string">`json:&quot;address&quot;`</span></span><br><span class="line"></span><br><span class="line">Fee <span class="keyword">int</span> <span class="string">`json:&quot;int&quot;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//交易核心</span></span><br><span class="line">RangeBloom bloom.RangeBloom <span class="string">`json:&quot;rbloom&quot;`</span></span><br><span class="line">TimeBloom  bloom.TimeBloom  <span class="string">`json:&quot;tbloom&quot;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//签名相关</span></span><br><span class="line">Pubkey sm2.PublicKey <span class="string">`json:&quot;pubkey&quot;`</span></span><br><span class="line">Sign   []<span class="keyword">byte</span>        <span class="string">`json:&quot;sign&quot;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//交易同态密文拼接，用于k-top查找</span></span><br><span class="line">Cipher <span class="keyword">string</span> <span class="string">`json:&quot;cipher&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后这个实例被传递到一个 SendTransaction 函数，用来创建一个交易 Tx。创建交易的过程如下：</p><ol><li>根据 Address 字段找到当前账户</li><li>设置交易默认参数</li><li>检查交易签名是否合法</li><li>检查交易是否冲突</li><li>对交易进行序列化，变为可存储和传输的形式。</li><li>提交交易到交易池</li></ol><h1 id="交易管理"><a href="#交易管理" class="headerlink" title="交易管理"></a>交易管理</h1><p>以太坊将交易按状态分为两部分：<strong>可执行交易</strong>和<strong>非可执行交易</strong>。分别记录在 pending 容器中和 queue 容器中。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E4%BA%A4%E6%98%93%E5%86%85%E5%AD%98%E6%B1%A0%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-1.png#clientId=u272c35f2-3d2a-4&from=paste&height=321&id=u5bf56761&margin=%5Bobject%20Object%5D&originHeight=538&originWidth=1160&originalType=binary&size=164987&status=done&style=none&taskId=u567ff6dc-553f-4a1c-af77-71fc9a19a73&width=693"><br>如上图所示，交易池先采用一个 txLookup (内部为 map）跟踪所有交易。同时将交易根据本地优先，价格优先原则将交易划分为两部分 queue 和 pending。而这两部交易则按账户分别跟踪。<br>为了不丢失未完成的本地交易，以太坊交易池通过 journal 文件存储和管理当前交易池中的本地交易，并定期更新存储。<br>下图是<strong>交易池对本地待处理交易的磁盘存储管理流程</strong>，涉及加载、实时写入和定期更新维护。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E4%BA%A4%E6%98%93%E5%86%85%E5%AD%98%E6%B1%A0%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-2.png#clientId=u272c35f2-3d2a-4&from=paste&height=826&id=ufc47fc0d&margin=%5Bobject%20Object%5D&originHeight=1356&originWidth=870&originalType=url&status=done&style=none&taskId=ubb8c227e-5868-49f4-b1ea-77abbe42349&width=530"></p><h2 id="存储交易"><a href="#存储交易" class="headerlink" title="存储交易"></a>存储交易</h2><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E4%BA%A4%E6%98%93%E5%86%85%E5%AD%98%E6%B1%A0%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-3.png#clientId=u272c35f2-3d2a-4&from=paste&height=317&id=uc114cf13&margin=%5Bobject%20Object%5D&originHeight=432&originWidth=826&originalType=url&status=done&style=none&taskId=u8fb70d54-24fd-45a9-880e-9b7951920f0&width=606"><br>当交易池新交易来自于本地账户时 ❶，如果已开启记录本地交易，则将此交易加入 journal ❷。到交易池时，将实时存储到 journal 文件中。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/tx_pool.go:757</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *TxPool)</span> <span class="title">journalTx</span><span class="params">(from common.Address, tx *types.Transaction)</span></span> &#123;</span><br><span class="line">   <span class="comment">// Only journal if it&#x27;s enabled and the transaction is local</span></span><br><span class="line">   <span class="keyword">if</span> pool.journal == <span class="literal">nil</span> || !pool.locals.contains(from) &#123;<span class="comment">//❶</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> err := pool.journal.insert(tx); err != <span class="literal">nil</span> &#123; <span class="comment">//❷</span></span><br><span class="line">      log.Warn(<span class="string">&quot;Failed to journal local transaction&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 journal.insert 则将交易实时写入文件流中 ❸，相当于实时存储到磁盘。而在写入时，是将交易进行 RLP 编码。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/tx_journal.go:120</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(journal *txJournal)</span> <span class="title">insert</span><span class="params">(tx *types.Transaction)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> journal.writer == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> errNoActiveJournal</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> err := rlp.Encode(journal.writer, tx); err != <span class="literal">nil</span> &#123;<span class="comment">//❸</span></span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>插一嘴，为什么要用 RLP 编码？</p></blockquote><h3 id="什么是-RLP"><a href="#什么是-RLP" class="headerlink" title="什么是 RLP"></a>什么是 RLP</h3><p>RLP(Recursive Length Prefix) 递归长度前缀编码是以太坊中最常使用的序列化格式方法。<br>RLP 旨在<strong>成为高度简约的序列化方法</strong>，<strong>唯一目标</strong>就是<strong>存储嵌套的字节数组</strong>。<br>RLP 只是以嵌套数组形式存储结构型数据，由上层协议来确定数组的含义。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E4%BA%A4%E6%98%93%E5%86%85%E5%AD%98%E6%B1%A0%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-4.png#clientId=u272c35f2-3d2a-4&from=paste&height=443&id=u3b9d54f1&margin=%5Bobject%20Object%5D&originHeight=886&originWidth=1716&originalType=url&status=done&style=none&taskId=u8fd870e4-dcb8-44b2-bd3b-a5ba9cd4ba8&width=858"><br>从图中可以看出，不同类型的数据，将有不同的前缀标识。 前缀也可以理解为报文头，通过报文头可准确获取报文内容。 图中灰色部分则为 RLP 编码输出前缀。</p><h2 id="加载已存储交易"><a href="#加载已存储交易" class="headerlink" title="加载已存储交易"></a>加载已存储交易</h2><p>在交易池首次启动 journal 时，将主动将该文件已存储的交易加载到交易池。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/tx_journal.go:61</span></span><br><span class="line"><span class="keyword">if</span> _, err := os.Stat(journal.path); os.IsNotExist(err) &#123; <span class="comment">//❶</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Open the journal for loading any past transactions</span></span><br><span class="line">input, err := os.Open(journal.path) <span class="comment">//❷</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> input.Close()</span><br></pre></td></tr></table></figure><p>处理时，如果文件不存在则退出 ❶，否则 Open 文件，获得 input 文件流 ❷。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/tx_journal.go:76</span></span><br><span class="line">stream := rlp.NewStream(input, <span class="number">0</span>)<span class="comment">//❸</span></span><br><span class="line">total, dropped := <span class="number">0</span>, <span class="number">0</span></span><br></pre></td></tr></table></figure><p>因为存储的内容格式是 rlp 编码内容，因此可以直接初始化 rlp 内容流 ❸，为连续解码做准备。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">   failure error</span><br><span class="line">   batch   types.Transactions</span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">   tx := <span class="built_in">new</span>(types.Transaction)</span><br><span class="line">   <span class="keyword">if</span> err = stream.Decode(tx); err != <span class="literal">nil</span> &#123; <span class="comment">//❹</span></span><br><span class="line">      <span class="keyword">if</span> err != io.EOF &#123;</span><br><span class="line">         failure = err</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> batch.Len() &gt; <span class="number">0</span> &#123;<span class="comment">//❼</span></span><br><span class="line">         loadBatch(batch)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">   &#125;</span><br><span class="line">   total++</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> batch = <span class="built_in">append</span>(batch, tx); batch.Len() &gt; <span class="number">1024</span> &#123;<span class="comment">//❺</span></span><br><span class="line">      loadBatch(batch)<span class="comment">//❻</span></span><br><span class="line">      batch = batch[:<span class="number">0</span>]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadBatch := <span class="function"><span class="keyword">func</span><span class="params">(txs types.Transactions)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> _, err := <span class="keyword">range</span> add(txs) &#123;</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         log.Debug(<span class="string">&quot;Failed to add journaled transaction&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">         dropped++ <span class="comment">//❽</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接进入 for 循环遍历，不断从 stream 中一笔笔地解码出交易 ❹。<br>但交易并非单笔直接载入交易池，而是采用批量提交模式，每 1024 笔交易提交一次 ❺。<br>批量写入，有利于降低交易池在每次写入交易后的更新。一个批次只需要更新（排序与超限处理等）一次。当然在遍历结束时（err==io.EOF）,也需要将当前批次中的交易载入 ❼。<br>loadBatch 就是将交易一批次加入到交易池，并获得交易池的每笔交易的处理情况。如果交易加入失败，则进行计数 ❽。最终在 load 方法执行完毕时，显示交易载入情况。</p><h1 id="交易添加到交易池"><a href="#交易添加到交易池" class="headerlink" title="交易添加到交易池"></a>交易添加到交易池</h1><p>SendTransaction 最后调用 SubmitTransaction 函数将交易提交到交易池，不过，更底层的调用是 AddLocals 函数。<br>这里需要注意，本地交易时调用 AddLocals，而从对等 p2p 节点发来的交易调用的是另一个函数，AddRemotes 函数。调用这两个函数之前都应该验证交易的有效性。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E4%BA%A4%E6%98%93%E5%86%85%E5%AD%98%E6%B1%A0%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-5.png#clientId=u272c35f2-3d2a-4&from=paste&height=264&id=ue6089192&margin=%5Bobject%20Object%5D&originHeight=528&originWidth=1174&originalType=binary&size=236384&status=done&style=none&taskId=uf8820385-fb3b-42bb-ab6f-9ae0571e933&width=587"></p><blockquote><p>因为交易时通过节点的 API 接收，因此此交易被视为一笔来自本地(local)（图中用红球表示），在经过一系列校验和处理后。交易成功进入交易池，随后向已连接的邻近节点发送此交易。<br>当邻近节点，如矿工节点从邻近节点接收到此交易时，在进入交易池之前。会将交易标记为来自远方（remote）的交易（图中用绿球表示）。也需要经过校验和处理后，进入矿工节点的交易池，等待矿工打包到区块中。<br>如果邻近节点，不是矿工，也无妨。因为任何节点会默认将接受到得合法交易及时发送给邻近节点。得益于 P2P 网络，一笔交易平均在 6s 内扩散到整个以太坊公链网络的各个节点中。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E4%BA%A4%E6%98%93%E5%86%85%E5%AD%98%E6%B1%A0%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-6.png#clientId=u272c35f2-3d2a-4&from=paste&height=254&id=u528314c1&margin=%5Bobject%20Object%5D&originHeight=373&originWidth=924&originalType=binary&size=74906&status=done&style=none&taskId=uae16074d-7e82-4415-a530-f8a271e0047&width=629"><br>下面我们来看一下交易池的结构：</p><blockquote><p>这是以太坊的</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TxPool contains all currently known transactions. Transactions</span></span><br><span class="line"><span class="comment">// enter the pool when they are received from the network or submitted</span></span><br><span class="line"><span class="comment">// locally. They exit the pool when they are included in the blockchain.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The pool separates processable transactions (which can be applied to the</span></span><br><span class="line"><span class="comment">// current state) and future transactions. Transactions move between those</span></span><br><span class="line"><span class="comment">// two states over time as they are received and processed.</span></span><br><span class="line"><span class="keyword">type</span> TxPool <span class="keyword">struct</span> &#123;</span><br><span class="line">config      TxPoolConfig</span><br><span class="line">chainconfig *params.ChainConfig</span><br><span class="line">chain       blockChain</span><br><span class="line">gasPrice    *big.Int</span><br><span class="line">txFeed      event.Feed</span><br><span class="line">scope       event.SubscriptionScope</span><br><span class="line">signer      types.Signer</span><br><span class="line">mu          sync.RWMutex</span><br><span class="line"></span><br><span class="line">istanbul <span class="keyword">bool</span> <span class="comment">// Fork indicator whether we are in the istanbul stage.</span></span><br><span class="line"></span><br><span class="line">currentState  *state.StateDB <span class="comment">// Current state in the blockchain head</span></span><br><span class="line">pendingNonces *txNoncer      <span class="comment">// Pending state tracking virtual nonces</span></span><br><span class="line">currentMaxGas <span class="keyword">uint64</span>         <span class="comment">// Current gas limit for transaction caps</span></span><br><span class="line"></span><br><span class="line">locals  *accountSet <span class="comment">// Set of local transaction to exempt from eviction rules</span></span><br><span class="line">journal *txJournal  <span class="comment">// Journal of local transaction to back up to disk</span></span><br><span class="line"></span><br><span class="line">pending <span class="keyword">map</span>[common.Address]*txList   <span class="comment">// All currently processable transactions</span></span><br><span class="line">queue   <span class="keyword">map</span>[common.Address]*txList   <span class="comment">// Queued but non-processable transactions</span></span><br><span class="line">beats   <span class="keyword">map</span>[common.Address]time.Time <span class="comment">// Last heartbeat from each known account</span></span><br><span class="line">all     *txLookup                    <span class="comment">// All transactions to allow lookups</span></span><br><span class="line">priced  *txPricedList                <span class="comment">// All transactions sorted by price</span></span><br><span class="line"></span><br><span class="line">chainHeadCh     <span class="keyword">chan</span> ChainHeadEvent</span><br><span class="line">chainHeadSub    event.Subscription</span><br><span class="line">reqResetCh      <span class="keyword">chan</span> *txpoolResetRequest</span><br><span class="line">reqPromoteCh    <span class="keyword">chan</span> *accountSet</span><br><span class="line">queueTxEventCh  <span class="keyword">chan</span> *types.Transaction</span><br><span class="line">reorgDoneCh     <span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">reorgShutdownCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;  <span class="comment">// requests shutdown of scheduleReorgLoop</span></span><br><span class="line">wg              sync.WaitGroup <span class="comment">// tracks loop, scheduleReorgLoop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中最核心的是两个字段，pending 和 queue<br><strong>queued 存放未来的、当前无法执行的交易</strong>。以太坊使用 nonce 值决定某个账户的交易顺序，多条交易值 nonce 值必须连续，如果和过去的交易不连续，则无法执行，我们不妨使用 nonce 值，标记交易的号码，nonce 为 10 的交易，称为第 10 号交易。举个例子，当前账户的 nonce 是 10，txpool 中有该账户的第 100 号交易，但 txpool 中没有第 11<del>99 号交易，这些交易的缺失，造成第 100 号交易无法执行，所以第 100 号交易就是未来的交易、不可执行的交易，存放在 queue 中。<br><strong>pending 存放可执行的交易</strong>。比如我们把上面的 11</del>99 号交易补全了，那么 11~100 号交易都可以进入到 pending，因为这些交易都是连续的，都可以打包进区块。<br>当节点收到交易（本地节点发起的或 peer 广播来的）时，会先存放到 queued，txpool 在某些情况下，把 queued 中可执行的交易，转移到 pending 中。<br>其中 config 的结构体为：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TxPoolConfig are the configuration parameters of the transaction pool.</span></span><br><span class="line"><span class="keyword">type</span> TxPoolConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">Locals    []common.Address <span class="comment">// Addresses that should be treated by default as local</span></span><br><span class="line">NoLocals  <span class="keyword">bool</span>             <span class="comment">// Whether local transaction handling should be disabled</span></span><br><span class="line">Journal   <span class="keyword">string</span>           <span class="comment">// Journal of local transactions to survive node restarts</span></span><br><span class="line">Rejournal time.Duration    <span class="comment">// Time interval to regenerate the local transaction journal</span></span><br><span class="line"></span><br><span class="line">PriceLimit <span class="keyword">uint64</span> <span class="comment">// Minimum gas price to enforce for acceptance into the pool</span></span><br><span class="line">PriceBump  <span class="keyword">uint64</span> <span class="comment">// Minimum price bump percentage to replace an already existing transaction (nonce)</span></span><br><span class="line"></span><br><span class="line">AccountSlots <span class="keyword">uint64</span> <span class="comment">// Number of executable transaction slots guaranteed per account</span></span><br><span class="line">GlobalSlots  <span class="keyword">uint64</span> <span class="comment">// Maximum number of executable transaction slots for all accounts</span></span><br><span class="line">AccountQueue <span class="keyword">uint64</span> <span class="comment">// Maximum number of non-executable transaction slots permitted per account</span></span><br><span class="line">GlobalQueue  <span class="keyword">uint64</span> <span class="comment">// Maximum number of non-executable transaction slots for all accounts</span></span><br><span class="line"></span><br><span class="line">Lifetime time.Duration <span class="comment">// Maximum amount of time non-executable transaction are queued</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Quorum</span></span><br><span class="line">TransactionSizeLimit <span class="keyword">uint64</span> <span class="comment">// Maximum size allowed for valid transaction (in KB)</span></span><br><span class="line">MaxCodeSize          <span class="keyword">uint64</span> <span class="comment">// Maximum size allowed of contract code that can be deployed (in KB)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DefaultTxPoolConfig = TxPoolConfig&#123;</span><br><span class="line">Journal:   <span class="string">&quot;transactions.rlp&quot;</span>,</span><br><span class="line">Rejournal: time.Hour,</span><br><span class="line"></span><br><span class="line">PriceLimit: <span class="number">1</span>,</span><br><span class="line">PriceBump:  <span class="number">10</span>,</span><br><span class="line"></span><br><span class="line">AccountSlots: <span class="number">16</span>,</span><br><span class="line">GlobalSlots:  <span class="number">4096</span>,</span><br><span class="line">AccountQueue: <span class="number">64</span>,</span><br><span class="line">GlobalQueue:  <span class="number">1024</span>,</span><br><span class="line"></span><br><span class="line">Lifetime: <span class="number">3</span> * time.Hour,</span><br><span class="line"></span><br><span class="line"><span class="comment">// Quorum</span></span><br><span class="line">TransactionSizeLimit: <span class="number">64</span>,</span><br><span class="line">MaxCodeSize:          <span class="number">24</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Locals: 定义了一组视为 local 交易的账户地址。任何来自此清单的交易均被视为 local 交易。</li><li>NoLocals: 是否禁止 local 交易处理。默认为 fasle,允许 local 交易。如果禁止，则来自 local 的交易均视为 remote 交易处理。</li><li>Journal： 存储 local 交易记录的文件名，默认是./transactions.rlp。</li><li>Rejournal：定期将 local 交易存储文件中的时间间隔。默认为每小时一次。</li><li>PriceLimit： remote 交易进入交易池的最低 Price 要求。此设置对 local 交易无效。默认值 1。</li><li>PriceBump：替换交易时所要求的价格上调涨幅比例最低要求。任何低于要求的替换交易均被拒绝。</li><li>AccountSlots： 当交易池中可执行交易（是已在等待矿工打包的交易）量超标时，允许每个账户可以保留在交易池最低交易数。默认值是 16 笔。</li><li>GlobalSlots： 交易池中所允许的可执行交易量上限，高于上限时将释放部分交易。默认是 4096 笔交易。</li><li>AccountQueue：交易池中单个账户非可执行交易上限，默认是 64 笔。</li><li>GlobalQueue： 交易池中所有非可执行交易上限，默认 1024 笔。</li><li>Lifetime： 允许 remote 的非可执行交易可在交易池存活的最长时间。交易池每分钟检查一次，一旦发现有超期的 remote 账户，则移除该账户下的所有非可执行交易。默认为 3 小时。<blockquote><p>参考：<a href="https://learnblockchain.cn/books/geth/part2/txpool/txpool.html">https://learnblockchain.cn/books/geth/part2/txpool/txpool.html</a></p></blockquote></li></ul><p>上面配置中，包含两个重要概念<strong>可执行交易</strong>和<strong>非可执行交易</strong>。可执行交易是指从交易池中择优选出的一部分交易可以被执行，打包到区块中。非可执行交易则相反，任何刚进入交易池的交易均属于非可执行状态，在某一个时刻才会提升为可执行状态。</p><blockquote><p>这是 dag 的</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TxPool <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// The following variables must only be used atomically.</span></span><br><span class="line">lastUpdated <span class="keyword">int64</span> <span class="comment">// last time pool was updated</span></span><br><span class="line"></span><br><span class="line">mtx           sync.RWMutex</span><br><span class="line">cfg           Config</span><br><span class="line">pool          <span class="keyword">map</span>[chainhash.Hash]*TxDesc</span><br><span class="line">orphans       <span class="keyword">map</span>[chainhash.Hash]*orphanTx</span><br><span class="line">orphansByPrev <span class="keyword">map</span>[wire.OutPoint]<span class="keyword">map</span>[chainhash.Hash]*soterutil.Tx</span><br><span class="line">outpoints     <span class="keyword">map</span>[wire.OutPoint]*soterutil.Tx</span><br><span class="line">pennyTotal    <span class="keyword">float64</span> <span class="comment">// exponentially decaying total for penny spends.</span></span><br><span class="line">lastPennyUnix <span class="keyword">int64</span>   <span class="comment">// unix time of last ``penny spend&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// nextExpireScan is the time after which the orphan pool will be</span></span><br><span class="line"><span class="comment">// scanned in order to evict orphans.  This is NOT a hard deadline as</span></span><br><span class="line"><span class="comment">// the scan will only run when an orphan is added to the pool as opposed</span></span><br><span class="line"><span class="comment">// to on an unconditional timer.</span></span><br><span class="line">nextExpireScan time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>交易提交到交易池还需要一个 add 函数，逻辑很简单：</p><ol><li>验证交易的有效性</li><li>如果 nonce 已存在，忽略。</li><li>如果 nonce 不存在，不可以替换 pending 中的任何交易，此时将新的交易插入 queue 的末尾</li></ol><p>注：交易中的 nonce 指的是 from 账户发出交易的次数, 从 0 开始递增，同一账户的交易会被依次确认，所以同一个 nonce 代表是同一个交易，会优先选择 price 更高的交易。</p><blockquote><p>这是我们的</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TxPool <span class="keyword">struct</span> &#123;</span><br><span class="line">    mtx           sync.RWMutex</span><br><span class="line">    config      TxPoolConfig</span><br><span class="line">    currentState  *state.StateDB <span class="comment">// 区块的当前状态</span></span><br><span class="line">    locals  *accountSet <span class="comment">//本地交易</span></span><br><span class="line">    journal *txJournal  <span class="comment">//  用于存储local交易记录的文件</span></span><br><span class="line"></span><br><span class="line">pending <span class="keyword">map</span>[common.Address]*txList   <span class="comment">// 存放可执行的交易</span></span><br><span class="line">queue   <span class="keyword">map</span>[common.Address]*txList   <span class="comment">// queued存放未来的、当前无法执行的交易</span></span><br><span class="line"></span><br><span class="line">    chainHeadSub    event.Subscription<span class="comment">//用于订阅区块</span></span><br><span class="line">    reqPromoteCh    <span class="keyword">chan</span> *accountSet<span class="comment">//账户集合</span></span><br><span class="line">queueTxEventCh  <span class="keyword">chan</span> *dag.Tx<span class="comment">//Tx队列事件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TxPoolConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">Locals    []common.Address</span><br><span class="line">Journal   <span class="keyword">string</span></span><br><span class="line">Rejournal time.Duration</span><br><span class="line"></span><br><span class="line">AccountSlots <span class="keyword">uint64</span></span><br><span class="line">GlobalSlots  <span class="keyword">uint64</span></span><br><span class="line">AccountQueue <span class="keyword">uint64</span></span><br><span class="line">GlobalQueue  <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">Lifetime time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DefaultTxPoolConfig = TxPoolConfig&#123;</span><br><span class="line">Journal:   <span class="string">&quot;transactions.rlp&quot;</span>,</span><br><span class="line">Rejournal: time.Hour,</span><br><span class="line"></span><br><span class="line">AccountSlots: <span class="number">16</span>,</span><br><span class="line">GlobalSlots:  <span class="number">8192</span>,</span><br><span class="line">AccountQueue: <span class="number">64</span>,</span><br><span class="line">GlobalQueue:  <span class="number">1024</span>,</span><br><span class="line"></span><br><span class="line">Lifetime: <span class="number">3</span> * time.Hour,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当节点收到交易（本地节点发起的或 peer 广播来的）时，会先存放到 queued，txpool 在某些情况下，把 queued 中可执行的交易，转移到 pending 中。</p><ul><li>Locals: 定义了一组视为 local 交易的账户地址。任何来自此清单的交易均被视为 local 交易。</li><li>Journal： 存储 local 交易记录的文件名，默认是./transactions.rlp。</li><li>Rejournal：定期将 local 交易存储文件中的时间间隔。默认为每小时一次。</li><li>AccountSlots： 当交易池中可执行交易（是已在等待矿工打包的交易）量超标时，允许每个账户可以保留在交易池最低交易数。默认值是 16 笔。</li><li>GlobalSlots： 交易池中所允许的可执行交易量上限，高于上限时将释放部分交易。默认是 8192 笔交易。</li><li>AccountQueue：交易池中单个账户非可执行交易上限，默认是 64 笔。</li><li>GlobalQueue： 交易池中所有非可执行交易上限，默认 1024 笔。</li><li>Lifetime： 允许 remote 的非可执行交易可在交易池存活的最长时间。交易池每分钟检查一次，一旦发现有超期的 remote 账户，则移除该账户下的所有非可执行交易。默认为 3 小时。</li></ul><h2 id="链状态"><a href="#链状态" class="headerlink" title="链状态"></a>链状态</h2><p>在交易池启动后，将订阅链的区块头事件：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/tx_pool.go:274</span></span><br><span class="line">pool.chainHeadSub = pool.chain.SubscribeChainHeadEvent(pool.chainHeadCh)</span><br></pre></td></tr></table></figure><p>并开始监听新事件：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/tx_pool.go:305</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="comment">// Handle ChainHeadEvent</span></span><br><span class="line">   <span class="keyword">case</span> ev := &lt;-pool.chainHeadCh:</span><br><span class="line">      <span class="keyword">if</span> ev.Block != <span class="literal">nil</span> &#123;</span><br><span class="line">         pool.mu.Lock()</span><br><span class="line">         <span class="keyword">if</span> pool.chainconfig.IsHomestead(ev.Block.Number()) &#123;</span><br><span class="line">            pool.homestead = <span class="literal">true</span></span><br><span class="line">         &#125;</span><br><span class="line">         pool.reset(head.Header(), ev.Block.Header())</span><br><span class="line">         head = ev.Block</span><br><span class="line"></span><br><span class="line">         pool.mu.Unlock()</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收到事件后，将执行 func (pool *TxPool) reset(oldHead, newHead *types.Header)方法更新 state 和处理交易。核心是将交易池中已经不符合要求的交易删除并更新整理交易</p><h2 id="本地交易"><a href="#本地交易" class="headerlink" title="本地交易"></a>本地交易</h2><p>在交易池中将交易标记为 local 的有多种用途：</p><ol><li>在本地磁盘存储已发送的交易。这样，本地交易不会丢失，重启节点时可以重新加载到交易池，实时广播出去。</li><li>可以作为外部程序和以太坊沟通的一个渠道。外部程序只需要监听文件内容变化，则可以获得交易清单。</li><li>local 交易可优先于 remote 交易。对交易量的限制等操作，不影响 local 下的账户和交易。</li></ol><p>对应本地交易存储，在启动交易池时根据配置开启本地交易存储能力：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/tx_pool.go:264</span></span><br><span class="line"><span class="keyword">if</span> !config.NoLocals &amp;&amp; config.Journal != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">pool.journal = newTxJournal(config.Journal)</span><br><span class="line"><span class="keyword">if</span> err := pool.journal.load(pool.AddLocals); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Warn(<span class="string">&quot;Failed to load transaction journal&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并从磁盘中加载已有交易到交易池。在新的 local 交易进入交易池时，将被实时写入 journal 文件。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// core/tx_pool.go:757</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *TxPool)</span> <span class="title">journalTx</span><span class="params">(from common.Address, tx *types.Transaction)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> pool.journal == <span class="literal">nil</span> || !pool.locals.contains(from) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> err := pool.journal.insert(tx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Warn(<span class="string">&quot;Failed to journal local transaction&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上可看到，<strong>只有属于 local 账户的交易才会被记录</strong>。你又没有注意到，如果仅仅是这样的话，journal 文件是否会跟随本地交易而无限增长？答案是否定的，<strong>虽然无法实时从 journal 中移除交易。但是支持定期更新 journal 文件</strong>。<br><strong>journal 并不是保存所有的本地交易以及历史</strong>，他<strong>仅仅是存储当前交易池中存在的本地交易</strong>。因此交易池会定期对 journal 文件执行 rotate，将交易池中的本地交易写入 journal 文件，并丢弃旧数据。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">journal := time.NewTicker(pool.config.Rejournal)</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//core/tx_pool.go:353</span></span><br><span class="line"><span class="keyword">case</span> &lt;-journal.C:</span><br><span class="line"><span class="keyword">if</span> pool.journal != <span class="literal">nil</span> &#123;</span><br><span class="line">pool.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> err := pool.journal.rotate(pool.local()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Warn(<span class="string">&quot;Failed to rotate local tx journal&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">pool.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="新交易信号"><a href="#新交易信号" class="headerlink" title="新交易信号"></a>新交易信号</h2><p>文章开头，有提到<strong>进入交易池的交易将被广播到网络</strong>中。这<strong>是依赖于交易池支持外部订阅新交易事件信号</strong>。任何<strong>订阅此事件的子模块</strong>，在交易池出现新的可执行交易时，均可实时接受到此事件通知，并获得新交易信息。</p><blockquote><p>需要注意的是并非所有进入交易池的交易均被通知外部，而是只有交易从非可执行状态变成可执行状态后才会发送信号。</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core/tx_pool.go:705</span></span><br><span class="line"><span class="keyword">go</span> pool.txFeed.Send(NewTxsEvent&#123;types.Transactions&#123;tx&#125;&#125;)</span><br><span class="line"><span class="comment">//core/tx_pool.go:1022</span></span><br><span class="line"><span class="keyword">go</span> pool.txFeed.Send(NewTxsEvent&#123;promoted&#125;)</span><br></pre></td></tr></table></figure><p>在交易池中，有两处地方才会执行发送信号。<br>一是<strong>交易时用于替换已经存在的可执行交易</strong>时。<br>二是有<strong>新的一批交易从非可执行状态提升到可执行状态后</strong>。<br>外部只需要订阅 SubscribeNewTxsEvent(ch chan&lt;- NewTxsEvent)新可执行交易事件，则可实时接受交易。<br>在 geth 中网络层将<strong>订阅交易事件</strong>，以便实时广播。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eth/handler.go:213</span></span><br><span class="line">pm.txsCh = <span class="built_in">make</span>(<span class="keyword">chan</span> core.NewTxsEvent, txChanSize)</span><br><span class="line">pm.txsSub = pm.txpool.SubscribeNewTxsEvent(pm.txsCh)</span><br><span class="line"><span class="comment">//eth/handler.go:781</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *ProtocolManager)</span> <span class="title">txBroadcastLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> event := &lt;-pm.txsCh:</span><br><span class="line">         pm.BroadcastTxs(event.Txs)</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外是矿工实时订阅交易，以便将交易打包到区块中。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//miner/worker.go:207</span></span><br><span class="line">worker.txsSub = eth.TxPool().SubscribeNewTxsEvent(worker.txsCh)</span><br><span class="line"><span class="comment">//miner/worker.go:462</span></span><br><span class="line">txs := <span class="built_in">make</span>(<span class="keyword">map</span>[common.Address]types.Transactions)</span><br><span class="line"><span class="keyword">for</span> _, tx := <span class="keyword">range</span> ev.Txs &#123;</span><br><span class="line">acc, _ := types.Sender(w.current.signer, tx)</span><br><span class="line">   txs[acc] = <span class="built_in">append</span>(txs[acc], tx)</span><br><span class="line">&#125;</span><br><span class="line">txset := types.NewTransactionsByPriceAndNonce(w.current.signer, txs)</span><br><span class="line">w.commitTransactions(txset, coinbase, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><h1 id="清理交易池"><a href="#清理交易池" class="headerlink" title="清理交易池"></a>清理交易池</h1><p>交易池是完全存在内存中的，因此有大小限制，每当超过一定的阈值就需要清理。实际实现时，pending 的缓冲区容量默认为 4096，queue 的缓冲区容量默认为 1024。<br>清理的时机是交易池满的时候，清理的原则是价格较低的最先清理</p><blockquote><p>但是本项目没有设计要清理交易池</p></blockquote><h1 id="惩罚恶意账号"><a href="#惩罚恶意账号" class="headerlink" title="惩罚恶意账号"></a>惩罚恶意账号</h1><p>这也是 txpool 很重要的一个属性，可以防止恶意账户以发起大量垃圾交易。防止恶意用户造成：</p><ol><li>占用 txpool 空间</li><li>浪费节点大量内存和 CPU</li><li>降低打包性能</li></ol><p>** 只有当交易的总数量超过缓冲区大小时，txpool 才会认为有恶意账户发起大量交易。**pending 和 queued 缓冲区大小不同，但处理策略类似：</p><ol><li>pending 的缓冲区容量是 4096，当 pending 的交易数量多于此时，就会运行检查，每个账号的交易数量是否多于 16，把这些账号搜集出来，进行循环依次清理，什么意思呢？就是每轮只删除（移动到 queued）这些账号的每个账号 1 条交易，然后看数量是否降下来了，不满足再进行下一轮，直到满足。</li><li>queued 的缓冲区容量是 1024，超过之后清理策略和 pending 差不多，但这里可是真删除了。</li></ol><p>该部分功能未抽象成单独的函数，而是在 promoteExecutables()中，就是在每次把 queued 交易转移到 pending 后执行的。<br><strong>本地交易的特权</strong>，txpool 虽然对交易有诸多限制，但如果交易是本节点的账号发起的，以上数量限制等都对他无效。所以，如果你用本节点账号不停的发送交易，并不会被认为是攻击者</p><h1 id="回答问题"><a href="#回答问题" class="headerlink" title="回答问题"></a>回答问题</h1><ol><li>用户发起的交易请求（不论以何种方式）是如何转变为实际的交易的；</li></ol><p>所有与交易请求相关的参数被赋值到一个结构体中，然后进行序列化转变为可存储和传输的形式，最后生成交易并进行签名</p><ol start="2"><li>产生的交易如果不能被及时处理，是如何进入交易池的？</li></ol><p>最终是调用一个 add 函数，添加到了一个队列里</p><ol start="3"><li>本地产生的交易和从网络中接收到的交易进入交易池是否有区别？</li></ol><p>有区别，底层都是调用 add 函数</p><ol start="4"><li>交易池的基本数据结构是怎么样的（优先队列？）</li></ol><p>交易池是一个结构体，核心是 pending 和 queue 两个 map，map 的键是一个地址，值是一个交易链表形成的队列</p><ol start="5"><li>从交易池中提取交易进行打包时顺序是怎么样的（调度算法）</li></ol><p>本地优先级大于远程交易</p><p>我们可以理解为区块链底层利用交易池对并发产生的请求做了<strong>异步化</strong>，<strong>交易产生的时刻</strong>和<strong>交易被打包的时刻</strong>是<strong>随机</strong>的。</p><blockquote><p>在实现 TXpool 的时候为了保证数据的一致性会使用大量的锁</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;既然要从头搭建一个区块链网络，交易池是绕不开的一个核心底层。对于它，以下几个问题是需要解决的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户发起的交易请求（不论以何种方式）是如何转变为实际的交易的；&lt;/li&gt;
&lt;li&gt;产生的交易如果不能被及时处理，是如何进入交易池的；&lt;/li&gt;
&lt;li&gt;本地产生的交易和从网络中接收到的交易进入交易池是否有区别；&lt;/li&gt;
&lt;li&gt;交易池的基本数据结构是怎么样的（优先队列？）&lt;/li&gt;
&lt;li&gt;从交易池中提取交易进行打包时顺序是怎么样的（调度算法）&lt;blockquote&gt;
&lt;p&gt;网络中很多文章提到内存池，指的就是是 txpool&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Life-Weekly-April-12-to-18</title>
    <link href="https://www.blog.hackerjerry.top/2021/04/15/Life-Weekly-April-12-to-18_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/04/15/Life-Weekly-April-12-to-18_new/</id>
    <published>2021-04-15T11:14:09.000Z</published>
    <updated>2021-05-06T13:04:00.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时讯"><a href="#时讯" class="headerlink" title="时讯"></a>时讯</h1><ol><li>日本宣布将把福岛核废水排放入海，还恬不知耻的推出了一个“氚”的吉祥物。</li><li>中科大夏令营开始接收报名。</li></ol><h1 id="小事"><a href="#小事" class="headerlink" title="小事"></a>小事</h1><ol><li>无聊的时候（吃完饭）给自己测了一下十六型人格，结果是“守卫者 ISFJ-A”，看了一下这个结果其实是比较准确的。</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Life-Weekly-April-12-to-18-1.png#clientId=ud3d92086-9aed-4&from=paste&height=341&id=ue2cb8370&margin=%5Bobject%20Object%5D&originHeight=804&originWidth=890&originalType=binary&size=46588&status=done&style=none&taskId=ud08b7ea8-50e0-4be0-846f-ac42bda13b9&width=377"><br>根据报告，守卫者人格在群体中所占比重最大，为 13%，不过我记得之前也做过这个测试，但是忘记结果了，我记得自己截了图，但是怎么也找不到，也不知道发到哪个平台了。<br>不过它描述的和我的人格真的非常像，摘抄一点：</p><blockquote><p><em>“守卫者”是真正的利他主义者，非常善良，对相信的人和事物慷慨而富有激情。</em></p></blockquote><p>这种人格类型的人（尤其是性格不安定的那一部分）经常<strong>一丝不苟到完美主义</strong>的程度，虽然他们<strong>有拖延的习惯</strong>，但他们总能<strong>可靠地按时完成工作</strong>。 守卫者人格类型的人重视自己的责任，时刻<strong>尽最大努力超出预期</strong>地让别人满意，无论在家庭还是工作中。<br><strong>天生喜欢社交</strong>是内向者身上少见的特点，“守卫者”们不会把出色的记忆力用在数据和琐事上，而是<strong>记住人和他们生活中的细节</strong>。 他们最<strong>擅长赠送礼物</strong>，他们<strong>天生富有想象力</strong>且<strong>感情细腻</strong>，他们的礼物可以送到接收者的心坎里。 对于被“守卫者”们当作朋友的同事们来说是这样，而在家庭里守卫者们会<strong>尽情表达爱意</strong>。<br><strong>弱点：</strong></p><ol><li>谦卑和害羞</li><li>压抑他们的感情</li><li>他们强烈的责任感和完美主义，加上这种对情感冲突的厌恶，造成了一种情况，即捍卫者太容易超载自己</li><li>太利他主义了，他们的麻烦却在无人协助的情况下增加。</li></ol><p>恋爱：</p><ol><li>守卫者花费大量时间和精力寻找让伴侣保持关系满意的方法。</li><li>作为回报，他们要求的就是承诺、爱，也许最重要的是欣赏。</li></ol><h1 id="本周收藏"><a href="#本周收藏" class="headerlink" title="本周收藏"></a>本周收藏</h1><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p>看到了哪些好文？</p><ol><li><a href="https://mp.weixin.qq.com/s/aj6LKXdAekoFCoSrpEwbAQ">攻破 GitHub 私有页面</a></li></ol><p>利用一个前缀绕过进行 XSS，利用缓存投毒进行认证流的持久化破坏。</p><ol start="2"><li><a href="https://mp.weixin.qq.com/s/k1ZRhTmNMgfaLCqniBmuNA">一篇有参考意义的产品 PPT 制作</a></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Life-Weekly-April-12-to-18-2.png#clientId=u49d79466-a36b-4&from=paste&height=239&id=uebef2f08&margin=%5Bobject%20Object%5D&originHeight=478&originWidth=852&originalType=binary&size=426622&status=done&style=none&taskId=ue23c0b44-6f1e-4c86-90c5-b20e1e6bff1&width=426"></p><ol start="3"><li><a href="https://mp.weixin.qq.com/s/__-d28S1X6CfpgiB3TwrTw">一位博士学长在大厂做安全算法工程师的感悟</a></li><li><a href="https://mp.weixin.qq.com/s/wDMcm4Q_waE3twkI-oajYg">基于机器学习的 Web 应用入侵威胁检测</a></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Life-Weekly-April-12-to-18-3.png#clientId=u49d79466-a36b-4&from=paste&height=427&id=u7c7b4016&margin=%5Bobject%20Object%5D&originHeight=854&originWidth=338&originalType=binary&size=44182&status=done&style=none&taskId=u3fa9a8b8-057c-4d41-9333-36f34a4d393&width=169"></p><ol start="5"><li><a href="https://mp.weixin.qq.com/s/fqYbyKKAXCrR8ooE_jNFdA">一篇对于处理多文字的 PPT 范例</a></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Life-Weekly-April-12-to-18-4.png#clientId=u49d79466-a36b-4&from=paste&height=401&id=uaedf9eeb&margin=%5Bobject%20Object%5D&originHeight=479&originWidth=851&originalType=binary&size=550925&status=done&style=none&taskId=ueb2143a6-5ef6-475a-aaf5-e9d206c1886&width=712.5"></p><ol start="6"><li><a href="https://mp.weixin.qq.com/s/elKxcNiwW14ceJOWiek2Ww">一篇关于毛玻璃效果的 PPT</a></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Life-Weekly-April-12-to-18-5.png#clientId=u49d79466-a36b-4&from=paste&height=242&id=ub988f9f1&margin=%5Bobject%20Object%5D&originHeight=483&originWidth=862&originalType=binary&size=179871&status=done&style=none&taskId=u45a7c337-9928-4762-93a2-20bb7020f3b&width=431"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Life-Weekly-April-12-to-18-6.png#clientId=u49d79466-a36b-4&from=paste&height=241&id=u603599ae&margin=%5Bobject%20Object%5D&originHeight=482&originWidth=848&originalType=binary&size=311473&status=done&style=none&taskId=uf73bcf00-d57c-4f2a-9c25-5d3b17036a9&width=424"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Life-Weekly-April-12-to-18-7.png#clientId=u49d79466-a36b-4&from=paste&height=212&id=u907476e8&margin=%5Bobject%20Object%5D&originHeight=424&originWidth=854&originalType=binary&size=507600&status=done&style=none&taskId=u4abc5901-834f-464a-9dcd-5c065781745&width=427"></p><h2 id="剧集"><a href="#剧集" class="headerlink" title="剧集"></a>剧集</h2><ol><li>《人潮汹涌》</li></ol><p>刘德华和肖央出演的一部本土改编剧，情节和原著有了一些变动，也很有趣。不过戏剧性冲突比韩国的原片还是要差一点，那个曾九蓉更是看的我云里雾里的，没看懂她存在的意义。笑点是比不上原著的，毕竟刘德华太帅了，很难表现出原著中“丑杀手”的一些搞笑的地方。 2.《 伍六七》第七集<br>伍六七终于到玄武国了，但是这都第七集了！！！一共就十集看个寂寞，估计这一季他连掌门的影子都见不到，还又挖了一堆坑，又是可乐，又是悬赏令，又是陈年旧账，何导可以的啊！！</p><h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><ol><li>踏实一点，不要着急，你想要的岁月都会给你。</li><li>寂寞会发慌，孤独则是饱满的。–蒋勋</li><li>人间忽晚，山河已秋。</li></ol><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><ol><li>面试的技巧–见 flomo</li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li>从朋友圈看到的：如果有人一开始就对你表示出超乎寻常的喜爱，那么他也一定会在某天返给你极其的恨意。他心里曾经爱慕的和现在痛恨的，都和你没有关系，那只是他的想象。很有道理，值得反复思考和践行。</li><li>毛姆的《巨匠与杰作》中有这样一段话：<strong>不对别人期待太多</strong>，从一开始就应该认识到，每个人的主要兴趣都是他自身；无论在哪方面，付出才有回报，不管是地位、财富、荣誉、爱情，皆为如此。而且所谓智慧，很大程度上是，<strong>对某个事物的付出不要超出其真正价值</strong>。</li></ol><p>由于平时（白天）交流较少，经常性出现情感溢出的现象，即对特定的人付出超过其身份的感情，但依旧很难表现出来，就这样憋在心里，造成不必要的情绪波动。需要改正。</p><ol start="3"><li>“你的心意过头了，反而会让人为难。”敲不开的门，一直敲是不礼貌的。感情中尤为如此，本就是你情我愿，遇见了，感谢，错过了，坦然。毕竟离开是常态，彼此喜欢是上天恩赐。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;时讯&quot;&gt;&lt;a href=&quot;#时讯&quot; class=&quot;headerlink&quot; title=&quot;时讯&quot;&gt;&lt;/a&gt;时讯&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;日本宣布将把福岛核废水排放入海，还恬不知耻的推出了一个“氚”的吉祥物。&lt;/li&gt;
&lt;li&gt;中科大夏令营开始接收报名。&lt;/li&gt;
</summary>
      
    
    
    
    <category term="周报" scheme="https://www.blog.hackerjerry.top/categories/%E5%91%A8%E6%8A%A5/"/>
    
    
    <category term="周报" scheme="https://www.blog.hackerjerry.top/tags/%E5%91%A8%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Basic-scientific-research-series-1-Pseudo-code-specifications</title>
    <link href="https://www.blog.hackerjerry.top/2021/04/15/Basic-scientific-research-series-1-Pseudo-code-specifications_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/04/15/Basic-scientific-research-series-1-Pseudo-code-specifications_new/</id>
    <published>2021-04-15T09:21:58.000Z</published>
    <updated>2021-05-06T13:04:16.969Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下科研论文中的伪代码。<br>转自：<a href="https://shuzang.github.io/2021/pseudocode-specification/">https://shuzang.github.io/2021/pseudocode-specification/</a></p><a id="more"></a><h2 id="伪代码规范"><a href="#伪代码规范" class="headerlink" title="伪代码规范"></a>伪代码规范</h2><p>伪代码是一种接近自然语言的算法描述形式，其目的是在不涉及具体实现（各种编程语言）的情况下将算法的流程和含义清楚的表达出来，因此它没有一个统一的规范，有的仅仅是在长期的实践过程中形成的一些约定俗成的表达样式。下图是一个简单的例子<a href="https://shuzang.github.io/2021/pseudocode-specification/#fn:1">1</a>，但已经包含了大多数主要元素<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Basic-scientific-research-series-1-Pseudo-code-specifications-1.png#clientId=u7f037a6a-77db-4&from=paste&height=380&id=u70552d91&margin=%5Bobject%20Object%5D&originHeight=759&originWidth=668&originalType=url&status=done&style=none&taskId=uef2d862d-a2fb-4d0c-9f58-61f5f43f3ea&width=334"><br>首先需要一个<strong>标题</strong>来描述整个算法，一般还会有一个与之一起的编号。在上图中，算法的标题为「Acesscontrol algorithm flow」，编号为「Algorithm 1」。标题与编号一般位于算法顶部，但也有人放在底部，编号多按全文的算法总数进行索引，但也可以按章节分别进行索引。<br>其次，在正式的算法流之前需要声明<strong>输入和输出</strong>。通常使用关键字 Input 和 Output 来声明，但也有人使用关键字 Data 和 Result。<br>顺序、选择与循环结构是算法的主体。通常，不同的程序块使用缩进来保持结构清晰，但也有不少人使用垂直连接线进行进一步划分，如上图。另外，和编程语言类似，伪代码中的选择和循环使用 if-then-else、while-do 和 for-do 等关键字和结构来描述<a href="https://shuzang.github.io/2021/pseudocode-specification/#fn:2">2</a>，举例如下，其中，每个程序块结束的 end 关键字有人选择写，也有人选择不写。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Basic-scientific-research-series-1-Pseudo-code-specifications-2.png#clientId=u7f037a6a-77db-4&from=paste&height=461&id=u980d4514&margin=%5Bobject%20Object%5D&originHeight=922&originWidth=1121&originalType=url&status=done&style=none&taskId=uebf9d8c3-b7d5-4640-bb35-d608225f8f0&width=560.5"><br>算法流程结构<br>赋值操作一般使用左箭头「&lt;—」表示。A[i] 用来表示数组 A 的第 i 个元素，A[1…j] 则表示下标从 1 到 j 的子数组；函数调用使用函数名+传入参数的形式；返回值使用 return 关键字，这些都和常规编程语言相同。需要注意的是，未声明而使用的变量都可以视为算法内的局部变量，如果是全局变量则需要进行解释，可以在上下文中，也可以使用注释；注释的形式也和传统语言相同，使用 // 或 /<em>……</em>/。<br>算法整体通常使用三线框包围，但也有少部分人使用一个完整的框。<br>伪代码的语句一般不需要在末尾使用分号，但行首通常会添加行号。</p><h2 id="2-LaTeX-包"><a href="#2-LaTeX-包" class="headerlink" title="2. LaTeX 包"></a>2. LaTeX 包</h2><p>latex 书写伪代码主要有三种排版格式：algorithm+algorithmic、algorithm+algorithmicx 以及 algorithm2e<a href="https://shuzang.github.io/2021/pseudocode-specification/#fn:3">3</a>。我们使用<a href="https://www.ctan.org/pkg/algorithm2e">algorithm2e</a>，它提供了垂直连接线，可以去掉 end 关键字，而且写起来更像编程语言，用着非常舒服。<br>引入 algorithm2e 包使用如下语句</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">[options]</span><span class="string">&#123;algorithm2e&#125;</span></span></span><br></pre></td></tr></table></figure><p>几个重要的 options 如下</p><ol><li>ruled：让标题显示在上面，默认会显示到最下面；</li><li>vlined：默认启用垂直连接线；</li><li>linesnumbered：让算法显示行号，不包括 input 和 output 部分；</li><li>noend：程序块结束不打印 end。</li></ol><p>常用命令如下<a href="https://shuzang.github.io/2021/pseudocode-specification/#fn:4">4</a><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Basic-scientific-research-series-1-Pseudo-code-specifications-3.png#clientId=u7f037a6a-77db-4&from=paste&height=372&id=u452ff8fa&margin=%5Bobject%20Object%5D&originHeight=743&originWidth=974&originalType=binary&size=52982&status=done&style=none&taskId=u7814261f-55f6-48b7-b9ab-bede03ce98b&width=487"><br>一个官方的例子如下</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;algorithm&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">SetKwData</span><span class="string">&#123;Left&#125;</span><span class="string">&#123;left&#125;</span></span><span class="tag">\<span class="name">SetKwData</span><span class="string">&#123;This&#125;</span><span class="string">&#123;this&#125;</span></span><span class="tag">\<span class="name">SetKwData</span><span class="string">&#123;Up&#125;</span><span class="string">&#123;up&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">SetKwFunction</span><span class="string">&#123;Union&#125;</span><span class="string">&#123;Union&#125;</span></span><span class="tag">\<span class="name">SetKwFunction</span><span class="string">&#123;FindCompress&#125;</span><span class="string">&#123;FindCompress&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">SetKwInOut</span><span class="string">&#123;Input&#125;</span><span class="string">&#123;input&#125;</span></span><span class="tag">\<span class="name">SetKwInOut</span><span class="string">&#123;Output&#125;</span><span class="string">&#123;output&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">Input</span><span class="string">&#123;A bitmap $Im$ of size $w\times l$&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">Output</span><span class="string">&#123;A partition of the bitmap&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">BlankLine</span></span></span><br><span class="line"><span class="tag">\<span class="name">emph</span><span class="string">&#123;special treatment of the first line&#125;</span></span><span class="tag">\<span class="name">;</span></span></span><br><span class="line"><span class="tag">\<span class="name">For</span><span class="string">&#123;$i\leftarrow 2$ \KwTo $l$&#125;</span><span class="string">&#123;</span></span></span><br><span class="line"><span class="tag"><span class="string">\emph&#123;special treatment of the first element of line $i$&#125;</span></span><span class="tag">\<span class="name">;</span></span></span><br><span class="line"><span class="tag">\<span class="name">For</span><span class="string">&#123;$j\leftarrow 2$ \KwTo $w$&#125;</span><span class="string">&#123;\label&#123;forins&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">Left</span></span><span class="formula">$<span class="tag">\<span class="name">leftarrow</span></span>$</span> <span class="tag">\<span class="name">FindCompress</span><span class="string">&#123;$Im[i,j-1]$&#125;</span></span><span class="tag">\<span class="name">;</span></span></span><br><span class="line"><span class="tag">\<span class="name">Up</span></span><span class="formula">$<span class="tag">\<span class="name">leftarrow</span></span>$</span> <span class="tag">\<span class="name">FindCompress</span><span class="string">&#123;$Im[i-1,]$&#125;</span></span><span class="tag">\<span class="name">;</span></span></span><br><span class="line"><span class="tag">\<span class="name">This</span></span><span class="formula">$<span class="tag">\<span class="name">leftarrow</span></span>$</span> <span class="tag">\<span class="name">FindCompress</span><span class="string">&#123;$Im[i,j]$&#125;</span></span><span class="tag">\<span class="name">;</span></span></span><br><span class="line"><span class="tag">\<span class="name">If</span></span>(<span class="tag">\<span class="name">tcp*</span><span class="string">[h]</span><span class="string">&#123;O(\Left,\This)==1&#125;</span></span>)&#123;<span class="tag">\<span class="name">Left</span></span> compatible with <span class="tag">\<span class="name">This</span></span>&#125;&#123;<span class="tag">\<span class="name">label</span><span class="string">&#123;lt&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">lIf</span><span class="string">&#123;\Left $&lt;$ \This&#125;</span><span class="string">&#123;\Union&#123;\Left,\This&#125;</span></span>&#125;</span><br><span class="line"><span class="tag">\<span class="name">lElse</span><span class="string">&#123;\Union&#123;\This,\Left&#125;</span></span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">\<span class="name">If</span></span>(<span class="tag">\<span class="name">tcp*</span><span class="string">[f]</span><span class="string">&#123;O(\Up,\This)==1&#125;</span></span>)&#123;<span class="tag">\<span class="name">Up</span></span> compatible with <span class="tag">\<span class="name">This</span></span>&#125;&#123;<span class="tag">\<span class="name">label</span><span class="string">&#123;ut&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">lIf</span><span class="string">&#123;\Up $&lt;$ \This&#125;</span><span class="string">&#123;\Union&#123;\Up,\This&#125;</span></span>&#125;</span><br><span class="line"><span class="tag">\<span class="name">tcp</span><span class="string">&#123;\This is put under \Up to keep tree as flat as possible&#125;</span></span><span class="tag">\<span class="name">label</span><span class="string">&#123;cmt&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">lElse</span><span class="string">&#123;\Union&#123;\This,\Up&#125;</span></span>&#125;<span class="tag">\<span class="name">tcp*</span><span class="string">[h]</span><span class="string">&#123;\This linked to \Up&#125;</span></span><span class="tag">\<span class="name">label</span><span class="string">&#123;lelse&#125;</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">\<span class="name">lForEach</span><span class="string">&#123;element $e$ of the line $i$&#125;</span><span class="string">&#123;\FindCompress&#123;p&#125;</span></span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">\<span class="name">caption</span><span class="string">&#123;disjoint decomposition&#125;</span></span><span class="tag">\<span class="name">label</span><span class="string">&#123;algo_disjdecomp&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;algorithm&#125;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>渲染后的样式如下<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Basic-scientific-research-series-1-Pseudo-code-specifications-4.png#clientId=u7f037a6a-77db-4&from=paste&height=310&id=u6b501371&margin=%5Bobject%20Object%5D&originHeight=619&originWidth=911&originalType=url&status=done&style=none&taskId=u55db2441-adb1-4199-95e7-79ec5ef27e2&width=455.5"><br>注：当前算法选然后条件语句会带有下划线，主要是因为同时使用了 \ulem 包，产生了冲突，去掉该包即可</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一下科研论文中的伪代码。&lt;br&gt;转自：&lt;a href=&quot;https://shuzang.github.io/2021/pseudocode-specification/&quot;&gt;https://shuzang.github.io/2021/pseudocode-specification/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>SPECTRE-Coding</title>
    <link href="https://www.blog.hackerjerry.top/2021/04/11/SPECTRE-Coding_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/04/11/SPECTRE-Coding_new/</id>
    <published>2021-04-11T09:46:39.000Z</published>
    <updated>2021-05-06T13:04:33.557Z</updated>
    
    <content type="html"><![CDATA[<p>虽然这个 paper 可能不是个能 work 的（有很多地方比较牵强，不稳定，且无任何项目声明实现了它），但既然老师要求了，只好硬着头皮上了。</p><a id="more"></a><h1 id="借鉴"><a href="#借鉴" class="headerlink" title="借鉴"></a>借鉴</h1><p>根据经验，我决定先学习一下现有项目中各种共识协议的编写。<br>pow-原理很简单，就是工作量证明，故不用看。<br>pos-选举人制度，具体原理还是可以了解一下的。</p><h2 id="pos–账本共识"><a href="#pos–账本共识" class="headerlink" title="pos–账本共识"></a>pos–账本共识</h2><p>切记，PoS 不是一种确定的定义（算法)，而是一种概念，因此对于不同的平台来说，可以有不同的 PoS 实现。<br>以太坊使用 GHOST，贪婪最重可观察子树协议，作为其分叉选择规则。在 GHOST 协议中，获得投票数最高的分叉将被选为链头（将每个分叉区块及其各自子区块的所有票数计入考虑）。<br>与最长链规则相比， <strong>GHOST 的优点在于能够在网络延迟较高时降低攻击效率，同时最小化链重组的深度</strong>。原因是即使攻击者能够高效地在其分叉链上继续产生区块，尝试使该链成为最长链，GHOST 也会选择另一条票数更高的分叉链。</p><h2 id="pow–挖矿共识"><a href="#pow–挖矿共识" class="headerlink" title="pow–挖矿共识"></a>pow–挖矿共识</h2><p><a href="https://www.yuque.com/docs/share/f47edbdb-8ca4-411b-b78c-1f0ea772ac2c#O7vbh">https://www.yuque.com/docs/share/f47edbdb-8ca4-411b-b78c-1f0ea772ac2c#O7vbh</a><br>挖矿可以设计一个动态调整难度的函数<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/SPECTRE-Coding-1.png#height=790&id=CCHi2&originHeight=790&originWidth=930&originalType=binary&status=done&style=none&width=930"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/SPECTRE-Coding-2.png#height=448&id=Lw1nX&originHeight=448&originWidth=836&originalType=binary&status=done&style=none&width=836"></p><h1 id="SPECTRE"><a href="#SPECTRE" class="headerlink" title="SPECTRE"></a>SPECTRE</h1><p>根据它的伪代码我写了一个 demo,看起来还不错。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Vote</span><span class="params">(node1 *dag.Blocknode, node2 *dag.Blocknode, graph *Graph)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">voteOfnode1 := <span class="number">0</span></span><br><span class="line">voteOfnode2 := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历全局图</span></span><br><span class="line">Graph := graph</span><br><span class="line"><span class="comment">//这里graph一开始要传dag.Graph这个全局图，之后可以传past集或者future集</span></span><br><span class="line"><span class="keyword">for</span> k, z := <span class="keyword">range</span> Graph.nodes &#123;</span><br><span class="line">_, ok1 := Graph.getFuture(node1)[k]</span><br><span class="line">_, ok2 := Graph.getFuture(node2)[k]</span><br><span class="line"><span class="keyword">if</span> ok1 &amp;&amp; !ok2 &#123;</span><br><span class="line">voteOfnode1 += <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> !ok1 &amp;&amp; ok2 &#123;</span><br><span class="line">voteOfnode2 += <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ok1 &amp;&amp; ok2 &#123;</span><br><span class="line"><span class="comment">//取决于past(z)的投票结果</span></span><br><span class="line">tem1, tem2 := Vote(node1, node2, Graph.getPast(z))</span><br><span class="line"><span class="keyword">if</span> tem1 &gt; tem2 &#123;</span><br><span class="line">voteOfnode1 += <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">voteOfnode2 += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> !ok1 &amp;&amp; !ok2 &#123;</span><br><span class="line"><span class="comment">//z的投票结果取决于future(z)的投票结果</span></span><br><span class="line">tem1, tem2 := Vote(node1, node2, getFutureToGraph(Graph.getFuture(z)))</span><br><span class="line"><span class="keyword">if</span> tem1 &gt; tem2 &#123;</span><br><span class="line">voteOfnode1 += <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">voteOfnode2 += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> z == node1 &#123;</span><br><span class="line">voteOfnode1 += <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> z == node2 &#123;</span><br><span class="line">voteOfnode2 += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> voteOfnode1, voteOfnode2</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;虽然这个 paper 可能不是个能 work 的（有很多地方比较牵强，不稳定，且无任何项目声明实现了它），但既然老师要求了，只好硬着头皮上了。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>wireshark抓包原理</title>
    <link href="https://www.blog.hackerjerry.top/2021/04/10/wireshark%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/04/10/wireshark%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86_new/</id>
    <published>2021-04-10T02:43:22.000Z</published>
    <updated>2021-05-06T13:00:14.390Z</updated>
    
    <content type="html"><![CDATA[<p>这几天学院研究生复试，院长出了这道题，就是问了 wireshark 的抓包原理，由于我并不太清楚，所以特此记录。</p><a id="more"></a><h2 id="Wireshark"><a href="#Wireshark" class="headerlink" title="Wireshark"></a>Wireshark</h2><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/wireshark%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86-1.jpeg#align=left&display=inline&height=463&margin=%5Bobject%20Object%5D&originHeight=463&originWidth=1102&size=0&status=done&style=none&width=1102"></p><p>网络上传输的数据包<strong>通过网卡进入到网络协议分析器系统</strong>。即<strong>Wireshark 使用的网卡数据复制，只要是经过指定网卡都会被抓取</strong>。<br>  每一个协议分析器内部都维护有一个“<strong>跟踪缓冲区</strong>”内存空间区域。它用于<strong>暂存从网络上面复制而来的数据包流</strong>。数据包流从“捕获过滤器”流入到协议分析器的跟踪缓存区中，该缓冲区中的数据包能够在被捕获之后立即查看或是以其他文件格式保持到磁盘上面。比如 Wireshark 协议分析器工具，打开之后，点击[开始捕获]， 然后便可立刻查看捕获到的数据包信息。此时的这些数据包就是放在协议分析器的“跟踪缓冲区”中的。<br>协议分析器所使用的网卡和网卡驱动程序必须能够支持“<strong>混杂模式操作</strong>（Promiscuous Mode Operation）”。因为<strong>只有运行在混杂模式下的网卡才能够捕获到网络中传输到其他设备的“广播数据包、多播数据包、单播数据包以及错误数据包等等”（</strong>支持 VLAN ,单播，多播等），两者一起协同工作。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/wireshark%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86-2.png#align=left&display=inline&height=375&margin=%5Bobject%20Object%5D&name=image.png&originHeight=461&originWidth=814&size=234125&status=done&style=none&width=662" alt="image.png"></p><h3 id="混杂模式与监视模式区别"><a href="#混杂模式与监视模式区别" class="headerlink" title="混杂模式与监视模式区别"></a>混杂模式与监视模式区别</h3><p>要弄清混杂模式和监视模式之间的区别：<strong>监视模式仅用于无线卡</strong>，<strong>混杂模式用于无线和有线</strong>。 监控模式使卡无需关联接入点即可侦听无线数据包。 混杂模式使卡可以侦听所有数据包，即使不是针对特定的数据包。</p><blockquote><p>作者：圣手书生黎公子<br>链接：<a href="https://zhuanlan.zhihu.com/p/267640786">https://zhuanlan.zhihu.com/p/267640786</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><h1 id="ping-流程"><a href="#ping-流程" class="headerlink" title="ping 流程"></a>ping 流程</h1><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/wireshark%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86-3.png#align=left&display=inline&height=265&margin=%5Bobject%20Object%5D&name=image.png&originHeight=265&originWidth=642&size=114805&status=done&style=none&width=642" alt="image.png"><br>在这里，我们搭建了一个 PC+交换机+路由器（文中又称网关）的本地网络</p><p>在一开始，所有机器的 arp 表其实都是空的。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/wireshark%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86-4.png#align=left&display=inline&height=429&margin=%5Bobject%20Object%5D&name=image.png&originHeight=523&originWidth=828&size=203088&status=done&style=none&width=679" alt="image.png"><br>而此时，让 PC 去进行 ping（使用 ICMP 协议）自己的网关 192.168.1.1，是可以通的。<br>为什么呢？<br>我们分析一下流程。</p><ol><li>PC 首先封装这个 ICMP 数据包，最里面是 ICMP 的数据，数据外面封装 IPV4 包头，IPV4 包头外面是帧头。格式如下：</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/wireshark%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86-5.png#align=left&display=inline&height=219&margin=%5Bobject%20Object%5D&name=image.png&originHeight=438&originWidth=1550&size=714203&status=done&style=none&width=775" alt="image.png"></p><ol start="2"><li>有个问题是，刚开始 ping 的时候，PC 的 ARP 表项是不知道目的 IP 所对应的 MAC 是多少，那么他怎么获取的呢。</li></ol><p>仔细看数据抓包，有一对 ARP 包：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/wireshark%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86-6.png#align=left&display=inline&height=215&margin=%5Bobject%20Object%5D&name=image.png&originHeight=430&originWidth=1547&size=653510&status=done&style=none&width=773.5" alt="image.png"><br>就是在发 ICMP 包之前，系统先发了一个 ARP 包！<br>上面的 ARP 请求包大概意思是：我是 192.168.1.99，我的 MAC 是 aabb.cc00.3000，我想问 192.168.1.1 你的 MAC 是多少，收到请回复收到请回复。<br>在 ARP 请求的过程中，SW 已经学到了 PC 和 R1 的接口 MAC 地址，MAC 地址表项已经形成。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/wireshark%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86-7.png#align=left&display=inline&height=148&margin=%5Bobject%20Object%5D&name=image.png&originHeight=295&originWidth=747&size=233011&status=done&style=none&width=373.5" alt="image.png"><br>那么，他是怎么形成的呢？<br>第一步：<br>当 SW 通过 e0/0 端口收到 PC 发来的 ARP 广播包，PC 首先查看自己的 MAC 地址表项，看看数据帧的源 MAC 是否存在于我的 MAC 地址表中，如果没有，那么就直接把 ARP 广播包的源 MAC（aabb.cc00.3000）和接收端口 e0/0 对应起来，形成第一个 MAC 地址表的条目。如果有对应的 MAC 地址条目，SW 就看已经存在的条目和当前的收包端口是否一致，如果不一致就更新 MAC 地址表里面的条目，如果一致就直接泛洪转发这个广播数据帧。<br>第二步：SW 通过 e0/1 端口把这个数据帧发给 R1，R1 收到之后，形成 ARP 表项。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/wireshark%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86-8.png#align=left&display=inline&height=62&margin=%5Bobject%20Object%5D&name=image.png&originHeight=124&originWidth=1131&size=180774&status=done&style=none&width=565.5" alt="image.png"><br>R1 拆开外面帧头看到目的 MAC 是自己（广播包本网段内所有人均可接收），R1 就继续拆包，拆开 ARP 头部，看到请求的 MAC 是自己的 IP 地址对应的 MAC，所以 R1 就响应这个 ARP 得请求包。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/wireshark%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86-9.png#align=left&display=inline&height=150&margin=%5Bobject%20Object%5D&name=image.png&originHeight=299&originWidth=1066&size=320679&status=done&style=none&width=533" alt="image.png"><br>第三步：响应的 ARP Reply 包发送到 SW 的 e0/1 口，SW1 把单播响应包源 MAC（aabb.cc00.1000）和自己的接收端口 e0/1 口对应起来，形成另外一条 MAC 地址表条目，然后查看到数据帧的目的 MAC 是 aabb.cc00.3000，SW 直接查找自己的 MAC 地址表，发现有对应的条目，直接通过 e0/0 口转发，PC 就收到了响应，获取到了 R1 的 e0/0 接口，也就是 PC 网关的 MAC。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这几天学院研究生复试，院长出了这道题，就是问了 wireshark 的抓包原理，由于我并不太清楚，所以特此记录。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>机器学习之随机森林</title>
    <link href="https://www.blog.hackerjerry.top/2021/04/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/04/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97_new/</id>
    <published>2021-04-09T12:33:30.000Z</published>
    <updated>2021-05-06T13:12:57.327Z</updated>
    
    <content type="html"><![CDATA[<p>这里记录一下 AI 作品赛里接触到的随机森林算法。</p><a id="more"></a><h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><p>随机森林由许多决策树（decision tree）组成，我们可以将决策树视为一系列关于数据的是/否问题，从而最终得出一个预测类别（或回归情况下的连续值）。 这是一个可解释的模型，因为它非常像我们人类进行分类的过程：在我们做出决定之前（在理想世界中），我们会对可用数据进行一系列的询问。<br>当我们训练决策树时到底发生了什么？可视化可以帮助我们更好地理解决策树，这可以通过 Scikit-Learn 的一个功能来实现（详细信息，请查看 notebook 或这篇文章）。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97-1.png#align=left&display=inline&height=732&margin=%5Bobject%20Object%5D&name=image.png&originHeight=732&originWidth=837&size=369303&status=done&style=none&width=837" alt="image.png"><br>除叶子节点（彩色终端节点）外，所有节点都有 5 个部分：</p><ul><li>基于某个特征的一个值对数据进行的提问，每个提问都有一个真或假的答案可以分裂节点。根据答案，数据点相应地向下移动。</li><li><strong>gini：</strong>节点的 Gini 不纯度。当我们沿着树向下移动时，平均加权基尼不纯度会减少。</li><li><strong>samples</strong>：节点中的观测数据数量。</li><li><strong>value：</strong>每个类中的样本数。例如，根节点中有 2 个样本属于类 0，有 4 个样本属于类 1。</li><li><strong>class：</strong>该节点中大多数点的分类。在叶节点中，即是对节点中所有样本的预测。</li></ul><p><strong>决策树的特征选择</strong>一般有 3 种量化方法：<strong>信息增益、信息增益率、基尼指数</strong>。</p><h2 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h2><p>在信息论中，<strong>熵</strong>表示随机变量不确定性的度量。假设随机变量 X 有有限个取值，取值 <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1618020812451-b0b3a075-5dcb-42d8-bf97-78aa34e4b86e.svg#align=left&display=inline&height=18&margin=%5Bobject%20Object%5D&originHeight=18&originWidth=19&size=0&status=done&style=none&width=19"> 对应的概率为 <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1618020812589-b6f620aa-d6a0-4990-8de0-93dcf01f721e.svg#align=left&display=inline&height=18&margin=%5Bobject%20Object%5D&originHeight=18&originWidth=19&size=0&status=done&style=none&width=19"> ，则 X 的熵定义为：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97-2.svg#align=left&display=inline&height=62&margin=%5Bobject%20Object%5D&originHeight=62&originWidth=196&size=0&status=done&style=none&width=196"><br>如果某件事<strong>一定发生</strong>（太阳东升西落）或<strong>一定不发生</strong>（钓鱼岛是日本的），则概率为 1 或 0，对应的<strong>熵均为 0</strong>。<br>如果某件事可能发生可能不发生（天要下雨，娘要嫁人），概率介于 0 到 1 之间，熵大于 0。<br>由此可见，<strong>熵越大，随机性越大，结果越不确定</strong>。<br>我们再来看一看<strong>条件熵</strong> <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1618020812831-53a78260-e1f7-4fe9-bd8b-1b6cbdd6d85d.svg#align=left&display=inline&height=26&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=74&size=0&status=done&style=none&width=74"> ，<strong>表示引入随机变量 Y 对于消除 X 不确定性的程度</strong>。假如 X、Y 相互独立，则 X 的条件熵和熵有相同的值；否则条件熵一定小于熵。<br>明确了这两个概念，理解信息增益就比较方便了。现在我们有一份数据集 D（例如贷款信息登记表）和特征 A（例如年龄），则<strong>A 的信息增益就是 D 本身的熵与特征 A 给定条件下 D 的条件熵之差</strong>，即：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97-3.svg#align=left&display=inline&height=26&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=248&size=0&status=done&style=none&width=248"><br>数据集 D 的熵是一个常量。信息增益越大，表示条件熵 <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1618020812738-fffb9065-834c-444d-9a51-8881c89e799f.svg#align=left&display=inline&height=26&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=74&size=0&status=done&style=none&width=74"> 越小，A 消除 D 的不确定性的功劳越大。<br>所以要<strong>优先选择信息增益大的特征，它们具有更强的分类能力。</strong>由此生成决策树，称为<strong>ID3 算法</strong>。</p><h2 id="信息增益率"><a href="#信息增益率" class="headerlink" title="信息增益率"></a><strong>信息增益率</strong></h2><p>当某个特征具有多种候选值时，信息增益容易偏大，造成误差。引入信息增益率可以校正这一问题。<br>信息增益率 <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1618020812748-d95f3fa5-1a2f-4372-ad0b-78d11ef80423.svg#align=left&display=inline&height=18&margin=%5Bobject%20Object%5D&originHeight=18&originWidth=23&size=0&status=done&style=none&width=23"> 为信息增益与数据集 D 的熵之比：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97-4.svg#align=left&display=inline&height=59&margin=%5Bobject%20Object%5D&originHeight=59&originWidth=186&size=0&status=done&style=none&width=186"><br>同样，我们<strong>优先选择信息增益率最大的特征，</strong>由此生成决策树，称为<strong>C4.5 算法。</strong><br>**</p><h2 id="基尼不纯度（Gini-Impurity）"><a href="#基尼不纯度（Gini-Impurity）" class="headerlink" title="基尼不纯度（Gini Impurity）"></a><strong>基尼不纯度（Gini Impurity）</strong></h2><p>节点的基尼不纯度是指，根据节点中样本的分布对样本分类时，从节点中随机选择的样本被分错的概率。<br>如，在根节点中，根据节点中的样本标签有 44.4％的可能性错误地对某个随机选择的数据点进行分类。可以      使用以下等式得出这个值：</p><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97-5.png#align=left&display=inline&height=56&margin=%5Bobject%20Object%5D&originHeight=242&originWidth=757&size=0&status=done&style=none&width=176"><br>节点 n 的基尼不纯度是<strong>1 减去每个类（二元分类任务中是 2）的样本比例的平方和</strong>。</p><p>例如根节点的基尼不纯度：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97-6.png#align=left&display=inline&height=73&margin=%5Bobject%20Object%5D&originHeight=73&originWidth=1080&size=0&status=done&style=none&width=1080"></p><p>在每个节点，决策树要在所有特征中搜索用于拆分的值，从而可以<strong>最大限度地减少基尼不纯度</strong>。（拆分节点的另一个<strong>替代方法</strong>是使用<strong>信息增益</strong>）。<br>然后，它以贪婪递归的过程重复这种拆分，直到达到最大深度，或者每个节点仅包含同类的样本。<br>树每层的加权总基尼不纯度（每个节点的基尼不纯度按照该节点中来自父节点的点的比例进行加权）一定是减少的。在树的第二层，总加权基尼不纯度值为 0.333：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97-7.png#align=left&display=inline&height=58&margin=%5Bobject%20Object%5D&name=image.png&originHeight=77&originWidth=845&size=17368&status=done&style=none&width=641" alt="image.png"><br>最终，最后一层的加权总基尼不纯度变为 0，也意味着每个节点都是完全纯粹的，从节点中随机选择的点不会被错误分类。虽然这一切看起来挺好的，但这意味着模型可能过拟合，因为所有节点都是仅仅使用训练数据构建的。</p><h2 id="决策树剪枝"><a href="#决策树剪枝" class="headerlink" title="决策树剪枝"></a>决策树剪枝</h2><p>决策树生成算法递归产生一棵决策树，直到结束划分。什么时候结束呢？</p><ul><li>样本属于同一种类型</li><li>没有特征可以分割</li></ul><p>这样得到的决策树往往对训练数据分类非常精准，但是对于未知数据表现比较差。<br>原因在于基于训练集构造的决策树过于复杂，产生过拟合。所以需要对决策树简化，砍掉多余的分支，提高泛化能力。<br>决策树剪枝一般有两种方法：</p><ul><li><strong>预剪枝</strong>：在树的生成过程中剪枝。<strong>基于贪心策略，可能造成局部最优</strong></li><li><strong>后剪枝</strong>：等树全部生成后剪枝。<strong>运算量较大，但是比较精准</strong></li></ul><p>决策树剪枝往往通过<strong>极小化决策树整体的损失函数实现</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97-8.png#align=left&display=inline&height=281&margin=%5Bobject%20Object%5D&name=image.png&originHeight=561&originWidth=731&size=122786&status=done&style=none&width=365.5" alt="image.png"><br>假设树 T 有|T|个叶子节点，某一个叶子节点 t 上有 <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1618021002264-6488bff2-9519-4ecc-bbdd-6f2f86c34189.svg#align=left&display=inline&height=23&margin=%5Bobject%20Object%5D&originHeight=23&originWidth=24&size=0&status=done&style=none&width=24"> 个样本，其中 k 类的样本有 <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1618021002341-9e586245-0eb4-43f1-ab4b-e9d2f1514bd9.svg#align=left&display=inline&height=23&margin=%5Bobject%20Object%5D&originHeight=23&originWidth=32&size=0&status=done&style=none&width=32"> 个，<img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1618021002330-b42005d2-d60f-4e39-927c-852a31a4810e.svg#align=left&display=inline&height=26&margin=%5Bobject%20Object%5D&originHeight=26&originWidth=56&size=0&status=done&style=none&width=56"> 为叶子节点 t 的熵， <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1618021002461-670ab097-97d8-4674-b83a-a27eed267988.svg#align=left&display=inline&height=21&margin=%5Bobject%20Object%5D&originHeight=21&originWidth=52&size=0&status=done&style=none&width=52"> 是参数，则决策树的<strong>损失函数</strong>定义为：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97-9.svg#align=left&display=inline&height=69&margin=%5Bobject%20Object%5D&originHeight=69&originWidth=264&size=0&status=done&style=none&width=264"><br>其中熵为：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97-10.svg#align=left&display=inline&height=57&margin=%5Bobject%20Object%5D&originHeight=57&originWidth=246&size=0&status=done&style=none&width=246"><br><strong>损失函数第一项为训练误差，第二项为模型复杂度，</strong>用参数 <img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/svg/1629942/1618021002545-b6955ef3-85ad-4594-9a5e-f5a27be46475.svg#align=left&display=inline&height=15&margin=%5Bobject%20Object%5D&originHeight=15&originWidth=13&size=0&status=done&style=none&width=13"> 来衡量二者的比重。</p><h2 id="CART-算法"><a href="#CART-算法" class="headerlink" title="CART 算法"></a>CART 算法</h2><p>CART 表示分类回归决策树，同样由特征选择、树的生成及剪枝组成，可以处理分类和回归任务。<br>相比之下，<strong>ID3 和 C4.5 算法只能处理分类任务</strong>。<br>CART 假设决策树是二叉树，内部结点特征的取值为“是”和“否”，依次递归地二分每个特征。<br><strong>CART 对回归树采用平方误差最小化准则，对分类树用基尼指数最小化准则</strong>。</p><h2 id="过拟合–为什么森林比一棵树更好"><a href="#过拟合–为什么森林比一棵树更好" class="headerlink" title="过拟合–为什么森林比一棵树更好"></a>过拟合–为什么森林比一棵树更好</h2><p><strong>因为这棵树是在训练数据上没有犯错，我们没有限制最大深度（树的层数），因此泛化能力差。</strong><br>过拟合发生在当我们有一个非常灵活的模型（模型具有高能力）时，其本质上是通过紧密拟合来记住训练数据。这样的问题是模型不仅学到了训练数据中的实际关系，还学习了存在的噪声。灵活的模型具有高方差<strong>（variance）</strong>，因为学到的参数（例如决策树的结构）将随着训练数据的不同而变化很大。</p><p>当我们<strong>不限制最大深度时决策树容易过拟合的原因</strong>是它<strong>具有无限的灵活性</strong>，这意味着它可以持续生长，直到它为每个单独的观察点都生成一个叶节点，<strong>达到完美地分类</strong>。<br>如果返回到之前决策树的图像并将最大深度限制为 2（仅进行一次拆分），则分类不再 100％正确。我们减少了决策树的方差，但代价是增加了偏差。<br><strong>限制树的深度</strong>可以<strong>减少方差（好）</strong>并且<strong>增加偏差（坏）</strong>，一种替代方案是，我们可以将许多决策树组合成一个称为随机森林的集成模型（ensemble model）。</p><h1 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h1><p>我们将<strong>使用 CART 决策树作为弱学习器的 bagging 方法称为随机森林</strong>。<br>bagging 是一种在原始数据集上，通过<strong>有放回抽样</strong>分别选出 k 个新数据集，来训练分类器的集成算法。分类器之间没有依赖关系。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97-11.png#align=left&display=inline&height=162&margin=%5Bobject%20Object%5D&name=image.png&originHeight=323&originWidth=799&size=117004&status=done&style=none&width=399.5" alt="image.png"><br>随机森林是由许多决策树组成的模型。这个模型不是简单地平均所有树（我们可以称之为“森林”）的预测，而是使用了两个关键概念，名字中的随机二字也是由此而来：</p><ul><li>在构建树时对训练数据点进行随机抽样</li><li>分割节点时考虑特征的随机子集</li></ul><h2 id="随机抽样训练观测数据"><a href="#随机抽样训练观测数据" class="headerlink" title="随机抽样训练观测数据"></a><strong>随机抽样训练观测数据</strong></h2><p>在训练时，随机森林中的<strong>每棵树</strong>都会<strong>从数据点的随机样本中学习</strong>。<strong>样本被有放回的抽样</strong>，称为<strong>自助抽样法</strong>（<strong>bootstrapping</strong>），这意味着<strong>一些样本将在一棵树中被多次使用</strong>。背后的<strong>想法</strong>是<strong>在不同样本上训练每棵树，尽管每棵树相对于特定训练数据集可能具有高方差，但总体而言，整个森林将具有较低的方差，同时不以增加偏差为代价。</strong><br>在测试时，通过<strong>平均每个决策树的预测</strong>来进行预测。这种<strong>在不同的自助抽样数据子集上训练单个学习器，然后对预测进行平均的过程称为 bagging</strong>，是 bootstrap aggregating 的缩写。</p><h2 id="用于拆分节点的随机特征子集"><a href="#用于拆分节点的随机特征子集" class="headerlink" title="用于拆分节点的随机特征子集"></a><strong>用于拆分节点的随机特征子集</strong></h2><p>随机森林中的另一个主要概念是，<strong>只考虑所有特征的一个子集来拆分每个决策树中的每个节点</strong>。通常将<strong>其设置为 sqrt（n_features）</strong>以进行分类，这意味着<strong>如果有 16 个特征</strong>，则在<strong>每个树中的每个节点处</strong>，<strong>只考虑 4 个随机特征</strong>来拆分节点。（随机森林也可以在每个节点处考虑所有的特征，如回归中常见的那样。这些选项可以在 Scikit-Learn Random Forest 的实现中控制）。<br>如果你能理解一棵单独的决策树，bagging 的理念，以及随机的特征子集，那么你对随机森林的工作方式也就有了很好的理解：</p><p>随机森林将成百上千棵决策树组合在一起，在略微不同的观察集上训练每个决策树，在每棵树中仅考虑有限数量的特征来拆分节点。&gt; <strong>随机森林的最终预测是通过平均每棵树的预测来得到的</strong>。</p><p>想理解为什么随机森林优于单一的决策树，请想象以下场景：你要判断特斯拉的股票是否上涨，现在你身边有十几位对该公司都没有先验知识的分析师。每个分析师都有较低的偏见，因为他们没有任何假设，并且可以从新闻报道的数据集中学习。<br>这似乎是一个理想的情况，但问题是报道中除了真实的信号外也可能包含噪音。 因为分析师们完全根据数据做出预测，即他们具有很高的灵活性，也就意味着他们可能会被无关的信息所左右。分析师们可能会从同一数据集中得出不同的预测。此外，如果提供不同的报道训练集，每个分析师都有高方差，并得出截然不同的预测。<br>解决方案是不依赖于任何一个人，而是汇集每个分析师的投票。此外，与随机森林一样，允许每个分析师仅使用一部分报道，并希望通过采样来消除噪声信息的影响。在现实生活中，我们也依赖于多种信息来源（从不信任亚马逊的单独评论），因此，不仅决策树的思想很直观，而且将它们组合在一起成为随机森林的想法同样如此。</p><h2 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h2><p>由于随机性，<strong>随机森林对于降低模型方差效果显著</strong>。故随机森林一般不需要额外剪枝，就能取得较好的泛化性能。</p><p>相对而言，模型对于训练集的拟合程度就会差一些，相比于基于 boosting 的 GBDT 模型，偏差会大一些。</p><p>另外，<strong>随机森林中的树一般会比较深，以尽可能地降低偏差；而 GBDT 树的深度会比较浅，通过减少模型复杂度来降低方差</strong>。</p><p>最后，我们总结一下随机森林都有哪些优点：</p><ul><li>采用了集成算法，精度优于大多数单模型算法</li><li>在测试集上表现良好，两个随机性的引入降低了过拟合风险</li><li>树的组合可以让随机森林处理非线性数据</li><li>训练过程中能检测特征重要性，是常见的<strong>特征筛选</strong>方法</li><li>每棵树可以同时生成，并行效率高，训练速度快</li><li>可以自动处理缺省值</li></ul><h1 id="模型评价"><a href="#模型评价" class="headerlink" title="模型评价"></a>模型评价</h1><p>AUC(area under the curve)是 ROC 曲线下的面积。所以，在理解 AUC 之前，要先了解 ROC 是什么。而 ROC 的计算又需要借助混淆矩阵。</p><blockquote><p>AUC 是一个从 0（最差）到 1（最佳）的度量值，</p></blockquote><p>我们还可以绘制单个决策树（顶部）和随机森林（底部）的 ROC 曲线。<strong>靠近左上角的曲线代表着更好的模型：</strong><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97-12.png#align=left&display=inline&height=271&margin=%5Bobject%20Object%5D&name=image.png&originHeight=542&originWidth=777&size=81703&status=done&style=none&width=388.5" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这里记录一下 AI 作品赛里接触到的随机森林算法。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>BlockDAG从零到一</title>
    <link href="https://www.blog.hackerjerry.top/2021/04/02/BlockDAG%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/04/02/BlockDAG%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80_new/</id>
    <published>2021-04-02T12:04:25.000Z</published>
    <updated>2021-05-06T13:02:08.262Z</updated>
    
    <content type="html"><![CDATA[<p>加油！</p><a id="more"></a><h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><ul><li><p>DAG</p><ul><li>SPECTRE<ul><li>snapshot.go–生成快照</li><li>vote.go–投票</li><li>log.go–记录日志</li></ul></li><li>accepttxs.go–维持可信交易集</li><li>blockdag.go–主程序</li><li>difficulty.go–动态调整 pow 困难度</li><li>error.go–错误信息</li><li>log.go–日志信息</li><li>process.go–将区块加入链？或者称检查块的合法性</li></ul></li><li><p>minner</p><ul><li>pow.go–工作量证明</li><li>worker.go</li></ul></li><li><p>account</p><ul><li>user.go–用户相关，身份认定，发送交易</li></ul></li><li><p>bloom</p><ul><li>timebloom.go–时间布隆过滤器</li><li>rangebloom.go–范围布隆过滤器</li></ul></li><li><p>p2pnet</p><ul><li>libp2p–p2p 网络对等节点发现</li></ul></li><li><p>mempool–内存池</p></li><li><p>crypto–密码学模块</p><ul><li>pkcs12–引用 gmsm <a href="https://github.com/tjfoc/gmsm">https://github.com/tjfoc/gmsm</a> 好像性能有点问题？ 这里有另外一个<a href="https://github.com/rongzer/gm">https://github.com/rongzer/gm</a> 看情况吧</li><li>sm2<ul><li>p256.go</li><li>sm2.go</li><li>utils.go</li></ul></li><li>sm3<ul><li>sm3.go</li><li>ifile</li></ul></li><li>sm4<ul><li>sm4.go</li><li>sm4_gcm.go</li><li>utils.go</li></ul></li></ul></li><li><p>database-存储 <a href="https://github.com/vldmkr/merkle-patricia-trie">https://github.com/vldmkr/merkle-patricia-trie</a></p><ul><li><p>mpt</p><ul><li>node.go</li><li>tire.go</li><li>type.go</li></ul></li><li><p>storage</p><ul><li>adapter.go</li><li>leveldb.go</li><li>memory.go</li></ul></li><li><p>database.go–利用 leveldb 存储交易（MPT），在区块中只存储根节点 hsha。</p></li><li><p>merkletire.go–MPT 树存储</p></li><li><p>可以先尝试安装<a href="https://github.com/soteria-dag/soterd/tree/master/database">https://github.com/soteria-dag/soterd/tree/master/database</a>，看看能不能保存交易</p></li></ul></li></ul><h1 id="p2pnet"><a href="#p2pnet" class="headerlink" title="p2pnet"></a>p2pnet</h1><p><a href="https://segmentfault.com/a/1190000018590682">区块链中的 P2P</a><br><a href="https://www.shangmayuan.com/a/61258d114131449994f5278e.html">使用 Go 语言编写区块链 P2P 网络</a>–项目：<a href="https://github.com/nosequeldeebee/blockchain-tutorial/blob/master/p2p/main.go">https://github.com/nosequeldeebee/blockchain-tutorial/blob/master/p2p/main.go</a><br><a href="https://github.com/Blockchain-CN/blockchain">https://github.com/Blockchain-CN/blockchain</a> –实现了对等协议的<br><a href="https://bbbob.win/b6edc29f/">利用 go-libp2p 实现在区块链上的 p2p</a>–里面目录分的挺清楚的</p><h1 id="mempool"><a href="#mempool" class="headerlink" title="mempool"></a>mempool</h1><p><a href="https://learnblockchain.cn/books/geth/part2/txpool/txpool.html">以太坊交易池架构设计</a>–这一系列很全<br><a href="https://blog.csdn.net/loy_184548/article/details/86178255">【区块链】比特币学习 - 4 - 交易池</a><br><a href="https://segmentfault.com/a/1190000017333194">以太坊源码分析：交易缓冲池 txpool</a><br><a href="https://github.com/lianxiangcloud/linkchain/tree/release/v0.1.3/mempool">https://github.com/lianxiangcloud/linkchain/tree/release/v0.1.3/mempool</a><br><a href="https://www.jianshu.com/p/521a0926303a">btcd 源码分析系列：6 - mempool</a><br><a href="https://github.com/wupeaking/tendermint_code_analysis/blob/master/Mempool%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md">Mempool 源码分析</a><br><a href="https://github.com/letsfire/factory">https://github.com/letsfire/factory</a> –单纯的内存池，而非交易池<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/BlockDAG%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80-1.png#align=left&display=inline&height=299&margin=%5Bobject%20Object%5D&name=image.png&originHeight=598&originWidth=1303&size=258120&status=done&style=none&width=651.5" alt="image.png"><br>说实话，这个有点难，可能暂时不考虑实现了。</p><h1 id="account"><a href="#account" class="headerlink" title="account"></a>account</h1><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/BlockDAG%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80-2.png#align=left&display=inline&height=288&margin=%5Bobject%20Object%5D&name=image.png&originHeight=576&originWidth=626&size=139030&status=done&style=none&width=313" alt="image.png"><br>来自白皮书：<a href="https://www.lianxiangcloud.com/static/download/%E4%BA%AB%E4%BA%91%E9%93%BE%E7%99%BD%E7%9A%AE%E4%B9%A61.0.pdf">享云链白皮书 1.0</a><br><a href="https://learnblockchain.cn/books/geth/part3/sign-and-valid.html">签名与校验</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;加油！&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>GO开发指南</title>
    <link href="https://www.blog.hackerjerry.top/2021/04/02/GO%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/04/02/GO%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97_new/</id>
    <published>2021-04-02T01:17:05.000Z</published>
    <updated>2021-05-06T13:00:22.142Z</updated>
    
    <content type="html"><![CDATA[<p>记录在进行 go 语言开发遇到的各种问题。</p><a id="more"></a><h1 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h1><h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><p>文件命名一律采用小写，不用驼峰式，尽量见名思义，看见文件名就可以知道这个文件下的大概内容。<br>其中测试文件以<em>test.go 结尾，除测试文件外，命名不出现</em>。<br>例子：</p><blockquote><p>stringutil.go， stringutil_test.go</p></blockquote><h3 id="package"><a href="#package" class="headerlink" title="package"></a>package</h3><p>包名用小写,使用短命名,尽量和标准库不要冲突。<br>包名统一使用单数形式。</p><p>在 go 源文件的开头必须申明文件所属的 package，如下所示：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> name</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="命名规范-1"><a href="#命名规范-1" class="headerlink" title="命名规范"></a>命名规范</h2><ul><li>建议 package 命名用小写字母</li><li>建议 packag<strong>e 命名必和其路径的最后一段一致</strong>（main package 除外）。注意，这并不是 Golang 的强制要求，文件目录只是用于存放同一个 package 的所有源文件，Golang 对目录名并无要求。但<strong>一个目录下不允许有多个 package 的源文件</strong>。</li><li>main package 中的 main 方法是可执行文件的入口，main package 名一般和路径名不一致</li><li>不同路径下 package 命名可以重复，但其完整路径名必须唯一</li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量命名一般采用驼峰式，当遇到特有名词（缩写或简称，如 DNS）的时候，特有名词根据是否私有全部大写或小写。<br>例子：</p><blockquote><p>apiClient、URLString</p></blockquote><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>单个函数的接口名以 er 为后缀</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="number">2.</span>     Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line"><span class="number">3.</span> &#125;</span><br></pre></td></tr></table></figure><p>两个函数的接口名综合两个函数名，如:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">type</span> WriteFlusher <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="number">2.</span> Write([]<span class="keyword">byte</span>) (<span class="keyword">int</span>, error)</span><br><span class="line"><span class="number">3.</span> Flush() error</span><br><span class="line"><span class="number">4.</span> &#125;</span><br></pre></td></tr></table></figure><p>三个以上函数的接口名类似于结构体名，如:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">type</span> Car <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="number">2.</span>     Start()</span><br><span class="line"><span class="number">3.</span>     Stop()</span><br><span class="line"><span class="number">4.</span>     Drive()</span><br><span class="line"><span class="number">5.</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法名应该是动词或动词短语，采用驼峰式。将功能及必要的参数体现在名字中， 不要嫌长， 如 updateById，getUserInfo.<br>如果是结构体方法，那么 Receiver 的名称应该缩写，一般使用一个或者两个字符作为 Receiver 的名称。如果 Receiver 是指针， 那么统一使用 p。 如：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">func</span> <span class="params">(f foo)</span> <span class="title">method</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="number">2.</span>     ...</span><br><span class="line"><span class="number">3.</span> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">func</span> <span class="params">(p *foo)</span> <span class="title">method</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="number">2.</span>     ...</span><br><span class="line"><span class="number">3.</span> &#125;</span><br></pre></td></tr></table></figure><p>对于 Receiver 命名应该统一， 要么都使用值， 要么都用指针。<br>每个以大写字母开头（即可以导出）的方法应该有注释，且以该函数名开头。如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. &#x2F;&#x2F; Get 会响应对应路由转发过来的 get 请求.</span><br><span class="line">2. func (c *Controller) Get() &#123;</span><br><span class="line">3.     ...</span><br><span class="line">4. &#125;</span><br></pre></td></tr></table></figure><p>大写字母开头的方法以为着是可供调用的公共方法，如果你的方法想只在本包内掉用，请以小写字母开发。如:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. func (c *Controller) curl() &#123;</span><br><span class="line">2.     ...</span><br><span class="line">3. &#125;</span><br></pre></td></tr></table></figure><p>注释应该用一个完整的句子，注释的第一个单词应该是要注释的指示符，以便在 godoc 中容易查找。<br>注释应该以一个句点 . 结束。</p><h1 id="各种报错"><a href="#各种报错" class="headerlink" title="各种报错"></a>各种报错</h1><p>【1】<strong>“与你运行的 Windows 版本不兼容“的解决方法</strong><br><a href="https://blog.csdn.net/willingtolove/article/details/107924423">https://blog.csdn.net/willingtolove/article/details/107924423</a><br>其实就是 package 名字错了，必须改成 main，不清楚为什么？<br>【2】每次创建新的项目都要<strong>重新设置一个 configuration 文件</strong>，后发现是我的问题，开发的时候，可以把所有的项目都在 goland 里打开，根目录就是$GOPATH,像这样：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/GO%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-1.png#align=left&display=inline&height=274&margin=%5Bobject%20Object%5D&name=image.png&originHeight=548&originWidth=431&size=24414&status=done&style=none&width=215.5" alt="image.png"><br>所有小项目都放在 src 里，是不是很棒？<br>但是！<strong>必须有 main 包</strong>，必须有 main 函数作为程序入口！<br>具体原理看：<br><a href="https://blog.csdn.net/zxy_666/article/details/80390843">https://blog.csdn.net/zxy_666/article/details/80390843</a><br><a href="https://zhuanlan.zhihu.com/p/69445822">如何写出优雅的 Golang 代码</a><br><a href="https://blog.csdn.net/CMbug/article/details/49339341">Golang import 包问题相关详解</a><br><a href="https://www.jianshu.com/p/b224982b6fd5">理解 Go 语言包(package)</a><br>【3】<strong>结构体属性导出问题</strong><br>结构体中的属性，如果是小写开头，是无法被跨包使用的，也就是说包外无法访问，太狗了。<br><a href="https://juejin.cn/post/6844903814168838151">Go Struct 超详细讲解</a> 建议好好看看这篇</p><h1 id="函数知识"><a href="#函数知识" class="headerlink" title="函数知识"></a>函数知识</h1><h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><p>make()函数在 golang 的代码如下：<br><code>func make(t Type,size IntegerType) Type</code><br>使用 make 来创建 slice，map，chanel 说明如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var slice_ []int = make([]int,5,10)</span><br><span class="line">fmt.Println(slice_)</span><br><span class="line">var slice_1 []int = make([]int,5)</span><br><span class="line">fmt.Println(slice_1)</span><br><span class="line">var slice_2 []int = []int&#123;1,2&#125;</span><br><span class="line">fmt.Println(slice_2)</span><br><span class="line">打印结果：</span><br><span class="line">[0 0 0 0 0]</span><br><span class="line">[0 0 0 0 0]</span><br><span class="line">[1,2]</span><br></pre></td></tr></table></figure><p>在创建 slice 时第一个参数用于确定初始化该 slice 的大小该 slice 中的值为零值，第三个参数用于确定该 slice 的长度<br>map：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var m_ map[string]int = make(map[string]int)</span><br><span class="line">m_[&quot;one&quot;] = 1</span><br><span class="line">fmt.Println(m_)</span><br><span class="line">var m map[string]int = map[string]int&#123;&quot;1&quot;:1&#125;</span><br><span class="line">m[&quot;2&quot;] = 2</span><br><span class="line">fmt.Println(m)</span><br><span class="line">打印结果：</span><br><span class="line">map[one:1]</span><br><span class="line">map[1:1 2:2]</span><br></pre></td></tr></table></figure><p>根据 size 大小来初始化分配内存，不过分配后的 map 长度为 0，如果 size 被忽略了，那么会在初始化分配内存时分配一个小尺寸的内存</p><h2 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h2><p>相信写过 Golang 的程序员对下面一段代码是非常非常熟悉的了：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// do something....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当出现不等于<code>nil</code>的时候，说明出现某些错误了，需要我们对这个错误进行一些处理，而如果等于<code>nil</code>说明运行正常。那什么是<code>nil</code>呢？查一下词典可以知道，<code>nil</code>的意思是无，或者是零值。零值，zero value，是不是有点熟悉？在 Go 语言中，如果你声明了一个变量但是没有对它进行赋值操作，那么这个变量就会有一个类型的默认零值。这是每种类型对应的零值：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span>      -&gt; <span class="literal">false</span></span><br><span class="line">numbers -&gt; <span class="number">0</span></span><br><span class="line"><span class="keyword">string</span>    -&gt; <span class="string">&quot;&quot;</span></span><br><span class="line">pointers -&gt; <span class="literal">nil</span></span><br><span class="line">slices -&gt; <span class="literal">nil</span></span><br><span class="line">maps -&gt; <span class="literal">nil</span></span><br><span class="line">channels -&gt; <span class="literal">nil</span></span><br><span class="line">functions -&gt; <span class="literal">nil</span></span><br><span class="line">interfaces -&gt; <span class="literal">nil</span></span><br></pre></td></tr></table></figure><p>举个例子，当你定义了一个 struct：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Person struct &#123;</span><br><span class="line">  AgeYears int</span><br><span class="line">  Name string</span><br><span class="line">  Friends []Person</span><br><span class="line">&#125;</span><br><span class="line">var p Person &#x2F;&#x2F; Person&#123;0, &quot;&quot;, nil&#125;</span><br></pre></td></tr></table></figure><p>变量<code>p</code>只声明但没有赋值，所以 p 的所有字段都有对应的零值。那么，这个<code>nil</code>到底是什么呢？Go 的文档中说到，_nil 是预定义的标识符，代表指针、通道、函数、接口、映射或切片的零值_，也就是预定义好的一个变量：</p><h2 id="slices"><a href="#slices" class="headerlink" title="slices"></a>slices</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nil slices</span></span><br><span class="line"><span class="keyword">var</span> s []slice</span><br><span class="line"><span class="built_in">len</span>(s)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">cap</span>(s)  <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> s  <span class="comment">// iterates zero times</span></span><br><span class="line">s[i]  <span class="comment">// panic: index out of range</span></span><br></pre></td></tr></table></figure><p>一个为<code>nil</code>的 slice，除了不能索引外，其他的操作都是可以的，当你需要填充值的时候可以使用<code>append</code>函数，slice 会自动进行扩充。那么为<code>nil</code>的 slice 的底层结构是怎样的呢？根据官方的文档，slice 有三个元素，分别是长度、容量、指向数组的指针：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/GO%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-2.png#align=left&display=inline&height=143&margin=%5Bobject%20Object%5D&name=image.png&originHeight=286&originWidth=601&size=27035&status=done&style=none&width=300.5" alt="image.png"><br>当有元素的时候，<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/GO%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-3.png#align=left&display=inline&height=133&margin=%5Bobject%20Object%5D&name=image.png&originHeight=266&originWidth=779&size=50465&status=done&style=none&width=389.5" alt="image.png"></p><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><blockquote><p>参考：<a href="https://colobu.com/2016/04/14/Golang-Channels/">https://colobu.com/2016/04/14/Golang-Channels/</a></p></blockquote><p>Channel 是 Go 中的一个核心类型，你可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯(communication)。<br>它的操作符是箭头  <strong>&lt;-</strong> 。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch &lt;- v    <span class="comment">// 发送值v到Channel ch中</span></span><br><span class="line">v := &lt;-ch  <span class="comment">// 从Channel ch中接收数据，并将数据赋值给v</span></span><br></pre></td></tr></table></figure><p>(箭头的指向就是数据的流向)<br>就像 map 和 slice 数据类型一样, channel 必须先创建再使用:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><h3 id="定义与用法"><a href="#定义与用法" class="headerlink" title="定义与用法"></a>定义与用法</h3><p>它包括三种类型的定义。可选的<code>&lt;-</code>代表 channel 的方向。如果没有指定方向，那么 Channel 就是双向的，既可以接收数据，也可以发送数据。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">chan</span> T          <span class="comment">// 可以接收和发送类型为 T 的数据</span></span><br><span class="line"><span class="keyword">chan</span>&lt;- <span class="keyword">float64</span>  <span class="comment">// 只可以用来发送 float64 类型的数据</span></span><br><span class="line">&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>      <span class="comment">// 只可以用来接收 int 类型的数据</span></span><br></pre></td></tr></table></figure><p>使用<code>make</code>初始化 Channel,并且可以设置容量:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>容量(capacity)代表 Channel 容纳的最多的元素的数量，代表 Channel 的缓存的大小。<br>如果没有设置容量，或者容量设置为 0, 说明 Channel 没有缓存，只有 sender 和 receiver 都准备好了后它们的通讯(communication)才会发生(Blocking)。<strong>如果设置了缓存，就有可能不发生阻塞</strong>， 只有 buffer 满了后 send 才会阻塞， 而只有缓存空了后 receive 才会阻塞。一个 nil channel 不会通信。<br>可以通过内建的<code>close</code>方法可以关闭 Channel。<br>你<strong>可以在多个 goroutine 从/往 一个 channel 中 receive/send 数据, 不必考虑额外的同步措施</strong>。<br>Channel 可以作为一个先入先出(FIFO)的队列，接收的数据和发送的数据的顺序是一致的。<br>channel 的 receive 支持  <em>multi-valued assignment</em>，如</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v, ok := &lt;-ch</span><br></pre></td></tr></table></figure><p>它可以用来检查 Channel 是否已经被关闭了。</p><h3 id="send"><a href="#send" class="headerlink" title="send"></a>send</h3><p>send 语句用来往 Channel 中发送数据， 如<code>ch &lt;- 3</code>。<br>它的定义如下:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">SendStmt = Channel <span class="string">&quot;&lt;-&quot;</span> Expression .</span><br><span class="line">Channel  = Expression .</span><br></pre></td></tr></table></figure><p>在通讯(communication)开始前 channel 和 expression 必选先求值出来(evaluated)，比如下面的(3+4)先计算出 7 然后再发送给 channel。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c &lt;- <span class="number">3</span> + <span class="number">4</span> &#125;()</span><br><span class="line">i := &lt;-c</span><br><span class="line">fmt.Println(i)</span><br></pre></td></tr></table></figure><p>send 被执行前(proceed)通讯(communication)一直被阻塞着。如前所言，无缓存的 channel 只有在 receiver 准备好后 send 才被执行。如果有缓存，并且缓存未满，则 send 会被执行。<br>往一个<strong>已经被 close 的 channel 中</strong>继续发送数据会导致<strong>run-time panic</strong>。<br><strong>往 nil channel 中发送数据会一致被阻塞</strong>着。</p><h3 id="receive"><a href="#receive" class="headerlink" title="receive"></a>receive</h3><p><code>&lt;-ch</code>用来从 channel ch 中接收数据，这个表达式会一直被 block,直到有数据可以接收。<br>从一个 nil channel 中接收数据会一直被 block。<br>从一个被 close 的 channel 中接收数据不会被阻塞，而是立即返回，接收完已发送的数据后会返回元素类型的零值(zero value)。<br>如前所述，你可以使用一个额外的返回参数来检查 channel 是否关闭。</p><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p>缺省情况下，发送和接收会一直阻塞着，直到另一方准备好。这种方式可以用来在 gororutine 中进行同步，而不必使用显示的锁或者条件变量。<br>如官方的例子中<code>x, y := &lt;-c, &lt;-c</code>这句会一直等待计算结果发送到 channel 中。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(s []<span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">sum += v</span><br><span class="line">&#125;</span><br><span class="line">c &lt;- sum <span class="comment">// send sum to c</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c)</span><br><span class="line"><span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c)</span><br><span class="line">x, y := &lt;-c, &lt;-c <span class="comment">// receive from c</span></span><br><span class="line">fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><p><code>for …… range</code>语句可以处理 Channel。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Hour)</span><br><span class="line">&#125;()</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i = i + <span class="number">1</span> &#123;</span><br><span class="line">c &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Finished&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>range c</code>产生的迭代值为 Channel 中发送的值，它会一直迭代直到 channel 被关闭。上面的例子中如果把<code>close(c)</code>注释掉，程序会一直阻塞在<code>for …… range</code>那一行。</p><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p><a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html">https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html</a><br>这个博客讲的挺好的，其他知识也有，可以常看看。<br>另外还有：<a href="https://sanyuesha.com/2017/07/23/go-defer/">https://sanyuesha.com/2017/07/23/go-defer/</a></p><h1 id="其他知识"><a href="#其他知识" class="headerlink" title="其他知识"></a>其他知识</h1><h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p><a href="https://www.cnblogs.com/wdliu/p/9272220.html">https://www.cnblogs.com/wdliu/p/9272220.html</a> 调度原理<br>代码示例：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cal</span><span class="params">(a <span class="keyword">int</span> , b <span class="keyword">int</span> )</span></span>  &#123;</span><br><span class="line">    c := a+b</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d + %d = %d\n&quot;</span>,a,b,c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;　　</span><br><span class="line">    <span class="keyword">for</span> i :=<span class="number">0</span> ; i&lt;<span class="number">10</span> ;i++&#123;</span><br><span class="line">        <span class="keyword">go</span> cal(i,i+<span class="number">1</span>)  <span class="comment">//启动10个goroutine 来计算</span></span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Second * <span class="number">2</span>) <span class="comment">// sleep作用是为了等待所有任务完成</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//8 + 9 = 17</span></span><br><span class="line"><span class="comment">//9 + 10 = 19</span></span><br><span class="line"><span class="comment">//4 + 5 = 9</span></span><br><span class="line"><span class="comment">//5 + 6 = 11</span></span><br><span class="line"><span class="comment">//0 + 1 = 1</span></span><br><span class="line"><span class="comment">//1 + 2 = 3</span></span><br><span class="line"><span class="comment">//2 + 3 = 5</span></span><br><span class="line"><span class="comment">//3 + 4 = 7</span></span><br><span class="line"><span class="comment">//7 + 8 = 15</span></span><br><span class="line"><span class="comment">//6 + 7 = 13</span></span><br></pre></td></tr></table></figure><h3 id="goroutine-异常捕捉"><a href="#goroutine-异常捕捉" class="headerlink" title="goroutine 异常捕捉"></a>goroutine 异常捕捉</h3><p>当启动多个 goroutine 时，如果<strong>其中一个 goroutine 异常</strong>了，并且我们并没有对进行异常处理，<strong>那么整个程序都会终止</strong>，所以我们在编写程序时候最好每个 goroutine 所运行的函数都做异常处理，异常处理采用 recover.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addele</span><span class="params">(a []<span class="keyword">int</span> ,i <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;    <span class="comment">//匿名函数捕获错误</span></span><br><span class="line">        err := <span class="built_in">recover</span>()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;add ele fail&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">   a[i]=i</span><br><span class="line">   fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Arry := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> i :=<span class="number">0</span> ; i&lt;<span class="number">10</span> ;i++&#123;</span><br><span class="line">        <span class="keyword">go</span> addele(Arry,i)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">add ele fail</span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">add ele fail</span><br><span class="line">add ele fail</span><br><span class="line">add ele fail</span><br><span class="line">add ele fail</span><br><span class="line">add ele fail</span><br></pre></td></tr></table></figure><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p>Go 语言中同时有函数和方法。<strong>一个方法就是一个包含了接受者的函数</strong>，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。<strong>所有给定类型的方法属于该类型的方法集</strong>。语法格式如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(variable_name variable_data_type)</span> <span class="title">function_name</span><span class="params">()</span> [<span class="title">return_type</span>]</span>&#123;</span><br><span class="line">   <span class="comment">/* 函数体*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义结构体 */</span></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">  radius <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> c1 Circle</span><br><span class="line">  c1.radius = <span class="number">10.00</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;圆的面积 = &quot;</span>, c1.getArea())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该 method 属于 Circle 类型对象中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span> <span class="title">getArea</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">  <span class="comment">//c.radius 即为 Circle 类型对象中的属性</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">3.14</span> * c.radius * c.radius</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h2><p>数组和切片很像，但是在调用的时候他们传递的类型是不同的！</p><ul><li>Go 语言的数组是值，其长度是其类型的一部分，作为函数参数时，是 <strong>值传递</strong>，函数中的修改对调用者不可见</li><li>Go 语言中对数组的处理，一般采用 <strong>切片</strong> 的方式，切片包含对底层数组内容的引用，作为函数参数时，类似于 <strong>指针传递</strong>，函数中的修改对调用者可见。</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line">b := [...]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">boo</span><span class="params">(tt [6]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    tt[<span class="number">0</span>], tt[<span class="built_in">len</span>(tt)<span class="number">-1</span>] = tt[<span class="built_in">len</span>(tt)<span class="number">-1</span>], tt[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line">boo(b)</span><br><span class="line">fmt.Println(b) <span class="comment">// [2 3 5 7 11 13]</span></span><br><span class="line"><span class="comment">// 切片</span></span><br><span class="line">p := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poo</span><span class="params">(tt []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    tt[<span class="number">0</span>], tt[<span class="built_in">len</span>(tt)<span class="number">-1</span>] = tt[<span class="built_in">len</span>(tt)<span class="number">-1</span>], tt[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line">poo(p)</span><br><span class="line">fmt.Println(p)  <span class="comment">// [13 3 5 7 11 2]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录在进行 go 语言开发遇到的各种问题。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>DAG区块链和传统区块链搭建异同</title>
    <link href="https://www.blog.hackerjerry.top/2021/04/01/DAG%E5%8C%BA%E5%9D%97%E9%93%BE%E5%92%8C%E4%BC%A0%E7%BB%9F%E5%8C%BA%E5%9D%97%E9%93%BE%E6%90%AD%E5%BB%BA%E5%BC%82%E5%90%8C_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/04/01/DAG%E5%8C%BA%E5%9D%97%E9%93%BE%E5%92%8C%E4%BC%A0%E7%BB%9F%E5%8C%BA%E5%9D%97%E9%93%BE%E6%90%AD%E5%BB%BA%E5%BC%82%E5%90%8C_new/</id>
    <published>2021-04-01T10:42:32.000Z</published>
    <updated>2021-05-06T13:10:23.224Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="区块数据类型区别"><a href="#区块数据类型区别" class="headerlink" title="区块数据类型区别"></a>区块数据类型区别</h1><p>dag 的：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// blockNode represents a block within the DAG</span></span><br><span class="line"><span class="keyword">type</span> blockNode <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> Additions, deletions, or modifications to the order of the</span></span><br><span class="line"><span class="comment">// definitions in this struct should not be changed without considering</span></span><br><span class="line"><span class="comment">// how it affects alignment on 64-bit platforms.  The current order is</span></span><br><span class="line"><span class="comment">// specifically crafted to result in minimal padding.  There will be</span></span><br><span class="line"><span class="comment">// hundreds of thousands of these in memory, so a few extra bytes of</span></span><br><span class="line"><span class="comment">// padding adds up.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// parents are the parent block for this node.</span></span><br><span class="line">parents []*blockNode</span><br><span class="line"></span><br><span class="line"><span class="comment">// parent metadata like version and extra data</span></span><br><span class="line">parentMetadata []*parentInfo</span><br><span class="line"></span><br><span class="line">parentVersion <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hash is the double sha 256 of the block.</span></span><br><span class="line">hash chainhash.Hash</span><br><span class="line"></span><br><span class="line"><span class="comment">// workSum is the total amount of work in the chain up to and including</span></span><br><span class="line"><span class="comment">// this node.</span></span><br><span class="line">workSum *big.Int</span><br><span class="line"></span><br><span class="line"><span class="comment">// height is parentsMaxHeight + 1</span></span><br><span class="line">height <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Some fields from block headers to</span></span><br><span class="line"><span class="comment">// reconstruct headers from memory.  These must be treated as</span></span><br><span class="line"><span class="comment">// immutable and are intentionally ordered to avoid padding on 64-bit</span></span><br><span class="line"><span class="comment">// platforms.</span></span><br><span class="line">version    <span class="keyword">int32</span></span><br><span class="line">bits       <span class="keyword">uint32</span></span><br><span class="line">nonce      <span class="keyword">uint32</span></span><br><span class="line">timestamp  <span class="keyword">int64</span></span><br><span class="line">merkleRoot chainhash.Hash</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> parentInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">hash chainhash.Hash</span><br><span class="line">data [<span class="number">32</span>]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>block 的：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">    Index     <span class="keyword">int</span></span><br><span class="line">    Timestamp <span class="keyword">string</span></span><br><span class="line">    BPM       <span class="keyword">int</span></span><br><span class="line">    Hash      <span class="keyword">string</span></span><br><span class="line">    PrevHash  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Index 是这个块在整个链中的位置</li><li>Timestamp 显而易见就是块生成时的时间戳</li><li>Hash 是这个块通过 SHA256 算法生成的散列值</li><li>PrevHash 代表前一个块的 SHA256 散列值</li><li>BPM 每分钟心跳数，也就是心率。–不太清楚干什么用的</li></ul><p>接着，我们再定义一个结构表示整个链，最简单的表示形式就是一个 Block 的数组：<br><code>var ``Blockchain`` []``Block</code><br>可以看出来，在 go 里面，是<strong>先写变量名，再写类型（比如*，[]），然后是最终类型。</strong></p><h1 id="通信系统"><a href="#通信系统" class="headerlink" title="通信系统"></a>通信系统</h1><h2 id="比特币网络"><a href="#比特币网络" class="headerlink" title="比特币网络"></a>比特币网络</h2><p>首先，比特币网络中的节点主要有四大功能：<strong>钱包、挖矿、区块链数据库、网络路由</strong>。每个节点都会具备路由功能，但其他功能不一定都具备，不同类型的节点可能只包含部分功能，一般只有<strong>比特币核心(bitcoin core)**节点才会包含所有四大功能。<br>所有节点都会参与校验和广播交易及区块信息，且会发现和维持与其他节点的连接。有些节点会包含完整的区块链数据库，包括所有交易数据，这种节点也称为</strong>全节点(Full Node)<strong>。另外一些节点只存储了区块链数据库的一部分，一般只存储区块头而不存储交易数据，它们会通过“</strong>简化交易验证(SPV)<strong>”的方式完成交易校验，这样的节点也称为  **SPV 节点</strong>或<strong>轻节点(Lightweight Node)**。钱包一般是 PC 或手机客户端的功能，用户通过钱包查看自己的账户金额、管理钱包地址和私钥、发起交易等。除了比特币核心钱包是全节点之外，大部分钱包都是</strong>轻节点<strong>。挖矿节点则通过解决</strong>工作量证明(PoW)<strong>算法问题，与其他挖矿节点相互竞争创建新区块。有些挖矿节点同时也是</strong>全节点<strong>，即也存储了完整的区块链数据库，这种节点一般都是</strong>独立矿工(Solo Miner)**。<br>我们知道，矿工创建新区块后，是需要广播给全网所有节点的，当全网都接受了该区块，给矿工的挖矿奖励才算是有效的，这之后才好开始下一个区块 Hash 的计算。所以矿工必须最大限度缩短新区块的广播和下一个区块 Hash 计算之间的时间。</p><h2 id="初试牛刀"><a href="#初试牛刀" class="headerlink" title="初试牛刀"></a>初试牛刀</h2><p>我猜你一定对传统的 web 服务及开发非常熟悉，所以这部分你肯定一看就会。 借助 Gorilla/mux 包，我们先写一个函数来初始化我们的 web 服务：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    mux := makeMuxRouter()</span><br><span class="line">    httpAddr := os.Getenv(<span class="string">&quot;ADDR&quot;</span>)</span><br><span class="line">    log.Println(<span class="string">&quot;Listening on &quot;</span>, os.Getenv(<span class="string">&quot;ADDR&quot;</span>))</span><br><span class="line">    s := &amp;http.Server&#123;</span><br><span class="line">        Addr:           <span class="string">&quot;:&quot;</span> + httpAddr,</span><br><span class="line">        Handler:        mux,</span><br><span class="line">        ReadTimeout:    <span class="number">10</span> * time.Second,</span><br><span class="line">        WriteTimeout:   <span class="number">10</span> * time.Second,</span><br><span class="line">        MaxHeaderBytes: <span class="number">1</span> &lt;&lt; <span class="number">20</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := s.ListenAndServe(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的端口号是通过前面提到的 .env 来获得，再添加一些基本的配置参数，这个 web 服务就已经可以 listen and serve 了！ 接下来我们再来定义不同 endpoint 以及对应的 handler。例如，对“/”的 GET 请求我们可以查看整个链，“/”的 POST 请求可以创建块。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeMuxRouter</span><span class="params">()</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">    muxRouter := mux.NewRouter()</span><br><span class="line">    muxRouter.HandleFunc(<span class="string">&quot;/&quot;</span>, handleGetBlockchain).Methods(<span class="string">&quot;GET&quot;</span>)</span><br><span class="line">    muxRouter.HandleFunc(<span class="string">&quot;/&quot;</span>, handleWriteBlock).Methods(<span class="string">&quot;POST&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> muxRouter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GET 请求的 handler：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleGetBlockchain</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    bytes, err := json.MarshalIndent(Blockchain, <span class="string">&quot;&quot;</span>, <span class="string">&quot;  &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    io.WriteString(w, <span class="keyword">string</span>(bytes))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了简化，我们直接以 JSON 格式返回整个链，你可以在浏览器中访问 localhost:8080 或者 127.0.0.1:8080 来查看（这里的 8080 就是你在 .env 中定义的端口号 ADDR）。<br>POST 请求的 handler 稍微有些复杂，我们先来定义一下 POST 请求的 payload：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">    BPM <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看 handler 的实现：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleWriteBlock</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m Message</span><br><span class="line">    decoder := json.NewDecoder(r.Body)</span><br><span class="line">    <span class="keyword">if</span> err := decoder.Decode(&amp;m); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        respondWithJSON(w, r, http.StatusBadRequest, r.Body)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> r.Body.Close()</span><br><span class="line">    newBlock, err := generateBlock(Blockchain[<span class="built_in">len</span>(Blockchain)<span class="number">-1</span>], m.BPM)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        respondWithJSON(w, r, http.StatusInternalServerError, m)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> isBlockValid(newBlock, Blockchain[<span class="built_in">len</span>(Blockchain)<span class="number">-1</span>]) &#123;</span><br><span class="line">        newBlockchain := <span class="built_in">append</span>(Blockchain, newBlock)</span><br><span class="line">        replaceChain(newBlockchain)</span><br><span class="line">        spew.Dump(Blockchain)</span><br><span class="line">    &#125;</span><br><span class="line">    respondWithJSON(w, r, http.StatusCreated, newBlock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的 POST 请求体中可以使用上面定义的 payload，比如：<br><code>&#123;``&quot;BPM&quot;``:``75``&#125;</code><br>还记得前面我们写的 generateBlock 这个函数吗？它接受一个“前一个块”参数，和一个 BPM 值。POST handler 接受请求后就能获得请求体中的 BPM 值，接着借助生成块的函数以及校验块的函数就能生成一个新的块了！<br>除此之外，你也可以：</p><ul><li>使用 spew.Dump 这个函数可以以非常美观和方便阅读的方式将 struct、slice 等数据打印在控制台里，方便我们调试。</li><li>测试 POST 请求时，可以使用 POSTMAN 这个 chrome 插件，相比 curl 它更直观和方便。</li></ul><p>POST 请求处理完之后，无论创建块成功与否，我们需要返回客户端一个响应：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">respondWithJSON</span><span class="params">(w http.ResponseWriter, r *http.Request, code <span class="keyword">int</span>, payload <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    response, err := json.MarshalIndent(payload, <span class="string">&quot;&quot;</span>, <span class="string">&quot;  &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line">        w.Write([]<span class="keyword">byte</span>(<span class="string">&quot;HTTP 500: Internal Server Error&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    w.WriteHeader(code)</span><br><span class="line">    w.Write(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快要大功告成了"><a href="#快要大功告成了" class="headerlink" title="快要大功告成了"></a>快要大功告成了</h3><p>接下来，我们把这些关于区块链的函数，web 服务的函数“组装”起来：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := godotenv.Load()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        t := time.Now()</span><br><span class="line">        genesisBlock := Block&#123;<span class="number">0</span>, t.String(), <span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>&#125;</span><br><span class="line">        spew.Dump(genesisBlock)</span><br><span class="line">        Blockchain = <span class="built_in">append</span>(Blockchain, genesisBlock)</span><br><span class="line">    &#125;()</span><br><span class="line">    log.Fatal(run())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>genesisBlock</code> （创世块）是 main 函数中最重要的部分，通过它来初始化区块链，毕竟第一个块的 PrevHash 是空的。</p><h2 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h2><p><a href="https://github.com/omnigeeker/golang_blockchain_demo/tree/master/networking">https://github.com/omnigeeker/golang_blockchain_demo/tree/master/networking</a><br>在参考这个步骤的时候，发现始终无法监听到 8000 端口的信息，晚上苦苦思索一个小时没有任何解决思路，今天早上又看了一下，发现我没有改文件？？？？我还是用第一个 demo 文件来模拟多节点，笑死。<br>赶紧创建文件，复制粘贴。<br>bingo！<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/DAG%E5%8C%BA%E5%9D%97%E9%93%BE%E5%92%8C%E4%BC%A0%E7%BB%9F%E5%8C%BA%E5%9D%97%E9%93%BE%E6%90%AD%E5%BB%BA%E5%BC%82%E5%90%8C-1.png#height=203&id=sjAuI&margin=%5Bobject%20Object%5D&name=image.png&originHeight=405&originWidth=1361&originalType=binary&size=1018627&status=done&style=none&width=680.5" alt="image.png"><br>这里设置的每 30 秒广播一次区块信息，所以如果一直监听可能会遇到这样的情况：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/DAG%E5%8C%BA%E5%9D%97%E9%93%BE%E5%92%8C%E4%BC%A0%E7%BB%9F%E5%8C%BA%E5%9D%97%E9%93%BE%E6%90%AD%E5%BB%BA%E5%BC%82%E5%90%8C-2.png#height=388&id=W1t1G&margin=%5Bobject%20Object%5D&name=image.png&originHeight=776&originWidth=1345&originalType=binary&size=1812987&status=done&style=none&width=672.5" alt="image.png"><br>注意：这里的 nc 命令和文章中提到的不一样，文章中简单的<code>nc localhost 8000</code>当然可以用，但是这样更规范，它相当于模拟了一个客户端，开放 5000 端口和主机地址的 8000 端口进行通信。<br>用它，甚至可以模拟一个简易的聊天室！<br>nc 的本质是在两台机器之间建立连接，之后就可以基于这个连接做很多事情，数据传输是其中一个最为基本的。我们下面就使用 nc 来建立一个 C/S 的聊天室。<br>模拟 Server 端：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -v ：输出详细信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -l ：指定监听地址和端口</span></span><br><span class="line">nc -v -l 127.0.0.1 6000</span><br></pre></td></tr></table></figure><p>模拟 Client 端：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -p : 指定源端口</span></span><br><span class="line">nc -v -p 5000 localhost 6000</span><br></pre></td></tr></table></figure><p>之后，Client 和 Server 端就可以相互聊天了。<br>Client：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> nc -v -p 5000 localhost 6000</span></span><br><span class="line">nc: connect to localhost port 6000 (tcp) failed: Connection refused</span><br><span class="line">Connection to localhost 6000 port [tcp/x11] succeeded!</span><br><span class="line">Hi, server</span><br><span class="line">Hi, client</span><br></pre></td></tr></table></figure><p>Server：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> nc -v -l 127.0.0.1 6000</span></span><br><span class="line">Listening on [127.0.0.1] (family 0, port 6000)</span><br><span class="line">Connection from [127.0.0.1] port 6000 [tcp/x11] accepted (family 2, sport 5000)</span><br><span class="line">Hi, server</span><br><span class="line">Hi, client</span><br></pre></td></tr></table></figure><p>nc 具体操作可以参考：<br>【1】<a href="https://www.cnblogs.com/bakari/p/10898604.html">https://www.cnblogs.com/bakari/p/10898604.html</a><br>【2】<a href="https://www.huaweicloud.com/articles/7f323edef71be76eb5705275718ecfef.html">https://www.huaweicloud.com/articles/7f323edef71be76eb5705275718ecfef.html</a><br>【3】<a href="https://www.cnblogs.com/zhaijiahui/p/9028402.html">https://www.cnblogs.com/zhaijiahui/p/9028402.html</a><br>【4】<a href="https://phpor.net/blog/post/225">https://phpor.net/blog/post/225</a></p><h2 id="p2p-多节点网络"><a href="#p2p-多节点网络" class="headerlink" title="p2p 多节点网络"></a>p2p 多节点网络</h2><p><a href="https://github.com/corgi-kx/blockchain_golang/blob/master/network/server.go">https://github.com/corgi-kx/blockchain_golang/blob/master/network/server.go</a><br>我认为需要先在单节点完成 dag 架构的 pow 之后再尝试多节点通讯，所以这里暂时搁置。</p><h1 id="DAG"><a href="#DAG" class="headerlink" title="DAG"></a>DAG</h1><h1 id="SPECTRE-共识"><a href="#SPECTRE-共识" class="headerlink" title="SPECTRE 共识"></a>SPECTRE 共识</h1><h1 id="账户系统与交易签名"><a href="#账户系统与交易签名" class="headerlink" title="账户系统与交易签名"></a>账户系统与交易签名</h1><p>前置知识：<br>【1】<a href="https://learnblockchain.cn/books/geth/part3/sign-and-valid.html">签名与校验</a><br>【2】<a href="https://aaron67.cc/2020/10/10/bitcoin-sign-transaction/">比特币交易中的签名</a><br>【3】<a href="https://blog.csdn.net/AAA123524457/article/details/107693278">比特币交易中的签名与验证</a></p><h2 id="国密-SM2"><a href="#国密-SM2" class="headerlink" title="国密 SM2"></a>国密 SM2</h2><p>流程：<a href="https://blog.csdn.net/samsho2/article/details/80770862">https://blog.csdn.net/samsho2/article/details/80770862</a><br>详细原理：<br>【1】<a href="https://learnblockchain.cn/article/1515">SM2 算法与 KDF 密钥导出函数</a><br>【2】<a href="https://learnblockchain.cn/article/1507">SM2 的签名和验证过程</a><br>以上均要写在本子里<br>“github.com/paul-lee-attorney/gm/sm2” 这个库将所有代码都注释了，非常好，可以直接用<br><a href="https://pkg.go.dev/github.com/paul-lee-attorney/gm/sm2">https://pkg.go.dev/github.com/paul-lee-attorney/gm/sm2</a> 这是它的用法<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/DAG%E5%8C%BA%E5%9D%97%E9%93%BE%E5%92%8C%E4%BC%A0%E7%BB%9F%E5%8C%BA%E5%9D%97%E9%93%BE%E6%90%AD%E5%BB%BA%E5%BC%82%E5%90%8C-3.png#height=386&id=P6Coj&margin=%5Bobject%20Object%5D&name=image.png&originHeight=771&originWidth=998&originalType=binary&size=54825&status=done&style=none&width=499" alt="image.png"><br>这个函数可以用在本子里，提升逼格。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;crypto/rand&quot;</span></span><br><span class="line"><span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line">_ <span class="string">&quot;time&quot;</span></span><br><span class="line"><span class="comment">//&quot;github.com/rongzer/gm/sm2&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/paul-lee-attorney/gm/sm2&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//fmt.Println(time.Now().Format(&quot;2006-01-02 15:04:05&quot;))</span></span><br><span class="line"><span class="comment">//fmt.Println(time.Now().Unix())</span></span><br><span class="line"><span class="comment">//bf := bbloom.New(float64(1&lt;&lt;12), float64(0.01))</span></span><br><span class="line"><span class="comment">//bf.Add([]byte(&quot;butter&quot;))</span></span><br><span class="line"><span class="comment">////Json := bf.JSONMarshal()</span></span><br><span class="line"><span class="comment">//var set = bf.ShowBitset()</span></span><br><span class="line"><span class="comment">////var value  = 0</span></span><br><span class="line"><span class="comment">////for _,v := range set&#123;</span></span><br><span class="line"><span class="comment">////value += int(v)</span></span><br><span class="line"><span class="comment">////&#125;</span></span><br><span class="line"><span class="comment">//fmt.Println(len(set))</span></span><br><span class="line"><span class="comment">//priv, err := sm2.GenerateKey(rand.Reader) // 生成密钥对</span></span><br><span class="line"><span class="comment">//if err != nil &#123;</span></span><br><span class="line"><span class="comment">//log.Fatal(err)</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//msg := []byte(&quot;Tongji Fintech Research Institute&quot;)</span></span><br><span class="line"><span class="comment">//pub := &amp;priv.PublicKey</span></span><br><span class="line"><span class="comment">//sign,err := priv.Sign(rand.Reader, msg, nil)  //sm2签名</span></span><br><span class="line"><span class="comment">//if err != nil &#123;</span></span><br><span class="line"><span class="comment">//log.Fatal(err)</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//fmt.Println(*pub)</span></span><br><span class="line"><span class="comment">//isok := pub.Verify(msg, sign)    //sm2验签</span></span><br><span class="line"><span class="comment">//fmt.Printf(&quot;Verified: %v\n&quot;, isok)</span></span><br><span class="line">msg := []<span class="keyword">byte</span>(<span class="string">&quot;test message 123012301230&quot;</span>)</span><br><span class="line"><span class="comment">// 创建公私钥</span></span><br><span class="line">priKey, _ := sm2.GenerateKey(rand.Reader)</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 签名</span></span><br><span class="line">sign, err := sm2.Sign(priKey,<span class="literal">nil</span>, msg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;sign:%s\n&quot;</span>, hex.EncodeToString(sign))</span><br><span class="line">fmt.Println(<span class="string">&quot;prikey:\n&quot;</span>,priKey.GetRawBytes())</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;prikey:%s\n&quot;</span>,hex.EncodeToString(priKey.GetRawBytes()))</span><br><span class="line">fmt.Printf(<span class="string">&quot;pubkey:%s\n&quot;</span>,hex.EncodeToString(priKey.PublicKey.GetRawBytes()))</span><br><span class="line"></span><br><span class="line">src := hex.EncodeToString(priKey.GetRawBytes())</span><br><span class="line">n, err :=  hex.DecodeString(src)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(n)</span><br><span class="line"><span class="comment">// 验签</span></span><br><span class="line"><span class="keyword">var</span> res <span class="keyword">bool</span></span><br><span class="line">res,err = sm2.Verify(&amp;priKey.PublicKey,<span class="literal">nil</span>,msg, sign)</span><br><span class="line"><span class="comment">//if err != nil&#123;</span></span><br><span class="line"><span class="comment">//panic(err)</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">fmt.Println(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/DAG%E5%8C%BA%E5%9D%97%E9%93%BE%E5%92%8C%E4%BC%A0%E7%BB%9F%E5%8C%BA%E5%9D%97%E9%93%BE%E6%90%AD%E5%BB%BA%E5%BC%82%E5%90%8C-4.png#height=97&id=h4IoK&margin=%5Bobject%20Object%5D&name=image.png&originHeight=193&originWidth=1487&originalType=binary&size=42228&status=done&style=none&width=743.5" alt="image.png"></p><h1 id="维护可信交易用到的技术栈"><a href="#维护可信交易用到的技术栈" class="headerlink" title="维护可信交易用到的技术栈"></a>维护可信交易用到的技术栈</h1><p>hashmap–用于快速查找<br>具体原理：<a href="https://zhuanlan.zhihu.com/p/27108356">https://zhuanlan.zhihu.com/p/27108356</a><br>测试性能：<a href="https://github.com/phf/go-hashmap">https://github.com/phf/go-hashmap</a> 那个测试的样式可以嫖一下</p><h1 id="测压-tps"><a href="#测压-tps" class="headerlink" title="测压 tps"></a>测压 tps</h1><p>【1】<a href="https://hyperledger.github.io/caliper/v0.3.2/architecture-ch/">https://hyperledger.github.io/caliper/v0.3.2/architecture-ch/</a><br>【2】<a href="https://blog.csdn.net/qq_44316726/article/details/108112300?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&spm=1001.2101.3001.4242">https://blog.csdn.net/qq_44316726/article/details/108112300?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;spm=1001.2101.3001.4242</a><br>【3】<a href="https://zhuanlan.zhihu.com/p/133873895">https://zhuanlan.zhihu.com/p/133873895</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;区块数据类型区别&quot;&gt;&lt;a href=&quot;#区块数据类型区别&quot; class=&quot;headerlink&quot; title=&quot;区块数据类型区别&quot;&gt;&lt;/a&gt;区块数据类型区别&lt;/h1&gt;&lt;p&gt;dag 的：&lt;/p&gt;
&lt;figure class=&quot;h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Spatio-temporal-blockchain</title>
    <link href="https://www.blog.hackerjerry.top/2021/03/26/Spatio-temporal-blockchain_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/03/26/Spatio-temporal-blockchain_new/</id>
    <published>2021-03-26T02:11:07.000Z</published>
    <updated>2021-05-06T13:10:09.329Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="13e2872c55e72eeaeb8b81b47fc4798fd723e4af0975164f3631daec44324286">042fc2365e7574de6a7704120abbed31d525f05cdde229bd422135de3fbe0a8e76747cc7b07f7d3966194695ad7f2e1c40e1d93c104cd2799eff9b1f2240591301993651d29bbd77dd03073315ae293bffbf8b000c209b2ac347c80bd39262bda7232baf526f154089d7b5c5ceec86e446214eff1fada696b6d4155110e3552ab826c86558109be3f7b4b9b31330a2c3a5f59401847fc01ccb7440be4f4a024fdf43055fc4fdc063b78200136fe98eee2efec197f2d0ea2bd68a61a9b773b63f40cba1a24b2e5dbe3d91682ba83a9484fdecdd7900724ed62ddb133c7e067ed537920f826462670fe10a95c86b45b1248d21e74615996c9c77017934d5e3a3c9ab571c7b193e344fffa9e45b3f614156a52313c26177be72c6de39a131e2dde91f26fc66d9abffae3a372535cc0166d8efeb77b185dcca283082d9b923d4a306b26f9e830bf021e35708691e8b086cf0d3a1f7240c66324c27b0ad0841e3dc156417f17565281cf5f5b2ae2128b39bbf32084a8121b44677661804b982214db3a93675ebbb3297ca6758cd0085eb5b1a6e0b3b6e5bf077c3e3d29c2bfda4b6e195db0b78bfa401dde1c306a482eb826f7bbb82b84e7b2696c1e0445a28e54df089d5266e225ea4c491e9a5cb7b19af3c7b923150e2f6689a881b544cbdb6b9ab9c194e58ae6802b29e3582d16d59bb405cbe5d4279a4a276305b54898c1dbb346e56459d2923e807a16c69541a1c9ebe8a5c2efc569aa8873ce81cd4566a18e1bfa1991daf9995d7e380fbe71caf0455ee6e28375899d46b78cdaa8fffb41b4cea97aae54b783df4ede1582f58088b5448a33aaf81bf78e8eb6f8d7067d4df353e5890d30c7434166d2dded46ef802bb34b270d88a3a08d5bc0b6236a9baab550820190e4db136f8a055feb2f107de7e63f872d2526158ab3ed48506ed27e58eeb1e07971c6cce7803ae5c5573acafd4a8b3c55b6a0269549548597a7daa1c10d8ddf5e6277bb38dea5a1f53fa58e285001e2853d752e8614824504fd4286696ee8c8a96d52d89cba3e44b8de1d84a1bec0ab8f5c23dbec7a263d76d720e0f7b03ed08583b5854ee478c8335ac1091386ddc26495460e7ba41daa20ba028f0a6e17ffaa6b30fc46d7604378b025d0f2ca467e27aa5f9a40f978262d2f09a986876c3c0fbccac52a8080111c42b6390ae078bb35f6b70785ce8260a7797b5306aac075ea15f12af5acbe6aa6bc63046921eabe7352ea99c331b19824ff0e42bfb1e4ac24cf6c71871ad3ca014c54b28c2518e465cd59122221a677037b1865043fc95bad6095b077a5823ed3e97e33e796bad7dc65c1abcc6de5df8cf47fa37a6e0e1d76593cb96bf9d272e13cabda0071ae214af23ef7e39aef5ea0a1f759643a3a0ac220b2a37146e5e167289370f2713bd278c2a248491f3e63589e35232508a51307f5ff68203485f31f980d8d17f8682398490953c97d55e9cabaf8f55194d730f42f147a4d2ced948d0f7c663caf1ee6480bdd1f8beda7a4ae55050431297e82334a84979b311561122778d1f523d7eb35004faf1b2f2231733c95fc5a1b5d695d0029cc31e4d2dddf178faca162505e74d7eb4479a2f62f87e09d32a877b8d494a4092f33868872f187ed3e1f66b69cf8ee04f6cd4b7ee0568e4039a133f016c619860fe247049feda6dcc139dc4248c6f2f3be4b3a8a51d8cdc5992ac3f0b3dc457df987854ee143a37f3bdd3169bdae85b41ffe9af59d950ba3f0cf3e90cae60fbd861812c89b8c350f15af31ee365456109b8c9c1a99092a772f051320c78888edbd6044d4d73ef12176526c73137c7b7b76399c2fbda11298da1f9f467aa99105ffdc00f1a3524fcf44461a6d33d669ee003027b5c92b79ad9c8b729c99a1c0a8d376ed289e2386bbfd015e65b708dc7159ac6e6a227886768eac27a4880732dc273d1bf5f8a93ff92729001a351b2cdcc49e10d9c5508b479f0eb0a2547fb6a8daaf28de0058d61d5568386503c3cb72f1df6a30cd81f3129f27d6ba67b71b61db396b553ed79f8501f0e2d7c746985b574e6dbd2e22c58929bf470c5f60ad7f8fa485d29ca29d89a6631c6fb8ba37b36d09d555fe859dbb5840bd1e08881f448cecf2731151a3966976cd3976672dfc7f531b3102149ca767a28855d45d59cd331b46799d8dc97f69e854b3566aeafec28ab66ccb8ada3641c6f58dd6e5711917b5bba677fa37eb1130d64bda0d55473fea14f4a22208f37fd1ac79e17d34026728fc87e339324e35866f40ac06ed9355e597206b428a213841104b9493a6ad4005a92bc45a54a97bb1b821e4bd16c192195de347690c24656969657a91588fde2a5b2ec3ff80204191a70c159c390c501db42394b656c3d0e50ea24e6722872b23e77180096b79fa81410faed9c7028ccb0d1208a640db60a01df1e1f47bf7393e4a2c1ff1f1c0c7d25799feb98c616d64770a5be30ed45e5fca84dd3626d2e9a8decf125d2ed51f48cce1a6cc695ffb60a5e22f7bb1080c236a231bc69d266076e340f57ce16709dd9daa2db20a18249fe4026de13372d61e696f29e3e2c0f3e706d37085fb47ad5028b0bff63157d447fc0a906722b0e89495a70722957d8db66ac35a139bf76ccc0ca151a0f3bbb490a5f47e8a6710b0f25adf6b288a3dc9638d3a5f833d010ff9401cdf890731986d35734572479f324e5cc738fb79db3071fadd7c27249d54196419a16d4db558daa2fa3c3cc85b8fbc9d979ccd2a9be98812c007f947ae4cfe6277b07c14b5e11656383e966544f705bc0df2b48362b7d36bb9f6c00ec104580997b10db6cecd149550806bc8a26e447868116564353695223948a9967ddb37ebd43722e7c0d33794d5331429ae0d9e4feb70ef7d4c64e81ed5cb63d7ce35c90c693a953082c52b741263fc6622083c8c96ba48acfb9ddb83ef3164b1bc6536d703a6797deba6f184999c2a4c0f02ce1b66bc1f9c7ca85f070591387dd6064c547b2a27a0a0a087b8dbc1ca8b9077cbca50770f877b5b5568444e2c1c6d33cd606df3ae015858ffdd841a50d4af019d12bc7b86e3c722327d017bb74b8a7c29e0ad66ca3a8406d56ad44ad32fb24124e48f55bbdff345e1dd89b3a380360bb431fcde8ce9588b51a0bb326f291aab3d532b07fceaa0cd7b63af0d913b7368b91a96ae5e7804dd6fe5e02be1e966eaadf9749be9ecbd611bc0ff98c1493505de403230ecd915a51e01c016b909d89827500e4b671f629572aa65c668c568e6dbe0d8646eb8ee81069da2b5c0a0818509bb74af54399b323df72c56c87e67ed4537d77a891bbce8d0beff1cc8f2f2bbda6deb2c8d01891fb01992ca3f2ed99235bbb5495f45d91699daf7d3f95f85546825076c668354b9646cb4b6b12978d821cfd7cb1c3369dddcfd18c7cfed24072c4bcceddc8f43f686cbb042fad89d4a5c5951cafc583b9a2f39eb98d10afb66d855eabbe71f5696eb45a190b9a82489c684aef692fca891e99f89dde6f38d186bb0fe63973663444415bde40d67d7407690d34a28ff9b44d9c0fe805879f22b684f6e8853d5c6bf49340e6298468a8a86413895198dde346222bcf35b9148df0a5784498ade71c771a51c67b537cac10c48f922c9505a9333f9f24a4f4659807ebad338ac72e7a3a3cfccb082be6c458af1cdc578c103b4f6c081e62be28a319d18fef0825ee9cded0cf22679c8f8da76f2a6fa2afbadb5364411001b2f505f15231cec38bd87f91157445be34d7035c52d08fef9b00a936e168244dae7a73a22f9f045fbf321ed21114ed22ef720a41d98df9a0e90dd000f3089af3f3d8662b03b3c0ffeb3b1b77cde06332137c2fc5633cfcabe37da68054bd0ff565d46c3d9d01e08f9cdc2d01ba27cce24b36a2335fb67a327828dd4b854b3e3786bc4e409b046705775800a93a79da26a10922cdcf6f2f62f53ffab6b2bbec28df332c3e7a9a3eebc54d021c7c3cf1ff38420ad3e33dd8b1771abc047d335a989a8c16eec3b11f43f88f3855145944706e3cae87b377d7f1ed0a5de3d8fd2698689d338885e47276579de5b7c632d8611944fcee8cf45b01264fcf8dd92786171d2a472bc6b260abc9556a4579eaf85051e6a028640ac92b95052e643dacd39834e7adf50ab47a737587173133f5c80cc49873854139b315d09862346fa5f675139ba637e63b01f6988d9cde1cc500c1d11d2c1e051fb177e618cfa5fa057ea67b56b7e89247b2af84b39d49d9f60d5767c6d2a42f4be8c07750ed4ee429aa65062c1493f04e15208917df31e0fd4baa8fd1054f3ae6c4e4df4bb4cfaebc2ecedba95e0bd93339f1b8043a84261d9367d2ce51d6ea2625e82a72c4aeabd01f032c20f068f7e444d561713374c272f47642dbbd6f2f56428c53a529abae63cce6359e1e8ce03021fc971ac4e3a01d097a7699637646531042c3b1a71ae84d60818efab5e31a633f1323f1f823229ace61d13f7c1e7307a65d6670a90b30a9ebe4ba1a1fb559150500a371df26ebdb61d26441c0624c97ab6b5bc827a5d02e5774ac7674ec9fc33abc4ba7006417596d850120967fc3b0c801a365a5a240fd76ff63fcbb0968dabba28b4ca2659684ecc32d2d3cc5f845d9b5378dd94688bebd43917f0ff012d32672da30fc509e3bd9ad0eb426660dfbb7c76b953fa61e96757cc3af7baa2f40790ba7066e5e983a7000792a5e23ed37c3c78a2ae1f6d885316a15ab5a792eec792918446a767cf996007be6ba7d4fcdc69620e3d8500bdd32d7261fdc83d8e76b48e75d502f2828ce7c0ca563f2393624308f0303aed274c9b2239cbb242c7ead505ce643d1ae7a6f6ee2f0df06bb647605544f4a14a617fb7f179b2b4c5f26870e9c1d4aabc67674858a812f335ad4d48aad551ac2da93cedd5e5822a03dc2def09ba52d8c894507d41fe18fac3a4f8cdf296e282a65bc835392aaa49cd08d9cf91fbb31e26b52eb5cab07165c03127873ab82bad4e1c601ec097f80a32e5ee37b06aae3fbc317d17669e922fed783ba1233d32ba3f0f1f1d5abb1d66fe9fd0f9f01428818f72967372928c12da363c66d9c9ef6dcacae83d8afa2b97f2d2252b8f772fe224d1be71f6f0f94d14e6d16902a26ce65b75c14ba551e6d6b2f7fbf71ba7abe5bbe3fdc0f1b21b29b54e1c9e1a07edd03ae082bc1cc4cb10215b6bb607afa816597127234aa4387002489c643b551f622d84980144e41c2b87d73c8bbef95675cf29c03f422e8b6fe43b5d3e3a3e82468e5ccf9bb7e8446197fdac72507c3dc7f362e3d0f81538ccc4c351843df0a9923f622026494c67019f9d181dcdc1d93bcf289b137d74496b5d43c882fcba6fbd68c317f3c3ebd200c751e02f771348dc24543c009ffc588453d030af8befcaaa8dd30507a7ecf281da034b88ff7995ff973ce20167ccc61748370299e3e0c743330467e8ce0f959d5d8965a86a6fede7a32924f1a0024dc0dce52dcf27843550efcb1f606889a3df1de2a7a0d6d0e4b43f3bfcf02bd51aae62b7b4721ed0df789d6437f76e42b7c5cb73b8da64ea555087b82111f5652832a74c93aa8723e814de68c393a6eda478385193953dd74572632b48e29509197e2f3c1146c161aa3e2d7eb715803fd8d3910011d652189a52d18d2c7b4f61c717414a32c3a85b88a98dffe7e4cf77b2b6336c64deb2739a89571dea62b7503531c57fb901954168dda9c2be57f5feb5192f58301f4d65f0983ec8b887e3c0aa0d12a48bd22a2c7bf9948207a817cb37210b28ff086d75a074069367312a3d99c42205c53ec532651d22114c6969a5e520cfb02d939f9e49672125f8dbba9b3cea3705725347885e17319d4cf02366c2083a89aa577c2d5356018622e73f71b86377fd93735af67459537233f7d161eaf685efbc17d86b1afad111d205e8738638a598da82960f9f43f2c621cfadbd883cfba788ce3e385e83fa9acadba3bec18407ac5903efd5d783acbb94adcb6da60d70e8b4083ff435c47cfcdff3c9ea3a263d512a3b3e186468407b74356e87e9a7aa6cbd5fc84c189945e94e35a50a6c21519a8833f38a55435e871b5cfbdfb775a8cfd3d8761e37096643688c6b51a429db60dbc76be166dfc5ccedcd920041ae6235773623af769cff232852f6f9c97fad5a9d03a11fd87ac454a2c4a401547bf62184aabce5fe0cf6087c848f4ee1fcbd2a1764c25770cc7ac9f12ac20f99c3dea0e2cba0b15bdf89defdba06e01f5e71d0cc5cdca446394a7f7ddbfe9b3bb37b60816fb3cfcfdbe8c23d42e6af8818f0b4532f55bf94e01cec14d992168e891081da7a391426358364d2178893b3b3102994db6ebd533f4458593fe32770b899c5cce4ceb50ddfadff7c8e09bca7fde1d8a07dca56fa94e98a34398bb0f137ab265fb1576d05d53bca26a98397a93c5217b3994b994cda764216b874a85d1dd7eea970275549b86ad7811c8085731b74d414bfdd5c205eba6fddd8c72e1dc1b1e1838141b396666a76a35cc971f75f305e943c354cc5fd535139aae182c341506aeda0b0475f9aaab1e83a1f023ca3018afd52634d0d7f754f915464d6484257999b4194b66506f2d225c1b9f605db8b711aee3ce81da8952e86394ba454ba52daa9dd86556895de6798f29b5212242b6a8adf3f382e8f9c08750ea6e8fa48fb92a089334a7f033a7a49784125b22220ad63fa9572a73ac0738716034069993a8eda4d447f84b34a55042d4e70ed74d60357f8758e8a29abd7d03021fd2a7ff417ac3859cf52cf90fe2ff0ca7397680030e99e4aa3b004be521483b017874def57a74acf76ab836b4dacf84d343388f8d62f36a7190a7c0366e05554a26fa4308688ec1720f844c4a8799cc358c45a183de1f6b87f81f44c81f3f1e0c46cbd3a8d7c7554cecac7b48b95fc79497fc164a088a9df0296831ab66c65ddc8a9f7aff2351dacfb6914fa865dcec7fd9478c294c47709b5cc7fc80c98f0daf208ac5d4e033a23f0d8da243595fdb503c0ba8930f379f18a9a764af38fc730b0978e645978e6f9ca2286461c5e8d39f4dcf1f5452350b6c8323beaa601cbcc2bb701b96a96a79e43d2857c3a7f15d9268b8bf11893511601afc00e9b58a267235be75c3d9d33ce9573234b77135584049fbf6e9b54e37d2798c7ccf0a743ad853e53d2916457dbaca1c046306cb014cc82902d6572d67ad5a8982e04177f65835d94679c48ac2c1787e6eee1ff9ab33e901c0160a22f5637386679934e12be53ed400376b10bc1fbecefa5819466f6016b331efad06088f08725b4731e8d191135882763001d51892e3e8390425d5bdff4832b611757e6e8087820d103eb003f289bf22e6194ace19b1f3a2e61a8f1fb9f586450dd4e4fef06879d9d2d9cd01c85918cf386a37e83a8fbab67e527d4b25c02dd26b5cfabb64182344531b0b722b3d1218a636d5863dd8057ec2144f206559353cdb72beeb97f0db8905a3a70606916d047412c11f4c445bf1817c5cb6dac98860c711f7ca96392af8c1f24828178d0515509cb42c13161544940067e83121c6d734aa4acd6a26e511680b3992504fc67f49272b81e7e5efcf779098c116519a900814e6efedaa2fde186aea3e183d42569e5cc65ab74b56e49440908f4007c0633db9939ecf97d38e22241c1f32088b295c1e44aee135e58c523d8f1fad79231886bc1918840c00c62468addf0f360ad47a548445b026be2a35539c6dcb40fc5350393ebf8494c1e7641d62ed64b520c2ff13ef10ed6e9f96ac20ddd4cf70c48501998f9abbbbb5c0f3146f026f7ecc6bee834b7b523dbf93f9fd09b16abdcf472b648ef6e291f1513c0d83918db73df0b04f604a1dc56d001010000d1bb8bb048c2c00ddd4be335d70520d7ff656e2edc9f228275941cba789125e7b711bf2ba0f1c7b53b7691a5d0cd50e7e563bb39b442f7c2d3178b9ddc70bc820daca3d3f1786ee11c7cb7004526108d0bfe6fd97f3a375725ada6efa1f3f067378db37e81de8ad48c57bb1fa5d48d5ce85856bb8d6fd9c991d0a47747fa629e677c77c3cf31754b417d6d3b6aa45b2a10ee867bb841cc09336efd7517c72ae07d8ffd46cdc0849542e2337453f72825542e245c306bfbe629a40afa5b85fecd376ae2f2c3f1a89e9fa2f7715e671933d36544151eca1ed8b4330a2dcbf842764ab57df8482094cb7aaa620ab7b4b1c7f6b23bfb80144ba88c3a89563b53fd04cf1acaff6ec2b68a01d7d6d822a4026e7e22ba83c1072c7bcceb761b555f66c7e392a2a255b64eafbe7631ebb6b9f7c03f74796e21f3eeed0935639c36bd96512925bc01419d68edb708b548a8416be50a1d34e29bcbc9f51d3fe0d27f372f66b5b2eb04902e3e0f2e459dc8e01e2f56e2c55dba1c7725feeb016587eb73bce305f262a48c16b738b0d792bc294697e4a23ba6aa9397085246b8973d18eb4ba766788d59198879be86fb259afe4614f5629879a0d3a0a60eaed97ff5f90725eec6ea6cb349aa3a7493417f128a94bce3f3ae391a5a1ddd8b7f11e51156e141f7bab76900810090ad046ae54b0611663bbb05c82190118b2a9494f2c74e0f3fc7812b3d998e0e49f57b3db61c9b44d58e19cd3cb8765b24a2bfe83824a3090b460bf345cf882c1b95ba84767600d0065fba0f98ae5d650229bfd1e83eac6a3ae8a590d353a1c404071f8efbd9cd7296ea8f0d8b0184fd8b7d6279d9bc12874a129e2674eefd8bee22feb1346ab3f1a4b34c708d2774380c789147203e3fb63ae4352f83add465a9e0132f161f64de0e630a20e9f2bf54aa9c0029223c39122f4e7631aeafd3d23ace8cf7e18a021ae614d26c9a461a1318d57f7802f5758c34cbb3fdb37b2b62aadf06d9c7dac40642c31daa4bbc1c9593e7ec688536e5a6b0948aa4a0e0940061779bb6faebc9a8757c36a022fee959e919fcd5cfb5ce4fe5f1ba7f54d62f59f57525c0e9a76e100bb9fc9bb2575418f969abdcf63b1c5bb187a04e9b254347308b1d69d93c006748e122792a7d9263accc2132d37ceefd0bedd022c6290a8143b27e93ea71a658c5edf473c68591eb811153c9da1e91ceb296006d95f6ce093c38e41bdd6442feb0c33aa7520eeec7fb897eaab42c2b7fb5a90ab15e982363e76778be2c25d89dd29aeef227a1f63306cc44252fe0af787f7afea14a5554daa11025830d712469b7749c55b7a1dba13986cb99e61473a46e8da6d82ac5875b337986e95c255e1188ecd0b857b26947ba98efe33110c2c0170f2f3c469faa429ec906a02dd5b4beb1c5edc8e1db90deb166a10bc7e99bd3d7cb16b91ee18adc2e75d7f2689bc25cd580d9b2dae1c1c7a184944e7bcebfc8d6e001753216b47dbd506da0b50384f3a4686ba8fddbe96894fbd428e620b4259fe001b37c8abfb6bb5ad2f236af89470b90c99bbfa62b3908a29a75ce4058e7f14c244315c7abff85d7c9396dbcc530b60856f4743c14e4b7ff6db405b04adf9dcb264f1c91bda016278a7a622805365bcecba28d88a45012b8c60d846c494e6ff1a79d1de662a2816210acb567dcdd1ca43534b4c382aa17544b77fcb124527f199e2ada80ca672cea85ed2e1104abc3ab3393c75a51c140cfcfc33ebcb1571aa9eb28f9f77f7bf8adda135f3c647d59f4d4d2a92da6a997d029b8a8175c530af7d4784a4d9128f702f74f26050193f67af040689409779d028a70bbb97e369145d94e1e4332f5018cdb2ae62f5c40f8a68f7cbaa7f2e20229de5e0437003226513fb5d4fb6fe16e2e65d1e499cfd8e79baae2aa6b0ce4b318802ab82c440c3b4bfd66a273df826c24144fc0587e6c96c16d39d764ea3f77c22c3de9a535c1f6fb33d62e54977ce9e56b8a28580df0665c2e1236bc4eaad1589b44792654ab07d72a407af4ca1eae1d70b357c10156a6337f48251cb989f55c7e646aaddd38fff542b5a681c709113a2d2777b2d2b46d98becef93ca85686088d99c3fc7c6f7dc4d36623e5359fd265f00d959a4cf1ea8a4c161f1903caf7fdf9e6c27b8f0648f1f66021586c26e48e1d8a90121e9ac3efa94467d2e25b3860a8ac2825c37eb2063bcd3e486d684c823b62713660fce93f36cd404e924f57569770eb7d916d4cef82a0f4fcd9325b0871c124c7775d349ec94b7680e96ce0480b0866bf81c38bcbaac2f846d9d79c291a956efb4a93c255789dd870f68eacb84961975da7fec19cb7a2d49ec4fbe9ff7fff074b26d1803519fa947239dcfb0f5ebdef4f202405a8a362764a8d270fa780378d4c9dec83bd57448b03a3f492f6d9af3ae5d991988655a234233317fdee63b4ff490a410e38bbf7dce81a77274cbe6293a18c3c4ab8f2cc7ebbf184d228f21079b3f6c7877c3e0a9aa74625984249343cf49b7c36d499320bb6c9e3a8f0a518ae5499e5471a9c15784c3e114c7a2554c502c686aa3061e627ec77e9f7316026652d5c1e097c9319cfc79de61a810684f3288f50f2fb21b23565f52d59533c18d3ea7e0a274f97a86c9cf43fc491d6f34cb247c7b6564819635b905540d87b188c1f72b45dd486906396314a403ac8d8488c16a95450ea7265301b7611335d2dc3c76c48b2633840d0e4a5cd4c670beb69c872f33cbd4a2c8350752eee6e61727908e145a8e23fd8ab8342a9774e203337cb94f2388699f9dad29988045bfceb413006af3b42aaedda496ff2068fb927e2e881a06fa824b871e202305450a5c780cb6003c2446da75bc47900d1af888c2baec5f53fa7697debaf49a32ae5476a87bfbe7963b321b0f4c66baa5b6f5f7a036d53aa9640bc77fa4ebe0436d1be5dd7209a4559a7facfac81348c79aaf9a3d312501fa4b1c3c50c0aaadcccd4eceffd10b22fe029da70dc403c50b568f37ae1a782e5060d30ac19750d2a98517f93b2cc9f479484dd1f80ea918bc1231b60ad8e7b4df4fb7d3796c378b83d1f7e0171411bece6822088b0739eb76f3f7b225635df85830a91b9e10a07d7e1f496a4f0f7d4d4cd9c904c3aedd24c3866edfbff7241f1fc5a45607ecaa49dc1517e514586865053daafe8b12a0f9ddec1b3f536355519bc5bb1c1edd6296878c94106973c2fb3564737cca5891d649e8f29f296a517e60d164d279f689a9c6d2ad361b0f004c0b15c4091221e33fe79eb9525ff78036b536f39e816baa4f27ba5358610ea5a56630a26f74ef567c3d285bf9b6810e17679f9096e1fc353af3ef5d205f707c3209f5ab2b8997634323ad2e9a13fd14ef2261cc40b180834b2339d81e5f15d3a16bea355cd3580474ac0244f784d8440ca93317868a93f2acfda4d05300f01802d2a053f694a61aa045b1b5f513b22ce22310a207fe83ecb008932b4aa28a8b3fef081df4488f82f277dab44f288de759476805ede8d8a6cbd912698016431a6914e422fed7dc3d20051494da6f81099c8f2d6ef527fc4170e9262fc23780177940a7ffe64b55d92e79d95365990e03631d0fee4ebc459a26e7d9909c77f4a536aee5986eaa7238903381b36b62438cad25081209e37023d2a851100659d38e77d633340bc6330ad2506e71b79ca7724bf83372b343176438ae4ea0ddd735c56a02814bd0c46de08de2e6914bcf937893ee59890e2aee65a61b3c0a5c3236edd35b9f889fc38502f136e82df4465b83c3c92dd2a96fea2999e80fe284766cfb33e9c87c28be65aa9a2c77a15843ef678c49660f1d5507608608a0fd11e6155a849a466df44c1759308a458ad36c0d8412861efddeecbfae83eb8f7b196ac7e7753340432f2901a5ef1b75c70e61c4fd4113bf5eac90e97889a8c08d7ca051998de228372b0bf26f59801bd2db58d6602e38287f6ee386b0a4f9daed9fbee63c03a1bbce0156e68d272fcc3e34f100c4dc66f812bc82e428278224e9ee0c94f94d3dd5d5f51fc8782f7f925f96ef001ec79d87eeeb4993333205bd413ed764bbf5d661819e047ebcb6383d3b4fce513204e67b5781e5778f901a653b71f0b63ef9a20b0e95674a4d9ff12ee5505414c788cecd40fd686a7cfbac15526dfa0ff924e52b888bf9ab84e55fddd7fde11876ef269aeb5e390820afa157a23242222bcd9b06525833fb05bb5ddea6f146565ece5652cf6c3502892816933b24e7e8d7c17e02769aaf495b7ad97c58dd98efe1e40ad3209dfdd1eceb4c02961d1a06db1b3274e93ad2396bcf751199394f867a4c901634f6ad9641bb2dbe8c14b98fd0d4d01e14e6afbbe441c1413b25a5c1298a44dafa3b8468742d26a387b15964a82c2f35dca51e8ce78ecc09bb59b4b35b6bf3eb39e83a1f14dc0256e4ac977f12973b30065b8239eb00cf1cace4814647d330d40a1eaf8f9d6d15ea8fb16cc06fcbeccebf5a8dbf60f6a1e9c1738e51e1c698148f64c6a52fd9bc1f51270ece124a185a03b64083beff96b89c8dd6e789cbec7feaf67cb65d39be120e67eba0b281e389dd32ca4f166f9d1385d1fd990c95f3d8e0739d01517c155c9accba21b5a82267c42c2e9995a9beb9553f7f36be2322900369abc98639695808c1fd75dd57819554982d31532499b0809f273c05536d5fac98a811135e9d3cd160f0417d6032320d3cd8962c01645c50157b8f7ccda75e0ec69c5954b22edae9183e1561723b1114bae8c3fd5e878a96240365150805b332a1e67068f207b63d7a3ace596b803c6a5700a332d2804b2f3f2205aec1b51dc7b73f0772f7217a7305de32767bf73cccb36f88dd27c6ec4ed5d4c580226d785c17db43447b9fa84a1029d6b04db0d6911159c6954c1a2878a760d1089b625928bdb93d1f532c7790fc36a96e46b7d5ef677682af417e120bb7fb95429a85521b341b2237d26474b4c9da3be94c26ad7202f7e47aa6661f8ce6ff49c15fb34dbe0fd0dd8e9ba358c2790b99b2fd4542b72f52ec2aaa4c75c1bd50231c970fefbd0f73e4f91033716552c92684e49d8799db44563d4f4653fd65b1cbb24c14c5e401cc162329b3f0144364dec7f1b464246c9d82eeaa40c932ee231104950d759768aa3d2b57ced776adcbbed33a65a9cbe4668c0d281a78295d35f66a248866407e545838776dcc374b36ea4737bec14890f963cfa928e8cfc61ddee7563bef153dcdf6020a4ee881985172128d05ba4257b70313843ff6ef001a502a967699dbccd2d062a5bd9db7d9e45387504bf07c4b75f14638549fcc422fff40fea36395d2ec3105563fd2436afd65feaee78d22ec1b2a779e247ca9546a035cfba16f6093fdf9764ed3cb2d2cdc6cf3b434cb986564c5cef31c34655a36099fd8969d897b9d9ac54f0bd3f2be0ad856dcc3e95c936d884a6c9b9de146f758fdb03be1a55124d63b3fba43d64d9a750f7dde0869ad28a4382835894f3f38d256a8211cd11a55265c1fbd3af9cf24e917536db539553b16a25255c32b3bab807315666163c959214755f4ea83214385ce101cab609be57416cfdba6c32c5cac31554e2ca19950a395f4d20dc117ce0537b1d5f130c37ca64887406ff8135f73b7f8ffc14a7e14ee0556cf57768c4592f894b30d67c799ee90ba67bd6fdc3794334339f81231a9fcf2c72d92d53dcfada8ef18afefc0592c595a14b254ca873470bb6f5b2961a54e0dc4ea5d9a70f89cfa63f009079d749d5633e5bf70c39f2a96ae5a5b9c719d17756c8c6c5f41464e309307301a8fe9c117c840c82452f154fed7ef951290ef0ccc65e6a605653825028ac61eb973666d57bc56eee6feff7300bc067cc6639d721945bb09a470dff7bf0b40de3942f8d586f3c387e7f2a8b575d497e51f4b757d68b024af0b2c1ccccedb211ef6453efb0dc55fae8d72139a123bba2ebccafb1b7241e7795ce239d46f5591fe478ac65aba92370fb96e77a725c87504fbf663ad0fe5745cfcd7f43df3b00ff838cb02bfdf793b6555c50fb5d3d6ccf3a721c0276947883c02d93ad0e5da2d134b396c8dc61d8a1055985864d1d2cbdc8a925af499ec2cf264c35e7fc3aa21ee6f7f84bfe02edf0b9a0b4d7cb987d1ccb9a94a07fb6fc4e927b7cf1c1e4dfbed89f1449c213618ad8b355966178b9c833e2135c32db5862bbae222e73bc2cd2d06cf32b0a01da15ca34b355c4e27b9810ffd4ba55ec5606cbed7f6f38a4d9516e0fb68656049f967625b548e40e0abab94cac06c8e145706a5eefb9fc99a6ea19a8056f11e7a652fe1f14d60372ee7411e9d9fae61c821e550cb5d2d243dc68aba271dfb0df32ff61b7a9e30fd54a2e558612d82188501e0710e9f22c2a3956a4beac8ebfd08c6b1995dcb762b1d8d80755abd476b3a5da5f7680b59dbecd0bd153ecd44b0e32a9c94240aa6dd9e3f1931531881252f8ef1a945d13e8158a61d6b07df716c12c6561e61417f844535cb5877374ff39fda258596a1b1e56fe202afacb3eba7108b245f4e9ab9dd55229061e64363e8d976a4bae6b612937daf7ad79dbe07ee026c7302e5dda420c835aa7bdd1635eac131407ac564e73cc95bf922d12e1ecefc0405a14347b1d668da60332db98739c31545ee38325349607a4e4e630b5069cf80f68c57f2de335a80b9d3c895ff867f01d249c65f38dee3276921a943a495feacd4f2a21ee54571f86c2c8f25dcaab43ab6e0bb6e64201b9cc69d16ae0e1e29a5569e4d108fdf3fc265ed64f7d24a11dc6d6821b3e7caa4aef9c4775c507adf3314b7673bac6577346076015ab21a1f5932b0023b1ec55aa3b778966ab24a38b6609401d1476e0926aa057ef0ee97c0ffd20484a6246c6087f7caeb2816dc65b1f5b3854012e149463e0618019e602de42d9bb66d6568313236efb4328f3d9173ac4a2183f7de9f2201718114c012ac999e16160a7e7f8c14e2ddb1c07a1c6d9840be420b2168a52c3b55d15d23cd26bb88e1ed120f8e744ec4379d3cbbcf2499456443a536b94c145d694fcfaed986117faecde0853eee7a21948f5ec1d63c22523909d9dd2bed7115edbe7c1d1cdfbd5cdeb0df27a504940d22246ed12801c424a695aa4aeb3489375685f1007b29af92f5aa20782d2c8e9f725fa31b2eaab40defb130f699275d0ca6c5e3cb4c1feb24808d30f331b977185111a2665b8e4fecd7ae3559a7b0665af4287a816058a2551f5615a3e67184a78015c33701b69e1a810b89e61af733128dd0c9625fe71de51c40f5a0196b06d26a26c36084fd729dd2c6593b5fa49960c2f79659e806c044e226d1afedede6561fc1170966b3702df31cd24ca4f3de6862ca2a64eb57976c01ea8a190c510a3ceefc8cee0e1d4feb6713b18d224b504e0349bb4d978ad19633f9ee32926b3d41b9b169939d490f17b0da61f800b5c0be201a7681e33a14b3844379b154bc7f319bf9ca7a5b8ce6c622655906b003cff4cca828298672881a344f4043b06faddd6878aa094852eecc74ce17b640dbeacdea8c4fa045e76da91d005e63bf667e04e522e2e919c5c54dcd3984cc2744db80f813d84848f3fa69dcc101cfe5b96c16a62a3e2d64a8c2e028f4b83ced885aabdffd2f39cf7213d6b78c1f60dc574fe36ae9df27c43edb7dd9579ed8e61d1d0628a09135eb95a4375614042d1dba400bd33ea6ecebb1bc57fa8f122df3ff365e8c5c3d7670e8abe175828848930183c5d54a8a6584f99589391eba75222404bd4a844fb16697b1187634dac3314f208ce5bcee94604fb29c34cf949db90f3e6f9d5dcbf241757a36ab5ff7de37509bf08e96bc933166ad14086cb51f379c59ae2f44e90302346009679fa7b3365b25fc2511093fe559dc98aedb55b2759459b8dda15d6eb97e206f3263756c29d271767d674b19f8e80f941f13724a9b4bdbc5ddba1754221b8a2f6179e78f05467656f73e44268c58872ffcf6cb7f19de580fe2e82029c95b23c4bca812a58430ab62a2ce97fc9e0d0df77fab7a934e0fecceb703abc16c60ce91f585e32fa2b00046a15d04478b66e05d6dad8509d7d529c5f12d8234c946e4d2853c5771488da0d4de14c6f9047d7c816fda3bb938e1520505a0296c1a10b96e1d5594a5c2680b4c9a12350dde86a7d3c2a9b6b89464ab025fe953d6d982a2f8834f88c1d7968682541757d17407151df17191c46cc1a4d3388d4ec5231a08ca1069bd9cdcca61e504b0060742c3eee1fd713ad27c0ec73eadabad9808768dd7ca43748702e0b00f5f96a409e1a809d63fc90047a410e14df24b8d6755709183dc303ab6e8c60cd2ef51c098c1770a75fd04a35d252b68a94caf7f5a438ff73ade75d0d40976ae1f66853f7574ba2a4f4b75b4a451e5bb9bfa3693f43d442e6d998b639c758ddf1e109d3231f0bd9e44e32ac87015a9ec95fb162adea76d5830c7e8dd6fddcb05ddb76a87fca0157314a50a8cf6e5eb7ae45401b53e54dadc2f5ea06facf2844423b2050862db866309671f87c8e7b7cb63c048cc2d4b9c2be5ab5879754db9f200a382b545a31cf89d365726f8d86138b534436bec095b7384d7069bfdf5ded8d0689e604f080a8c7aa0c248283b4d87ae545a0883a75431f27eb907cfcb83289e18046b1a2fc31c0a13cc3f1d4d1f1405c376f1de79653e672f9cd7bcac848e97515f6493bf630dc29590a013f18aa5dce1b446faa75f7aa941e2e0cb1c236a810caae261539ec260a805e940fb6683486b6e773f7f3fe16875743afea7a617e3c9591cedd098714ec7ac18701551cf587bb61ddd630df755e59f9d7162dc1cd73dd4e3e5b542b4dff2d5995b73b89d2958e27355571f42837fbe360193d69bbbfd6ff3bfac159d23af268bb5131062ab10c2bd7af39a7a530259eca59130d0bf100ae53a58f96f3ed8d5b37ef6119ae5e19a4211dcb222d8043b3987880d8de1d07db3bffababb84714dede1074c5b04a31fd02e11d83fd2f69f5e50cecda823b308ce3b5599807cfd9f01220df30346aeb2edbb5cbe7570e79b5faaefaab2ab45d0f9f53a57b78283259eb8e4ba2c38198e2b66344291041cdc5abf6177f76627c0e9b7db6bc3cf6e002a1012646f2da27e7fadd2521c494d872236eb723427215ed6b2d20b37448397ce200342c09e7b037b199bdf4024d91fe14efc0c5c2d0b3cdb2fe9a80b5f1bb812d12600afe993fb92466b3bedf2d50d1b5f03a9f27ad4e88065b51660f1c1999de3f63d0e6a484b567c5186664d90eacc817da01da9426879087931a74f5aa14c6261fdcf087c755e916848125cb3510f6986048a3faaf783a6df5e0f74396edea443b24be788865574e0781da56d6a64b277116643cede78ce6bb6281d2fc8a25e3405b7b6ec7ffee2ad67de75c73e391129b690f2a9d301695c8c0dd1f58d284e539c013efdc21692f0df234f9c58e5fde3f4e51e91b95345ceb830ff6109a1554e544ad667ff515ca817d3609338591a3fad694a3c4323166c6aa170a9c87997160a69983a68961cc764b21fb8472c4128feae4771e529219f335ba35e8e170b987515ea4f3621b3c2ba7e34025441ed22929486112bc752fcc1a83161da3665791ca45da2aaca2a53be9672e2adab1eebc5f582a842ff7e4720700743ec7721ee6de95d079e5318648e9e409a3fb34520b7b2da896ff3b768ca9ae28ab0c51110a5d7e30900c9393c7e1b686e50f26b0fc43126bc4c61f9bcec4df8460c1377f7d44ce5c2bebfa02e71c80f18d80e6ec52a10511393ed934b41429d18bff66d0c0dddbab6ad82b33dbd3ce5bf75b68472ceaad875f5c81a3620db1357dac982b5ea7c0b8e0e6269e13ffa2f8cafac44a321c7f81b6733f39590c438f0fa400ab80b5e8f36d773174f7300e51408c40ac40967d4ae9bc1ed2a4f4997779eea3dc711ed339e92457a23738a6dea280ddc71dbb4afa332fa7800c3c48cf605f5640a1e30ad80f3421d4c3b4b3a0574f025b6d38c6f679cec64230d53e4c91340f2d48380699756aa402d6b8febe9a4b52367932ad1eeee7cb33beb8afde695273c4f0169dfdd9009c7934f0daeb07ee13e18e0b461c24398f04540828119129e20a0d421959d3f9e0843ba9f7cdf29b4d511aa92a6a23519ff5b0b023ab123c30ad85266153d7637fe7ac5b5e8c4df940cf4387f717fb9044d60a22268fa6901c72f8520cda44ea5f2ad1b7a2ac472205d5d7c8c7fd1156f5265a8a66e88a5cc4268297c2b697cad0b7077169d3663e9d0ff04c85602c1250ddfec089c4a4019e4adf5009d2118056c82345e2b287d3f50d0a1d2c6dcfedd1160c66ec0d277014a48231fc03628a5c0d7cebca1064b957bbc01c99828136cfe80befa6069d9dcef0c34bf52a3aaa03156fb3accbcc56e36b88dead855e69c1d97478d6f71781471358c8e179a558fd657898fef9c4f3febe35aabcca81d7eb2134c55aba1caaea92134c4d50b1f9081561cdc10ea7d4f4c58d1ccd6044febdfca771a93cfd1d68a59f60e6f826a0d562b149c853427358dd5fe30910fb32aa630a12a6d151acbf9f9df4aeb0e8104f3ad59d2dd2eb525e8440f706af23daec20ac6c9026c2386d241a267d6378e094d969846ce28f60333145d28d6b1988f326616ff5b781088ce45e88f383f7bc8807820e699dc071300eecf1a09b4802adf574cd7d491e90f1bed6562be5ce7287ba99927c32cde5c20ee71d8932531be75eb1063a2e8867a538d6eb350c8b8df1a22ac8f2ae32fa4fb59f279b4efc7fd63b6cbe460835f0feebde3771018cb2b073d79af15c032e86aafb6ce51ab58da8ba7d5768e7e195bb66af2b4c32de58b72a9768d408004c6e49878f587d2bca2ae5f914704d357833ab8915e6d3d4beb6fca8dd7b297a96ac3c31b9154b75422791637851db6d99f3f0de304b7a6f9b4a8175913eb645fda85d28f88400d4fa91d4725d0e8ecc4760f2d73b2334e856949eeb6e7a4a45a0e522d2ad21752da9b1a70cff99ee48e938583be1e5cb9f629ea8cd12cf042b894dcbd7962796eb23803e79fcd57113925d179ea2dcdc579d95ac47bde8867350ac2db67c43d3fc8b510a71aec2a4927d77d58a96e0f1a7d123dc272a2b343f2e07f675e9c25b64f87643c1bab654dc00cb8f372bf46eeed814e01acdfd9a528597769eff4204af1fdee12e2d128516641169fab21808b393d0fb310aaa796f06cd12f22238a1e9bf61faf3a8b4ac96c094245cf92da7943f52af7283d0290eeea0dc836a36f2ce54d99ffd10002c26cc614446910fecd051baa8a26d0da8f4737cac20fb71450cdb3585bfb544b9171d1d5334897cbb9a60d37836ac9f3dbf63d5186b9af2a9596597c291a774f585e1d8c269fce5395b0070ddf2e2e58b218acf737251c4e5d6c95a8574b3a7ff96d4924d2a0db3e88631d0c61747d2bb2686fc83f08b6463e3558945f8940d8267ef8f85ea8e9c738ee1be99124718642c8d15e717224ddf47623e09b29e950cd3c089c50240ea3d94f352aa449b4e33f5a4697e337cfc7e0dfe6caf1aa5afb0f8473ff0480fe59d896376cef79bac34af078cacbebb2514107b4de5d124a18837eada1c8ddbf4b9376235915f1d5fcd865bcd0f2d17bc55ea60c8a775942222caf210543109a3c898af0fbfda493521f05acec2da0d802bdacc7fb67becb528b22e60e721ff683a80ba4f6548100f6d28be10f81284928426c720d375f7e88867e01852626c43489b35bab2a8f7b409de3cd2a7e0c7f721962248e779382c549785a2105fac9219b37c9479a79ec7045f372e202eb30e1c56ece240dfec3b7e28c9c9ee989b342ce04e2bcba957d7ab66ce3d4a1d6a9e29d927ef8ff14293d70a2c0d4c097c9fe35b64aeb21a0da7da6a8cb5d60addca715e3f7f1feb8cb01d58e7205e90ad3521c6c919b0af9baa2159eb450944fb1df84450ed6c276a45f6abbcd73d72384897f8daea77800b1d393c5a64feda4d1391826fdfbd2dd7f3d96d49358dbfd0a4bd5ad15894e29076e679ca2c6733d8d6455096149c88d8ae07f7edb2e80999975263b1032be2a2b9579e829da764441d937cdfbbd97565f9418a365dfe0aac522e962411795fdc9b24b49903f3d4fd2ad5ffa126bde2641cb1246596e705451c6c6676b262cf0283b652ffda0c6559b5254c284b2a3f7137ee803dd722e3bba558274910b956d94a192a34149b676d0eecc659d806d73779c196efc45b68e50aef6bccc8609c2182e7c1b3d4ea7dcd7629c9a8658a4411603a58715d22c44d54b48953c4c6543bd34a9e0c717cab2536ad0309a319a84462ca8966dde970e21689b1b6a8182e263ab05860e927ce3630c8df38b3288fe09f993c4c532fba1174f92d768b698da187e53f001e7c497219fd8add5f65f806160fae7433e7eef1071a7c0651110fbe5c28331fd2bf61be5821acc594b5b42f6b761fe273fcc779d9c6020995f6cb0a8d394e145f5accdf4dfd237670531c78065fd1d10c7cd526d9e17b8f33e938129e1e345c17152acd6339994dafad3fb4a73964eccf99462c340e3d2d99c919cc5ccf98a37121942a2e3b1146c26b4793fc26d17bb942f64d0373ff1157f2c62ef39276d23b7aa4e1425a891a275493f354318aa0e71450662022c8dd4f181f42a41ed69fa5771e2a089d611e87237eac75614a2079af913cda740acf83b7a67cc64dc3960979e4d871821cda3ee57a6fa7d7eb527dbe506ad082e6015188fea984669790c8677f16392adb2d5d6903f2496b933fd1ea8f746a24df7f2b1c2445cb93948d8ca11b59527ebd3b345d45219e892f65d807994841589cc096d1a9fc32807c886fcc08fb56f429ad30f939d66e914bebfb20c973a2cf5506949bfe23ee607c53928d688c8a61019990d3acde5965170c579318a895110bccfed1fcc596d2da7d95c002b173789ce4dc08e80a7e80f9aee915cdd7c9270b50fecc9ec0890d12bf50435b23a4d2f8329ec4455105dc2a2c5366c172157556478f39e39020ec9649807a976cd9986dd854aa6362b76aa10292c2304b9ff11f58e4430a0a4b6439cb5d42e799cb28f7cd3361260731333d6c7479f4ca965b12dc9bfcb522cf4d7961e41b8939d55ab37e0c3df9885e32ed1186458761ca85ca91abc341b943c8e2c584818585a2357e6268257aa67f995dac239bbdb8e4cc7ebe5bc0b590c2c90eb8de4e65c204cd46091ef08bbacf90af40224f6e2be13c673eb0f02e3f14a5a6c26e008d2c395a502ba1d74ef527c23bf91dbcd8a1d914680296718c3f270c0c4d41654d9499412910426e9a710acba80bbed9639657d048bba4f1a208d0680ed3eeb7170ac36264229c7507a6b17be574e32a447f585523104c957df7616e89ab99ea5892ca6a65e3e05e67314d54e8f2cf0defd16ef4ca9d1ddf4cbec2b87995c9123069727a334161784479b95344628893c8c79b31c84581c519b17883cd9cad32d19ad6f3ae7da74b56eaf0dccec1da708823cda4f4ff3ed722a639ddf92f02b1fec0f27c29596a27c95e5361af4f2a982d846d2c2573fdf960cf47c42e3a41d01879219d228f657e828b8c06530a091f1b6ba4d6234e466ca09a50735f5a44ae9ef7d97efe8185df071056cc9bc0d8eef514d52e60579cc4755f62b248ee15ff62f0570870c39eb98f42214d63384513fd25c7011f7269d310a825a40ac03910613e75b487e5094f3fd1062511eefaf3961492a3e5b01e878c766cfb2a1aa9dbb1e3d3c16773916cfe883ff7819a89722f145e7f5a7d7dcd6ff7976cd8db58d7cdf68438a99d71d86cfdae18a8dea7340cb5cbe5d436281ab003462a2e70f49966898584fae033e48f32018305101ba9c0142edd451ab6ea2369f4c8fa5ca21a9312ce746401b6ade786c5ea9585b84586c905fb43e04a5ae49ef5f17bdb0168c4231319dbcabcbfde03b91541233d6d2479969470d248ae50d632a0bddf6a0186de358542d5b1a7f90ef0843ca669495de6dae4f1ee648766a4763f9395e557459bddafe0137b8767f3b195e9c441da2d672d9bdabc8bd19570c70bc36d8b9cc080f1b434b9fe90e3ae5fb4b4647d1e3768b8a7fd905f26d5074b51b17848bd7c843b3f3f4dfb59d82e2d973bbfa3cfd2dd07aedc29b1953feecb318d4d448075f77a960fdadf5ea20d916a31c54117c92be9ed015943833e01c7cc2e35120344bd7fd3c46f1c10d5fe093614719e102630f543e52796d409cfc13b67ce4ec06335fabb0fe98598b71ed0feb71c4ad72f748936e0989ac30642e1da95365f7c9546972da88b76f2b11a72ca576ab14232ab4c5a9ac41e39640a136b3b04d7353ec7f46e37e834abb71af6f8923befa2a7859976c04912ac4c83aa8e754b0cb2bb8a7c91619e1f95238dd0171433178bbb6b46eda5baa294b238d10bb21be4a93198844a229ff04a0aaa6a817e0cd6bdef1b3bdc0b6a1bb1be22eb2d769f60cd6f519a0aa565c94592d28646a0f7d9053a15fe4f2ff853c2a99c3e52cb4813881c57c0e6c8bd49092fc9add0261f3e84d022bd916670af544345384c2d8881a5a1736987f069d4273471bad75a84a3b03041c596f0374421d45ee4ccb044181c16ee0e9252e1289209b13b585d27bac7ce76414b9b5806b3dd670c96b84b92f6dc9f4e579b02234a2aac5ddc8c89735cce41dfd8a360f9f78f42d71b228037cebddbaee6fbc71650a3219256e43513f8a1c22fd39471548053bebd866f3f018d7dced1a44841321ab9e2f2290f6220d75208a151efa7e0100b2f4f58bbf6fcaa6f647c72639e0ae0eb38d73ee8804f0b809644e788c8f21ad82b733183d41a19e148d6aa5912784a472bcc79d11f4f65c1ac0e057e90c970f0b67def03e6176930837a8322a6d0d4f3fcc3c88d0abd25d860b7314298516db1656e4e92d7249b6b7d33a3a6e95131659f4c5f33bd65fed53dc819efd0ec309eec88e10d311813262cb47d8ae8b17c58415f188964fadaa70c5d6829c8a8a9e029e29031f67bed2d1c88a1df4cad01a165703de173855bb5790580c73be3e2ba7ce4c52b4e0fcf8e6a69eaf52f6fbbecb16711f858db2244199b53aa26facc028e6f6d1c34634a1bb25ef645c655631aa28bc0a3f4e5abd2ea26037773c0c5f0f6929e398575163c6691e75b6bf3217cd6ddc3a8b1368028f93c5b2c9f39bbab95de6f55ce11a23b6b77112155af5163816c6ce6ad0770896d788648ba3e6900b9e39186efb33926c515dbd4db0c60e7e3d7b15a4eb9b90c5645da10d9a9ece24e845f72309a3f4cd0b5d0394af05121b9e610a4049690ab16e84fa97ee9fd620d2fe0450166d709ed0051c09b78dd70fe78a544c79498cf513efe6942425f48198d098d9eed3543bd0d58a9f459c591ed0a2804c59ab5bedbd4c2e90fad95233c7fb3e2a1bf4549b6528a67021762209444e5f381c54422b08fe49df68c668853a0aec6e48b502973cc8e5c9fb2bf9178b6ce97b8cfe4761d736d901e984b1f29bd484717cef53b534ea40160aee74e8246140b163d5b817fa0dce34122fd96d6d22549e116a8660cc3158d551b163e4bfba5d28aaff9287491bd70ce14f83482d9f5d00282a216e9018292ea6b4c24cabaa1618ba874b5729d779b8c890f563df6fcacf287f36db41c100716e89ebc94b59ec5658e18029aef1c82ca520bc5ef05a9aca96f5c22ae120a3b2c03d038c89828bf4f3213e3925f321274cd7bce02f924639d02c8df56b0de8c56a822055cdf096f2656d51bcd300c6f3c0f1a37980d71c622810a81a0cc5016e557dccf74c78983a1ff8a2b23cc6fe2bd3f4bc5adb8ae160757d6b2f86f52d1d33bfee08175d165afb78713f0f4f95c3f7dbbae5a3167e3c967d91b875d2128e6d7c24ea9ed8fc23be0d0e47718e7834e2b44ba00583951f238c0e31d4f44e992806519677424c157a0bc854996ba20729429391e39edffc6e6a90b785df479795a4e50b781793e3762328be52c9cd5744c43d6fcef78688493794d914dd7abd1fff07ef4cc0906c2e0fba43f2546aa46592e5fefed59e5548eed8cac514e66deed73f8cc67c8960616ca531dddbbfad10b5ae67d80571d07d1321243c5c349c019b5970799d9efde09f9792b79907e2adb88f72847a35bb6183276bad65bd6fe8ca143b9b3efc06eafa37e599108f4ad6645c8222063e8ae6b421fc3000e211b94eafc8d20e6a25d0a0caf8e20b82c98a098020ef2e7e660e50da0294cb63a6642a0a49380049780aeb5b67a4e7e06b39a02b15a02ed53a2a41b8b86b708b21bd1e1bed035855a962a8f6c762718544ccd0884dc72035c1a595f5d335d8bb3e2c9c436a1b1d0bf7e47ce19a4a7d5ff21191b4b0f7e4f8d2906161ae24093fa55f26e8072962081f8a46eb4e3b411a77c4a53ed607cf54a06b449528256a173fff376a19669e1fdbae88c73e602359b216fcea96bdd2f2833c5bb3363aabda9bf24ce6a1fe0c1150fdd1be73cbd5ff6e5eb646eadc1de8ef509d99003ce513e001679c4d42db6023f451714a6a0917d1d11d2c066bf4678a16a434d9ee6326396df3bd561135ee3dcb1ca3c3cd47e56fe58083f84830a62b823de0e7c629fb59ba54e3a1d95af449e7d8280817ef2e4ef9d92db70b2e416f7b72dd2677d9f51a7b59024315b5a0cd7cd12242cd696939a6aac512e3952d6b29f6bf4d33124c5b3b6d4f4b962aca19bcfad4a8fdd2f147734a62f2252e5bf1c2f528e5e22e312ed635f3ca5f838d863550943704305db080256970557568af93be41278683df217c1b6d98778ab049e1a2c1c2e6fcafb469a6ea35f57fd6c6564e9fab1c1cf235f1e5e9b1f77412243526e6b6f43cd6ea851b8257d703d394c0ca830854313e28fb6199638f15fc84ef7a0efde74374d395b6905fba1ae22ae59d0bb8414688e1af2f9a06ab3e74ac49d8436223741cf5762c3ec6229bd41e01d2278a771cb7d2c83ab8574bc6ae8f0a679a3b572c6aba57e6408db378f898712198ca77e6a18add5f8d3626b6122a6c1c86caf78906286256f57ecd6a33fae1d19835cddb44d6c747fe2e07d0809ae9dbfaad335227328b0131a17bc24e73a4fd1a9929cea733b6a8f9a912a30665b44e44020c55feec0b50f78e033360b81a791c84361b081fbc51197d27cfec215d976012a4e672ee938b0960de94ea3019e6f9bcb658dc877fb32febf132e546c3a5b889e01dd8fd3b797fbf1606931a03a7d35aeb969778495d27fe3b10b058f7d1dc24375448e3602764fbce3bc1dcf295950c66c067c0f695d180013aa36af16ce77da81c486ea60a71781e43a9eac8aa468c08097f5fd2316a51b8c570bc013eff45db83ebcb1e0c482615790b7950dfeff12bd41ca9f4d7ee73af71f3596c44df61c4b4538e4add7180427c7ec0d440eeef63459b14f34ce7dff486f975663c932833a677e3fc5e74cfd196a417ce192cefbdcee3a0088b277a2586507e1ce12d3171d9e7b778d75a1dcc107308ca63151ad005120dd040f8d70be229a0ab9b657bc1728ffc5197185a9cd7a8af0353213475d9219f3f5b7e1e546f21a5d03e70f8f2fd41d94c568686b8654253aeb06169052a8e5828978020886199c3f3b79d065bd616e2a159b9c60812ca4b768ec8967c6710dcd26b184fa9b902bc5b83a38f19f1835180cdb5ed479969a86f9aab81678450ad3a1d3f04c58937b62b25081919d9f37c173dde690b4d1481add0742e9e89dd44ec957e6478b9d1085259126a0237d90524ef3a8caa5d92d3c35950edf06248e5d5784a713d38d9a28a605ea31fd02c272f152ecaaf97dd0a5dfd200f7a459ca960ccd84cdb3cbab2d869f787f44508f2b19655126dd194ef922adaf499fa7bc128ae9632007049f481e4a00339f9bdef802891275ad668dcfaabaf9d42897886d08aa2619ad2ff6706b22542182993c8faa1eb67445c61381051f7237d22a687f342e7a094130c32de0113569e7ee0db50624791068cc3f95a161be59d9f619e04d96237d46edef43d401444f8823c50778873efc444f4558b012854aeb71597244c6f94698208b4483a661359eebe06c39f969a7ff0802c0e67011171ac4bf5a63c28c6a63137d09a4f73815f43925ec233f9293e1aa41699f9742564f8a3a301dd370ca1a55394ac831b10bedef14e0609bbea006d6ca3deac2852f4e8f2fc3497f4b30743ff0db48243cb64c65953310558f755c7d31df05970119c2f66691661cf2d3459fdf796c7fe458a768f2a54d3b6f01452bf10051d2e95cae021d74c0c3f7067ea94bcaabe31fba911e2009273f5a13a8c103339a85b603725ac8cebe0b54c175dd5386e7582f1acdca36b43505a444a8f958d9e690f3688ab91283e32615d5ef7e4ba03b75fd72b8af173adcc0199198a32b6f896e4e46375063d301044dd9f6a0993b42bd911880c8e805b904a95607b692f599ef785c39be3e35ca70fb2a4a23157521af22b39b22fd0ea98ffca1fc435c5a7a47adae515c320a503a306d046c941c34c950bdb4c7d5ab33e9b842202f6ad4a3d6e106a1d7ab56a74b7a71ff451cc72b0a9552489ab3cc7c7e81b23cf1f4092102db5cf500a30f192f28c6e91a4bf0f56dd272c71076de4de8c2a87ab496e1850f68d86f0d811ef6bef6eba7bf7881566ffe67f133ed8c99d285060529f6be05f4de6abd66bc457291bc2a81a54baad38f94b12f7ba3e65112d89f20b7840eed1cf986a45a40642b69fec60c78acff12979b28a5d52bde885c980840562d6d49dd822e73630546f986c231a4bc8169604444b47b1c9481827726e21e6c9313b88aa3e3789b99f66f2d606e02f4730f1b3c5ee760d2d97e73f08bd236e6bd0cd8c1c11bfd8fd47b64e1771a255a92bbf3ffd3f2fa3d55f9e9ed76ce7ff94b12bcc6beb6c0c7e3f7ce714b4ee58f857275939c55797a2db79f4e873d7907c191d9ca79fec544cdd21a547b5f7b9a23dee7850ec31df41544bfb159bc4927f0c7ffbc8b93514743072ffa08c4aa40ae9d125069b2716a26e5d42b4a804a211307533d55bd1addd4c96bac8c57074313bca48b1951624ee65cf8c8175c880eacd6e1e5f507f33c9e31bed980b6b0b448676c3c04c953b03a102fa9739492f3764692b4b42e5d4b1c3704aec63168c8e4527356c4ce0a3c430198cf61b9b1e6f84103dbebd01aaf66a4530f8437ba472f42322b85fb2cf32e44789f5eaac62dafed5471b5de4323d9eaddb5ac2b1bdd6f930c702ce24dea6ffb36fbed546a450b6497865c42e4da334654105b1c0977beae4a51420bac80db27f4fdd7bcb77153b091d9831fcbd0e8be1eb3fcb61bb5967a5898a65ccaacb3393610ae211d99007bf51d1da2c31e303e88f4e97875102426cc8f3ea0c4a63f72cfe6659dffe0e45b50dad34b0083c7a4bbfdccabc9683104867ab90a871741ba37afde8210379172222cd91d979ae3096a064ddb0a9f039583eb9ef3c7c3258527a5e830bde84fdb461674f8c7abecabe93f0cb5d4beff655a51254eb34d218c63e7429b89bdf12a57b744a872f306a97c8d8af40c769a7491489ccbdcd767b9594b17a9b70c8d7073b28b00bcb3d9b1fcc51bfb8600b623ae92a46d4752325b11e6e2c2a45ff9be9fae7ab339ee64b39f396a983c5f8660e72e4aa9a20e07b32989bd11f889443bd08acfd15ccb58a9df846fa595c8f119058c8e6ab4389018c86a6d60efa555e0ae0f8073603349afd39aa7c6bab5a7e7687bd71e04206dc3397c0c243f9d7ab37a02fa8dcb99dd2c37466c0f13dd561d88f07356403c6c358abef2404f8ddf97b79dd01b1ebad555b29dde0626b8809bd3094ee24b79839251d82a538373c6ada143e01b0bb4d0301d954ed77ced1f8d5600d970772d0872c29d40e8aa12a5cf6af4d8d3e14ef1b030f0155ae6c3772f50cfeeab141a5eb71ea5d95b4012ed247959ac406884b5e8230f892de0b3c888cf257081fd2416d8422c50bbcc497410dc20cd5674faf68b0adb45aef9744c7ab62b907c707695c1743795eb0075a0e87834c2a8dcb4705e057cbdc1d54f1ecc00f3ab7c43faad45c69df2a484256b60266be891762d15a24f1ee839211d4e02d13c502ccca0783b273d985930708c91f27f5ad86592b1d64e342aa5ec260192ca32279111335ca13662d26d70b828b059c5046b73a616180770aaaeeb65d61b10ab35510dd8a35600af8230d7b033f5852f3881afe5c5c168f90639116d73961f3bed532070f115cc6c9c7d3e53638ddb6e82d6e95a5648f5df3a150aa30ee7633cb2f49d3b7214113591b643c7908672c090c1f31f3fccf78c450dbefee175c2f51f0a69961cc6b2c0369d33483d9acafe904c8e510b48c8578ff3fa2c01fb17cd6914f4145c6bba6e50b45eaf6d4e5a7f3df8d15cd1c9143791604c6e785d2dace6948395e45d4f63c6ed1a1b183308632ce11322463a8cfd1fce1a4ddb300362f304fdfbf73c2a217a4ed47a917132a41ad2199e1e5344e4ee560ceb6a5e601ee4bb8791c771506fa8897f80dbaec6480b9a64b6b75a54e712e5e73b000569621bdf0480df9ee77f8f2ab70c67e1ea9cd9636cc5fc210b2b4a7f97891ae3ebe0919e6287174600e3a434d476e74612f616952cbde67d10a9059da2a26c19efa990f7cfb493f7bc3e669e3f493a8bfd55d46b6a9ee0641a1278d589ae995007868a3d2d4860c491e9ce6d978174936a93dc06eda56347a9173faac3e7126207da2e56b4556ad3420490692049cfb46b34956f3bb00f3a000373f20ca826ce9198df077846a1301df4974232b506b2c89997f6d27c8cb971f9650c5f4e400c9dd030c7e81ddae6c796bdf314e74327a46bb320c9ffdf197f0f103b3387fdb6617704e3b0aae444c22fb411f176044a1f0dee1993046ffaa4129f3d790beb510a4f44b7ae5ffa1d34fbb02e612e039af386033651fbeba3ca43414a5de154bb0e82df736391e0ef57e17fd6f80c587a86248d3c8df7d2c7d1116d48ea21f34668b3db22ff9faeddd7fe668c7c477ec726d4860dc2dd0a89199db366c5b538e2c0cef01ed608811db33b85a0929d39cdfdc394acbe5f4e8e526323658122c7ceca0a253a0a8a987c4905fc07a27762477b68ef66d295cb519bd33b25be2ec6fd6a560521d4ce2d84eb4de66ae460cc8f143b4a0838f02a7226ead1bbe153f86e2cd95f4993a383e1cbaf78414019420e2ebf0363f2b9fc8a00b9885a7c4151e939c82776fde3888c021be0635d5f63895743080c8e52c2c6256a6027d6fba41e2c07209232898dc8ae4edb8d37d39a2c1130169793b37872786e20e6bebb4a44894ae6e702cdf1afdf0525f922450f80fd7ac6b135c851d61d05b86d34e438ce6624305bff310fe7da652457b1df4e3c4323ff849ccd19a14fce797640c0ee905fcbf472b531d1fbe095d971e672ca1027dbe6d0d2798e0805ca825ffd4bd2bb8f3f5ad9dab577012539a35932c957b05994ddbe232546b22f7b3e0d72374d4b9ab2b2afe9cbf663056d8e568b73a6b58740f9b6e651148af79f26197c9bcc724e24bab24edd983192bd46cd646132f2354c90691b8287d8703f60938d74c8110afd2af7dcb3610ac60a3e315a64f5dc8ad4768db6935e279d7a7e2d8290375b01d6205eaf05915d2799ea51805c4b92de7d530d53d55414e4e7be3114bb45fb7a2fdfaa6c8a720fc3d9f75dc6893b406baf327663b5c097171bd0a01ad96c17e2faa7f45640feb936b09b8a2577a6a6666c135b5bdfb6521b009e8606f1980d33d96e8ac36bd4934cd932e50544ed2430ef3134bed78dd38cd6057e1ac8e6f41174b2da38643f329152e5aa6ff7e52f6b2b7d40affbdece746b3f0ffa8109efee286673fb3f434338bf762983875ba4a2ce9236090c4b8e92ab7f8ea7c8e0dcb0e8e1151c22ba414c45ac36f95dad1875ed940abd3c90987d4415c6925a9b8b534ceeebd57a6ddfeddb91816a0ff0a85a73cda4c3aa9caa49c387d4e6b4972b744f6ed575c2ce0850501159b65548e117fddb70ffdc38f2ccb9b278116ceb55cf1c72cde00bd352d79817ac533126f4dc4d885c6f83cd0bdff1e0b811a5891f278a24cd740c4ea9964d6495e996e83bf377053d82f4737edb0cf11ddeed04dbef1645e20ba255e66ee52c8b866f5395f39e0ba513eca115288db1585a0df23f60c9371c88ec468e6ab60d9f3e875a193453dfb2750e587341fb9da38e8dff771f435727a4dbd2ae75ef1ccc47a8fedf2d174dcf63cd28bd8f5bcbf54d19cdb7d2ef4fc50fe1af4b293ab0eed8cbde1d60468449cce8d4a8804d59b76749650bdf49626048eb5163a6024ec1d54d0526144cacf4172e74b3a68b8b3d6483d779accbc18c015a060f5f31f008a8111d79ae928978593c3cde2161cd823681e7a2f582ea5d7ec155e38a7e65eb2b7df2ffd8acd2e8007587d9f8404a48081571d506c61c60609ffb303d8889a68b1249b430f554e03bcb66274c9c56b8050e03a5e9c886109522932f4c060e8fa14c5d4e74134fc430638e54093ece2593a539901dcbc858a731d3f06cbe98661062b96c470d8d193f22d606bbeca5ee045db437d371861a59388ed9bc23db3f193c59daa856542eec1f5b7d73bd69b7bdac216399d8873b8b6a3742f53a31332de98be2b1ff89d55805c55d4c11a0d605de973b4cf3be7b0c8f22af64114f6efc532cdd7a8eb21a5a4cb6d26b47456b7071e2674313f6ebf3c1dca972be1af4b2d2291dc637b2203276403f8d6a8b9d094ae97b42abf0973c3e45411fc71582b2d47e7e2104fe43d8c57392b22c3eeb2ef86b94b6478d3bb415187c162de7c2d0a8f85344309b8047a8f13774de71533a36540715c94dbded104cadcbe9113a2c2be6f56dc7312ad0729cdcb398b7d2121c34008de6cf2fecd557f1c59e304a77d8837a4ddd81773b157c2bfb58085a68bb1b5b772f23ec4808354e5d6780719c1631d700c7abc120ca6975a1d2c402e2acefceaa454fc190d53122bb0560c1e95c90288bf1a4965b7ded9791e9d84339095383431f54849cb60fab61e739a1c94f48110902256ee4aaedde0148f</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="区块链" scheme="https://www.blog.hackerjerry.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="Blockchain" scheme="https://www.blog.hackerjerry.top/tags/Blockchain/"/>
    
    <category term="时空区块链" scheme="https://www.blog.hackerjerry.top/tags/%E6%97%B6%E7%A9%BA%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Deep-understanding-of-intelligent-contracts</title>
    <link href="https://www.blog.hackerjerry.top/2021/03/24/Deep-understanding-of-intelligent-contracts_new/"/>
    <id>https://www.blog.hackerjerry.top/2021/03/24/Deep-understanding-of-intelligent-contracts_new/</id>
    <published>2021-03-24T10:56:29.000Z</published>
    <updated>2021-05-06T13:02:43.402Z</updated>
    
    <content type="html"><![CDATA[<p>参考官方文档进行进一步了解。</p><a id="more"></a><h1 id="智能合约能干什么"><a href="#智能合约能干什么" class="headerlink" title="智能合约能干什么"></a>智能合约能干什么</h1><p>在各业务彼此进行交互之前，必须先定义一套通用的合约，其中包括通用术语、数据、规则、概念定义和流程。将这些合约放在一起，就构成了管理交易各方之间所有交互的<strong>业务模型</strong>。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Deep-understanding-of-intelligent-contracts-1.png#align=left&display=inline&height=273&margin=%5Bobject%20Object%5D&name=image.png&originHeight=354&originWidth=865&size=56096&status=done&style=none&width=668" alt="image.png"><br>_智能合约用可执行的代码定义了不同组织之间的规则。_<strong><em>应用程序调用智能合约来生成被记录到账本上的交易。</em></strong><br>在<a href="https://hyperledger-fabric.readthedocs.io/zh_CN/latest/smartcontract/smartcontract.html#%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6">上图</a>中，我们可以看到组织  <code>ORG1</code>  和  <code>ORG2</code>  是如何通过定义一个  <code>car</code>  智能合约来实现  <code>查询</code>、<code>转移</code>  和  <code>更新</code>  汽车的。来自这些组织的应用程序调用此智能合约执行业务流程中已商定的步骤，例如将特定汽车的所有权从  <code>ORG1</code>  转移到  <code>ORG2</code>。</p><h1 id="智能合约-amp-链码"><a href="#智能合约-amp-链码" class="headerlink" title="智能合约&amp;链码"></a>智能合约&amp;链码</h1><p>通常，智能合约定义的是控制世界状态中业务对象生命周期的<strong>交易逻辑</strong>，随后该交易逻辑被打包进链码，紧接着链码会被部署到区块链网络中。可以将智能合约看成交易的管理者，而链码则管理着如何将智能合约打包以便用于部署。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Deep-understanding-of-intelligent-contracts-2.png#align=left&display=inline&height=256&margin=%5Bobject%20Object%5D&name=image.png&originHeight=280&originWidth=739&size=28395&status=done&style=none&width=675" alt="image.png"><br><em>一个智能合约定义在一个链码中。而多个智能合约也可以定义在同一个链码中。当一个链码部署完毕，该链码中的所有智能合约都可供应用程序使用。</em><br>从上图中我们可以看到，<code>vehicle</code> 链码包含了以下三个智能合约：<code>cars</code>、<code>boats</code> 和 <code>trucks</code>；而 <code>insurance</code> 链码包含了以下四个智能合约：<code>policy</code>、<code>liability</code>、<code>syndication</code> 和 <code>securitization</code>。以上每种智能合约都涵盖了与车辆和保险有关的业务流程的一些关键点。在本主题中，我们将以 <code>car</code> 智能合约为例。我们可以看到，智能合约是一个特定领域的程序，它与特定的业务流程相关，而链码则是一组相关智能合约安装和实例化的技术容器。</p><h1 id="账本"><a href="#账本" class="headerlink" title="账本"></a>账本</h1><p>以最简单的方式来说，区块链记录着更新账本状态的交易，且记录不可篡改。智能合约以编程方式访问账本两个不同的部分：一个是<strong>区块链</strong>（记录所有交易的历史，且记录不可篡改），另一个是<strong>世界状态</strong>（保存这些状态当前值的缓存，是经常需要用到的对象的当前值）。<br>首先，<strong>世界状态</strong>是一个数据库，它存储了一组账本状态的<strong>当前值</strong>。通过世界状态，程序可以直接访问一个账本状态的当前值，不需要遍历整个交易日志来计算当前值。默认情况下，账本状态是以<strong>键值</strong>对的方式来表示的。因为我们可以创建、更新和删除状态，所以世界状态能够频繁更改。<br>其次，<strong>区块链</strong>是交易日志，它记录了促成当前世界状态的所有改变。交易被收集在附加到区块链的区块中，能帮助我们理解所有促成当前世界状态的改变的历史。区块链数据结构与世界状态相差甚远，因为一旦把数据写入区块链，就无法修改，它是<strong>不可篡改的</strong>。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Deep-understanding-of-intelligent-contracts-3.png#align=left&display=inline&height=292&margin=%5Bobject%20Object%5D&name=image.png&originHeight=345&originWidth=804&size=50947&status=done&style=none&width=680" alt="image.png"><br><em>账本 L 由区块链 B 和世界状态 W 组成，其中世界状态 W 由区块链 B 决定。我们也可以说世界状态 W 是源自区块链 B。</em><br>智能合约主要在世界状态中将状态<strong>写入</strong>（put）、<strong>读取</strong>（get）和<strong>删除</strong>（delete），还可以查询不可篡改的区块链交易记录。</p><ul><li><strong>读取（get）</strong> 操作一般代表的是查询，目的是获取关于交易对象当前状态的信息。</li><li><strong>写入（put）</strong> 操作通常生成一个新的业务对象或者对账本世界状态中现有的业务对象进行修改。</li><li><strong>删除（delete）</strong> 操作代表的是将一个业务对象从账本的当前状态中移除，但不从账本的历史中移除。</li></ul><p>智能合约有许多可用的 <a href="https://hyperledger-fabric.readthedocs.io/zh_CN/latest/developapps/transactioncontext.html#structure">API</a>。但重要的是，在任意情况下，无论交易创建、读取、更新还是删除世界状态中的业务对象，区块链都包含了这些操作的记录，且<a href="https://hyperledger-fabric.readthedocs.io/zh_CN/latest/ledger/ledger.html">记录不可更改</a> 。</p><h2 id="世界状态"><a href="#世界状态" class="headerlink" title="世界状态"></a>世界状态</h2><p>世界状态将业务对象属性的当前值保存为唯一的账本状态。这很有用，因为程序通常需要对象的当前值，如果遍历整个区块链来计算对象的当前值会很麻烦——从世界状态中可以直接获取当前值。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Deep-understanding-of-intelligent-contracts-4.png#align=left&display=inline&height=266&margin=%5Bobject%20Object%5D&name=image.png&originHeight=339&originWidth=863&size=90524&status=done&style=none&width=677" alt="image.png"><br><em>一个账本世界状态包含两个状态。第一个状态是： key=CAR1 和 value=Audi。第二个状态中有一个更复杂的值：key=CAR2 和 value={model:BMW, color=red, owner=Jane} 。两个状态的版本都是 0。</em><br>账本状态记录了一组与特定业务对象有关的事实。我们的示例展示的是 CAR1 和 CAR2 这两辆车的账本状态，二者都各有一个值和一个键。应用程序可以调用智能合约，该合约使用简单的账本 API 来<strong>获取</strong>、<strong>写入</strong>和<strong>删除</strong>状态。注意状态值可以是简单值（Audi…），也可以是复合值（type:BMW…）。经常会通过查询世界状态来检索具有某些特定属性的对象，例如查找所有红色宝马汽车。<br>应用程序提交那些会更改世界状态的交易，这些交易最终被提交到账本区块链上。应用程序无法看到 Hyperledger Fabric SDK（软件开发工具包）设定的<a href="https://hyperledger-fabric.readthedocs.io/zh_CN/latest/txflow.html">共识机制</a>的细节内容，它们能做的只是调用智能合约以及在交易被收进区块链时收到通知（<strong>所有被提交的交易，无论有效与否，都会被收进区块链</strong>）。Hyperledger Fabric 的关键设计在于，只有那些受到相关<strong>背书组织签名</strong>的交易才会更新世界状态。<br>您还会注意到，每个状态都有一个版本号，在上面的图表中，状态 CAR1 和 CAR2 都处于它们的初始版本 0。版本号是供 Hyperledger Fabric 内部使用的，并且每次状态更改时版本号会发生递增。每当更新状态时，都会检查该状态的版本，以确保当前状态与背书时的版本相匹配。这就确保了世界状态是按照预期进行更新的，没有发生并发更新。<br>最后，首次创建账本时，世界状态是空的。<strong>因为区块链上记录了所有代表有效世界状态更新的交易，所以任何时候都可以从区块链中重新生成世界状态。</strong>这样一来就变得非常方便，例如，<strong>创建节点时会自动生成世界状态</strong>。此外，如果某个节点发生异常，<strong>重启该节点时能够在接受交易之前重新生成世界状态</strong>。</p><h2 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h2><p>世界状态存储了与业务对象当前状态相关的事实信息，而区块链是一种历史记录，它记录了这些业务对象是如何到达各自当前状态的相关事实。<strong>区块链记录了每个账本状态之前的所有版本以及状态是如何被更改的。</strong><br><strong>区块链的结构是一群相互链接的区块的序列化日志，其中每个区块都包含一系列交易，各项交易代表了一个对世界状态进行的查询或更新操作。</strong></p><blockquote><p>在这里，官方提到了一个排序服务。<br>其中重要的是<strong>区块排序以及区块内的交易排序</strong>，这一机制是在 Hyperledger Fabric 的<strong>排序服务</strong>组件首次创建区块时被建立起来的。</p></blockquote><p>每个区块的头部都包含区块交易的一个哈希，以及前一个区块头的哈希。这样一来，账本上的所有交易都被按序排列，并以密码方式连接在一起。这种哈希和链接使账本数据变得非常安全。即使某个保存账本的节点被篡改了，该节点也无法让其他节点相信自己拥有“正确的”区块链，这是因为账本被分布在一个由独立节点组成的网络中。<br><strong>区块链总是以文件实现</strong>，而与之相反的是<strong>，世界状态以数据库实现</strong>。这是一个明智的设计，因为区块链数据结构高度偏向于非常小的一组简单操作。第一项操作被放在区块链的末尾，就目前来说，查询操纵相对少见。</p><p>当<strong>应用程序需要访问账本和链码的时候</strong>，他们总是需要连接到 Peer 节点。Hyperledger Fabric SDK 将这个操作变得非常简单，它的 API 使应用程序能够连接到 Peer 节点，<strong>调用链码生成交易，提交交易到网络，在网络中交易会被排序并且提交到分布式账本中</strong>，并且在这个流程结束的时候接收到事件。<br><strong>！不过，我们注意到 xuperchain 在文档中提到了使用 JDK 通过</strong><a href="https://xuper.baidu.com/n/xuperdoc/development_manuals/XuperRPC.html#id1"><strong>rpc 接口</strong></a><strong>构造交易发布！</strong><br><strong>目前需要知道：</strong></p><ul><li>智能合约发布的交易，发布方地址是什么，接收方地址是什么，他们在链上存储的和普通交易是否有区别？</li><li>在搞清问题 1 之后，是否有可能构造交易，把添加自定义字段，然后使用 rpc 接口发布？</li><li>因为区块链链式结构只需要将上一个区块的 hsah 包含在本区块头中，而 DAG 则将多个（至少两个块作为前置块，那么它们是如何连接的）</li></ul><hr><p>补充一个：<br>【1】快照链<a href="https://github.com/vitelabs/go-vite/blob/master/ledger/chain/block/snapshot_block.go">https://github.com/vitelabs/go-vite/blob/master/ledger/chain/block/snapshot_block.go</a><br>【2】真正的 DAG？<a href="https://github.com/vitelabs/go-vite/blob/master/ledger/chain/chain.go">https://github.com/vitelabs/go-vite/blob/master/ledger/chain/chain.go</a><br>【3】靠谱一点的白皮书<a href="https://www.yuque.com/attachments/yuque/0/2021/pdf/1629942/1616644033176-46652e0d-d91b-41c0-823a-ee503f7d8264.pdf?_lake_card=%7B%22uid%22:%221616644031374-0%22,%22src%22:%22https://www.yuque.com/attachments/yuque/0/2021/pdf/1629942/1616644033176-46652e0d-d91b-41c0-823a-ee503f7d8264.pdf%22,%22name%22:%22vite_cn.pdf%22,%22size%22:1164591,%22type%22:%22application/pdf%22,%22ext%22:%22pdf%22,%22progress%22:%7B%22percent%22:99%7D,%22status%22:%22done%22,%22percent%22:0,%22id%22:%22N6Qwn%22,%22card%22:%22file%22%7D">vite_cn.pdf</a><br>【4】xuper 里的交易定义<a href="https://github.com/xuperchain/xuperchain/blob/7de83707283ba872129d66aa5e4435d04ed67bee/core/cmd/cli/types.go">https://github.com/xuperchain/xuperchain/blob/7de83707283ba872129d66aa5e4435d04ed67bee/core/cmd/cli/types.go</a><br>【5】xuper 的快照链<a href="https://github.com/xuperchain/xuperchain/blob/9d9e60a3bcd87bafafdac51784b504a310ead3d7/core/xmodel/xmodel.go#L51">https://github.com/xuperchain/xuperchain/blob/9d9e60a3bcd87bafafdac51784b504a310ead3d7/core/xmodel/xmodel.go#L51</a><br>【6】<a href="https://www.jianshu.com/p/8734e06d558f">GHOST，DAG，SPECTRE，PHANTOM 和 CONFLUX 技术原理</a>–挺全的<br>【7】<a href="https://confluxnetwork.org/zh/developers/assets">https://confluxnetwork.org/zh/developers/assets</a>–conflux 区块链，清华自研，树形结构，网站挺好的，白皮书也行</p><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/Deep-understanding-of-intelligent-contracts-5.png#align=left&display=inline&height=362&margin=%5Bobject%20Object%5D&name=image.png&originHeight=724&originWidth=1419&size=128783&status=done&style=none&width=709.5" alt="image.png"><br>【8】conflux 的白皮书<a href="https://www.yuque.com/attachments/yuque/0/2021/pdf/1629942/1616675325254-7b3d2143-8a29-4ae3-979b-0da2ca0b759e.pdf?_lake_card=%7B%22uid%22:%221616675322385-0%22,%22src%22:%22https://www.yuque.com/attachments/yuque/0/2021/pdf/1629942/1616675325254-7b3d2143-8a29-4ae3-979b-0da2ca0b759e.pdf%22,%22name%22:%22Conflux_Technical_Presentation_whitepaper.pdf%22,%22size%22:1899775,%22type%22:%22application/pdf%22,%22ext%22:%22pdf%22,%22progress%22:%7B%22percent%22:99%7D,%22status%22:%22done%22,%22percent%22:0,%22id%22:%22DpkoK%22,%22card%22:%22file%22%7D">Conflux_Technical_Presentation_whitepaper.pdf</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;参考官方文档进行进一步了解。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
