{"title":"GO开发指南","slug":"GO开发指南","date":"2021-04-02T01:17:05.000Z","updated":"2022-02-07T09:20:02.807Z","comments":true,"path":"api/articles/GO开发指南.json","realPath":null,"excerpt":"记录在进行 go 语言开发遇到的各种问题。","covers":["https://cdn.nlark.com/yuque/0/2021/png/1629942/1617328565539-a55e3882-7a05-47c5-8c91-78dd136d7a5c.png#align=left&display=inline&height=274&margin=%5Bobject%20Object%5D&name=image.png&originHeight=548&originWidth=431&size=24414&status=done&style=none&width=215.5","https://cdn.nlark.com/yuque/0/2021/png/1629942/1617344622341-e1babb6a-2494-437c-93cb-30da90e11894.png#align=left&display=inline&height=143&margin=%5Bobject%20Object%5D&name=image.png&originHeight=286&originWidth=601&size=27035&status=done&style=none&width=300.5"],"cover":"https://cdn.nlark.com/yuque/0/2021/png/1629942/1617328565539-a55e3882-7a05-47c5-8c91-78dd136d7a5c.png#align=left&display=inline&height=274&margin=%5Bobject%20Object%5D&name=image.png&originHeight=548&originWidth=431&size=24414&status=done&style=none&width=215.5","content":"<p>记录在进行 go 语言开发遇到的各种问题。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"命名规范\"><a href=\"#命名规范\" class=\"headerlink\" title=\"命名规范\"></a>命名规范</h1><h3 id=\"文件命名\"><a href=\"#文件命名\" class=\"headerlink\" title=\"文件命名\"></a>文件命名</h3><p>文件命名一律采用小写，不用驼峰式，尽量见名思义，看见文件名就可以知道这个文件下的大概内容。<br>其中测试文件以<em>test.go 结尾，除测试文件外，命名不出现</em>。<br>例子：</p>\n<blockquote>\n<p>stringutil.go， stringutil_test.go</p>\n</blockquote>\n<h3 id=\"package\"><a href=\"#package\" class=\"headerlink\" title=\"package\"></a>package</h3><p>包名用小写,使用短命名,尽量和标准库不要冲突。<br>包名统一使用单数形式。</p>\n<p>在 go 源文件的开头必须申明文件所属的 package，如下所示：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> name<br>......<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"命名规范-1\"><a href=\"#命名规范-1\" class=\"headerlink\" title=\"命名规范\"></a>命名规范</h2><ul>\n<li>建议 package 命名用小写字母</li>\n<li>建议 packag<strong>e 命名必和其路径的最后一段一致</strong>（main package 除外）。注意，这并不是 Golang 的强制要求，文件目录只是用于存放同一个 package 的所有源文件，Golang 对目录名并无要求。但<strong>一个目录下不允许有多个 package 的源文件</strong>。</li>\n<li>main package 中的 main 方法是可执行文件的入口，main package 名一般和路径名不一致</li>\n<li>不同路径下 package 命名可以重复，但其完整路径名必须唯一</li>\n</ul>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><p>变量命名一般采用驼峰式，当遇到特有名词（缩写或简称，如 DNS）的时候，特有名词根据是否私有全部大写或小写。<br>例子：</p>\n<blockquote>\n<p>apiClient、URLString</p>\n</blockquote>\n<h3 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h3><p>单个函数的接口名以 er 为后缀</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-number\">1.</span> <span class=\"hljs-keyword\">type</span> Reader <span class=\"hljs-keyword\">interface</span> &#123;<br><span class=\"hljs-number\">2.</span>     Read(p []<span class=\"hljs-keyword\">byte</span>) (n <span class=\"hljs-keyword\">int</span>, err error)<br><span class=\"hljs-number\">3.</span> &#125;<br></code></pre></td></tr></table></figure>\n\n<p>两个函数的接口名综合两个函数名，如:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-number\">1.</span> <span class=\"hljs-keyword\">type</span> WriteFlusher <span class=\"hljs-keyword\">interface</span> &#123;<br><span class=\"hljs-number\">2.</span> Write([]<span class=\"hljs-keyword\">byte</span>) (<span class=\"hljs-keyword\">int</span>, error)<br><span class=\"hljs-number\">3.</span> Flush() error<br><span class=\"hljs-number\">4.</span> &#125;<br></code></pre></td></tr></table></figure>\n\n<p>三个以上函数的接口名类似于结构体名，如:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-number\">1.</span> <span class=\"hljs-keyword\">type</span> Car <span class=\"hljs-keyword\">interface</span> &#123;<br><span class=\"hljs-number\">2.</span>     Start()<br><span class=\"hljs-number\">3.</span>     Stop()<br><span class=\"hljs-number\">4.</span>     Drive()<br><span class=\"hljs-number\">5.</span> &#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><p>方法名应该是动词或动词短语，采用驼峰式。将功能及必要的参数体现在名字中， 不要嫌长， 如 updateById，getUserInfo.<br>如果是结构体方法，那么 Receiver 的名称应该缩写，一般使用一个或者两个字符作为 Receiver 的名称。如果 Receiver 是指针， 那么统一使用 p。 如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-number\">1.</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(f foo)</span> <span class=\"hljs-title\">method</span><span class=\"hljs-params\">()</span></span> &#123;<br><span class=\"hljs-number\">2.</span>     ...<br><span class=\"hljs-number\">3.</span> &#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-number\">1.</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(p *foo)</span> <span class=\"hljs-title\">method</span><span class=\"hljs-params\">()</span></span> &#123;<br><span class=\"hljs-number\">2.</span>     ...<br><span class=\"hljs-number\">3.</span> &#125;<br></code></pre></td></tr></table></figure>\n\n<p>对于 Receiver 命名应该统一， 要么都使用值， 要么都用指针。<br>每个以大写字母开头（即可以导出）的方法应该有注释，且以该函数名开头。如：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\"><span class=\"hljs-number\">1.</span> <span class=\"hljs-comment\">// Get 会响应对应路由转发过来的 get 请求.</span><br><span class=\"hljs-number\">2.</span> func (c *Controller) Get() &#123;<br><span class=\"hljs-number\">3.</span>     ...<br><span class=\"hljs-number\">4.</span> &#125;<br></code></pre></td></tr></table></figure>\n\n<p>大写字母开头的方法以为着是可供调用的公共方法，如果你的方法想只在本包内掉用，请以小写字母开发。如:</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autoit\"><span class=\"hljs-number\">1.</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Controller)</span> <span class=\"hljs-title\">curl</span><span class=\"hljs-params\">()</span> &#123;</span><br><span class=\"hljs-number\">2.</span>     ...<br><span class=\"hljs-number\">3.</span> &#125;<br></code></pre></td></tr></table></figure>\n\n<p>注释应该用一个完整的句子，注释的第一个单词应该是要注释的指示符，以便在 godoc 中容易查找。<br>注释应该以一个句点 . 结束。</p>\n<h1 id=\"各种报错\"><a href=\"#各种报错\" class=\"headerlink\" title=\"各种报错\"></a>各种报错</h1><p>【1】<strong>“与你运行的 Windows 版本不兼容“的解决方法</strong><br><a href=\"https://blog.csdn.net/willingtolove/article/details/107924423\">https://blog.csdn.net/willingtolove/article/details/107924423</a><br>其实就是 package 名字错了，必须改成 main，不清楚为什么？<br>【2】每次创建新的项目都要<strong>重新设置一个 configuration 文件</strong>，后发现是我的问题，开发的时候，可以把所有的项目都在 goland 里打开，根目录就是$GOPATH,像这样：<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1617328565539-a55e3882-7a05-47c5-8c91-78dd136d7a5c.png#align=left&display=inline&height=274&margin=%5Bobject%20Object%5D&name=image.png&originHeight=548&originWidth=431&size=24414&status=done&style=none&width=215.5\" alt=\"image.png\"><br>所有小项目都放在 src 里，是不是很棒？<br>但是！<strong>必须有 main 包</strong>，必须有 main 函数作为程序入口！<br>具体原理看：<br><a href=\"https://blog.csdn.net/zxy_666/article/details/80390843\">https://blog.csdn.net/zxy_666/article/details/80390843</a><br><a href=\"https://zhuanlan.zhihu.com/p/69445822\">如何写出优雅的 Golang 代码</a><br><a href=\"https://blog.csdn.net/CMbug/article/details/49339341\">Golang import 包问题相关详解</a><br><a href=\"https://www.jianshu.com/p/b224982b6fd5\">理解 Go 语言包(package)</a><br>【3】<strong>结构体属性导出问题</strong><br>结构体中的属性，如果是小写开头，是无法被跨包使用的，也就是说包外无法访问，太狗了。<br><a href=\"https://juejin.cn/post/6844903814168838151\">Go Struct 超详细讲解</a> 建议好好看看这篇</p>\n<h1 id=\"函数知识\"><a href=\"#函数知识\" class=\"headerlink\" title=\"函数知识\"></a>函数知识</h1><h2 id=\"make\"><a href=\"#make\" class=\"headerlink\" title=\"make\"></a>make</h2><p>make()函数在 golang 的代码如下：<br><code>func make(t Type,size IntegerType) Type</code><br>使用 make 来创建 slice，map，chanel 说明如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><br>var slice_ []int = make([]int,5,10)<br>fmt.Println(slice_)<br>var slice_1 []int = make([]int,5)<br>fmt.Println(slice_1)<br>var slice_2 []int = []int&#123;1,2&#125;<br>fmt.Println(slice_2)<br>打印结果：<br>[0 0 0 0 0]<br>[0 0 0 0 0]<br>[1,2]<br></code></pre></td></tr></table></figure>\n\n<p>在创建 slice 时第一个参数用于确定初始化该 slice 的大小该 slice 中的值为零值，第三个参数用于确定该 slice 的长度<br>map：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">var m_ map[string]int = make(map[string]int)<br>m_[&quot;one&quot;] = 1<br>fmt.Println(m_)<br>var m map[string]int = map[string]int&#123;&quot;1&quot;:1&#125;<br>m[&quot;2&quot;] = 2<br>fmt.Println(m)<br>打印结果：<br>map[one:1]<br>map[1:1 2:2]<br></code></pre></td></tr></table></figure>\n\n<p>根据 size 大小来初始化分配内存，不过分配后的 map 长度为 0，如果 size 被忽略了，那么会在初始化分配内存时分配一个小尺寸的内存</p>\n<h2 id=\"nil\"><a href=\"#nil\" class=\"headerlink\" title=\"nil\"></a>nil</h2><p>相信写过 Golang 的程序员对下面一段代码是非常非常熟悉的了：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> &#123;<br>    <span class=\"hljs-comment\">// do something....</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>当出现不等于<code>nil</code>的时候，说明出现某些错误了，需要我们对这个错误进行一些处理，而如果等于<code>nil</code>说明运行正常。那什么是<code>nil</code>呢？查一下词典可以知道，<code>nil</code>的意思是无，或者是零值。零值，zero value，是不是有点熟悉？在 Go 语言中，如果你声明了一个变量但是没有对它进行赋值操作，那么这个变量就会有一个类型的默认零值。这是每种类型对应的零值：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">bool</span>      -&gt; <span class=\"hljs-literal\">false</span><br>numbers -&gt; <span class=\"hljs-number\">0</span><br><span class=\"hljs-keyword\">string</span>    -&gt; <span class=\"hljs-string\">&quot;&quot;</span><br>pointers -&gt; <span class=\"hljs-literal\">nil</span><br>slices -&gt; <span class=\"hljs-literal\">nil</span><br>maps -&gt; <span class=\"hljs-literal\">nil</span><br>channels -&gt; <span class=\"hljs-literal\">nil</span><br>functions -&gt; <span class=\"hljs-literal\">nil</span><br>interfaces -&gt; <span class=\"hljs-literal\">nil</span><br></code></pre></td></tr></table></figure>\n\n<p>举个例子，当你定义了一个 struct：</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elm\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-type\">Person</span> struct &#123;<br>  <span class=\"hljs-type\">AgeYears</span> int<br>  <span class=\"hljs-type\">Name</span> string<br>  <span class=\"hljs-type\">Friends</span> []<span class=\"hljs-type\">Person</span><br>&#125;<br><span class=\"hljs-title\">var</span> p <span class=\"hljs-type\">Person</span> // <span class=\"hljs-type\">Person</span>&#123;<span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&quot;&quot;</span>, nil&#125;<br></code></pre></td></tr></table></figure>\n\n<p>变量<code>p</code>只声明但没有赋值，所以 p 的所有字段都有对应的零值。那么，这个<code>nil</code>到底是什么呢？Go 的文档中说到，_nil 是预定义的标识符，代表指针、通道、函数、接口、映射或切片的零值_，也就是预定义好的一个变量：</p>\n<h2 id=\"slices\"><a href=\"#slices\" class=\"headerlink\" title=\"slices\"></a>slices</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// nil slices</span><br><span class=\"hljs-keyword\">var</span> s []slice<br><span class=\"hljs-built_in\">len</span>(s)  <span class=\"hljs-comment\">// 0</span><br><span class=\"hljs-built_in\">cap</span>(s)  <span class=\"hljs-comment\">// 0</span><br><span class=\"hljs-keyword\">for</span> <span class=\"hljs-keyword\">range</span> s  <span class=\"hljs-comment\">// iterates zero times</span><br>s[i]  <span class=\"hljs-comment\">// panic: index out of range</span><br></code></pre></td></tr></table></figure>\n\n<p>一个为<code>nil</code>的 slice，除了不能索引外，其他的操作都是可以的，当你需要填充值的时候可以使用<code>append</code>函数，slice 会自动进行扩充。那么为<code>nil</code>的 slice 的底层结构是怎样的呢？根据官方的文档，slice 有三个元素，分别是长度、容量、指向数组的指针：<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1617344622341-e1babb6a-2494-437c-93cb-30da90e11894.png#align=left&display=inline&height=143&margin=%5Bobject%20Object%5D&name=image.png&originHeight=286&originWidth=601&size=27035&status=done&style=none&width=300.5\" alt=\"image.png\"><br>当有元素的时候，<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1617344635243-979b77ee-3516-4c3b-a112-a45caad93fdb.png#align=left&display=inline&height=133&margin=%5Bobject%20Object%5D&name=image.png&originHeight=266&originWidth=779&size=50465&status=done&style=none&width=389.5\" alt=\"image.png\"></p>\n<h2 id=\"channel\"><a href=\"#channel\" class=\"headerlink\" title=\"channel\"></a>channel</h2><blockquote>\n<p>参考：<a href=\"https://colobu.com/2016/04/14/Golang-Channels/\">https://colobu.com/2016/04/14/Golang-Channels/</a></p>\n</blockquote>\n<p>Channel 是 Go 中的一个核心类型，你可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯(communication)。<br>它的操作符是箭头  <strong>&lt;-</strong> 。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">ch &lt;- v    <span class=\"hljs-comment\">// 发送值v到Channel ch中</span><br>v := &lt;-ch  <span class=\"hljs-comment\">// 从Channel ch中接收数据，并将数据赋值给v</span><br></code></pre></td></tr></table></figure>\n\n<p>(箭头的指向就是数据的流向)<br>就像 map 和 slice 数据类型一样, channel 必须先创建再使用:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">ch := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-keyword\">int</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"定义与用法\"><a href=\"#定义与用法\" class=\"headerlink\" title=\"定义与用法\"></a>定义与用法</h3><p>它包括三种类型的定义。可选的<code>&lt;-</code>代表 channel 的方向。如果没有指定方向，那么 Channel 就是双向的，既可以接收数据，也可以发送数据。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">chan</span> T          <span class=\"hljs-comment\">// 可以接收和发送类型为 T 的数据</span><br><span class=\"hljs-keyword\">chan</span>&lt;- <span class=\"hljs-keyword\">float64</span>  <span class=\"hljs-comment\">// 只可以用来发送 float64 类型的数据</span><br>&lt;-<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-keyword\">int</span>      <span class=\"hljs-comment\">// 只可以用来接收 int 类型的数据</span><br></code></pre></td></tr></table></figure>\n\n<p>使用<code>make</code>初始化 Channel,并且可以设置容量:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-keyword\">int</span>, <span class=\"hljs-number\">100</span>)<br></code></pre></td></tr></table></figure>\n\n<p>容量(capacity)代表 Channel 容纳的最多的元素的数量，代表 Channel 的缓存的大小。<br>如果没有设置容量，或者容量设置为 0, 说明 Channel 没有缓存，只有 sender 和 receiver 都准备好了后它们的通讯(communication)才会发生(Blocking)。<strong>如果设置了缓存，就有可能不发生阻塞</strong>， 只有 buffer 满了后 send 才会阻塞， 而只有缓存空了后 receive 才会阻塞。一个 nil channel 不会通信。<br>可以通过内建的<code>close</code>方法可以关闭 Channel。<br>你<strong>可以在多个 goroutine 从/往 一个 channel 中 receive/send 数据, 不必考虑额外的同步措施</strong>。<br>Channel 可以作为一个先入先出(FIFO)的队列，接收的数据和发送的数据的顺序是一致的。<br>channel 的 receive 支持  <em>multi-valued assignment</em>，如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">v, ok := &lt;-ch<br></code></pre></td></tr></table></figure>\n\n<p>它可以用来检查 Channel 是否已经被关闭了。</p>\n<h3 id=\"send\"><a href=\"#send\" class=\"headerlink\" title=\"send\"></a>send</h3><p>send 语句用来往 Channel 中发送数据， 如<code>ch &lt;- 3</code>。<br>它的定义如下:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">SendStmt = Channel <span class=\"hljs-string\">&quot;&lt;-&quot;</span> Expression .<br>Channel  = Expression .<br></code></pre></td></tr></table></figure>\n\n<p>在通讯(communication)开始前 channel 和 expression 必选先求值出来(evaluated)，比如下面的(3+4)先计算出 7 然后再发送给 channel。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">c := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-keyword\">int</span>)<br><span class=\"hljs-keyword\">defer</span> <span class=\"hljs-built_in\">close</span>(c)<br><span class=\"hljs-keyword\">go</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> &#123; c &lt;- <span class=\"hljs-number\">3</span> + <span class=\"hljs-number\">4</span> &#125;()<br>i := &lt;-c<br>fmt.Println(i)<br></code></pre></td></tr></table></figure>\n\n<p>send 被执行前(proceed)通讯(communication)一直被阻塞着。如前所言，无缓存的 channel 只有在 receiver 准备好后 send 才被执行。如果有缓存，并且缓存未满，则 send 会被执行。<br>往一个<strong>已经被 close 的 channel 中</strong>继续发送数据会导致<strong>run-time panic</strong>。<br><strong>往 nil channel 中发送数据会一致被阻塞</strong>着。</p>\n<h3 id=\"receive\"><a href=\"#receive\" class=\"headerlink\" title=\"receive\"></a>receive</h3><p><code>&lt;-ch</code>用来从 channel ch 中接收数据，这个表达式会一直被 block,直到有数据可以接收。<br>从一个 nil channel 中接收数据会一直被 block。<br>从一个被 close 的 channel 中接收数据不会被阻塞，而是立即返回，接收完已发送的数据后会返回元素类型的零值(zero value)。<br>如前所述，你可以使用一个额外的返回参数来检查 channel 是否关闭。</p>\n<h3 id=\"阻塞\"><a href=\"#阻塞\" class=\"headerlink\" title=\"阻塞\"></a>阻塞</h3><p>缺省情况下，发送和接收会一直阻塞着，直到另一方准备好。这种方式可以用来在 gororutine 中进行同步，而不必使用显示的锁或者条件变量。<br>如官方的例子中<code>x, y := &lt;-c, &lt;-c</code>这句会一直等待计算结果发送到 channel 中。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;fmt&quot;</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">sum</span><span class=\"hljs-params\">(s []<span class=\"hljs-keyword\">int</span>, c <span class=\"hljs-keyword\">chan</span> <span class=\"hljs-keyword\">int</span>)</span></span> &#123;<br>\tsum := <span class=\"hljs-number\">0</span><br>\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> s &#123;<br>\t\tsum += v<br>\t&#125;<br>\tc &lt;- sum <span class=\"hljs-comment\">// send sum to c</span><br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>\ts := []<span class=\"hljs-keyword\">int</span>&#123;<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">-9</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">0</span>&#125;<br>\tc := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-keyword\">int</span>)<br>\t<span class=\"hljs-keyword\">go</span> sum(s[:<span class=\"hljs-built_in\">len</span>(s)/<span class=\"hljs-number\">2</span>], c)<br>\t<span class=\"hljs-keyword\">go</span> sum(s[<span class=\"hljs-built_in\">len</span>(s)/<span class=\"hljs-number\">2</span>:], c)<br>\tx, y := &lt;-c, &lt;-c <span class=\"hljs-comment\">// receive from c</span><br>\tfmt.Println(x, y, x+y)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Range\"><a href=\"#Range\" class=\"headerlink\" title=\"Range\"></a>Range</h3><p><code>for …… range</code>语句可以处理 Channel。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>\t<span class=\"hljs-keyword\">go</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> &#123;<br>\t\ttime.Sleep(<span class=\"hljs-number\">1</span> * time.Hour)<br>\t&#125;()<br>\tc := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-keyword\">int</span>)<br>\t<span class=\"hljs-keyword\">go</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i = i + <span class=\"hljs-number\">1</span> &#123;<br>\t\t\tc &lt;- i<br>\t\t&#125;<br>\t\t<span class=\"hljs-built_in\">close</span>(c)<br>\t&#125;()<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-keyword\">range</span> c &#123;<br>\t\tfmt.Println(i)<br>\t&#125;<br>\tfmt.Println(<span class=\"hljs-string\">&quot;Finished&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>range c</code>产生的迭代值为 Channel 中发送的值，它会一直迭代直到 channel 被关闭。上面的例子中如果把<code>close(c)</code>注释掉，程序会一直阻塞在<code>for …… range</code>那一行。</p>\n<h3 id=\"defer\"><a href=\"#defer\" class=\"headerlink\" title=\"defer\"></a>defer</h3><p><a href=\"https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html\">https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html</a><br>这个博客讲的挺好的，其他知识也有，可以常看看。<br>另外还有：<a href=\"https://sanyuesha.com/2017/07/23/go-defer/\">https://sanyuesha.com/2017/07/23/go-defer/</a></p>\n<h1 id=\"其他知识\"><a href=\"#其他知识\" class=\"headerlink\" title=\"其他知识\"></a>其他知识</h1><h2 id=\"goroutine\"><a href=\"#goroutine\" class=\"headerlink\" title=\"goroutine\"></a>goroutine</h2><p><a href=\"https://www.cnblogs.com/wdliu/p/9272220.html\">https://www.cnblogs.com/wdliu/p/9272220.html</a> 调度原理<br>代码示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main<br><br><span class=\"hljs-keyword\">import</span> (<br>    <span class=\"hljs-string\">&quot;fmt&quot;</span><br>    <span class=\"hljs-string\">&quot;time&quot;</span><br>)<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">cal</span><span class=\"hljs-params\">(a <span class=\"hljs-keyword\">int</span> , b <span class=\"hljs-keyword\">int</span> )</span></span>  &#123;<br>    c := a+b<br>    fmt.Printf(<span class=\"hljs-string\">&quot;%d + %d = %d\\n&quot;</span>,a,b,c)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;　　<br>    <span class=\"hljs-keyword\">for</span> i :=<span class=\"hljs-number\">0</span> ; i&lt;<span class=\"hljs-number\">10</span> ;i++&#123;<br>        <span class=\"hljs-keyword\">go</span> cal(i,i+<span class=\"hljs-number\">1</span>)  <span class=\"hljs-comment\">//启动10个goroutine 来计算</span><br>    &#125;<br>    time.Sleep(time.Second * <span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// sleep作用是为了等待所有任务完成</span><br>&#125;<br><span class=\"hljs-comment\">//结果</span><br><span class=\"hljs-comment\">//8 + 9 = 17</span><br><span class=\"hljs-comment\">//9 + 10 = 19</span><br><span class=\"hljs-comment\">//4 + 5 = 9</span><br><span class=\"hljs-comment\">//5 + 6 = 11</span><br><span class=\"hljs-comment\">//0 + 1 = 1</span><br><span class=\"hljs-comment\">//1 + 2 = 3</span><br><span class=\"hljs-comment\">//2 + 3 = 5</span><br><span class=\"hljs-comment\">//3 + 4 = 7</span><br><span class=\"hljs-comment\">//7 + 8 = 15</span><br><span class=\"hljs-comment\">//6 + 7 = 13</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"goroutine-异常捕捉\"><a href=\"#goroutine-异常捕捉\" class=\"headerlink\" title=\"goroutine 异常捕捉\"></a>goroutine 异常捕捉</h3><p>当启动多个 goroutine 时，如果<strong>其中一个 goroutine 异常</strong>了，并且我们并没有对进行异常处理，<strong>那么整个程序都会终止</strong>，所以我们在编写程序时候最好每个 goroutine 所运行的函数都做异常处理，异常处理采用 recover.</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main<br><br><span class=\"hljs-keyword\">import</span> (<br>    <span class=\"hljs-string\">&quot;fmt&quot;</span><br>    <span class=\"hljs-string\">&quot;time&quot;</span><br>)<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">addele</span><span class=\"hljs-params\">(a []<span class=\"hljs-keyword\">int</span> ,i <span class=\"hljs-keyword\">int</span>)</span></span>  &#123;<br>    <span class=\"hljs-keyword\">defer</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> &#123;    <span class=\"hljs-comment\">//匿名函数捕获错误</span><br>        err := <span class=\"hljs-built_in\">recover</span>()<br>        <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> &#123;<br>            fmt.Println(<span class=\"hljs-string\">&quot;add ele fail&quot;</span>)<br>        &#125;<br>    &#125;()<br>   a[i]=i<br>   fmt.Println(a)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    Arry := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">int</span>,<span class=\"hljs-number\">4</span>)<br>    <span class=\"hljs-keyword\">for</span> i :=<span class=\"hljs-number\">0</span> ; i&lt;<span class=\"hljs-number\">10</span> ;i++&#123;<br>        <span class=\"hljs-keyword\">go</span> addele(Arry,i)<br>    &#125;<br>    time.Sleep(time.Second * <span class=\"hljs-number\">2</span>)<br>&#125;<br><span class=\"hljs-comment\">//结果</span><br>add ele fail<br>[<span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0</span>]<br>[<span class=\"hljs-number\">0</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0</span>]<br>[<span class=\"hljs-number\">0</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">0</span>]<br>[<span class=\"hljs-number\">0</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span>]<br>add ele fail<br>add ele fail<br>add ele fail<br>add ele fail<br>add ele fail<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"方法-1\"><a href=\"#方法-1\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>Go 语言中同时有函数和方法。<strong>一个方法就是一个包含了接受者的函数</strong>，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。<strong>所有给定类型的方法属于该类型的方法集</strong>。语法格式如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(variable_name variable_data_type)</span> <span class=\"hljs-title\">function_name</span><span class=\"hljs-params\">()</span> [<span class=\"hljs-title\">return_type</span>]</span>&#123;<br>   <span class=\"hljs-comment\">/* 函数体*/</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main<br><br><span class=\"hljs-keyword\">import</span> (<br>   <span class=\"hljs-string\">&quot;fmt&quot;</span><br>)<br><br><span class=\"hljs-comment\">/* 定义结构体 */</span><br><span class=\"hljs-keyword\">type</span> Circle <span class=\"hljs-keyword\">struct</span> &#123;<br>  radius <span class=\"hljs-keyword\">float64</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>  <span class=\"hljs-keyword\">var</span> c1 Circle<br>  c1.radius = <span class=\"hljs-number\">10.00</span><br>  fmt.Println(<span class=\"hljs-string\">&quot;圆的面积 = &quot;</span>, c1.getArea())<br>&#125;<br><br><span class=\"hljs-comment\">//该 method 属于 Circle 类型对象中的方法</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c Circle)</span> <span class=\"hljs-title\">getArea</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">float64</span></span> &#123;<br>  <span class=\"hljs-comment\">//c.radius 即为 Circle 类型对象中的属性</span><br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">3.14</span> * c.radius * c.radius<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"函数传参\"><a href=\"#函数传参\" class=\"headerlink\" title=\"函数传参\"></a>函数传参</h2><p>数组和切片很像，但是在调用的时候他们传递的类型是不同的！</p>\n<ul>\n<li>Go 语言的数组是值，其长度是其类型的一部分，作为函数参数时，是 <strong>值传递</strong>，函数中的修改对调用者不可见</li>\n<li>Go 语言中对数组的处理，一般采用 <strong>切片</strong> 的方式，切片包含对底层数组内容的引用，作为函数参数时，类似于 <strong>指针传递</strong>，函数中的修改对调用者可见。</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 数组</span><br>b := [...]<span class=\"hljs-keyword\">int</span>&#123;<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">13</span>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">boo</span><span class=\"hljs-params\">(tt [6]<span class=\"hljs-keyword\">int</span>)</span></span> &#123;<br>    tt[<span class=\"hljs-number\">0</span>], tt[<span class=\"hljs-built_in\">len</span>(tt)<span class=\"hljs-number\">-1</span>] = tt[<span class=\"hljs-built_in\">len</span>(tt)<span class=\"hljs-number\">-1</span>], tt[<span class=\"hljs-number\">0</span>]<br>&#125;<br>boo(b)<br>fmt.Println(b) <span class=\"hljs-comment\">// [2 3 5 7 11 13]</span><br><span class=\"hljs-comment\">// 切片</span><br>p := []<span class=\"hljs-keyword\">int</span>&#123;<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">13</span>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">poo</span><span class=\"hljs-params\">(tt []<span class=\"hljs-keyword\">int</span>)</span></span> &#123;<br>    tt[<span class=\"hljs-number\">0</span>], tt[<span class=\"hljs-built_in\">len</span>(tt)<span class=\"hljs-number\">-1</span>] = tt[<span class=\"hljs-built_in\">len</span>(tt)<span class=\"hljs-number\">-1</span>], tt[<span class=\"hljs-number\">0</span>]<br>&#125;<br>poo(p)<br>fmt.Println(p)  <span class=\"hljs-comment\">// [13 3 5 7 11 2]</span><br></code></pre></td></tr></table></figure>\n","more":"<h1 id=\"命名规范\"><a href=\"#命名规范\" class=\"headerlink\" title=\"命名规范\"></a>命名规范</h1><h3 id=\"文件命名\"><a href=\"#文件命名\" class=\"headerlink\" title=\"文件命名\"></a>文件命名</h3><p>文件命名一律采用小写，不用驼峰式，尽量见名思义，看见文件名就可以知道这个文件下的大概内容。<br>其中测试文件以<em>test.go 结尾，除测试文件外，命名不出现</em>。<br>例子：</p>\n<blockquote>\n<p>stringutil.go， stringutil_test.go</p>\n</blockquote>\n<h3 id=\"package\"><a href=\"#package\" class=\"headerlink\" title=\"package\"></a>package</h3><p>包名用小写,使用短命名,尽量和标准库不要冲突。<br>包名统一使用单数形式。</p>\n<p>在 go 源文件的开头必须申明文件所属的 package，如下所示：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> name<br>......<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"命名规范-1\"><a href=\"#命名规范-1\" class=\"headerlink\" title=\"命名规范\"></a>命名规范</h2><ul>\n<li>建议 package 命名用小写字母</li>\n<li>建议 packag<strong>e 命名必和其路径的最后一段一致</strong>（main package 除外）。注意，这并不是 Golang 的强制要求，文件目录只是用于存放同一个 package 的所有源文件，Golang 对目录名并无要求。但<strong>一个目录下不允许有多个 package 的源文件</strong>。</li>\n<li>main package 中的 main 方法是可执行文件的入口，main package 名一般和路径名不一致</li>\n<li>不同路径下 package 命名可以重复，但其完整路径名必须唯一</li>\n</ul>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><p>变量命名一般采用驼峰式，当遇到特有名词（缩写或简称，如 DNS）的时候，特有名词根据是否私有全部大写或小写。<br>例子：</p>\n<blockquote>\n<p>apiClient、URLString</p>\n</blockquote>\n<h3 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h3><p>单个函数的接口名以 er 为后缀</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-number\">1.</span> <span class=\"hljs-keyword\">type</span> Reader <span class=\"hljs-keyword\">interface</span> &#123;<br><span class=\"hljs-number\">2.</span>     Read(p []<span class=\"hljs-keyword\">byte</span>) (n <span class=\"hljs-keyword\">int</span>, err error)<br><span class=\"hljs-number\">3.</span> &#125;<br></code></pre></td></tr></table></figure>\n\n<p>两个函数的接口名综合两个函数名，如:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-number\">1.</span> <span class=\"hljs-keyword\">type</span> WriteFlusher <span class=\"hljs-keyword\">interface</span> &#123;<br><span class=\"hljs-number\">2.</span> Write([]<span class=\"hljs-keyword\">byte</span>) (<span class=\"hljs-keyword\">int</span>, error)<br><span class=\"hljs-number\">3.</span> Flush() error<br><span class=\"hljs-number\">4.</span> &#125;<br></code></pre></td></tr></table></figure>\n\n<p>三个以上函数的接口名类似于结构体名，如:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-number\">1.</span> <span class=\"hljs-keyword\">type</span> Car <span class=\"hljs-keyword\">interface</span> &#123;<br><span class=\"hljs-number\">2.</span>     Start()<br><span class=\"hljs-number\">3.</span>     Stop()<br><span class=\"hljs-number\">4.</span>     Drive()<br><span class=\"hljs-number\">5.</span> &#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><p>方法名应该是动词或动词短语，采用驼峰式。将功能及必要的参数体现在名字中， 不要嫌长， 如 updateById，getUserInfo.<br>如果是结构体方法，那么 Receiver 的名称应该缩写，一般使用一个或者两个字符作为 Receiver 的名称。如果 Receiver 是指针， 那么统一使用 p。 如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-number\">1.</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(f foo)</span> <span class=\"hljs-title\">method</span><span class=\"hljs-params\">()</span></span> &#123;<br><span class=\"hljs-number\">2.</span>     ...<br><span class=\"hljs-number\">3.</span> &#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-number\">1.</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(p *foo)</span> <span class=\"hljs-title\">method</span><span class=\"hljs-params\">()</span></span> &#123;<br><span class=\"hljs-number\">2.</span>     ...<br><span class=\"hljs-number\">3.</span> &#125;<br></code></pre></td></tr></table></figure>\n\n<p>对于 Receiver 命名应该统一， 要么都使用值， 要么都用指针。<br>每个以大写字母开头（即可以导出）的方法应该有注释，且以该函数名开头。如：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\"><span class=\"hljs-number\">1.</span> <span class=\"hljs-comment\">// Get 会响应对应路由转发过来的 get 请求.</span><br><span class=\"hljs-number\">2.</span> func (c *Controller) Get() &#123;<br><span class=\"hljs-number\">3.</span>     ...<br><span class=\"hljs-number\">4.</span> &#125;<br></code></pre></td></tr></table></figure>\n\n<p>大写字母开头的方法以为着是可供调用的公共方法，如果你的方法想只在本包内掉用，请以小写字母开发。如:</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autoit\"><span class=\"hljs-number\">1.</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Controller)</span> <span class=\"hljs-title\">curl</span><span class=\"hljs-params\">()</span> &#123;</span><br><span class=\"hljs-number\">2.</span>     ...<br><span class=\"hljs-number\">3.</span> &#125;<br></code></pre></td></tr></table></figure>\n\n<p>注释应该用一个完整的句子，注释的第一个单词应该是要注释的指示符，以便在 godoc 中容易查找。<br>注释应该以一个句点 . 结束。</p>\n<h1 id=\"各种报错\"><a href=\"#各种报错\" class=\"headerlink\" title=\"各种报错\"></a>各种报错</h1><p>【1】<strong>“与你运行的 Windows 版本不兼容“的解决方法</strong><br><a href=\"https://blog.csdn.net/willingtolove/article/details/107924423\">https://blog.csdn.net/willingtolove/article/details/107924423</a><br>其实就是 package 名字错了，必须改成 main，不清楚为什么？<br>【2】每次创建新的项目都要<strong>重新设置一个 configuration 文件</strong>，后发现是我的问题，开发的时候，可以把所有的项目都在 goland 里打开，根目录就是$GOPATH,像这样：<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1617328565539-a55e3882-7a05-47c5-8c91-78dd136d7a5c.png#align=left&display=inline&height=274&margin=%5Bobject%20Object%5D&name=image.png&originHeight=548&originWidth=431&size=24414&status=done&style=none&width=215.5\" alt=\"image.png\"><br>所有小项目都放在 src 里，是不是很棒？<br>但是！<strong>必须有 main 包</strong>，必须有 main 函数作为程序入口！<br>具体原理看：<br><a href=\"https://blog.csdn.net/zxy_666/article/details/80390843\">https://blog.csdn.net/zxy_666/article/details/80390843</a><br><a href=\"https://zhuanlan.zhihu.com/p/69445822\">如何写出优雅的 Golang 代码</a><br><a href=\"https://blog.csdn.net/CMbug/article/details/49339341\">Golang import 包问题相关详解</a><br><a href=\"https://www.jianshu.com/p/b224982b6fd5\">理解 Go 语言包(package)</a><br>【3】<strong>结构体属性导出问题</strong><br>结构体中的属性，如果是小写开头，是无法被跨包使用的，也就是说包外无法访问，太狗了。<br><a href=\"https://juejin.cn/post/6844903814168838151\">Go Struct 超详细讲解</a> 建议好好看看这篇</p>\n<h1 id=\"函数知识\"><a href=\"#函数知识\" class=\"headerlink\" title=\"函数知识\"></a>函数知识</h1><h2 id=\"make\"><a href=\"#make\" class=\"headerlink\" title=\"make\"></a>make</h2><p>make()函数在 golang 的代码如下：<br><code>func make(t Type,size IntegerType) Type</code><br>使用 make 来创建 slice，map，chanel 说明如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><br>var slice_ []int = make([]int,5,10)<br>fmt.Println(slice_)<br>var slice_1 []int = make([]int,5)<br>fmt.Println(slice_1)<br>var slice_2 []int = []int&#123;1,2&#125;<br>fmt.Println(slice_2)<br>打印结果：<br>[0 0 0 0 0]<br>[0 0 0 0 0]<br>[1,2]<br></code></pre></td></tr></table></figure>\n\n<p>在创建 slice 时第一个参数用于确定初始化该 slice 的大小该 slice 中的值为零值，第三个参数用于确定该 slice 的长度<br>map：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">var m_ map[string]int = make(map[string]int)<br>m_[&quot;one&quot;] = 1<br>fmt.Println(m_)<br>var m map[string]int = map[string]int&#123;&quot;1&quot;:1&#125;<br>m[&quot;2&quot;] = 2<br>fmt.Println(m)<br>打印结果：<br>map[one:1]<br>map[1:1 2:2]<br></code></pre></td></tr></table></figure>\n\n<p>根据 size 大小来初始化分配内存，不过分配后的 map 长度为 0，如果 size 被忽略了，那么会在初始化分配内存时分配一个小尺寸的内存</p>\n<h2 id=\"nil\"><a href=\"#nil\" class=\"headerlink\" title=\"nil\"></a>nil</h2><p>相信写过 Golang 的程序员对下面一段代码是非常非常熟悉的了：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> &#123;<br>    <span class=\"hljs-comment\">// do something....</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>当出现不等于<code>nil</code>的时候，说明出现某些错误了，需要我们对这个错误进行一些处理，而如果等于<code>nil</code>说明运行正常。那什么是<code>nil</code>呢？查一下词典可以知道，<code>nil</code>的意思是无，或者是零值。零值，zero value，是不是有点熟悉？在 Go 语言中，如果你声明了一个变量但是没有对它进行赋值操作，那么这个变量就会有一个类型的默认零值。这是每种类型对应的零值：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">bool</span>      -&gt; <span class=\"hljs-literal\">false</span><br>numbers -&gt; <span class=\"hljs-number\">0</span><br><span class=\"hljs-keyword\">string</span>    -&gt; <span class=\"hljs-string\">&quot;&quot;</span><br>pointers -&gt; <span class=\"hljs-literal\">nil</span><br>slices -&gt; <span class=\"hljs-literal\">nil</span><br>maps -&gt; <span class=\"hljs-literal\">nil</span><br>channels -&gt; <span class=\"hljs-literal\">nil</span><br>functions -&gt; <span class=\"hljs-literal\">nil</span><br>interfaces -&gt; <span class=\"hljs-literal\">nil</span><br></code></pre></td></tr></table></figure>\n\n<p>举个例子，当你定义了一个 struct：</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elm\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-type\">Person</span> struct &#123;<br>  <span class=\"hljs-type\">AgeYears</span> int<br>  <span class=\"hljs-type\">Name</span> string<br>  <span class=\"hljs-type\">Friends</span> []<span class=\"hljs-type\">Person</span><br>&#125;<br><span class=\"hljs-title\">var</span> p <span class=\"hljs-type\">Person</span> // <span class=\"hljs-type\">Person</span>&#123;<span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&quot;&quot;</span>, nil&#125;<br></code></pre></td></tr></table></figure>\n\n<p>变量<code>p</code>只声明但没有赋值，所以 p 的所有字段都有对应的零值。那么，这个<code>nil</code>到底是什么呢？Go 的文档中说到，_nil 是预定义的标识符，代表指针、通道、函数、接口、映射或切片的零值_，也就是预定义好的一个变量：</p>\n<h2 id=\"slices\"><a href=\"#slices\" class=\"headerlink\" title=\"slices\"></a>slices</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// nil slices</span><br><span class=\"hljs-keyword\">var</span> s []slice<br><span class=\"hljs-built_in\">len</span>(s)  <span class=\"hljs-comment\">// 0</span><br><span class=\"hljs-built_in\">cap</span>(s)  <span class=\"hljs-comment\">// 0</span><br><span class=\"hljs-keyword\">for</span> <span class=\"hljs-keyword\">range</span> s  <span class=\"hljs-comment\">// iterates zero times</span><br>s[i]  <span class=\"hljs-comment\">// panic: index out of range</span><br></code></pre></td></tr></table></figure>\n\n<p>一个为<code>nil</code>的 slice，除了不能索引外，其他的操作都是可以的，当你需要填充值的时候可以使用<code>append</code>函数，slice 会自动进行扩充。那么为<code>nil</code>的 slice 的底层结构是怎样的呢？根据官方的文档，slice 有三个元素，分别是长度、容量、指向数组的指针：<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1617344622341-e1babb6a-2494-437c-93cb-30da90e11894.png#align=left&display=inline&height=143&margin=%5Bobject%20Object%5D&name=image.png&originHeight=286&originWidth=601&size=27035&status=done&style=none&width=300.5\" alt=\"image.png\"><br>当有元素的时候，<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1617344635243-979b77ee-3516-4c3b-a112-a45caad93fdb.png#align=left&display=inline&height=133&margin=%5Bobject%20Object%5D&name=image.png&originHeight=266&originWidth=779&size=50465&status=done&style=none&width=389.5\" alt=\"image.png\"></p>\n<h2 id=\"channel\"><a href=\"#channel\" class=\"headerlink\" title=\"channel\"></a>channel</h2><blockquote>\n<p>参考：<a href=\"https://colobu.com/2016/04/14/Golang-Channels/\">https://colobu.com/2016/04/14/Golang-Channels/</a></p>\n</blockquote>\n<p>Channel 是 Go 中的一个核心类型，你可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯(communication)。<br>它的操作符是箭头  <strong>&lt;-</strong> 。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">ch &lt;- v    <span class=\"hljs-comment\">// 发送值v到Channel ch中</span><br>v := &lt;-ch  <span class=\"hljs-comment\">// 从Channel ch中接收数据，并将数据赋值给v</span><br></code></pre></td></tr></table></figure>\n\n<p>(箭头的指向就是数据的流向)<br>就像 map 和 slice 数据类型一样, channel 必须先创建再使用:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">ch := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-keyword\">int</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"定义与用法\"><a href=\"#定义与用法\" class=\"headerlink\" title=\"定义与用法\"></a>定义与用法</h3><p>它包括三种类型的定义。可选的<code>&lt;-</code>代表 channel 的方向。如果没有指定方向，那么 Channel 就是双向的，既可以接收数据，也可以发送数据。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">chan</span> T          <span class=\"hljs-comment\">// 可以接收和发送类型为 T 的数据</span><br><span class=\"hljs-keyword\">chan</span>&lt;- <span class=\"hljs-keyword\">float64</span>  <span class=\"hljs-comment\">// 只可以用来发送 float64 类型的数据</span><br>&lt;-<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-keyword\">int</span>      <span class=\"hljs-comment\">// 只可以用来接收 int 类型的数据</span><br></code></pre></td></tr></table></figure>\n\n<p>使用<code>make</code>初始化 Channel,并且可以设置容量:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-keyword\">int</span>, <span class=\"hljs-number\">100</span>)<br></code></pre></td></tr></table></figure>\n\n<p>容量(capacity)代表 Channel 容纳的最多的元素的数量，代表 Channel 的缓存的大小。<br>如果没有设置容量，或者容量设置为 0, 说明 Channel 没有缓存，只有 sender 和 receiver 都准备好了后它们的通讯(communication)才会发生(Blocking)。<strong>如果设置了缓存，就有可能不发生阻塞</strong>， 只有 buffer 满了后 send 才会阻塞， 而只有缓存空了后 receive 才会阻塞。一个 nil channel 不会通信。<br>可以通过内建的<code>close</code>方法可以关闭 Channel。<br>你<strong>可以在多个 goroutine 从/往 一个 channel 中 receive/send 数据, 不必考虑额外的同步措施</strong>。<br>Channel 可以作为一个先入先出(FIFO)的队列，接收的数据和发送的数据的顺序是一致的。<br>channel 的 receive 支持  <em>multi-valued assignment</em>，如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">v, ok := &lt;-ch<br></code></pre></td></tr></table></figure>\n\n<p>它可以用来检查 Channel 是否已经被关闭了。</p>\n<h3 id=\"send\"><a href=\"#send\" class=\"headerlink\" title=\"send\"></a>send</h3><p>send 语句用来往 Channel 中发送数据， 如<code>ch &lt;- 3</code>。<br>它的定义如下:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">SendStmt = Channel <span class=\"hljs-string\">&quot;&lt;-&quot;</span> Expression .<br>Channel  = Expression .<br></code></pre></td></tr></table></figure>\n\n<p>在通讯(communication)开始前 channel 和 expression 必选先求值出来(evaluated)，比如下面的(3+4)先计算出 7 然后再发送给 channel。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">c := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-keyword\">int</span>)<br><span class=\"hljs-keyword\">defer</span> <span class=\"hljs-built_in\">close</span>(c)<br><span class=\"hljs-keyword\">go</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> &#123; c &lt;- <span class=\"hljs-number\">3</span> + <span class=\"hljs-number\">4</span> &#125;()<br>i := &lt;-c<br>fmt.Println(i)<br></code></pre></td></tr></table></figure>\n\n<p>send 被执行前(proceed)通讯(communication)一直被阻塞着。如前所言，无缓存的 channel 只有在 receiver 准备好后 send 才被执行。如果有缓存，并且缓存未满，则 send 会被执行。<br>往一个<strong>已经被 close 的 channel 中</strong>继续发送数据会导致<strong>run-time panic</strong>。<br><strong>往 nil channel 中发送数据会一致被阻塞</strong>着。</p>\n<h3 id=\"receive\"><a href=\"#receive\" class=\"headerlink\" title=\"receive\"></a>receive</h3><p><code>&lt;-ch</code>用来从 channel ch 中接收数据，这个表达式会一直被 block,直到有数据可以接收。<br>从一个 nil channel 中接收数据会一直被 block。<br>从一个被 close 的 channel 中接收数据不会被阻塞，而是立即返回，接收完已发送的数据后会返回元素类型的零值(zero value)。<br>如前所述，你可以使用一个额外的返回参数来检查 channel 是否关闭。</p>\n<h3 id=\"阻塞\"><a href=\"#阻塞\" class=\"headerlink\" title=\"阻塞\"></a>阻塞</h3><p>缺省情况下，发送和接收会一直阻塞着，直到另一方准备好。这种方式可以用来在 gororutine 中进行同步，而不必使用显示的锁或者条件变量。<br>如官方的例子中<code>x, y := &lt;-c, &lt;-c</code>这句会一直等待计算结果发送到 channel 中。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;fmt&quot;</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">sum</span><span class=\"hljs-params\">(s []<span class=\"hljs-keyword\">int</span>, c <span class=\"hljs-keyword\">chan</span> <span class=\"hljs-keyword\">int</span>)</span></span> &#123;<br>\tsum := <span class=\"hljs-number\">0</span><br>\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> s &#123;<br>\t\tsum += v<br>\t&#125;<br>\tc &lt;- sum <span class=\"hljs-comment\">// send sum to c</span><br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>\ts := []<span class=\"hljs-keyword\">int</span>&#123;<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">-9</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">0</span>&#125;<br>\tc := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-keyword\">int</span>)<br>\t<span class=\"hljs-keyword\">go</span> sum(s[:<span class=\"hljs-built_in\">len</span>(s)/<span class=\"hljs-number\">2</span>], c)<br>\t<span class=\"hljs-keyword\">go</span> sum(s[<span class=\"hljs-built_in\">len</span>(s)/<span class=\"hljs-number\">2</span>:], c)<br>\tx, y := &lt;-c, &lt;-c <span class=\"hljs-comment\">// receive from c</span><br>\tfmt.Println(x, y, x+y)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Range\"><a href=\"#Range\" class=\"headerlink\" title=\"Range\"></a>Range</h3><p><code>for …… range</code>语句可以处理 Channel。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>\t<span class=\"hljs-keyword\">go</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> &#123;<br>\t\ttime.Sleep(<span class=\"hljs-number\">1</span> * time.Hour)<br>\t&#125;()<br>\tc := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-keyword\">int</span>)<br>\t<span class=\"hljs-keyword\">go</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i = i + <span class=\"hljs-number\">1</span> &#123;<br>\t\t\tc &lt;- i<br>\t\t&#125;<br>\t\t<span class=\"hljs-built_in\">close</span>(c)<br>\t&#125;()<br>\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-keyword\">range</span> c &#123;<br>\t\tfmt.Println(i)<br>\t&#125;<br>\tfmt.Println(<span class=\"hljs-string\">&quot;Finished&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>range c</code>产生的迭代值为 Channel 中发送的值，它会一直迭代直到 channel 被关闭。上面的例子中如果把<code>close(c)</code>注释掉，程序会一直阻塞在<code>for …… range</code>那一行。</p>\n<h3 id=\"defer\"><a href=\"#defer\" class=\"headerlink\" title=\"defer\"></a>defer</h3><p><a href=\"https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html\">https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html</a><br>这个博客讲的挺好的，其他知识也有，可以常看看。<br>另外还有：<a href=\"https://sanyuesha.com/2017/07/23/go-defer/\">https://sanyuesha.com/2017/07/23/go-defer/</a></p>\n<h1 id=\"其他知识\"><a href=\"#其他知识\" class=\"headerlink\" title=\"其他知识\"></a>其他知识</h1><h2 id=\"goroutine\"><a href=\"#goroutine\" class=\"headerlink\" title=\"goroutine\"></a>goroutine</h2><p><a href=\"https://www.cnblogs.com/wdliu/p/9272220.html\">https://www.cnblogs.com/wdliu/p/9272220.html</a> 调度原理<br>代码示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main<br><br><span class=\"hljs-keyword\">import</span> (<br>    <span class=\"hljs-string\">&quot;fmt&quot;</span><br>    <span class=\"hljs-string\">&quot;time&quot;</span><br>)<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">cal</span><span class=\"hljs-params\">(a <span class=\"hljs-keyword\">int</span> , b <span class=\"hljs-keyword\">int</span> )</span></span>  &#123;<br>    c := a+b<br>    fmt.Printf(<span class=\"hljs-string\">&quot;%d + %d = %d\\n&quot;</span>,a,b,c)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;　　<br>    <span class=\"hljs-keyword\">for</span> i :=<span class=\"hljs-number\">0</span> ; i&lt;<span class=\"hljs-number\">10</span> ;i++&#123;<br>        <span class=\"hljs-keyword\">go</span> cal(i,i+<span class=\"hljs-number\">1</span>)  <span class=\"hljs-comment\">//启动10个goroutine 来计算</span><br>    &#125;<br>    time.Sleep(time.Second * <span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// sleep作用是为了等待所有任务完成</span><br>&#125;<br><span class=\"hljs-comment\">//结果</span><br><span class=\"hljs-comment\">//8 + 9 = 17</span><br><span class=\"hljs-comment\">//9 + 10 = 19</span><br><span class=\"hljs-comment\">//4 + 5 = 9</span><br><span class=\"hljs-comment\">//5 + 6 = 11</span><br><span class=\"hljs-comment\">//0 + 1 = 1</span><br><span class=\"hljs-comment\">//1 + 2 = 3</span><br><span class=\"hljs-comment\">//2 + 3 = 5</span><br><span class=\"hljs-comment\">//3 + 4 = 7</span><br><span class=\"hljs-comment\">//7 + 8 = 15</span><br><span class=\"hljs-comment\">//6 + 7 = 13</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"goroutine-异常捕捉\"><a href=\"#goroutine-异常捕捉\" class=\"headerlink\" title=\"goroutine 异常捕捉\"></a>goroutine 异常捕捉</h3><p>当启动多个 goroutine 时，如果<strong>其中一个 goroutine 异常</strong>了，并且我们并没有对进行异常处理，<strong>那么整个程序都会终止</strong>，所以我们在编写程序时候最好每个 goroutine 所运行的函数都做异常处理，异常处理采用 recover.</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main<br><br><span class=\"hljs-keyword\">import</span> (<br>    <span class=\"hljs-string\">&quot;fmt&quot;</span><br>    <span class=\"hljs-string\">&quot;time&quot;</span><br>)<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">addele</span><span class=\"hljs-params\">(a []<span class=\"hljs-keyword\">int</span> ,i <span class=\"hljs-keyword\">int</span>)</span></span>  &#123;<br>    <span class=\"hljs-keyword\">defer</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> &#123;    <span class=\"hljs-comment\">//匿名函数捕获错误</span><br>        err := <span class=\"hljs-built_in\">recover</span>()<br>        <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> &#123;<br>            fmt.Println(<span class=\"hljs-string\">&quot;add ele fail&quot;</span>)<br>        &#125;<br>    &#125;()<br>   a[i]=i<br>   fmt.Println(a)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    Arry := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">int</span>,<span class=\"hljs-number\">4</span>)<br>    <span class=\"hljs-keyword\">for</span> i :=<span class=\"hljs-number\">0</span> ; i&lt;<span class=\"hljs-number\">10</span> ;i++&#123;<br>        <span class=\"hljs-keyword\">go</span> addele(Arry,i)<br>    &#125;<br>    time.Sleep(time.Second * <span class=\"hljs-number\">2</span>)<br>&#125;<br><span class=\"hljs-comment\">//结果</span><br>add ele fail<br>[<span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0</span>]<br>[<span class=\"hljs-number\">0</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0</span>]<br>[<span class=\"hljs-number\">0</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">0</span>]<br>[<span class=\"hljs-number\">0</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span>]<br>add ele fail<br>add ele fail<br>add ele fail<br>add ele fail<br>add ele fail<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"方法-1\"><a href=\"#方法-1\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>Go 语言中同时有函数和方法。<strong>一个方法就是一个包含了接受者的函数</strong>，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。<strong>所有给定类型的方法属于该类型的方法集</strong>。语法格式如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(variable_name variable_data_type)</span> <span class=\"hljs-title\">function_name</span><span class=\"hljs-params\">()</span> [<span class=\"hljs-title\">return_type</span>]</span>&#123;<br>   <span class=\"hljs-comment\">/* 函数体*/</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main<br><br><span class=\"hljs-keyword\">import</span> (<br>   <span class=\"hljs-string\">&quot;fmt&quot;</span><br>)<br><br><span class=\"hljs-comment\">/* 定义结构体 */</span><br><span class=\"hljs-keyword\">type</span> Circle <span class=\"hljs-keyword\">struct</span> &#123;<br>  radius <span class=\"hljs-keyword\">float64</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>  <span class=\"hljs-keyword\">var</span> c1 Circle<br>  c1.radius = <span class=\"hljs-number\">10.00</span><br>  fmt.Println(<span class=\"hljs-string\">&quot;圆的面积 = &quot;</span>, c1.getArea())<br>&#125;<br><br><span class=\"hljs-comment\">//该 method 属于 Circle 类型对象中的方法</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c Circle)</span> <span class=\"hljs-title\">getArea</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">float64</span></span> &#123;<br>  <span class=\"hljs-comment\">//c.radius 即为 Circle 类型对象中的属性</span><br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">3.14</span> * c.radius * c.radius<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"函数传参\"><a href=\"#函数传参\" class=\"headerlink\" title=\"函数传参\"></a>函数传参</h2><p>数组和切片很像，但是在调用的时候他们传递的类型是不同的！</p>\n<ul>\n<li>Go 语言的数组是值，其长度是其类型的一部分，作为函数参数时，是 <strong>值传递</strong>，函数中的修改对调用者不可见</li>\n<li>Go 语言中对数组的处理，一般采用 <strong>切片</strong> 的方式，切片包含对底层数组内容的引用，作为函数参数时，类似于 <strong>指针传递</strong>，函数中的修改对调用者可见。</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// 数组</span><br>b := [...]<span class=\"hljs-keyword\">int</span>&#123;<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">13</span>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">boo</span><span class=\"hljs-params\">(tt [6]<span class=\"hljs-keyword\">int</span>)</span></span> &#123;<br>    tt[<span class=\"hljs-number\">0</span>], tt[<span class=\"hljs-built_in\">len</span>(tt)<span class=\"hljs-number\">-1</span>] = tt[<span class=\"hljs-built_in\">len</span>(tt)<span class=\"hljs-number\">-1</span>], tt[<span class=\"hljs-number\">0</span>]<br>&#125;<br>boo(b)<br>fmt.Println(b) <span class=\"hljs-comment\">// [2 3 5 7 11 13]</span><br><span class=\"hljs-comment\">// 切片</span><br>p := []<span class=\"hljs-keyword\">int</span>&#123;<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">13</span>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">poo</span><span class=\"hljs-params\">(tt []<span class=\"hljs-keyword\">int</span>)</span></span> &#123;<br>    tt[<span class=\"hljs-number\">0</span>], tt[<span class=\"hljs-built_in\">len</span>(tt)<span class=\"hljs-number\">-1</span>] = tt[<span class=\"hljs-built_in\">len</span>(tt)<span class=\"hljs-number\">-1</span>], tt[<span class=\"hljs-number\">0</span>]<br>&#125;<br>poo(p)<br>fmt.Println(p)  <span class=\"hljs-comment\">// [13 3 5 7 11 2]</span><br></code></pre></td></tr></table></figure>","categories":[],"tags":[]}