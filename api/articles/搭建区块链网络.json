{"title":"搭建区块链网络","slug":"搭建区块链网络","date":"2021-03-28T03:51:38.000Z","updated":"2023-04-17T12:00:42.048Z","comments":true,"path":"api/articles/搭建区块链网络.json","realPath":null,"excerpt":null,"covers":["https://cdn.nlark.com/yuque/0/2021/png/1629942/1616903705092-eb040ef2-e211-434c-a2c1-27e75c9667d7.png#height=166&id=kcgh9&name=image.png&originHeight=332&originWidth=357&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=13594&status=done&style=none&title=&width=178.5","https://cdn.nlark.com/yuque/0/2021/png/1629942/1616908860946-be7368d2-b3fa-4cd9-9b7d-8a3899e04937.png#height=224&id=zQyhh&name=image.png&originHeight=448&originWidth=645&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=15493&status=done&style=shadow&title=&width=322.5","https://cdn.nlark.com/yuque/0/2021/png/1629942/1616912721520-33ef9da2-c62d-4d5a-97c2-99077a0b7d1b.png#height=184&id=KiuBx&name=image.png&originHeight=367&originWidth=685&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=62156&status=done&style=none&title=&width=342.5","https://cdn.nlark.com/yuque/0/2021/png/1629942/1616914229993-778efd1e-9f02-4746-b4e6-3891fd1f7c82.png#height=303&id=MOTgK&name=image.png&originHeight=362&originWidth=848&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=243838&status=done&style=none&title=&width=710","https://cdn.nlark.com/yuque/0/2021/png/1629942/1616918388824-cb331dd8-b883-4bff-ad05-700b10a64f28.png#height=330&id=SE4Hx&name=image.png&originHeight=447&originWidth=823&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=213757&status=done&style=none&title=&width=608","https://cdn.nlark.com/yuque/0/2021/png/1629942/1617414711574-3c923c62-e148-45bc-874e-6da4cafcfd0a.png#height=278&id=f71iF&name=image.png&originHeight=555&originWidth=972&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=192050&status=done&style=none&title=&width=486","https://cdn.nlark.com/yuque/0/2021/png/1629942/1617440689986-4ebfa454-4b06-4fdc-99d3-c5b84c27c0db.png#height=320&id=Yqb4B&name=image.png&originHeight=639&originWidth=989&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=90760&status=done&style=none&title=&width=494.5"],"cover":"https://cdn.nlark.com/yuque/0/2021/png/1629942/1616903705092-eb040ef2-e211-434c-a2c1-27e75c9667d7.png#height=166&id=kcgh9&name=image.png&originHeight=332&originWidth=357&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=13594&status=done&style=none&title=&width=178.5","content":"<a id=\"more\"></a>\n\n<h1 id=\"从零开始\"><a href=\"#从零开始\" class=\"headerlink\" title=\"从零开始\"></a>从零开始</h1><p>【1】<a href=\"https://github.com/omnigeeker/golang_blockchain_demo/tree/master/blockchain\">https://github.com/omnigeeker/golang_blockchain_demo/tree/master/blockchain</a><br>这是第一个，当然，我还找到好几个不错的，都 star 了。<br>下载之后，需要放置到 GOPATH 的 src 目录下面，然后开始跑。</p>\n<p>注意，定义端口的文件叫<code>.env</code>，需要放在这里，当时报错报的我都懵了。<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1616903705092-eb040ef2-e211-434c-a2c1-27e75c9667d7.png#height=166&id=kcgh9&name=image.png&originHeight=332&originWidth=357&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=13594&status=done&style=none&title=&width=178.5\" alt=\"image.png\"><br>然后，运行起来是这样的。<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1616903978333-917b06c4-fb2e-4897-a825-07ff5a7e26af.png#height=142&id=CcaX0&name=image.png&originHeight=283&originWidth=895&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=32187&status=done&style=none&title=&width=447.5\" alt=\"image.png\"><br>原文中说，可以发送一个 post 请求用来创建新的块，我试了一下，postman 不能用插件了，postwoman 无法调试本地地址？然后 curl 命令也是可以的，参考<a href=\"https://www.jianshu.com/p/9bd018253bed\">https://www.jianshu.com/p/9bd018253bed</a>，然后另外一个插件<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1616904095287-f81eed6a-fc08-4ec7-9ded-74a9ccdd23c3.png#height=148&id=oXKMq&name=image.png&originHeight=295&originWidth=806&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=32785&status=done&style=none&title=&width=403\" alt=\"image.png\"><br>也不错。<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1616904175832-884b4446-3c1f-4df5-bca4-cdf3e9bcaaea.png#height=341&id=o3BPd&name=image.png&originHeight=682&originWidth=908&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=56987&status=done&style=none&title=&width=454\" alt=\"image.png\"><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1616904253263-b87ff0fb-9ff2-4196-86c2-d5a434559bcd.png#height=330&id=G3ELB&name=image.png&originHeight=659&originWidth=892&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=62473&status=done&style=none&title=&width=446\" alt=\"image.png\"><br>完美。<br>当我们访问<a href=\"http://localhost:8000/\">http://localhost:8000/</a>，可以看到：<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1616904286585-4e03e1f1-4e49-41f1-96c8-272fa2397ceb.png#height=226&id=PNpA5&name=image.png&originHeight=451&originWidth=703&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=23406&status=done&style=none&title=&width=351.5\" alt=\"image.png\"></p>\n<h1 id=\"搭建-block-DAG\"><a href=\"#搭建-block-DAG\" class=\"headerlink\" title=\"搭建 block-DAG\"></a>搭建 block-DAG</h1><p>网上这部分资料很少，只找到一个<a href=\"https://github.com/soteria-dag/soterd/tree/master/blockdag\">https://github.com/soteria-dag/soterd/tree/master/blockdag</a>，还不确定可不可以利用，加油。<br>然后还有一个 python 版的<a href=\"https://github.com/AvivYaish/PHANTOM/tree/master/phantom\">https://github.com/AvivYaish/PHANTOM/tree/master/phantom</a>，里面貌似实现了一个小型的 DAG 区块链，但是感觉写的代码好少，不确定能不能用。</p>\n<h2 id=\"根据-soteria-dag-搭建\"><a href=\"#根据-soteria-dag-搭建\" class=\"headerlink\" title=\"根据 soteria-dag 搭建\"></a>根据 soteria-dag 搭建</h2><p>本模块除了搭建步骤记录，还包括，数据结构记录，类方法记录，调用关系记录，以及 DAG 前置知识。</p>\n<h3 id=\"为什么用-BLOCK-DAG\"><a href=\"#为什么用-BLOCK-DAG\" class=\"headerlink\" title=\"为什么用 BLOCK-DAG\"></a>为什么用 BLOCK-DAG</h3><p>BlockDAG 提供了比特币设计的主要功能，包括（1）分散化；您可以在没有中间人的情况下将货币转移给其他人。（2）某种程度的匿名性；货币与你的真实身份没有直接联系。（3）无信任共识；区块链实施的规则允许您对陌生人所做的区块验证工作有一定程度的信任，并使更改区块和交易变得困难。<br>另外，还提供了：</p>\n<ul>\n<li>提高了事务吞吐量；</li>\n<li>允许使用工作证明系统，提高区块开采的可访问性和公平性。</li>\n<li>加密事务负载</li>\n<li>可扩展性</li>\n<li>轻巧</li>\n<li>量子安全（使用三元或平衡三元计算，而不是经典计算机执行的标准二进制计算</li>\n</ul>\n<h3 id=\"DAG-Vs-Bitchain\"><a href=\"#DAG-Vs-Bitchain\" class=\"headerlink\" title=\"DAG Vs Bitchain\"></a>DAG Vs Bitchain</h3><ol>\n<li>单链技术存在的几个问题</li>\n</ol>\n<p>效率问题：传统区块链技术基于区块，比特币的效率较低，每十分钟出一个块，6 个出块确认需要一个小时，整个网络同时只能有一条单链，基于 PoW 共识机制出块无法并发执行。<br>确定性问题：比特币和以太坊存在 51%算力攻击问题，基于 PoW 共识的最大问题就是没有一个确定的不可更改的最终状态；如果某群体控制 51%算力，并发起攻击，比特币体系会崩溃。<br>中心化问题：基于区块的 PoW 共识中，矿工一方面可以形成集中化的矿场集团，一方面，获得打包交易权的矿工拥有巨大权力，可以选择那些交易进入区块，哪些交易不被处理，这样的风险目前已经是事实存在。<br>能耗问题：由于传统区块链基于 PoW 算力工作量证明，达成共识机制，比特币的挖矿能耗已经和阿根廷整个国家的耗电量持平。<br>2.DAG 区块链的优势和价值<br>a.传统区块链需要矿工完成工作量证明（PoW)来执行每一笔交易，而 DAG 区块链能摆脱这样的限制。<br>b.在 DAG 系统中，交易指令能极快的扩散通知至全网，大部分双重支付的攻击尝试将会被系统捕捉到并立即拒绝执行。</p>\n<p>二者区块结构示意图对比：<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1616908860946-be7368d2-b3fa-4cd9-9b7d-8a3899e04937.png#height=224&id=zQyhh&name=image.png&originHeight=448&originWidth=645&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=15493&status=done&style=shadow&title=&width=322.5\" alt=\"image.png\"><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1616908870524-9b40f2d6-0c7c-4bbe-b54d-510dcc608329.png#height=220&id=cnjIc&name=image.png&originHeight=439&originWidth=654&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=17168&status=done&style=shadow&title=&width=327\" alt=\"image.png\"><br>其中<code>parent sub-header</code>包括：</p>\n<ul>\n<li>Version - A value that could be used to trigger different block evaluation rules</li>\n<li>Parents count - The number of parents this block has</li>\n<li>Parents - A list of parents</li>\n</ul>\n<h3 id=\"BLOCK-DAG-整体结构\"><a href=\"#BLOCK-DAG-整体结构\" class=\"headerlink\" title=\"BLOCK-DAG 整体结构\"></a>BLOCK-DAG 整体结构</h3><p>区块链系统架构分别由数据层、网络层、共识层、激励层、合约层和应用层组成。<br>此处需要一个 DAG 区块链的架构图，类似于传统区块链的架构图–共识层，激励层什么的</p>\n<ul>\n<li>创世区块：高度为 0 的 genesis 块（它没有父块，同一高度/代上没有其他块）</li>\n<li>一个或多个区块连接到 genesis 区块（高度 1）</li>\n<li>连接到这些块的一个或多个块</li>\n</ul>\n<p>拓扑结构如下：<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1616912721520-33ef9da2-c62d-4d5a-97c2-99077a0b7d1b.png#height=184&id=KiuBx&name=image.png&originHeight=367&originWidth=685&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=62156&status=done&style=none&title=&width=342.5\" alt=\"image.png\"></p>\n<blockquote>\n<p>由 Yonatan Sompolinsky 提出，新产生的区块指向所有已知的分叉末端区块，即一个区块有多个父亲，此时<strong>区块链就从一条链变为多条分叉链共同组成的的结构。</strong></p>\n</blockquote>\n<p>这就形成了一个远离创世纪区块的区块结构，每个世代/高度都有一组区块远离创世纪区块。区块之间的连接不像区块链那样严格；您可以有多个父级，并且父级的高度不同（在一个上限内）。<br>没有任何块与之连接的块集称为 DAG 的“tips”。当挖掘新块时，这些块用作父块，当节点彼此同步时，这些块也被引用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> BlockDAG <span class=\"hljs-keyword\">struct</span> &#123;<br>\t<span class=\"hljs-comment\">// The following fields are set when the instance is created and can&#x27;t</span><br>\t<span class=\"hljs-comment\">// be changed afterwards, so there is no need to protect them with a</span><br>\t<span class=\"hljs-comment\">// separate mutex.</span><br>\t<span class=\"hljs-comment\">//checkpoints         []chaincfg.Checkpoint</span><br>\t<span class=\"hljs-comment\">//checkpointsByHeight map[int32]*chaincfg.Checkpoint</span><br>\tdb           database.DB<br>\tchainParams  *chaincfg.Params<br>\ttimeSource   MedianTimeSource<br>\tsigCache     *txscript.SigCache<br>\tindexManager IndexManager<br>\thashCache    *txscript.HashCache<br><br>\t<span class=\"hljs-comment\">// The following fields are calculated based upon the provided chain</span><br>\t<span class=\"hljs-comment\">// parameters.  They are also set when the instance is created and</span><br>\t<span class=\"hljs-comment\">// can&#x27;t be changed afterwards, so there is no need to protect them with</span><br>\t<span class=\"hljs-comment\">// a separate mutex.</span><br>\tminRetargetTimespan <span class=\"hljs-keyword\">int64</span> <span class=\"hljs-comment\">// target timespan / adjustment factor</span><br>\tmaxRetargetTimespan <span class=\"hljs-keyword\">int64</span> <span class=\"hljs-comment\">// target timespan * adjustment factor</span><br>\tblocksPerRetarget   <span class=\"hljs-keyword\">int64</span> <span class=\"hljs-comment\">// target timespan / target time per block</span><br><br>\t<span class=\"hljs-comment\">// chainLock protects concurrent access to the vast majority of the</span><br>\t<span class=\"hljs-comment\">// fields in this struct below this point.</span><br>\tchainLock sync.RWMutex<br><br>\t<span class=\"hljs-comment\">// These fields are related to the memory block index.  They both have</span><br>\t<span class=\"hljs-comment\">// their own locks, however they are often also protected by the chain</span><br>\t<span class=\"hljs-comment\">// lock to help prevent logic races when blocks are being processed.</span><br>\t<span class=\"hljs-comment\">//</span><br>\t<span class=\"hljs-comment\">// index houses the entire block index in memory.</span><br>\tindex             *blockIndex<br>\tdView             *dagView<br>\tgraph             *phantom.Graph<br>\tblueSet           *phantom.BlueSetCache<br>\tnodeOrder         []*chainhash.Hash<br>\torderCache        *phantom.OrderCache<br><br><br>\t<span class=\"hljs-comment\">// These fields are related to checkpoint handling.  They are protected</span><br>\t<span class=\"hljs-comment\">// by the chain lock.</span><br>\t<span class=\"hljs-comment\">//nextCheckpoint *chaincfg.Checkpoint</span><br>\t<span class=\"hljs-comment\">//checkpointNode *blockNode</span><br><br>\t<span class=\"hljs-comment\">// The state is used as a fairly efficient way to cache information</span><br>\t<span class=\"hljs-comment\">// about the current best chain state that is returned to callers when</span><br>\t<span class=\"hljs-comment\">// requested.  It operates on the principle of MVCC such that any time a</span><br>\t<span class=\"hljs-comment\">// new block becomes the best block, the state pointer is replaced with</span><br>\t<span class=\"hljs-comment\">// a new struct and the old state is left untouched.  In this way,</span><br>\t<span class=\"hljs-comment\">// multiple callers can be pointing to different best chain states.</span><br>\t<span class=\"hljs-comment\">// This is acceptable for most callers because the state is only being</span><br>\t<span class=\"hljs-comment\">// queried at a specific point in time.</span><br>\t<span class=\"hljs-comment\">//</span><br>\t<span class=\"hljs-comment\">// In addition, some of the fields are stored in the database so the</span><br>\t<span class=\"hljs-comment\">// chain state can be quickly reconstructed on load.</span><br>\tstateLock     sync.RWMutex<br>\tstateSnapshot *BestState<br>\tdagSnapshot   *DAGState<br><br>\t<span class=\"hljs-comment\">// The following caches are used to efficiently keep track of the</span><br>\t<span class=\"hljs-comment\">// current deployment threshold state of each rule change deployment.</span><br>\t<span class=\"hljs-comment\">//</span><br>\t<span class=\"hljs-comment\">// This information is stored in the database so it can be quickly</span><br>\t<span class=\"hljs-comment\">// reconstructed on load.</span><br>\t<span class=\"hljs-comment\">//</span><br>\t<span class=\"hljs-comment\">// warningCaches caches the current deployment threshold state for blocks</span><br>\t<span class=\"hljs-comment\">// in each of the **possible** deployments.  This is used in order to</span><br>\t<span class=\"hljs-comment\">// detect when new unrecognized rule changes are being voted on and/or</span><br>\t<span class=\"hljs-comment\">// have been activated such as will be the case when older versions of</span><br>\t<span class=\"hljs-comment\">// the software are being used</span><br>\t<span class=\"hljs-comment\">//</span><br>\t<span class=\"hljs-comment\">// deploymentCaches caches the current deployment threshold state for</span><br>\t<span class=\"hljs-comment\">// blocks in each of the actively defined deployments.</span><br>\twarningCaches    []thresholdStateCache<br>\tdeploymentCaches []thresholdStateCache<br><br>\t<span class=\"hljs-comment\">// The following fields are used to determine if certain warnings have</span><br>\t<span class=\"hljs-comment\">// already been shown.</span><br>\t<span class=\"hljs-comment\">//</span><br>\t<span class=\"hljs-comment\">// unknownRulesWarned refers to warnings due to unknown rules being</span><br>\t<span class=\"hljs-comment\">// activated.</span><br>\t<span class=\"hljs-comment\">//</span><br>\t<span class=\"hljs-comment\">// unknownVersionsWarned refers to warnings due to unknown versions</span><br>\t<span class=\"hljs-comment\">// being mined.</span><br>\tunknownRulesWarned    <span class=\"hljs-keyword\">bool</span><br>\tunknownVersionsWarned <span class=\"hljs-keyword\">bool</span><br><br>\t<span class=\"hljs-comment\">// The notifications field stores a slice of callbacks to be executed on</span><br>\t<span class=\"hljs-comment\">// certain blockchain events.</span><br>\tnotificationsLock sync.RWMutex<br>\tnotifications     []NotificationCallback<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>并且使用“链视图”来存储链状态，</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// chainView provides a flat view of a specific branch of the block chain from</span><br><span class=\"hljs-comment\">// its tip back to the genesis block and provides various convenience functions</span><br><span class=\"hljs-comment\">// for comparing chains.</span><br><span class=\"hljs-comment\">//</span><br><span class=\"hljs-comment\">// For example, assume a block chain with a side chain as depicted below:</span><br><span class=\"hljs-comment\">//   genesis -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4  -&gt; 5 -&gt;  6  -&gt; 7  -&gt; 8</span><br><span class=\"hljs-comment\">//                         \\-&gt; 4a -&gt; 5a -&gt; 6a</span><br><span class=\"hljs-comment\">//</span><br><span class=\"hljs-comment\">// The chain view for the branch ending in 6a consists of:</span><br><span class=\"hljs-comment\">//   genesis -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4a -&gt; 5a -&gt; 6a</span><br><span class=\"hljs-keyword\">type</span> dagView <span class=\"hljs-keyword\">struct</span> &#123;<br>\tmtx      sync.Mutex<br>\tdagTips  <span class=\"hljs-keyword\">map</span>[*blockNode]<span class=\"hljs-keyword\">struct</span>&#123;&#125;<br>\tnodes    [][]*blockNode<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"类方法\"><a href=\"#类方法\" class=\"headerlink\" title=\"类方法\"></a>类方法</h3><h4 id=\"BlockDAG\"><a href=\"#BlockDAG\" class=\"headerlink\" title=\"BlockDAG\"></a>BlockDAG</h4><p>Methods:</p>\n<table>\n<thead>\n<tr>\n<th>calcNextBlockVersion(prevNodes []*blockNode) (int32, error)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>calcNextParentVersion(prevNodes []*blockNode) (int32, error)</td>\n</tr>\n<tr>\n<td>CalcNextBlockVersion() (int32, error)</td>\n</tr>\n<tr>\n<td>CalcNextParentVersion() (int32, error)</td>\n</tr>\n<tr>\n<td>warnUnknownRuleActivations(nodes []*blockNode) error</td>\n</tr>\n<tr>\n<td>warnUnknownVersions(nodes []*blockNode) error</td>\n</tr>\n<tr>\n<td>calcEasiestDifficulty(bits uint32, duration time.Duration) uint32</td>\n</tr>\n<tr>\n<td>findPrevTestNetDifficulty(startNode *blockNode) uint32</td>\n</tr>\n<tr>\n<td>calcNextRequiredDifficulty(lastNode *blockNode, newBlockTime time.Time) (uint32, error)</td>\n</tr>\n<tr>\n<td>CalcNextRequiredDifficulty(timestamp time.Time) (uint32, error)</td>\n</tr>\n<tr>\n<td>TargetDifficulty(blockHeight int32) (*big.Int, error)</td>\n</tr>\n<tr>\n<td>FetchSpendJournal(targetBlock *soterutil.Block) ([]SpentTxOut, error)</td>\n</tr>\n<tr>\n<td>createChainState() error</td>\n</tr>\n<tr>\n<td>initChainState() error</td>\n</tr>\n<tr>\n<td>BlocksByHeight(blockHeight int32) ([]*soterutil.Block, error)</td>\n</tr>\n<tr>\n<td>BlockByHash(hash *chainhash.Hash) (*soterutil.Block, error)</td>\n</tr>\n<tr>\n<td>FetchUtxoView(tx *soterutil.Tx) (*UtxoViewpoint, error)</td>\n</tr>\n<tr>\n<td>FetchUtxoEntry(outpoint wire.OutPoint) (*UtxoEntry, error)</td>\n</tr>\n<tr>\n<td>visitOrphan(hash _chainhash.Hash, order _[]chainhash.Hash, tempMark *map[chainhash.Hash]int, done *map[chainhash.Hash]int) error</td>\n</tr>\n<tr>\n<td>HaveBlock(hash *chainhash.Hash) (bool, error)</td>\n</tr>\n<tr>\n<td>IsKnownOrphan(hash *chainhash.Hash) bool</td>\n</tr>\n<tr>\n<td>GetOrphanBlocks() []*soterutil.Block</td>\n</tr>\n<tr>\n<td>GetOrphanChildren(parent *chainhash.Hash) []*soterutil.Block</td>\n</tr>\n<tr>\n<td>GetOrphanLocator(hashes []chainhash.Hash) BlockLocator</td>\n</tr>\n<tr>\n<td>GetOrphanOrder() ([]chainhash.Hash, error)</td>\n</tr>\n<tr>\n<td>GetOrphanRoot(hash *chainhash.Hash) []chainhash.Hash</td>\n</tr>\n<tr>\n<td>GetOrphans() []*orphanBlock</td>\n</tr>\n<tr>\n<td>removeOrphanBlock(orphan *orphanBlock)</td>\n</tr>\n<tr>\n<td>addOrphanBlock(block *soterutil.Block)</td>\n</tr>\n<tr>\n<td>CalcSequenceLock(tx *soterutil.Tx, utxoView <em>UtxoViewpoint, mempool bool) (\\</em>SequenceLock, error)</td>\n</tr>\n<tr>\n<td>calcSequenceLock(nodes []*blockNode, tx *soterutil.Tx, utxoView *UtxoViewpoint, mempool bool) (*SequenceLock, error)</td>\n</tr>\n<tr>\n<td>getAllInputTxos(block *soterutil.Block, view *UtxoViewpoint) ([]SpentTxOut, error)</td>\n</tr>\n<tr>\n<td>connectBlock(node *blockNode, block <em>soterutil.Block, view \\</em>UtxoViewpoint, stxos []SpentTxOut) error</td>\n</tr>\n<tr>\n<td>connectBestChain(node *blockNode, block *soterutil.Block, flags BehaviorFlags) (bool, error)</td>\n</tr>\n<tr>\n<td>isCurrent() bool</td>\n</tr>\n<tr>\n<td>IsCurrent() bool</td>\n</tr>\n<tr>\n<td>BestSnapshot() *BestState</td>\n</tr>\n<tr>\n<td>DAGSnapshot() *DAGState</td>\n</tr>\n<tr>\n<td>DAGColoring() []*chainhash.Hash</td>\n</tr>\n<tr>\n<td>DAGOrdering() []*chainhash.Hash</td>\n</tr>\n<tr>\n<td>HeaderByHash(hash *chainhash.Hash) (wire.BlockHeader, error)</td>\n</tr>\n<tr>\n<td>MainChainHasBlock(hash *chainhash.Hash) bool</td>\n</tr>\n<tr>\n<td>BlockLocatorFromHash(hash *chainhash.Hash) BlockLocator</td>\n</tr>\n<tr>\n<td>BlockLocatorFromHeight(height int32) BlockLocator</td>\n</tr>\n<tr>\n<td>LatestBlockLocator() (BlockLocator, error)</td>\n</tr>\n<tr>\n<td>BlockHeightByHash(hash *chainhash.Hash) (int32, error)</td>\n</tr>\n<tr>\n<td>BlockHashesByHeight(blockHeight int32) ([]chainhash.Hash, error)</td>\n</tr>\n<tr>\n<td>HeightRange(startHeight int32, endHeight int32) ([]chainhash.Hash, error)</td>\n</tr>\n<tr>\n<td>HeightToHashRange(startHeight int32, endHash *chainhash.Hash, maxResults int) ([]chainhash.Hash, error)</td>\n</tr>\n<tr>\n<td>IntervalBlockHashes(endHash *chainhash.Hash, interval int) ([]chainhash.Hash, error)</td>\n</tr>\n<tr>\n<td>locateInventory(locator BlockLocator, hashStop *chainhash.Hash, maxEntries uint32) []*blockNode</td>\n</tr>\n<tr>\n<td>locateBlocks(locator BlockLocator, hashStop *chainhash.Hash, maxHashes uint32) []chainhash.Hash</td>\n</tr>\n<tr>\n<td>LocateBlocks(locator BlockLocator, hashStop *chainhash.Hash, maxHashes uint32) []chainhash.Hash</td>\n</tr>\n<tr>\n<td>locateHeaders(locator BlockLocator, hashStop *chainhash.Hash, maxHeaders uint32) []wire.BlockHeader</td>\n</tr>\n<tr>\n<td>LocateHeaders(locator BlockLocator, hashStop *chainhash.Hash) []wire.BlockHeader</td>\n</tr>\n<tr>\n<td>GetBlockDiff(subtips []*chainhash.Hash) []*chainhash.Hash</td>\n</tr>\n<tr>\n<td>Subscribe(callback NotificationCallback)</td>\n</tr>\n<tr>\n<td>sendNotification(typ NotificationType, data interface{})</td>\n</tr>\n<tr>\n<td>checkBlockHeaderContext(header *wire.BlockHeader, prevNodes []*blockNode, flags BehaviorFlags) error</td>\n</tr>\n<tr>\n<td>checkBlockContext(block *soterutil.Block, prevNodes []*blockNode, flags BehaviorFlags) error</td>\n</tr>\n<tr>\n<td>checkBIP0030(node *blockNode, block <em>soterutil.Block, view \\</em>UtxoViewpoint) error</td>\n</tr>\n<tr>\n<td>checkConnectBlock(node *blockNode, block *soterutil.Block, view _UtxoViewpoint, stxos _[]SpentTxOut) error</td>\n</tr>\n<tr>\n<td>CheckConnectBlockTemplate(block *soterutil.Block) error</td>\n</tr>\n<tr>\n<td>RenderDot() ([]byte, error)</td>\n</tr>\n<tr>\n<td>RenderSvg() ([]byte, error)</td>\n</tr>\n<tr>\n<td>TstSetCoinbaseMaturity(maturity uint16)</td>\n</tr>\n<tr>\n<td>thresholdStates(nodes []*blockNode, checker thresholdConditionChecker, cache *thresholdStateCache) ([]ThresholdState, error)</td>\n</tr>\n<tr>\n<td>ThresholdStates(deploymentID uint32) ([]ThresholdState, error)</td>\n</tr>\n<tr>\n<td>IsDeploymentActive(deploymentID uint32) (bool, error)</td>\n</tr>\n<tr>\n<td>deploymentStates(prevNodes []*blockNode, deploymentID uint32) ([]ThresholdState, error)</td>\n</tr>\n<tr>\n<td>initThresholdCaches() error</td>\n</tr>\n<tr>\n<td>blockExists(hash *chainhash.Hash) (bool, error)</td>\n</tr>\n<tr>\n<td>processOrphans(flags BehaviorFlags) (bool, error)</td>\n</tr>\n<tr>\n<td>ProcessBlock(block *soterutil.Block, flags BehaviorFlags) (bool, bool, error)</td>\n</tr>\n<tr>\n<td>maybeAcceptBlock(block *soterutil.Block, flags BehaviorFlags) (bool, error)</td>\n</tr>\n</tbody></table>\n<h4 id=\"dagview\"><a href=\"#dagview\" class=\"headerlink\" title=\"dagview\"></a>dagview</h4><table>\n<thead>\n<tr>\n<th>genesis() *blockNode</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Genesis() *blockNode</td>\n</tr>\n<tr>\n<td>tips() []*blockNode</td>\n</tr>\n<tr>\n<td>Tips() []*blockNode</td>\n</tr>\n<tr>\n<td>addTip(node *blockNode)</td>\n</tr>\n<tr>\n<td>AddTip(node *blockNode)</td>\n</tr>\n<tr>\n<td>checkAndAddNode(height int32, node *blockNode) bool</td>\n</tr>\n<tr>\n<td>removeTip(node *blockNode)</td>\n</tr>\n<tr>\n<td>RemoveTip(node *blockNode)</td>\n</tr>\n<tr>\n<td>containsAtHeight(height int32, node *blockNode) bool</td>\n</tr>\n<tr>\n<td>height() int32</td>\n</tr>\n<tr>\n<td>Height() int32</td>\n</tr>\n<tr>\n<td>nodesByHeight(height int32) []*blockNode</td>\n</tr>\n<tr>\n<td>NodesByHeight(height int32) []*blockNode</td>\n</tr>\n<tr>\n<td>virtualHash() *chainhash.Hash</td>\n</tr>\n<tr>\n<td>count() int</td>\n</tr>\n<tr>\n<td>Equals(other *dagView) bool</td>\n</tr>\n<tr>\n<td>contains(node *blockNode) bool</td>\n</tr>\n<tr>\n<td>Contains(node *blockNode) bool</td>\n</tr>\n<tr>\n<td>next(node *blockNode) *blockNode</td>\n</tr>\n<tr>\n<td>Next(node *blockNode) *blockNode</td>\n</tr>\n<tr>\n<td>blockLocator(node *blockNode) BlockLocator</td>\n</tr>\n<tr>\n<td>BlockLocator(node *blockNode) BlockLocator</td>\n</tr>\n</tbody></table>\n<h3 id=\"SPECTRE-共识协议\"><a href=\"#SPECTRE-共识协议\" class=\"headerlink\" title=\"SPECTRE 共识协议\"></a>SPECTRE 共识协议</h3><p>核心思想：<strong>丢弃主链概念，所有产生的区块共同构成账本，不丢弃任何一个区块，同时维护一个无冲突交易集合。</strong><br>只要是产生的区块就不会被丢弃，所有的区块都是有效的，所有区块共同组成账本，这样进一步提高了区块链的处理交易能力，<strong>该设计的关键在于设计算法来保证区块链不会被恶意攻击成功。</strong></p>\n<h4 id=\"如何产生区块\"><a href=\"#如何产生区块\" class=\"headerlink\" title=\"如何产生区块\"></a>如何产生区块</h4><p><strong>SPECTRE 协议中，当产生区块时，要从之前所有分叉的末端区块（入度为零,又称 tip）中挑选大于等于 2 个父块 hash 作为引用。</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// blockNode represents a block within the DAG</span><br><span class=\"hljs-keyword\">type</span> blockNode <span class=\"hljs-keyword\">struct</span> &#123;<br>\t<span class=\"hljs-comment\">// <span class=\"hljs-doctag\">NOTE:</span> Additions, deletions, or modifications to the order of the</span><br>\t<span class=\"hljs-comment\">// definitions in this struct should not be changed without considering</span><br>\t<span class=\"hljs-comment\">// how it affects alignment on 64-bit platforms.  The current order is</span><br>\t<span class=\"hljs-comment\">// specifically crafted to result in minimal padding.  There will be</span><br>\t<span class=\"hljs-comment\">// hundreds of thousands of these in memory, so a few extra bytes of</span><br>\t<span class=\"hljs-comment\">// padding adds up.</span><br><br>\t<span class=\"hljs-comment\">// parents are the parent block for this node.</span><br>\tparents []*blockNode<br><br>\t<span class=\"hljs-comment\">// parent metadata like version and extra data</span><br>\tparentMetadata []*parentInfo<br><br>\tparentVersion <span class=\"hljs-keyword\">int32</span><br><br>\t<span class=\"hljs-comment\">// hash is the double sha 256 of the block.</span><br>\thash chainhash.Hash<br><br>\t<span class=\"hljs-comment\">// workSum is the total amount of work in the chain up to and including</span><br>\t<span class=\"hljs-comment\">// this node.</span><br>\tworkSum *big.Int<br><br>\t<span class=\"hljs-comment\">// height is parentsMaxHeight + 1</span><br>\theight <span class=\"hljs-keyword\">int32</span><br><br>\t<span class=\"hljs-comment\">// Some fields from block headers to</span><br>\t<span class=\"hljs-comment\">// reconstruct headers from memory.  These must be treated as</span><br>\t<span class=\"hljs-comment\">// immutable and are intentionally ordered to avoid padding on 64-bit</span><br>\t<span class=\"hljs-comment\">// platforms.</span><br>\tversion    <span class=\"hljs-keyword\">int32</span><br>\tbits       <span class=\"hljs-keyword\">uint32</span><br>\tnonce      <span class=\"hljs-keyword\">uint32</span><br>\ttimestamp  <span class=\"hljs-keyword\">int64</span><br>\tmerkleRoot chainhash.Hash<br><br>&#125;<br><br><span class=\"hljs-keyword\">type</span> parentInfo <span class=\"hljs-keyword\">struct</span> &#123;<br>\thash chainhash.Hash<br>\tdata [<span class=\"hljs-number\">32</span>]<span class=\"hljs-keyword\">byte</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>当有新区块产生时，节点要立刻将新区块(包含基于哪些区块产生这一信息)发送给与自己相连接的节点。</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> DAGState <span class=\"hljs-keyword\">struct</span> &#123;<br>\tTips      []chainhash.Hash <span class=\"hljs-comment\">// Hash of the tip blocks</span><br>\tHash      chainhash.Hash <span class=\"hljs-comment\">//Hash of the tip hashes</span><br>\tMinHeight <span class=\"hljs-keyword\">int32</span><br>\tMaxHeight <span class=\"hljs-keyword\">int32</span><br>\tBlkCount  <span class=\"hljs-keyword\">uint32</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1616914229993-778efd1e-9f02-4746-b4e6-3891fd1f7c82.png#height=303&id=MOTgK&name=image.png&originHeight=362&originWidth=848&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=243838&status=done&style=none&title=&width=710\" alt=\"image.png\"><br>该协议下，挖矿节点只<strong>负责迅速挖区块</strong>(能够达到 1 秒一个区块)，而对分叉中可能包含的冲突交易在挖矿阶段并<strong>不做任何处理</strong>，将记录交易速度最大化，让 DAG 这种区块链有着恐怖的处理交易能力。</p>\n<h4 id=\"冲突解决\"><a href=\"#冲突解决\" class=\"headerlink\" title=\"冲突解决\"></a>冲突解决</h4><p>SPECTRE 的思路是设计一个计算投票的算法，让诚实区块会投票给诚实的区块，后边的诚实区块会给前边的<strong>堆叠算力</strong>，从而让恶意攻击失败，其安全算力也是<strong>51%**。<br>**算法是：</strong><br>对指定的块 z，考虑其对其他的块 x,y 的投票过程。<br>(1) 如果 z 的先行块是 x 不是 y，那么它将投票给 x。<br>(2) 如果 z 的先行块既是 x 也是 y，投票将取决于与 z 的可达块相同的虚拟块进行递归投票的结果。<br>(3) 如果 z 的先行块既不是 x 也不是 y，投票将取决于以 z 为先行块的大多数块的投票。<br>(4) 如果 z 是一个可以到达整个 DAG 的虚拟块，它将遵从 DAG 的大多数块来决定投票结果。<br>(5) 如果 z=x 或者 z=y，只要 x 与 y 之间互相不可达，它将投票给自己。<br>拿双花举例，下图中，X 和 Y 区块中包含着两条冲突交易会导致双花，此时 DAG 中的区块会对 X 和 Y 进行投票，<strong>决定哪一个交易有效。</strong><br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1616918388824-cb331dd8-b883-4bff-ad05-700b10a64f28.png#height=330&id=SE4Hx&name=image.png&originHeight=447&originWidth=823&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=213757&status=done&style=none&title=&width=608\" alt=\"image.png\">  <br>投票规则如下，投 X 的标蓝，投 Y 的标红，X&lt;Y 代表 X 先于 Y：</p>\n<ul>\n<li>X 后边的，<strong>只能到 X 的投 X</strong>，图中 6、7、8 投 X，同理 9、10、11 投 Y。</li>\n<li>X 后边的，<strong>能到 X 也能到 Y</strong>，根据上一次(图中虚线圈内)的投票结果投，12 投 X。</li>\n<li>不在 X、Y 后边的，<strong>根据自己后边所有的区块投哪个票多的投</strong>，1-5 区块投 X</li>\n<li>X、Y 投自己</li>\n</ul>\n<p>根据投票结果，X 中的那条交易信息<strong>有效</strong>，Y 中对应的那条交易信息<strong>无效</strong>。</p>\n<h4 id=\"可信交易集合\"><a href=\"#可信交易集合\" class=\"headerlink\" title=\"可信交易集合\"></a>可信交易集合</h4><p><strong>SPECTRE 可信交易集就相当于超过当前 6 个区块的比特币链里组成的交易集合。</strong><br>区块链从数字加密货币的角度来说，就是一个<strong>账本</strong>，从账本上的交易信息中得出每个<strong>账户</strong>所拥有的货币，所以，得出<strong>确定的、不可能更改</strong>的交易信息就至关重要，SPECTRE 可信交易集产生过程如下：</p>\n<ul>\n<li>遍历区块，依次提取交易信息，<strong>无冲突交易</strong>加入无冲突交易集。</li>\n<li>将<strong>导致账户余额不足的冲突交易</strong>加入冲突交易集。对应时空数据即相同时间的用户</li>\n<li>根据上边的投票算法，依次对冲突交易进行<strong>投票</strong>，产生冲突区块顺序集，决定哪一条交易有效。</li>\n<li>将投票<strong>有效</strong>的交易加入<strong>无冲突交易集</strong>。</li>\n<li>将无冲突交易集中超过一定时间的交易组建可信交易集，即该交易池交易信息<strong>基本不可能被篡改</strong>。</li>\n</ul>\n<p><strong>SPECTRE 并不会对所有区块进行排序，所有区块没有一个完整的线形顺序，有的只是决定冲突信息先后的区块顺序对。</strong></p>\n<p><strong>比特币中的高度</strong>代表的就是<strong>线形顺序</strong>，高度低的区块中交易信息<strong>先于</strong>高度高的区块里的信息，高度高的区块就不能<strong>包含和高度低的区块冲突的交易</strong>，而<strong>SPECTRE 有大量的分叉</strong>，区块高度不能代表线形顺序，前边的区块交易信息不一定先于后边的分叉区块交易信息，交易信息的<strong>有效性要由投票算法</strong>来决定。<br>区块投票算法很快，再加上它将<strong>所有分叉区块</strong>都包含进来，也就没有了比特币所面临的<strong>分叉风险</strong>(等待 6 个区块)，交易确认时间可以达到 10 秒。（我认为，一次投票的时间肯定低于 10s（即使它遍历了所有块），因此，只要投票成功，交易就被确认，因此效率非常高！）</p>\n<h3 id=\"DAG-区块链通信机制\"><a href=\"#DAG-区块链通信机制\" class=\"headerlink\" title=\"DAG 区块链通信机制\"></a>DAG 区块链通信机制</h3><h4 id=\"P2P-对等网络\"><a href=\"#P2P-对等网络\" class=\"headerlink\" title=\"P2P 对等网络\"></a>P2P 对等网络</h4><p>见书 19 页</p>\n<blockquote>\n<p>似乎应该放到前置知识？</p>\n</blockquote>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1617414711574-3c923c62-e148-45bc-874e-6da4cafcfd0a.png#height=278&id=f71iF&name=image.png&originHeight=555&originWidth=972&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=192050&status=done&style=none&title=&width=486\" alt=\"image.png\"><br>其他图详见：<a href=\"https://github.com/Blockchain-CN/blockchain\">https://github.com/Blockchain-CN/blockchain</a></p>\n<h4 id=\"网络结构及特性\"><a href=\"#网络结构及特性\" class=\"headerlink\" title=\"网络结构及特性\"></a>网络结构及特性</h4><p>从底层网络的角度来看，本作品的核心是基于 Gossip 协议的交易传播。这种机制意味着只要数据具有足够的权重，就能快速传播到整个网络中去。作品中的时空数据发布分五步完成：</p>\n<ul>\n<li>金字塔编码：通过多级金字塔编码，将时空数据划分进入多个层次，提高时空数据的细粒度；</li>\n<li>加入 Bloom 过滤器：将编码后的数据放入 Bloom 过滤器，并使用同态加密将 Bloom 数组进行加密处理；</li>\n<li>签名：采用自身私钥对加密结果进行签名；</li>\n<li>Tip 选择：采用马尔科夫链蒙特卡洛（MCMC）算法随机挑选 50 个未确认的交易并将它们打包进入区块；</li>\n<li>工作量证明（Proof of Work）：只是用于限制出块速率，防止网络堵塞。<blockquote>\n<p>见 p28</p>\n</blockquote>\n</li>\n</ul>\n<p>注意：比特币中，如果我想转账一笔 BTC，我会发出一个交易，并广播给周围的节点，周围节点验证后，继续广播，最后被矿工收到，打包进入区块，并把区块广播出来，同样的传遍整个网络，交易生效。</p>\n<p>而且通过比特币钱包，可以做到每次交易都更换地址，即生成不同的公钥私钥对，然后都指向同一个账户，这样可以避免被追踪。</p>\n<h4 id=\"掩码认证消息\"><a href=\"#掩码认证消息\" class=\"headerlink\" title=\"掩码认证消息\"></a>掩码认证消息</h4><p>由于本作品的数据发布是通过没有手续费的交易，因此可以在分布式账本中自由的发送消息，该消息可以占据交易中的字段，而普通交易中该字段是被发送者的签名所占据。默认情况下，这些消息对任何人都是可见的。而本项目采用掩码认证消息（MAM）加密消息，提供基于哈希的签名认证和完整性验证。</p>\n<h5 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h5><p>MAM 是一个附加的数据传输协议，在 DAG 上增加了发送和接受加密数据流的功能，且对设备的大小和成本没有限制。鉴于这些特性，MAM 满足了行业重要的需求，及完整性和私密性。用户可以在任意时间发布</p>\n<blockquote>\n<p>见 p29</p>\n</blockquote>\n<h1 id=\"写本子能用到的图\"><a href=\"#写本子能用到的图\" class=\"headerlink\" title=\"写本子能用到的图\"></a>写本子能用到的图</h1><p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1617440689986-4ebfa454-4b06-4fdc-99d3-c5b84c27c0db.png#height=320&id=Yqb4B&name=image.png&originHeight=639&originWidth=989&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=90760&status=done&style=none&title=&width=494.5\" alt=\"image.png\"><br>见：<a href=\"https://ledger.jd.com/architecturedesign.html\">https://ledger.jd.com/architecturedesign.html</a></p>\n<h1 id=\"存储层\"><a href=\"#存储层\" class=\"headerlink\" title=\"存储层\"></a>存储层</h1><p>【1】trillian/google<br><a href=\"https://www.jianshu.com/p/61e432d121f9\">https://www.jianshu.com/p/61e432d121f9</a><br><a href=\"https://blog.csdn.net/mutourend/article/details/113365448\">https://blog.csdn.net/mutourend/article/details/113365448</a><br><a href=\"https://my.oschina.net/u/3843525/blog/3175914\">https://my.oschina.net/u/3843525/blog/3175914</a><br>项目地址：<a href=\"https://github.com/google/trillian\">https://github.com/google/trillian</a><br>应用示例：<a href=\"https://github.com/google/trillian-examples\">https://github.com/google/trillian-examples</a><br>【2】<a href=\"https://github.com/vldmkr/merkle-patricia-trie\">https://github.com/vldmkr/merkle-patricia-trie</a> 这个接口非常干净简洁，竟然没人点 star</p>\n<p>这里有两篇解释性文档。提到了这些问题（未给出解决）：<br><a href=\"https://www.tangshuang.net/4097.html\">区块链中，交易被如何打包进区块</a></p>\n<ol>\n<li>在打包开始之前，这些交易记录是以什么方式存在于网络？</li>\n<li>打包是否会把所有交易记录打包进区块？怎么可能保证所有交易都不被遗漏？</li>\n<li>如何防止矿工伪造交易？将伪造的交易打包进区块？</li>\n</ol>\n<p><a href=\"https://www.tangshuang.net/4117.html\">区块链如何运用 merkle tree 验证交易真实性</a></p>\n<ul>\n<li>怎么从区块链里面查一个交易？</li>\n<li>怎么获取 merkle 验证路径？</li>\n<li>怎么确保网络上这个返回的验证路径不是伪造的？</li>\n</ul>\n<h1 id=\"激励层\"><a href=\"#激励层\" class=\"headerlink\" title=\"激励层\"></a>激励层</h1><p>为了能够把挖矿过程讲清楚，我们只拿比特币遵循的 PoW 来进行演示。</p>\n<blockquote>\n<p>SHA256(SHA256(version + prevHash + merkleRoot + time + currentDifficulty + nonce )) &lt; TARGET</p>\n</blockquote>\n<p>矿机执行上面公式，只要满足上面这个公式（执行结果为真），就算挖到矿。现在对这个公式进行解释。</p>\n<ol>\n<li>矿机会做一个 double sha256 的运算，运算的参数其实全部是块头里面的信息，但是因为这个时候区块还没有生成，所以这些信息是暂时保存的，如果抢到记账权，就把这些信息记录进去，因此，当你觉得一个区块的 hash 是否是作弊算出来的时候，用区块头里面的信息自己去算一遍，看看是不是能得到相同的 hash 就可以了，从一点上讲，挖矿也是不能作弊的，必须老老实实不停算</li>\n<li>version 是当前运行矿机的客户端软件版本，每次版本升级，可能对一些参数会有影响，比如区块大小从 1M 扩容到 2M，但是对于挖矿算法而言是不变的</li>\n<li>prevHash 是前一个区块的 hash 值</li>\n<li>merkleRoot 是当前矿机内存里暂存的交易的 merkle 算法得到的根 hash，merkle 会在下文讲</li>\n<li>time 是当前时间戳</li>\n<li>currentDifficulty 是当前难度，这个当前难度是由一个公式算出来的，这个公式是 <code>currentDifficulty = diff_1_target/TARGET</code> 这个公式里面的 diff_1_target 可以认为是一个常量，在比特币客户端里面是不变的，值为 0x1d00ffff。当然，其实它也有可能变，但怎么变都差不多这个值，我们还是把它当作常量。而 TARGET 我们在下面会讲到。</li>\n<li>nonce 是一个正整数，nonce 的值就算矿机要找的值。当矿机开始执行 double sha256 算法时，nonce 为 0，如果执行完一次，无法满足上面那个公式，那么 nonce 就自加 1，再执行一遍算法，如果不满足公式，继续加 1 再执行，就是这样一直加上去，直到找到一个 nonce 满足上面的公式，就算挖到矿。所以，这个 nonce 每一次挖矿都可能不一样，它是完全随机出现的，到底是多少完全看运气。但不管怎样，你看每个区块里面但 nonce 值，就知道矿机做了多少次运算，也就知道挖到矿有多难了。</li>\n<li>TARGET 是用以对比的目标值，它是一个特定值，比特币的发明者希望 10 分钟产生一个区块，所以最初设计的 TARGET 就是为了让 currentDifficulty 能够到一个合适的值，保证 10 分钟一个块。但是实际情况并不可能保证 10 分钟一定出一个块，如果算力下降，时间就会加长，这时就应该调整一下难度，使出块时间尽可能恢复在 10 分钟左右。所以 2016 个区块（2 周）TARGET 就会调整一次，而如果真实的情况是产生 2016 个区块的时间超过 2 周，那么 TARGET 就会适当增加，从而使 currentDifficulty 减小，下面 2016 个区块的难度就会降低一些。相反，则提高难度。这个调整算法本文就不展开了。所以 TARGET 是一个 2016 次不变，但总体而言一直在变的值，它的目标就是让产生一个区块的时间大概在 10 分钟左右。</li>\n</ol>\n","more":"<h1 id=\"从零开始\"><a href=\"#从零开始\" class=\"headerlink\" title=\"从零开始\"></a>从零开始</h1><p>【1】<a href=\"https://github.com/omnigeeker/golang_blockchain_demo/tree/master/blockchain\">https://github.com/omnigeeker/golang_blockchain_demo/tree/master/blockchain</a><br>这是第一个，当然，我还找到好几个不错的，都 star 了。<br>下载之后，需要放置到 GOPATH 的 src 目录下面，然后开始跑。</p>\n<p>注意，定义端口的文件叫<code>.env</code>，需要放在这里，当时报错报的我都懵了。<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1616903705092-eb040ef2-e211-434c-a2c1-27e75c9667d7.png#height=166&id=kcgh9&name=image.png&originHeight=332&originWidth=357&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=13594&status=done&style=none&title=&width=178.5\" alt=\"image.png\"><br>然后，运行起来是这样的。<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1616903978333-917b06c4-fb2e-4897-a825-07ff5a7e26af.png#height=142&id=CcaX0&name=image.png&originHeight=283&originWidth=895&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=32187&status=done&style=none&title=&width=447.5\" alt=\"image.png\"><br>原文中说，可以发送一个 post 请求用来创建新的块，我试了一下，postman 不能用插件了，postwoman 无法调试本地地址？然后 curl 命令也是可以的，参考<a href=\"https://www.jianshu.com/p/9bd018253bed\">https://www.jianshu.com/p/9bd018253bed</a>，然后另外一个插件<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1616904095287-f81eed6a-fc08-4ec7-9ded-74a9ccdd23c3.png#height=148&id=oXKMq&name=image.png&originHeight=295&originWidth=806&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=32785&status=done&style=none&title=&width=403\" alt=\"image.png\"><br>也不错。<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1616904175832-884b4446-3c1f-4df5-bca4-cdf3e9bcaaea.png#height=341&id=o3BPd&name=image.png&originHeight=682&originWidth=908&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=56987&status=done&style=none&title=&width=454\" alt=\"image.png\"><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1616904253263-b87ff0fb-9ff2-4196-86c2-d5a434559bcd.png#height=330&id=G3ELB&name=image.png&originHeight=659&originWidth=892&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=62473&status=done&style=none&title=&width=446\" alt=\"image.png\"><br>完美。<br>当我们访问<a href=\"http://localhost:8000/\">http://localhost:8000/</a>，可以看到：<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1616904286585-4e03e1f1-4e49-41f1-96c8-272fa2397ceb.png#height=226&id=PNpA5&name=image.png&originHeight=451&originWidth=703&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=23406&status=done&style=none&title=&width=351.5\" alt=\"image.png\"></p>\n<h1 id=\"搭建-block-DAG\"><a href=\"#搭建-block-DAG\" class=\"headerlink\" title=\"搭建 block-DAG\"></a>搭建 block-DAG</h1><p>网上这部分资料很少，只找到一个<a href=\"https://github.com/soteria-dag/soterd/tree/master/blockdag\">https://github.com/soteria-dag/soterd/tree/master/blockdag</a>，还不确定可不可以利用，加油。<br>然后还有一个 python 版的<a href=\"https://github.com/AvivYaish/PHANTOM/tree/master/phantom\">https://github.com/AvivYaish/PHANTOM/tree/master/phantom</a>，里面貌似实现了一个小型的 DAG 区块链，但是感觉写的代码好少，不确定能不能用。</p>\n<h2 id=\"根据-soteria-dag-搭建\"><a href=\"#根据-soteria-dag-搭建\" class=\"headerlink\" title=\"根据 soteria-dag 搭建\"></a>根据 soteria-dag 搭建</h2><p>本模块除了搭建步骤记录，还包括，数据结构记录，类方法记录，调用关系记录，以及 DAG 前置知识。</p>\n<h3 id=\"为什么用-BLOCK-DAG\"><a href=\"#为什么用-BLOCK-DAG\" class=\"headerlink\" title=\"为什么用 BLOCK-DAG\"></a>为什么用 BLOCK-DAG</h3><p>BlockDAG 提供了比特币设计的主要功能，包括（1）分散化；您可以在没有中间人的情况下将货币转移给其他人。（2）某种程度的匿名性；货币与你的真实身份没有直接联系。（3）无信任共识；区块链实施的规则允许您对陌生人所做的区块验证工作有一定程度的信任，并使更改区块和交易变得困难。<br>另外，还提供了：</p>\n<ul>\n<li>提高了事务吞吐量；</li>\n<li>允许使用工作证明系统，提高区块开采的可访问性和公平性。</li>\n<li>加密事务负载</li>\n<li>可扩展性</li>\n<li>轻巧</li>\n<li>量子安全（使用三元或平衡三元计算，而不是经典计算机执行的标准二进制计算</li>\n</ul>\n<h3 id=\"DAG-Vs-Bitchain\"><a href=\"#DAG-Vs-Bitchain\" class=\"headerlink\" title=\"DAG Vs Bitchain\"></a>DAG Vs Bitchain</h3><ol>\n<li>单链技术存在的几个问题</li>\n</ol>\n<p>效率问题：传统区块链技术基于区块，比特币的效率较低，每十分钟出一个块，6 个出块确认需要一个小时，整个网络同时只能有一条单链，基于 PoW 共识机制出块无法并发执行。<br>确定性问题：比特币和以太坊存在 51%算力攻击问题，基于 PoW 共识的最大问题就是没有一个确定的不可更改的最终状态；如果某群体控制 51%算力，并发起攻击，比特币体系会崩溃。<br>中心化问题：基于区块的 PoW 共识中，矿工一方面可以形成集中化的矿场集团，一方面，获得打包交易权的矿工拥有巨大权力，可以选择那些交易进入区块，哪些交易不被处理，这样的风险目前已经是事实存在。<br>能耗问题：由于传统区块链基于 PoW 算力工作量证明，达成共识机制，比特币的挖矿能耗已经和阿根廷整个国家的耗电量持平。<br>2.DAG 区块链的优势和价值<br>a.传统区块链需要矿工完成工作量证明（PoW)来执行每一笔交易，而 DAG 区块链能摆脱这样的限制。<br>b.在 DAG 系统中，交易指令能极快的扩散通知至全网，大部分双重支付的攻击尝试将会被系统捕捉到并立即拒绝执行。</p>\n<p>二者区块结构示意图对比：<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1616908860946-be7368d2-b3fa-4cd9-9b7d-8a3899e04937.png#height=224&id=zQyhh&name=image.png&originHeight=448&originWidth=645&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=15493&status=done&style=shadow&title=&width=322.5\" alt=\"image.png\"><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1616908870524-9b40f2d6-0c7c-4bbe-b54d-510dcc608329.png#height=220&id=cnjIc&name=image.png&originHeight=439&originWidth=654&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=17168&status=done&style=shadow&title=&width=327\" alt=\"image.png\"><br>其中<code>parent sub-header</code>包括：</p>\n<ul>\n<li>Version - A value that could be used to trigger different block evaluation rules</li>\n<li>Parents count - The number of parents this block has</li>\n<li>Parents - A list of parents</li>\n</ul>\n<h3 id=\"BLOCK-DAG-整体结构\"><a href=\"#BLOCK-DAG-整体结构\" class=\"headerlink\" title=\"BLOCK-DAG 整体结构\"></a>BLOCK-DAG 整体结构</h3><p>区块链系统架构分别由数据层、网络层、共识层、激励层、合约层和应用层组成。<br>此处需要一个 DAG 区块链的架构图，类似于传统区块链的架构图–共识层，激励层什么的</p>\n<ul>\n<li>创世区块：高度为 0 的 genesis 块（它没有父块，同一高度/代上没有其他块）</li>\n<li>一个或多个区块连接到 genesis 区块（高度 1）</li>\n<li>连接到这些块的一个或多个块</li>\n</ul>\n<p>拓扑结构如下：<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1616912721520-33ef9da2-c62d-4d5a-97c2-99077a0b7d1b.png#height=184&id=KiuBx&name=image.png&originHeight=367&originWidth=685&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=62156&status=done&style=none&title=&width=342.5\" alt=\"image.png\"></p>\n<blockquote>\n<p>由 Yonatan Sompolinsky 提出，新产生的区块指向所有已知的分叉末端区块，即一个区块有多个父亲，此时<strong>区块链就从一条链变为多条分叉链共同组成的的结构。</strong></p>\n</blockquote>\n<p>这就形成了一个远离创世纪区块的区块结构，每个世代/高度都有一组区块远离创世纪区块。区块之间的连接不像区块链那样严格；您可以有多个父级，并且父级的高度不同（在一个上限内）。<br>没有任何块与之连接的块集称为 DAG 的“tips”。当挖掘新块时，这些块用作父块，当节点彼此同步时，这些块也被引用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> BlockDAG <span class=\"hljs-keyword\">struct</span> &#123;<br>\t<span class=\"hljs-comment\">// The following fields are set when the instance is created and can&#x27;t</span><br>\t<span class=\"hljs-comment\">// be changed afterwards, so there is no need to protect them with a</span><br>\t<span class=\"hljs-comment\">// separate mutex.</span><br>\t<span class=\"hljs-comment\">//checkpoints         []chaincfg.Checkpoint</span><br>\t<span class=\"hljs-comment\">//checkpointsByHeight map[int32]*chaincfg.Checkpoint</span><br>\tdb           database.DB<br>\tchainParams  *chaincfg.Params<br>\ttimeSource   MedianTimeSource<br>\tsigCache     *txscript.SigCache<br>\tindexManager IndexManager<br>\thashCache    *txscript.HashCache<br><br>\t<span class=\"hljs-comment\">// The following fields are calculated based upon the provided chain</span><br>\t<span class=\"hljs-comment\">// parameters.  They are also set when the instance is created and</span><br>\t<span class=\"hljs-comment\">// can&#x27;t be changed afterwards, so there is no need to protect them with</span><br>\t<span class=\"hljs-comment\">// a separate mutex.</span><br>\tminRetargetTimespan <span class=\"hljs-keyword\">int64</span> <span class=\"hljs-comment\">// target timespan / adjustment factor</span><br>\tmaxRetargetTimespan <span class=\"hljs-keyword\">int64</span> <span class=\"hljs-comment\">// target timespan * adjustment factor</span><br>\tblocksPerRetarget   <span class=\"hljs-keyword\">int64</span> <span class=\"hljs-comment\">// target timespan / target time per block</span><br><br>\t<span class=\"hljs-comment\">// chainLock protects concurrent access to the vast majority of the</span><br>\t<span class=\"hljs-comment\">// fields in this struct below this point.</span><br>\tchainLock sync.RWMutex<br><br>\t<span class=\"hljs-comment\">// These fields are related to the memory block index.  They both have</span><br>\t<span class=\"hljs-comment\">// their own locks, however they are often also protected by the chain</span><br>\t<span class=\"hljs-comment\">// lock to help prevent logic races when blocks are being processed.</span><br>\t<span class=\"hljs-comment\">//</span><br>\t<span class=\"hljs-comment\">// index houses the entire block index in memory.</span><br>\tindex             *blockIndex<br>\tdView             *dagView<br>\tgraph             *phantom.Graph<br>\tblueSet           *phantom.BlueSetCache<br>\tnodeOrder         []*chainhash.Hash<br>\torderCache        *phantom.OrderCache<br><br><br>\t<span class=\"hljs-comment\">// These fields are related to checkpoint handling.  They are protected</span><br>\t<span class=\"hljs-comment\">// by the chain lock.</span><br>\t<span class=\"hljs-comment\">//nextCheckpoint *chaincfg.Checkpoint</span><br>\t<span class=\"hljs-comment\">//checkpointNode *blockNode</span><br><br>\t<span class=\"hljs-comment\">// The state is used as a fairly efficient way to cache information</span><br>\t<span class=\"hljs-comment\">// about the current best chain state that is returned to callers when</span><br>\t<span class=\"hljs-comment\">// requested.  It operates on the principle of MVCC such that any time a</span><br>\t<span class=\"hljs-comment\">// new block becomes the best block, the state pointer is replaced with</span><br>\t<span class=\"hljs-comment\">// a new struct and the old state is left untouched.  In this way,</span><br>\t<span class=\"hljs-comment\">// multiple callers can be pointing to different best chain states.</span><br>\t<span class=\"hljs-comment\">// This is acceptable for most callers because the state is only being</span><br>\t<span class=\"hljs-comment\">// queried at a specific point in time.</span><br>\t<span class=\"hljs-comment\">//</span><br>\t<span class=\"hljs-comment\">// In addition, some of the fields are stored in the database so the</span><br>\t<span class=\"hljs-comment\">// chain state can be quickly reconstructed on load.</span><br>\tstateLock     sync.RWMutex<br>\tstateSnapshot *BestState<br>\tdagSnapshot   *DAGState<br><br>\t<span class=\"hljs-comment\">// The following caches are used to efficiently keep track of the</span><br>\t<span class=\"hljs-comment\">// current deployment threshold state of each rule change deployment.</span><br>\t<span class=\"hljs-comment\">//</span><br>\t<span class=\"hljs-comment\">// This information is stored in the database so it can be quickly</span><br>\t<span class=\"hljs-comment\">// reconstructed on load.</span><br>\t<span class=\"hljs-comment\">//</span><br>\t<span class=\"hljs-comment\">// warningCaches caches the current deployment threshold state for blocks</span><br>\t<span class=\"hljs-comment\">// in each of the **possible** deployments.  This is used in order to</span><br>\t<span class=\"hljs-comment\">// detect when new unrecognized rule changes are being voted on and/or</span><br>\t<span class=\"hljs-comment\">// have been activated such as will be the case when older versions of</span><br>\t<span class=\"hljs-comment\">// the software are being used</span><br>\t<span class=\"hljs-comment\">//</span><br>\t<span class=\"hljs-comment\">// deploymentCaches caches the current deployment threshold state for</span><br>\t<span class=\"hljs-comment\">// blocks in each of the actively defined deployments.</span><br>\twarningCaches    []thresholdStateCache<br>\tdeploymentCaches []thresholdStateCache<br><br>\t<span class=\"hljs-comment\">// The following fields are used to determine if certain warnings have</span><br>\t<span class=\"hljs-comment\">// already been shown.</span><br>\t<span class=\"hljs-comment\">//</span><br>\t<span class=\"hljs-comment\">// unknownRulesWarned refers to warnings due to unknown rules being</span><br>\t<span class=\"hljs-comment\">// activated.</span><br>\t<span class=\"hljs-comment\">//</span><br>\t<span class=\"hljs-comment\">// unknownVersionsWarned refers to warnings due to unknown versions</span><br>\t<span class=\"hljs-comment\">// being mined.</span><br>\tunknownRulesWarned    <span class=\"hljs-keyword\">bool</span><br>\tunknownVersionsWarned <span class=\"hljs-keyword\">bool</span><br><br>\t<span class=\"hljs-comment\">// The notifications field stores a slice of callbacks to be executed on</span><br>\t<span class=\"hljs-comment\">// certain blockchain events.</span><br>\tnotificationsLock sync.RWMutex<br>\tnotifications     []NotificationCallback<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>并且使用“链视图”来存储链状态，</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// chainView provides a flat view of a specific branch of the block chain from</span><br><span class=\"hljs-comment\">// its tip back to the genesis block and provides various convenience functions</span><br><span class=\"hljs-comment\">// for comparing chains.</span><br><span class=\"hljs-comment\">//</span><br><span class=\"hljs-comment\">// For example, assume a block chain with a side chain as depicted below:</span><br><span class=\"hljs-comment\">//   genesis -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4  -&gt; 5 -&gt;  6  -&gt; 7  -&gt; 8</span><br><span class=\"hljs-comment\">//                         \\-&gt; 4a -&gt; 5a -&gt; 6a</span><br><span class=\"hljs-comment\">//</span><br><span class=\"hljs-comment\">// The chain view for the branch ending in 6a consists of:</span><br><span class=\"hljs-comment\">//   genesis -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4a -&gt; 5a -&gt; 6a</span><br><span class=\"hljs-keyword\">type</span> dagView <span class=\"hljs-keyword\">struct</span> &#123;<br>\tmtx      sync.Mutex<br>\tdagTips  <span class=\"hljs-keyword\">map</span>[*blockNode]<span class=\"hljs-keyword\">struct</span>&#123;&#125;<br>\tnodes    [][]*blockNode<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"类方法\"><a href=\"#类方法\" class=\"headerlink\" title=\"类方法\"></a>类方法</h3><h4 id=\"BlockDAG\"><a href=\"#BlockDAG\" class=\"headerlink\" title=\"BlockDAG\"></a>BlockDAG</h4><p>Methods:</p>\n<table>\n<thead>\n<tr>\n<th>calcNextBlockVersion(prevNodes []*blockNode) (int32, error)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>calcNextParentVersion(prevNodes []*blockNode) (int32, error)</td>\n</tr>\n<tr>\n<td>CalcNextBlockVersion() (int32, error)</td>\n</tr>\n<tr>\n<td>CalcNextParentVersion() (int32, error)</td>\n</tr>\n<tr>\n<td>warnUnknownRuleActivations(nodes []*blockNode) error</td>\n</tr>\n<tr>\n<td>warnUnknownVersions(nodes []*blockNode) error</td>\n</tr>\n<tr>\n<td>calcEasiestDifficulty(bits uint32, duration time.Duration) uint32</td>\n</tr>\n<tr>\n<td>findPrevTestNetDifficulty(startNode *blockNode) uint32</td>\n</tr>\n<tr>\n<td>calcNextRequiredDifficulty(lastNode *blockNode, newBlockTime time.Time) (uint32, error)</td>\n</tr>\n<tr>\n<td>CalcNextRequiredDifficulty(timestamp time.Time) (uint32, error)</td>\n</tr>\n<tr>\n<td>TargetDifficulty(blockHeight int32) (*big.Int, error)</td>\n</tr>\n<tr>\n<td>FetchSpendJournal(targetBlock *soterutil.Block) ([]SpentTxOut, error)</td>\n</tr>\n<tr>\n<td>createChainState() error</td>\n</tr>\n<tr>\n<td>initChainState() error</td>\n</tr>\n<tr>\n<td>BlocksByHeight(blockHeight int32) ([]*soterutil.Block, error)</td>\n</tr>\n<tr>\n<td>BlockByHash(hash *chainhash.Hash) (*soterutil.Block, error)</td>\n</tr>\n<tr>\n<td>FetchUtxoView(tx *soterutil.Tx) (*UtxoViewpoint, error)</td>\n</tr>\n<tr>\n<td>FetchUtxoEntry(outpoint wire.OutPoint) (*UtxoEntry, error)</td>\n</tr>\n<tr>\n<td>visitOrphan(hash _chainhash.Hash, order _[]chainhash.Hash, tempMark *map[chainhash.Hash]int, done *map[chainhash.Hash]int) error</td>\n</tr>\n<tr>\n<td>HaveBlock(hash *chainhash.Hash) (bool, error)</td>\n</tr>\n<tr>\n<td>IsKnownOrphan(hash *chainhash.Hash) bool</td>\n</tr>\n<tr>\n<td>GetOrphanBlocks() []*soterutil.Block</td>\n</tr>\n<tr>\n<td>GetOrphanChildren(parent *chainhash.Hash) []*soterutil.Block</td>\n</tr>\n<tr>\n<td>GetOrphanLocator(hashes []chainhash.Hash) BlockLocator</td>\n</tr>\n<tr>\n<td>GetOrphanOrder() ([]chainhash.Hash, error)</td>\n</tr>\n<tr>\n<td>GetOrphanRoot(hash *chainhash.Hash) []chainhash.Hash</td>\n</tr>\n<tr>\n<td>GetOrphans() []*orphanBlock</td>\n</tr>\n<tr>\n<td>removeOrphanBlock(orphan *orphanBlock)</td>\n</tr>\n<tr>\n<td>addOrphanBlock(block *soterutil.Block)</td>\n</tr>\n<tr>\n<td>CalcSequenceLock(tx *soterutil.Tx, utxoView <em>UtxoViewpoint, mempool bool) (\\</em>SequenceLock, error)</td>\n</tr>\n<tr>\n<td>calcSequenceLock(nodes []*blockNode, tx *soterutil.Tx, utxoView *UtxoViewpoint, mempool bool) (*SequenceLock, error)</td>\n</tr>\n<tr>\n<td>getAllInputTxos(block *soterutil.Block, view *UtxoViewpoint) ([]SpentTxOut, error)</td>\n</tr>\n<tr>\n<td>connectBlock(node *blockNode, block <em>soterutil.Block, view \\</em>UtxoViewpoint, stxos []SpentTxOut) error</td>\n</tr>\n<tr>\n<td>connectBestChain(node *blockNode, block *soterutil.Block, flags BehaviorFlags) (bool, error)</td>\n</tr>\n<tr>\n<td>isCurrent() bool</td>\n</tr>\n<tr>\n<td>IsCurrent() bool</td>\n</tr>\n<tr>\n<td>BestSnapshot() *BestState</td>\n</tr>\n<tr>\n<td>DAGSnapshot() *DAGState</td>\n</tr>\n<tr>\n<td>DAGColoring() []*chainhash.Hash</td>\n</tr>\n<tr>\n<td>DAGOrdering() []*chainhash.Hash</td>\n</tr>\n<tr>\n<td>HeaderByHash(hash *chainhash.Hash) (wire.BlockHeader, error)</td>\n</tr>\n<tr>\n<td>MainChainHasBlock(hash *chainhash.Hash) bool</td>\n</tr>\n<tr>\n<td>BlockLocatorFromHash(hash *chainhash.Hash) BlockLocator</td>\n</tr>\n<tr>\n<td>BlockLocatorFromHeight(height int32) BlockLocator</td>\n</tr>\n<tr>\n<td>LatestBlockLocator() (BlockLocator, error)</td>\n</tr>\n<tr>\n<td>BlockHeightByHash(hash *chainhash.Hash) (int32, error)</td>\n</tr>\n<tr>\n<td>BlockHashesByHeight(blockHeight int32) ([]chainhash.Hash, error)</td>\n</tr>\n<tr>\n<td>HeightRange(startHeight int32, endHeight int32) ([]chainhash.Hash, error)</td>\n</tr>\n<tr>\n<td>HeightToHashRange(startHeight int32, endHash *chainhash.Hash, maxResults int) ([]chainhash.Hash, error)</td>\n</tr>\n<tr>\n<td>IntervalBlockHashes(endHash *chainhash.Hash, interval int) ([]chainhash.Hash, error)</td>\n</tr>\n<tr>\n<td>locateInventory(locator BlockLocator, hashStop *chainhash.Hash, maxEntries uint32) []*blockNode</td>\n</tr>\n<tr>\n<td>locateBlocks(locator BlockLocator, hashStop *chainhash.Hash, maxHashes uint32) []chainhash.Hash</td>\n</tr>\n<tr>\n<td>LocateBlocks(locator BlockLocator, hashStop *chainhash.Hash, maxHashes uint32) []chainhash.Hash</td>\n</tr>\n<tr>\n<td>locateHeaders(locator BlockLocator, hashStop *chainhash.Hash, maxHeaders uint32) []wire.BlockHeader</td>\n</tr>\n<tr>\n<td>LocateHeaders(locator BlockLocator, hashStop *chainhash.Hash) []wire.BlockHeader</td>\n</tr>\n<tr>\n<td>GetBlockDiff(subtips []*chainhash.Hash) []*chainhash.Hash</td>\n</tr>\n<tr>\n<td>Subscribe(callback NotificationCallback)</td>\n</tr>\n<tr>\n<td>sendNotification(typ NotificationType, data interface{})</td>\n</tr>\n<tr>\n<td>checkBlockHeaderContext(header *wire.BlockHeader, prevNodes []*blockNode, flags BehaviorFlags) error</td>\n</tr>\n<tr>\n<td>checkBlockContext(block *soterutil.Block, prevNodes []*blockNode, flags BehaviorFlags) error</td>\n</tr>\n<tr>\n<td>checkBIP0030(node *blockNode, block <em>soterutil.Block, view \\</em>UtxoViewpoint) error</td>\n</tr>\n<tr>\n<td>checkConnectBlock(node *blockNode, block *soterutil.Block, view _UtxoViewpoint, stxos _[]SpentTxOut) error</td>\n</tr>\n<tr>\n<td>CheckConnectBlockTemplate(block *soterutil.Block) error</td>\n</tr>\n<tr>\n<td>RenderDot() ([]byte, error)</td>\n</tr>\n<tr>\n<td>RenderSvg() ([]byte, error)</td>\n</tr>\n<tr>\n<td>TstSetCoinbaseMaturity(maturity uint16)</td>\n</tr>\n<tr>\n<td>thresholdStates(nodes []*blockNode, checker thresholdConditionChecker, cache *thresholdStateCache) ([]ThresholdState, error)</td>\n</tr>\n<tr>\n<td>ThresholdStates(deploymentID uint32) ([]ThresholdState, error)</td>\n</tr>\n<tr>\n<td>IsDeploymentActive(deploymentID uint32) (bool, error)</td>\n</tr>\n<tr>\n<td>deploymentStates(prevNodes []*blockNode, deploymentID uint32) ([]ThresholdState, error)</td>\n</tr>\n<tr>\n<td>initThresholdCaches() error</td>\n</tr>\n<tr>\n<td>blockExists(hash *chainhash.Hash) (bool, error)</td>\n</tr>\n<tr>\n<td>processOrphans(flags BehaviorFlags) (bool, error)</td>\n</tr>\n<tr>\n<td>ProcessBlock(block *soterutil.Block, flags BehaviorFlags) (bool, bool, error)</td>\n</tr>\n<tr>\n<td>maybeAcceptBlock(block *soterutil.Block, flags BehaviorFlags) (bool, error)</td>\n</tr>\n</tbody></table>\n<h4 id=\"dagview\"><a href=\"#dagview\" class=\"headerlink\" title=\"dagview\"></a>dagview</h4><table>\n<thead>\n<tr>\n<th>genesis() *blockNode</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Genesis() *blockNode</td>\n</tr>\n<tr>\n<td>tips() []*blockNode</td>\n</tr>\n<tr>\n<td>Tips() []*blockNode</td>\n</tr>\n<tr>\n<td>addTip(node *blockNode)</td>\n</tr>\n<tr>\n<td>AddTip(node *blockNode)</td>\n</tr>\n<tr>\n<td>checkAndAddNode(height int32, node *blockNode) bool</td>\n</tr>\n<tr>\n<td>removeTip(node *blockNode)</td>\n</tr>\n<tr>\n<td>RemoveTip(node *blockNode)</td>\n</tr>\n<tr>\n<td>containsAtHeight(height int32, node *blockNode) bool</td>\n</tr>\n<tr>\n<td>height() int32</td>\n</tr>\n<tr>\n<td>Height() int32</td>\n</tr>\n<tr>\n<td>nodesByHeight(height int32) []*blockNode</td>\n</tr>\n<tr>\n<td>NodesByHeight(height int32) []*blockNode</td>\n</tr>\n<tr>\n<td>virtualHash() *chainhash.Hash</td>\n</tr>\n<tr>\n<td>count() int</td>\n</tr>\n<tr>\n<td>Equals(other *dagView) bool</td>\n</tr>\n<tr>\n<td>contains(node *blockNode) bool</td>\n</tr>\n<tr>\n<td>Contains(node *blockNode) bool</td>\n</tr>\n<tr>\n<td>next(node *blockNode) *blockNode</td>\n</tr>\n<tr>\n<td>Next(node *blockNode) *blockNode</td>\n</tr>\n<tr>\n<td>blockLocator(node *blockNode) BlockLocator</td>\n</tr>\n<tr>\n<td>BlockLocator(node *blockNode) BlockLocator</td>\n</tr>\n</tbody></table>\n<h3 id=\"SPECTRE-共识协议\"><a href=\"#SPECTRE-共识协议\" class=\"headerlink\" title=\"SPECTRE 共识协议\"></a>SPECTRE 共识协议</h3><p>核心思想：<strong>丢弃主链概念，所有产生的区块共同构成账本，不丢弃任何一个区块，同时维护一个无冲突交易集合。</strong><br>只要是产生的区块就不会被丢弃，所有的区块都是有效的，所有区块共同组成账本，这样进一步提高了区块链的处理交易能力，<strong>该设计的关键在于设计算法来保证区块链不会被恶意攻击成功。</strong></p>\n<h4 id=\"如何产生区块\"><a href=\"#如何产生区块\" class=\"headerlink\" title=\"如何产生区块\"></a>如何产生区块</h4><p><strong>SPECTRE 协议中，当产生区块时，要从之前所有分叉的末端区块（入度为零,又称 tip）中挑选大于等于 2 个父块 hash 作为引用。</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// blockNode represents a block within the DAG</span><br><span class=\"hljs-keyword\">type</span> blockNode <span class=\"hljs-keyword\">struct</span> &#123;<br>\t<span class=\"hljs-comment\">// <span class=\"hljs-doctag\">NOTE:</span> Additions, deletions, or modifications to the order of the</span><br>\t<span class=\"hljs-comment\">// definitions in this struct should not be changed without considering</span><br>\t<span class=\"hljs-comment\">// how it affects alignment on 64-bit platforms.  The current order is</span><br>\t<span class=\"hljs-comment\">// specifically crafted to result in minimal padding.  There will be</span><br>\t<span class=\"hljs-comment\">// hundreds of thousands of these in memory, so a few extra bytes of</span><br>\t<span class=\"hljs-comment\">// padding adds up.</span><br><br>\t<span class=\"hljs-comment\">// parents are the parent block for this node.</span><br>\tparents []*blockNode<br><br>\t<span class=\"hljs-comment\">// parent metadata like version and extra data</span><br>\tparentMetadata []*parentInfo<br><br>\tparentVersion <span class=\"hljs-keyword\">int32</span><br><br>\t<span class=\"hljs-comment\">// hash is the double sha 256 of the block.</span><br>\thash chainhash.Hash<br><br>\t<span class=\"hljs-comment\">// workSum is the total amount of work in the chain up to and including</span><br>\t<span class=\"hljs-comment\">// this node.</span><br>\tworkSum *big.Int<br><br>\t<span class=\"hljs-comment\">// height is parentsMaxHeight + 1</span><br>\theight <span class=\"hljs-keyword\">int32</span><br><br>\t<span class=\"hljs-comment\">// Some fields from block headers to</span><br>\t<span class=\"hljs-comment\">// reconstruct headers from memory.  These must be treated as</span><br>\t<span class=\"hljs-comment\">// immutable and are intentionally ordered to avoid padding on 64-bit</span><br>\t<span class=\"hljs-comment\">// platforms.</span><br>\tversion    <span class=\"hljs-keyword\">int32</span><br>\tbits       <span class=\"hljs-keyword\">uint32</span><br>\tnonce      <span class=\"hljs-keyword\">uint32</span><br>\ttimestamp  <span class=\"hljs-keyword\">int64</span><br>\tmerkleRoot chainhash.Hash<br><br>&#125;<br><br><span class=\"hljs-keyword\">type</span> parentInfo <span class=\"hljs-keyword\">struct</span> &#123;<br>\thash chainhash.Hash<br>\tdata [<span class=\"hljs-number\">32</span>]<span class=\"hljs-keyword\">byte</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>当有新区块产生时，节点要立刻将新区块(包含基于哪些区块产生这一信息)发送给与自己相连接的节点。</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> DAGState <span class=\"hljs-keyword\">struct</span> &#123;<br>\tTips      []chainhash.Hash <span class=\"hljs-comment\">// Hash of the tip blocks</span><br>\tHash      chainhash.Hash <span class=\"hljs-comment\">//Hash of the tip hashes</span><br>\tMinHeight <span class=\"hljs-keyword\">int32</span><br>\tMaxHeight <span class=\"hljs-keyword\">int32</span><br>\tBlkCount  <span class=\"hljs-keyword\">uint32</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1616914229993-778efd1e-9f02-4746-b4e6-3891fd1f7c82.png#height=303&id=MOTgK&name=image.png&originHeight=362&originWidth=848&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=243838&status=done&style=none&title=&width=710\" alt=\"image.png\"><br>该协议下，挖矿节点只<strong>负责迅速挖区块</strong>(能够达到 1 秒一个区块)，而对分叉中可能包含的冲突交易在挖矿阶段并<strong>不做任何处理</strong>，将记录交易速度最大化，让 DAG 这种区块链有着恐怖的处理交易能力。</p>\n<h4 id=\"冲突解决\"><a href=\"#冲突解决\" class=\"headerlink\" title=\"冲突解决\"></a>冲突解决</h4><p>SPECTRE 的思路是设计一个计算投票的算法，让诚实区块会投票给诚实的区块，后边的诚实区块会给前边的<strong>堆叠算力</strong>，从而让恶意攻击失败，其安全算力也是<strong>51%**。<br>**算法是：</strong><br>对指定的块 z，考虑其对其他的块 x,y 的投票过程。<br>(1) 如果 z 的先行块是 x 不是 y，那么它将投票给 x。<br>(2) 如果 z 的先行块既是 x 也是 y，投票将取决于与 z 的可达块相同的虚拟块进行递归投票的结果。<br>(3) 如果 z 的先行块既不是 x 也不是 y，投票将取决于以 z 为先行块的大多数块的投票。<br>(4) 如果 z 是一个可以到达整个 DAG 的虚拟块，它将遵从 DAG 的大多数块来决定投票结果。<br>(5) 如果 z=x 或者 z=y，只要 x 与 y 之间互相不可达，它将投票给自己。<br>拿双花举例，下图中，X 和 Y 区块中包含着两条冲突交易会导致双花，此时 DAG 中的区块会对 X 和 Y 进行投票，<strong>决定哪一个交易有效。</strong><br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1616918388824-cb331dd8-b883-4bff-ad05-700b10a64f28.png#height=330&id=SE4Hx&name=image.png&originHeight=447&originWidth=823&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=213757&status=done&style=none&title=&width=608\" alt=\"image.png\">  <br>投票规则如下，投 X 的标蓝，投 Y 的标红，X&lt;Y 代表 X 先于 Y：</p>\n<ul>\n<li>X 后边的，<strong>只能到 X 的投 X</strong>，图中 6、7、8 投 X，同理 9、10、11 投 Y。</li>\n<li>X 后边的，<strong>能到 X 也能到 Y</strong>，根据上一次(图中虚线圈内)的投票结果投，12 投 X。</li>\n<li>不在 X、Y 后边的，<strong>根据自己后边所有的区块投哪个票多的投</strong>，1-5 区块投 X</li>\n<li>X、Y 投自己</li>\n</ul>\n<p>根据投票结果，X 中的那条交易信息<strong>有效</strong>，Y 中对应的那条交易信息<strong>无效</strong>。</p>\n<h4 id=\"可信交易集合\"><a href=\"#可信交易集合\" class=\"headerlink\" title=\"可信交易集合\"></a>可信交易集合</h4><p><strong>SPECTRE 可信交易集就相当于超过当前 6 个区块的比特币链里组成的交易集合。</strong><br>区块链从数字加密货币的角度来说，就是一个<strong>账本</strong>，从账本上的交易信息中得出每个<strong>账户</strong>所拥有的货币，所以，得出<strong>确定的、不可能更改</strong>的交易信息就至关重要，SPECTRE 可信交易集产生过程如下：</p>\n<ul>\n<li>遍历区块，依次提取交易信息，<strong>无冲突交易</strong>加入无冲突交易集。</li>\n<li>将<strong>导致账户余额不足的冲突交易</strong>加入冲突交易集。对应时空数据即相同时间的用户</li>\n<li>根据上边的投票算法，依次对冲突交易进行<strong>投票</strong>，产生冲突区块顺序集，决定哪一条交易有效。</li>\n<li>将投票<strong>有效</strong>的交易加入<strong>无冲突交易集</strong>。</li>\n<li>将无冲突交易集中超过一定时间的交易组建可信交易集，即该交易池交易信息<strong>基本不可能被篡改</strong>。</li>\n</ul>\n<p><strong>SPECTRE 并不会对所有区块进行排序，所有区块没有一个完整的线形顺序，有的只是决定冲突信息先后的区块顺序对。</strong></p>\n<p><strong>比特币中的高度</strong>代表的就是<strong>线形顺序</strong>，高度低的区块中交易信息<strong>先于</strong>高度高的区块里的信息，高度高的区块就不能<strong>包含和高度低的区块冲突的交易</strong>，而<strong>SPECTRE 有大量的分叉</strong>，区块高度不能代表线形顺序，前边的区块交易信息不一定先于后边的分叉区块交易信息，交易信息的<strong>有效性要由投票算法</strong>来决定。<br>区块投票算法很快，再加上它将<strong>所有分叉区块</strong>都包含进来，也就没有了比特币所面临的<strong>分叉风险</strong>(等待 6 个区块)，交易确认时间可以达到 10 秒。（我认为，一次投票的时间肯定低于 10s（即使它遍历了所有块），因此，只要投票成功，交易就被确认，因此效率非常高！）</p>\n<h3 id=\"DAG-区块链通信机制\"><a href=\"#DAG-区块链通信机制\" class=\"headerlink\" title=\"DAG 区块链通信机制\"></a>DAG 区块链通信机制</h3><h4 id=\"P2P-对等网络\"><a href=\"#P2P-对等网络\" class=\"headerlink\" title=\"P2P 对等网络\"></a>P2P 对等网络</h4><p>见书 19 页</p>\n<blockquote>\n<p>似乎应该放到前置知识？</p>\n</blockquote>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1617414711574-3c923c62-e148-45bc-874e-6da4cafcfd0a.png#height=278&id=f71iF&name=image.png&originHeight=555&originWidth=972&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=192050&status=done&style=none&title=&width=486\" alt=\"image.png\"><br>其他图详见：<a href=\"https://github.com/Blockchain-CN/blockchain\">https://github.com/Blockchain-CN/blockchain</a></p>\n<h4 id=\"网络结构及特性\"><a href=\"#网络结构及特性\" class=\"headerlink\" title=\"网络结构及特性\"></a>网络结构及特性</h4><p>从底层网络的角度来看，本作品的核心是基于 Gossip 协议的交易传播。这种机制意味着只要数据具有足够的权重，就能快速传播到整个网络中去。作品中的时空数据发布分五步完成：</p>\n<ul>\n<li>金字塔编码：通过多级金字塔编码，将时空数据划分进入多个层次，提高时空数据的细粒度；</li>\n<li>加入 Bloom 过滤器：将编码后的数据放入 Bloom 过滤器，并使用同态加密将 Bloom 数组进行加密处理；</li>\n<li>签名：采用自身私钥对加密结果进行签名；</li>\n<li>Tip 选择：采用马尔科夫链蒙特卡洛（MCMC）算法随机挑选 50 个未确认的交易并将它们打包进入区块；</li>\n<li>工作量证明（Proof of Work）：只是用于限制出块速率，防止网络堵塞。<blockquote>\n<p>见 p28</p>\n</blockquote>\n</li>\n</ul>\n<p>注意：比特币中，如果我想转账一笔 BTC，我会发出一个交易，并广播给周围的节点，周围节点验证后，继续广播，最后被矿工收到，打包进入区块，并把区块广播出来，同样的传遍整个网络，交易生效。</p>\n<p>而且通过比特币钱包，可以做到每次交易都更换地址，即生成不同的公钥私钥对，然后都指向同一个账户，这样可以避免被追踪。</p>\n<h4 id=\"掩码认证消息\"><a href=\"#掩码认证消息\" class=\"headerlink\" title=\"掩码认证消息\"></a>掩码认证消息</h4><p>由于本作品的数据发布是通过没有手续费的交易，因此可以在分布式账本中自由的发送消息，该消息可以占据交易中的字段，而普通交易中该字段是被发送者的签名所占据。默认情况下，这些消息对任何人都是可见的。而本项目采用掩码认证消息（MAM）加密消息，提供基于哈希的签名认证和完整性验证。</p>\n<h5 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h5><p>MAM 是一个附加的数据传输协议，在 DAG 上增加了发送和接受加密数据流的功能，且对设备的大小和成本没有限制。鉴于这些特性，MAM 满足了行业重要的需求，及完整性和私密性。用户可以在任意时间发布</p>\n<blockquote>\n<p>见 p29</p>\n</blockquote>\n<h1 id=\"写本子能用到的图\"><a href=\"#写本子能用到的图\" class=\"headerlink\" title=\"写本子能用到的图\"></a>写本子能用到的图</h1><p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1617440689986-4ebfa454-4b06-4fdc-99d3-c5b84c27c0db.png#height=320&id=Yqb4B&name=image.png&originHeight=639&originWidth=989&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=90760&status=done&style=none&title=&width=494.5\" alt=\"image.png\"><br>见：<a href=\"https://ledger.jd.com/architecturedesign.html\">https://ledger.jd.com/architecturedesign.html</a></p>\n<h1 id=\"存储层\"><a href=\"#存储层\" class=\"headerlink\" title=\"存储层\"></a>存储层</h1><p>【1】trillian/google<br><a href=\"https://www.jianshu.com/p/61e432d121f9\">https://www.jianshu.com/p/61e432d121f9</a><br><a href=\"https://blog.csdn.net/mutourend/article/details/113365448\">https://blog.csdn.net/mutourend/article/details/113365448</a><br><a href=\"https://my.oschina.net/u/3843525/blog/3175914\">https://my.oschina.net/u/3843525/blog/3175914</a><br>项目地址：<a href=\"https://github.com/google/trillian\">https://github.com/google/trillian</a><br>应用示例：<a href=\"https://github.com/google/trillian-examples\">https://github.com/google/trillian-examples</a><br>【2】<a href=\"https://github.com/vldmkr/merkle-patricia-trie\">https://github.com/vldmkr/merkle-patricia-trie</a> 这个接口非常干净简洁，竟然没人点 star</p>\n<p>这里有两篇解释性文档。提到了这些问题（未给出解决）：<br><a href=\"https://www.tangshuang.net/4097.html\">区块链中，交易被如何打包进区块</a></p>\n<ol>\n<li>在打包开始之前，这些交易记录是以什么方式存在于网络？</li>\n<li>打包是否会把所有交易记录打包进区块？怎么可能保证所有交易都不被遗漏？</li>\n<li>如何防止矿工伪造交易？将伪造的交易打包进区块？</li>\n</ol>\n<p><a href=\"https://www.tangshuang.net/4117.html\">区块链如何运用 merkle tree 验证交易真实性</a></p>\n<ul>\n<li>怎么从区块链里面查一个交易？</li>\n<li>怎么获取 merkle 验证路径？</li>\n<li>怎么确保网络上这个返回的验证路径不是伪造的？</li>\n</ul>\n<h1 id=\"激励层\"><a href=\"#激励层\" class=\"headerlink\" title=\"激励层\"></a>激励层</h1><p>为了能够把挖矿过程讲清楚，我们只拿比特币遵循的 PoW 来进行演示。</p>\n<blockquote>\n<p>SHA256(SHA256(version + prevHash + merkleRoot + time + currentDifficulty + nonce )) &lt; TARGET</p>\n</blockquote>\n<p>矿机执行上面公式，只要满足上面这个公式（执行结果为真），就算挖到矿。现在对这个公式进行解释。</p>\n<ol>\n<li>矿机会做一个 double sha256 的运算，运算的参数其实全部是块头里面的信息，但是因为这个时候区块还没有生成，所以这些信息是暂时保存的，如果抢到记账权，就把这些信息记录进去，因此，当你觉得一个区块的 hash 是否是作弊算出来的时候，用区块头里面的信息自己去算一遍，看看是不是能得到相同的 hash 就可以了，从一点上讲，挖矿也是不能作弊的，必须老老实实不停算</li>\n<li>version 是当前运行矿机的客户端软件版本，每次版本升级，可能对一些参数会有影响，比如区块大小从 1M 扩容到 2M，但是对于挖矿算法而言是不变的</li>\n<li>prevHash 是前一个区块的 hash 值</li>\n<li>merkleRoot 是当前矿机内存里暂存的交易的 merkle 算法得到的根 hash，merkle 会在下文讲</li>\n<li>time 是当前时间戳</li>\n<li>currentDifficulty 是当前难度，这个当前难度是由一个公式算出来的，这个公式是 <code>currentDifficulty = diff_1_target/TARGET</code> 这个公式里面的 diff_1_target 可以认为是一个常量，在比特币客户端里面是不变的，值为 0x1d00ffff。当然，其实它也有可能变，但怎么变都差不多这个值，我们还是把它当作常量。而 TARGET 我们在下面会讲到。</li>\n<li>nonce 是一个正整数，nonce 的值就算矿机要找的值。当矿机开始执行 double sha256 算法时，nonce 为 0，如果执行完一次，无法满足上面那个公式，那么 nonce 就自加 1，再执行一遍算法，如果不满足公式，继续加 1 再执行，就是这样一直加上去，直到找到一个 nonce 满足上面的公式，就算挖到矿。所以，这个 nonce 每一次挖矿都可能不一样，它是完全随机出现的，到底是多少完全看运气。但不管怎样，你看每个区块里面但 nonce 值，就知道矿机做了多少次运算，也就知道挖到矿有多难了。</li>\n<li>TARGET 是用以对比的目标值，它是一个特定值，比特币的发明者希望 10 分钟产生一个区块，所以最初设计的 TARGET 就是为了让 currentDifficulty 能够到一个合适的值，保证 10 分钟一个块。但是实际情况并不可能保证 10 分钟一定出一个块，如果算力下降，时间就会加长，这时就应该调整一下难度，使出块时间尽可能恢复在 10 分钟左右。所以 2016 个区块（2 周）TARGET 就会调整一次，而如果真实的情况是产生 2016 个区块的时间超过 2 周，那么 TARGET 就会适当增加，从而使 currentDifficulty 减小，下面 2016 个区块的难度就会降低一些。相反，则提高难度。这个调整算法本文就不展开了。所以 TARGET 是一个 2016 次不变，但总体而言一直在变的值，它的目标就是让产生一个区块的时间大概在 10 分钟左右。</li>\n</ol>","categories":[{"name":"区块链","path":"api/categories/区块链.json"}],"tags":[]}