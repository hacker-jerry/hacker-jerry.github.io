{"title":"wireshark抓包原理","slug":"wireshark抓包原理","date":"2021-04-10T02:43:22.000Z","updated":"2023-01-08T08:09:15.721Z","comments":true,"path":"api/articles/wireshark抓包原理.json","realPath":null,"excerpt":"这几天学院研究生复试，院长出了这道题，就是问了 wireshark 的抓包原理，由于我并不太清楚，所以特此记录。","covers":["https://cdn.nlark.com/yuque/0/2021/jpeg/1629942/1618023149469-2a296e81-a3c5-4c86-a35c-e855b0f96ad2.jpeg#align=left&display=inline&height=463&margin=%5Bobject%20Object%5D&originHeight=463&originWidth=1102&size=0&status=done&style=none&width=1102","https://cdn.nlark.com/yuque/0/2021/png/1629942/1618023234035-308938e5-9df1-49c9-a18c-cbf03eb49db6.png#align=left&display=inline&height=375&margin=%5Bobject%20Object%5D&name=image.png&originHeight=461&originWidth=814&size=234125&status=done&style=none&width=662","https://cdn.nlark.com/yuque/0/2021/png/1629942/1618127378381-8711b7dc-55aa-4883-8422-2d58c2d56c08.png#align=left&display=inline&height=265&margin=%5Bobject%20Object%5D&name=image.png&originHeight=265&originWidth=642&size=114805&status=done&style=none&width=642","https://cdn.nlark.com/yuque/0/2021/png/1629942/1618127469796-3243bc5d-73bb-4426-999a-357d79c4d9b1.png#align=left&display=inline&height=429&margin=%5Bobject%20Object%5D&name=image.png&originHeight=523&originWidth=828&size=203088&status=done&style=none&width=679","https://cdn.nlark.com/yuque/0/2021/png/1629942/1618127718780-137b5c86-7c50-48eb-ada4-13f1b3c07994.png#align=left&display=inline&height=219&margin=%5Bobject%20Object%5D&name=image.png&originHeight=438&originWidth=1550&size=714203&status=done&style=none&width=775","https://cdn.nlark.com/yuque/0/2021/png/1629942/1618127872003-dd2d8b5b-7109-4df7-9d92-d907317974eb.png#align=left&display=inline&height=215&margin=%5Bobject%20Object%5D&name=image.png&originHeight=430&originWidth=1547&size=653510&status=done&style=none&width=773.5"],"cover":"https://cdn.nlark.com/yuque/0/2021/jpeg/1629942/1618023149469-2a296e81-a3c5-4c86-a35c-e855b0f96ad2.jpeg#align=left&display=inline&height=463&margin=%5Bobject%20Object%5D&originHeight=463&originWidth=1102&size=0&status=done&style=none&width=1102","content":"<p>这几天学院研究生复试，院长出了这道题，就是问了 wireshark 的抓包原理，由于我并不太清楚，所以特此记录。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Wireshark\"><a href=\"#Wireshark\" class=\"headerlink\" title=\"Wireshark\"></a>Wireshark</h2><p><img src=\"https://cdn.nlark.com/yuque/0/2021/jpeg/1629942/1618023149469-2a296e81-a3c5-4c86-a35c-e855b0f96ad2.jpeg#align=left&display=inline&height=463&margin=%5Bobject%20Object%5D&originHeight=463&originWidth=1102&size=0&status=done&style=none&width=1102\"></p>\n<p>网络上传输的数据包<strong>通过网卡进入到网络协议分析器系统</strong>。即<strong>Wireshark 使用的网卡数据复制，只要是经过指定网卡都会被抓取</strong>。<br>  每一个协议分析器内部都维护有一个“<strong>跟踪缓冲区</strong>”内存空间区域。它用于<strong>暂存从网络上面复制而来的数据包流</strong>。数据包流从“捕获过滤器”流入到协议分析器的跟踪缓存区中，该缓冲区中的数据包能够在被捕获之后立即查看或是以其他文件格式保持到磁盘上面。比如 Wireshark 协议分析器工具，打开之后，点击[开始捕获]， 然后便可立刻查看捕获到的数据包信息。此时的这些数据包就是放在协议分析器的“跟踪缓冲区”中的。<br>协议分析器所使用的网卡和网卡驱动程序必须能够支持“<strong>混杂模式操作</strong>（Promiscuous Mode Operation）”。因为<strong>只有运行在混杂模式下的网卡才能够捕获到网络中传输到其他设备的“广播数据包、多播数据包、单播数据包以及错误数据包等等”（</strong>支持 VLAN ,单播，多播等），两者一起协同工作。<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1618023234035-308938e5-9df1-49c9-a18c-cbf03eb49db6.png#align=left&display=inline&height=375&margin=%5Bobject%20Object%5D&name=image.png&originHeight=461&originWidth=814&size=234125&status=done&style=none&width=662\" alt=\"image.png\"></p>\n<h3 id=\"混杂模式与监视模式区别\"><a href=\"#混杂模式与监视模式区别\" class=\"headerlink\" title=\"混杂模式与监视模式区别\"></a>混杂模式与监视模式区别</h3><p>要弄清混杂模式和监视模式之间的区别：<strong>监视模式仅用于无线卡</strong>，<strong>混杂模式用于无线和有线</strong>。 监控模式使卡无需关联接入点即可侦听无线数据包。 混杂模式使卡可以侦听所有数据包，即使不是针对特定的数据包。</p>\n<blockquote>\n<p>作者：圣手书生黎公子<br>链接：<a href=\"https://zhuanlan.zhihu.com/p/267640786\">https://zhuanlan.zhihu.com/p/267640786</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n</blockquote>\n<h1 id=\"ping-流程\"><a href=\"#ping-流程\" class=\"headerlink\" title=\"ping 流程\"></a>ping 流程</h1><p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1618127378381-8711b7dc-55aa-4883-8422-2d58c2d56c08.png#align=left&display=inline&height=265&margin=%5Bobject%20Object%5D&name=image.png&originHeight=265&originWidth=642&size=114805&status=done&style=none&width=642\" alt=\"image.png\"><br>在这里，我们搭建了一个 PC+交换机+路由器（文中又称网关）的本地网络</p>\n<p>在一开始，所有机器的 arp 表其实都是空的。<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1618127469796-3243bc5d-73bb-4426-999a-357d79c4d9b1.png#align=left&display=inline&height=429&margin=%5Bobject%20Object%5D&name=image.png&originHeight=523&originWidth=828&size=203088&status=done&style=none&width=679\" alt=\"image.png\"><br>而此时，让 PC 去进行 ping（使用 ICMP 协议）自己的网关 192.168.1.1，是可以通的。<br>为什么呢？<br>我们分析一下流程。</p>\n<ol>\n<li>PC 首先封装这个 ICMP 数据包，最里面是 ICMP 的数据，数据外面封装 IPV4 包头，IPV4 包头外面是帧头。格式如下：</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1618127718780-137b5c86-7c50-48eb-ada4-13f1b3c07994.png#align=left&display=inline&height=219&margin=%5Bobject%20Object%5D&name=image.png&originHeight=438&originWidth=1550&size=714203&status=done&style=none&width=775\" alt=\"image.png\"></p>\n<ol start=\"2\">\n<li>有个问题是，刚开始 ping 的时候，PC 的 ARP 表项是不知道目的 IP 所对应的 MAC 是多少，那么他怎么获取的呢。</li>\n</ol>\n<p>仔细看数据抓包，有一对 ARP 包：<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1618127872003-dd2d8b5b-7109-4df7-9d92-d907317974eb.png#align=left&display=inline&height=215&margin=%5Bobject%20Object%5D&name=image.png&originHeight=430&originWidth=1547&size=653510&status=done&style=none&width=773.5\" alt=\"image.png\"><br>就是在发 ICMP 包之前，系统先发了一个 ARP 包！<br>上面的 ARP 请求包大概意思是：我是 192.168.1.99，我的 MAC 是 aabb.cc00.3000，我想问 192.168.1.1 你的 MAC 是多少，收到请回复收到请回复。<br>在 ARP 请求的过程中，SW 已经学到了 PC 和 R1 的接口 MAC 地址，MAC 地址表项已经形成。<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1618127946335-3d26191d-d89f-49f9-a331-2fc558f5e4cd.png#align=left&display=inline&height=148&margin=%5Bobject%20Object%5D&name=image.png&originHeight=295&originWidth=747&size=233011&status=done&style=none&width=373.5\" alt=\"image.png\"><br>那么，他是怎么形成的呢？<br>第一步：<br>当 SW 通过 e0/0 端口收到 PC 发来的 ARP 广播包，PC 首先查看自己的 MAC 地址表项，看看数据帧的源 MAC 是否存在于我的 MAC 地址表中，如果没有，那么就直接把 ARP 广播包的源 MAC（aabb.cc00.3000）和接收端口 e0/0 对应起来，形成第一个 MAC 地址表的条目。如果有对应的 MAC 地址条目，SW 就看已经存在的条目和当前的收包端口是否一致，如果不一致就更新 MAC 地址表里面的条目，如果一致就直接泛洪转发这个广播数据帧。<br>第二步：SW 通过 e0/1 端口把这个数据帧发给 R1，R1 收到之后，形成 ARP 表项。<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1618128016114-6971d3ca-2137-4bbc-a82c-98505999e543.png#align=left&display=inline&height=62&margin=%5Bobject%20Object%5D&name=image.png&originHeight=124&originWidth=1131&size=180774&status=done&style=none&width=565.5\" alt=\"image.png\"><br>R1 拆开外面帧头看到目的 MAC 是自己（广播包本网段内所有人均可接收），R1 就继续拆包，拆开 ARP 头部，看到请求的 MAC 是自己的 IP 地址对应的 MAC，所以 R1 就响应这个 ARP 得请求包。<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1618128064981-d60ade96-4891-4eab-9150-1c1fe32d3e1f.png#align=left&display=inline&height=150&margin=%5Bobject%20Object%5D&name=image.png&originHeight=299&originWidth=1066&size=320679&status=done&style=none&width=533\" alt=\"image.png\"><br>第三步：响应的 ARP Reply 包发送到 SW 的 e0/1 口，SW1 把单播响应包源 MAC（aabb.cc00.1000）和自己的接收端口 e0/1 口对应起来，形成另外一条 MAC 地址表条目，然后查看到数据帧的目的 MAC 是 aabb.cc00.3000，SW 直接查找自己的 MAC 地址表，发现有对应的条目，直接通过 e0/0 口转发，PC 就收到了响应，获取到了 R1 的 e0/0 接口，也就是 PC 网关的 MAC。</p>\n","more":"<h2 id=\"Wireshark\"><a href=\"#Wireshark\" class=\"headerlink\" title=\"Wireshark\"></a>Wireshark</h2><p><img src=\"https://cdn.nlark.com/yuque/0/2021/jpeg/1629942/1618023149469-2a296e81-a3c5-4c86-a35c-e855b0f96ad2.jpeg#align=left&display=inline&height=463&margin=%5Bobject%20Object%5D&originHeight=463&originWidth=1102&size=0&status=done&style=none&width=1102\"></p>\n<p>网络上传输的数据包<strong>通过网卡进入到网络协议分析器系统</strong>。即<strong>Wireshark 使用的网卡数据复制，只要是经过指定网卡都会被抓取</strong>。<br>  每一个协议分析器内部都维护有一个“<strong>跟踪缓冲区</strong>”内存空间区域。它用于<strong>暂存从网络上面复制而来的数据包流</strong>。数据包流从“捕获过滤器”流入到协议分析器的跟踪缓存区中，该缓冲区中的数据包能够在被捕获之后立即查看或是以其他文件格式保持到磁盘上面。比如 Wireshark 协议分析器工具，打开之后，点击[开始捕获]， 然后便可立刻查看捕获到的数据包信息。此时的这些数据包就是放在协议分析器的“跟踪缓冲区”中的。<br>协议分析器所使用的网卡和网卡驱动程序必须能够支持“<strong>混杂模式操作</strong>（Promiscuous Mode Operation）”。因为<strong>只有运行在混杂模式下的网卡才能够捕获到网络中传输到其他设备的“广播数据包、多播数据包、单播数据包以及错误数据包等等”（</strong>支持 VLAN ,单播，多播等），两者一起协同工作。<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1618023234035-308938e5-9df1-49c9-a18c-cbf03eb49db6.png#align=left&display=inline&height=375&margin=%5Bobject%20Object%5D&name=image.png&originHeight=461&originWidth=814&size=234125&status=done&style=none&width=662\" alt=\"image.png\"></p>\n<h3 id=\"混杂模式与监视模式区别\"><a href=\"#混杂模式与监视模式区别\" class=\"headerlink\" title=\"混杂模式与监视模式区别\"></a>混杂模式与监视模式区别</h3><p>要弄清混杂模式和监视模式之间的区别：<strong>监视模式仅用于无线卡</strong>，<strong>混杂模式用于无线和有线</strong>。 监控模式使卡无需关联接入点即可侦听无线数据包。 混杂模式使卡可以侦听所有数据包，即使不是针对特定的数据包。</p>\n<blockquote>\n<p>作者：圣手书生黎公子<br>链接：<a href=\"https://zhuanlan.zhihu.com/p/267640786\">https://zhuanlan.zhihu.com/p/267640786</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n</blockquote>\n<h1 id=\"ping-流程\"><a href=\"#ping-流程\" class=\"headerlink\" title=\"ping 流程\"></a>ping 流程</h1><p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1618127378381-8711b7dc-55aa-4883-8422-2d58c2d56c08.png#align=left&display=inline&height=265&margin=%5Bobject%20Object%5D&name=image.png&originHeight=265&originWidth=642&size=114805&status=done&style=none&width=642\" alt=\"image.png\"><br>在这里，我们搭建了一个 PC+交换机+路由器（文中又称网关）的本地网络</p>\n<p>在一开始，所有机器的 arp 表其实都是空的。<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1618127469796-3243bc5d-73bb-4426-999a-357d79c4d9b1.png#align=left&display=inline&height=429&margin=%5Bobject%20Object%5D&name=image.png&originHeight=523&originWidth=828&size=203088&status=done&style=none&width=679\" alt=\"image.png\"><br>而此时，让 PC 去进行 ping（使用 ICMP 协议）自己的网关 192.168.1.1，是可以通的。<br>为什么呢？<br>我们分析一下流程。</p>\n<ol>\n<li>PC 首先封装这个 ICMP 数据包，最里面是 ICMP 的数据，数据外面封装 IPV4 包头，IPV4 包头外面是帧头。格式如下：</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1618127718780-137b5c86-7c50-48eb-ada4-13f1b3c07994.png#align=left&display=inline&height=219&margin=%5Bobject%20Object%5D&name=image.png&originHeight=438&originWidth=1550&size=714203&status=done&style=none&width=775\" alt=\"image.png\"></p>\n<ol start=\"2\">\n<li>有个问题是，刚开始 ping 的时候，PC 的 ARP 表项是不知道目的 IP 所对应的 MAC 是多少，那么他怎么获取的呢。</li>\n</ol>\n<p>仔细看数据抓包，有一对 ARP 包：<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1618127872003-dd2d8b5b-7109-4df7-9d92-d907317974eb.png#align=left&display=inline&height=215&margin=%5Bobject%20Object%5D&name=image.png&originHeight=430&originWidth=1547&size=653510&status=done&style=none&width=773.5\" alt=\"image.png\"><br>就是在发 ICMP 包之前，系统先发了一个 ARP 包！<br>上面的 ARP 请求包大概意思是：我是 192.168.1.99，我的 MAC 是 aabb.cc00.3000，我想问 192.168.1.1 你的 MAC 是多少，收到请回复收到请回复。<br>在 ARP 请求的过程中，SW 已经学到了 PC 和 R1 的接口 MAC 地址，MAC 地址表项已经形成。<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1618127946335-3d26191d-d89f-49f9-a331-2fc558f5e4cd.png#align=left&display=inline&height=148&margin=%5Bobject%20Object%5D&name=image.png&originHeight=295&originWidth=747&size=233011&status=done&style=none&width=373.5\" alt=\"image.png\"><br>那么，他是怎么形成的呢？<br>第一步：<br>当 SW 通过 e0/0 端口收到 PC 发来的 ARP 广播包，PC 首先查看自己的 MAC 地址表项，看看数据帧的源 MAC 是否存在于我的 MAC 地址表中，如果没有，那么就直接把 ARP 广播包的源 MAC（aabb.cc00.3000）和接收端口 e0/0 对应起来，形成第一个 MAC 地址表的条目。如果有对应的 MAC 地址条目，SW 就看已经存在的条目和当前的收包端口是否一致，如果不一致就更新 MAC 地址表里面的条目，如果一致就直接泛洪转发这个广播数据帧。<br>第二步：SW 通过 e0/1 端口把这个数据帧发给 R1，R1 收到之后，形成 ARP 表项。<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1618128016114-6971d3ca-2137-4bbc-a82c-98505999e543.png#align=left&display=inline&height=62&margin=%5Bobject%20Object%5D&name=image.png&originHeight=124&originWidth=1131&size=180774&status=done&style=none&width=565.5\" alt=\"image.png\"><br>R1 拆开外面帧头看到目的 MAC 是自己（广播包本网段内所有人均可接收），R1 就继续拆包，拆开 ARP 头部，看到请求的 MAC 是自己的 IP 地址对应的 MAC，所以 R1 就响应这个 ARP 得请求包。<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1618128064981-d60ade96-4891-4eab-9150-1c1fe32d3e1f.png#align=left&display=inline&height=150&margin=%5Bobject%20Object%5D&name=image.png&originHeight=299&originWidth=1066&size=320679&status=done&style=none&width=533\" alt=\"image.png\"><br>第三步：响应的 ARP Reply 包发送到 SW 的 e0/1 口，SW1 把单播响应包源 MAC（aabb.cc00.1000）和自己的接收端口 e0/1 口对应起来，形成另外一条 MAC 地址表条目，然后查看到数据帧的目的 MAC 是 aabb.cc00.3000，SW 直接查找自己的 MAC 地址表，发现有对应的条目，直接通过 e0/0 口转发，PC 就收到了响应，获取到了 R1 的 e0/0 接口，也就是 PC 网关的 MAC。</p>","categories":[],"tags":[]}