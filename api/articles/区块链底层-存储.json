{"title":"区块链底层-存储","slug":"区块链底层-存储","date":"2021-04-16T12:20:09.000Z","updated":"2022-02-07T08:56:41.210Z","comments":true,"path":"api/articles/区块链底层-存储.json","realPath":null,"excerpt":"本文聚焦区块链底层技术–存储技术。主要包含世界状态、账户状态和 MPT 树。<br>参考：https://learnblockchain.cn/books/geth/part3/statedb.html","covers":["https://cdn.nlark.com/yuque/0/2021/png/1629942/1618575710431-5b3c9d14-5230-49a7-95d4-045bca35bd54.png#clientId=u34e3a6f1-8d42-4&from=paste&height=136&id=u29593524&margin=%5Bobject%20Object%5D&originHeight=174&originWidth=955&originalType=url&status=done&style=none&taskId=ud67f5524-9e0a-474e-8ebf-a18abeb618d&width=747.5","https://cdn.nlark.com/yuque/0/2021/png/1629942/1618664027914-80262f2e-9aaf-460f-9d7e-0452241d3a9c.png#clientId=u34e3a6f1-8d42-4&from=paste&height=506&id=ufcde743f&margin=%5Bobject%20Object%5D&originHeight=1012&originWidth=936&originalType=url&status=done&style=none&taskId=u9036f292-bba3-41a2-a09a-3566a7f7e94&width=468"],"cover":"https://cdn.nlark.com/yuque/0/2021/png/1629942/1618575710431-5b3c9d14-5230-49a7-95d4-045bca35bd54.png#clientId=u34e3a6f1-8d42-4&from=paste&height=136&id=u29593524&margin=%5Bobject%20Object%5D&originHeight=174&originWidth=955&originalType=url&status=done&style=none&taskId=ud67f5524-9e0a-474e-8ebf-a18abeb618d&width=747.5","content":"<p>本文聚焦区块链底层技术–存储技术。主要包含世界状态、账户状态和 MPT 树。<br>参考：<a href=\"https://learnblockchain.cn/books/geth/part3/statedb.html\">https://learnblockchain.cn/books/geth/part3/statedb.html</a></p>\n<a id=\"more\"></a>\n\n<h1 id=\"StateDB-世界状态\"><a href=\"#StateDB-世界状态\" class=\"headerlink\" title=\"StateDB-世界状态\"></a>StateDB-世界状态</h1><p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1618575710431-5b3c9d14-5230-49a7-95d4-045bca35bd54.png#clientId=u34e3a6f1-8d42-4&from=paste&height=136&id=u29593524&margin=%5Bobject%20Object%5D&originHeight=174&originWidth=955&originalType=url&status=done&style=none&taskId=ud67f5524-9e0a-474e-8ebf-a18abeb618d&width=747.5\"><br>从程序设计角度，StateDB 有多种用途：</p>\n<ol>\n<li>维护账户状态到世界状态的映射。</li>\n<li>支持修改、回滚、提交状态。</li>\n<li>支持持久化状态到数据库中。</li>\n<li>是状态进出默克尔树的媒介。</li>\n</ol>\n<p>实际上** StateDB <strong>充当</strong>状态（数据）<strong>、</strong>Trie(树)<strong>、</strong>LevelDB（存储）**的协调者。</p>\n<h2 id=\"实例化-StateDB\"><a href=\"#实例化-StateDB\" class=\"headerlink\" title=\"实例化 StateDB\"></a>实例化 StateDB</h2><p>在对状态的任何操作前，我们要先构建一个 StateDB 来操作状态。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">db: = state.NewDatabase(levelDB)<br>statedb, err := state.New(block.Root(), db)<br></code></pre></td></tr></table></figure>\n\n<p>首先，我们要告诉 StateDB ，我们要使用哪个状态。因此<strong>需要提供 StateRoot 作为默克尔树根去构建树</strong>。StateRoot 值相当于数据版本号，根据版本号可以明确的知道要使用使用哪个版本的状态。当然，数据内容并没在树中，<strong>需要到一个数据库中读取</strong>。因此在构建 State DB 时需要提供 stateRoot 和 db 才能完成构建。<br>任何实现 state.Database 接口的 db 都可以使用</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// core/state/database.go:42</span><br><span class=\"hljs-keyword\">type</span> Database <span class=\"hljs-keyword\">interface</span> &#123;<br>\tOpenTrie(root common.Hash) (Trie, error)<br>\tOpenStorageTrie(addrHash, root common.Hash) (Trie, error)<br>\tCopyTrie(Trie) Trie<br>\tContractCode(addrHash, codeHash common.Hash) ([]<span class=\"hljs-keyword\">byte</span>, error)<br>\tContractCodeSize(addrHash, codeHash common.Hash) (<span class=\"hljs-keyword\">int</span>, error)<br><br>\t<span class=\"hljs-comment\">// TrieDB retrieves the low level trie database used for data storage.</span><br>\tTrieDB() *trie.Database<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>通过 db 可以访问：</p>\n<ol>\n<li>OpenTrie: 打开指定状态版本(root)的含世界状态的顶层树。</li>\n<li>OpenStorageTrie: <strong>打开账户(addrHash)下</strong>指定状态版本(root)的<strong>账户数据存储树</strong>。</li>\n<li>CopyTrie: 深度拷贝树。</li>\n<li>ContractCode：获取账户（addrHash）的合约，必须和合约哈希(codeHash)匹配。</li>\n<li>ContractCodeSize 获取指定合约大小</li>\n<li>TrieDB：<strong>获得 Trie 底层的数据驱动 DB</strong>，如:** levedDB** 、<strong>内存数据库</strong>、远程数据库</li>\n</ol>\n<p>当前有两种类型的 DB 实现了 Database 接口，轻节点使用的 odrDatabase ，和正常节点端使用的带有缓存的 cachingDB 。 因为轻节点并不存储数据，需要通过向其他节点查询来获得数据，而 odrDatabase 就是这种数据读取方式的封装。一个普通节点已内置 levelDB，为了提高读写性能，使用 cachingDB 对其进行一次封装。<br>在实例化 StateDB 时，需要立即打开含有世界状态的 Trie 树。如果 root 对应的树不存在，则会实例化失败 ①。实例化的 StateDB 中将记录多种信息。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">//core/state/statedb.go:59</span><br><span class=\"hljs-keyword\">type</span> StateDB <span class=\"hljs-keyword\">struct</span> &#123;<br>\tdb   Database<br>\ttrie Trie<br>\tstateObjects      <span class=\"hljs-keyword\">map</span>[common.Address]*stateObject<br>\tstateObjectsDirty <span class=\"hljs-keyword\">map</span>[common.Address]<span class=\"hljs-keyword\">struct</span>&#123;&#125;<br>\tdbErr error<br>\trefund <span class=\"hljs-keyword\">uint64</span><br><br>\tthash, bhash common.Hash<br>\ttxIndex      <span class=\"hljs-keyword\">int</span><br>\tlogs         <span class=\"hljs-keyword\">map</span>[common.Hash][]*types.Log<br>\tlogSize      <span class=\"hljs-keyword\">uint</span><br><br>\tpreimages <span class=\"hljs-keyword\">map</span>[common.Hash][]<span class=\"hljs-keyword\">byte</span><br>\tjournal        *journal<br>\tvalidRevisions []revision<br>\tnextRevisionId <span class=\"hljs-keyword\">int</span><br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>db: 操作状态的<strong>底层数据库</strong>，在实例化 StateDB 时指定 ②。</li>\n<li>trie: 世界状态所在的树实例对象，现在只有以太坊改进的默克尔前缀压缩树。</li>\n<li>stateObjects: <strong>已账户地址为键的账户状态对象，能够在内存中维护使用过的账户</strong>。</li>\n<li>stateObjectsDirty： 标记被修改过的账户。</li>\n<li>journal： 是修改状态的日志流水，使用此日志流水可回滚状态。</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">//core/state/statedb.go:92</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">New</span><span class=\"hljs-params\">(root common.Hash, db Database)</span> <span class=\"hljs-params\">(*StateDB, error)</span></span> &#123;<br>\ttr, err := db.OpenTrie(root)<span class=\"hljs-comment\">//①</span><br>\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>, err<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> &amp;StateDB&#123;<br>\t\tdb:                db,<span class=\"hljs-comment\">//②</span><br>\t\ttrie:              tr,<br>\t\tstateObjects:      <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[common.Address]*stateObject),<br>\t\tstateObjectsDirty: <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[common.Address]<span class=\"hljs-keyword\">struct</span>&#123;&#125;),<br>\t\tlogs:              <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[common.Hash][]*types.Log),<br>\t\tpreimages:         <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[common.Hash][]<span class=\"hljs-keyword\">byte</span>),<br>\t\tjournal:           newJournal(),<br>\t&#125;, <span class=\"hljs-literal\">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面对的代码实例化了一个 statedb。</p>\n<h2 id=\"读写-StateDB-状态\"><a href=\"#读写-StateDB-状态\" class=\"headerlink\" title=\"读写 StateDB 状态\"></a>读写 StateDB 状态</h2><p>你所访问的任何数据必然属于某个账户下的状态，世界状态态仅仅是通过一颗树来建立安全的映射。因此你所访问的数据可以分为如下几种类型：</p>\n<ol>\n<li>访问账户基础属性：Balance、Nonce、Root、CodeHash</li>\n<li>读取合约账户代码</li>\n<li>读取合约账户中存储内容</li>\n</ol>\n<p>在代码实现中，为了便于账户隔离管理，使用不开放的 stateObject 来维护。 stateObject 注意代码如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> stateObject <span class=\"hljs-keyword\">struct</span> &#123;<br>\taddress  common.Address<span class=\"hljs-comment\">//对应的账户地址</span><br>\taddrHash common.Hash <span class=\"hljs-comment\">// 账户地址的哈希值</span><br>\tdata     Account <span class=\"hljs-comment\">//账户属性</span><br>\tdb       *StateDB <span class=\"hljs-comment\">//底层数据库</span><br><br>    <span class=\"hljs-comment\">//...</span><br>\t<span class=\"hljs-comment\">// 写缓存</span><br>\ttrie Trie <span class=\"hljs-comment\">// 存储树，第一次访问时初始化</span><br>\tcode Code <span class=\"hljs-comment\">// contract bytecode, which gets set when code is loaded</span><br>    <span class=\"hljs-comment\">//...</span><br>&#125;<br><span class=\"hljs-keyword\">type</span> Account <span class=\"hljs-keyword\">struct</span> &#123;<br>\tNonce    <span class=\"hljs-keyword\">uint64</span><br>\tBalance  *big.Int<br>\tRoot     common.Hash <span class=\"hljs-comment\">// merkle root of the storage trie</span><br>\tCodeHash []<span class=\"hljs-keyword\">byte</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>可以看到 stateObject 中维护关于某个账户的所有信息，涉及账户地址、账户地址哈希、账户属性、底层数据库、存储树等内容。<br>当你访问状态时，需要指定账户地址。比如获取账户合约，合约账户代码，均是通过账户地址，获得获得对应的账户的 stateObject。因此，当你访问某账户余额时，需要从世界状态树 Trie 中读取账户状态。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// core/state/statedb.go:408</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *StateDB)</span> <span class=\"hljs-title\">getStateObject</span><span class=\"hljs-params\">(addr common.Address)</span> <span class=\"hljs-params\">(stateObject *stateObject)</span></span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> obj := self.stateObjects[addr]; obj != <span class=\"hljs-literal\">nil</span> &#123;<span class=\"hljs-comment\">//①</span><br>\t\t<span class=\"hljs-keyword\">if</span> obj.deleted &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span><br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">return</span> obj<br>\t&#125;<br><br>\tenc, err := self.trie.TryGet(addr[:])<span class=\"hljs-comment\">//②</span><br>\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(enc) == <span class=\"hljs-number\">0</span> &#123;<br>\t\tself.setError(err)<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">var</span> data Account<br>\t<span class=\"hljs-keyword\">if</span> err := rlp.DecodeBytes(enc, &amp;data); err != <span class=\"hljs-literal\">nil</span> &#123;<span class=\"hljs-comment\">//③</span><br>\t\tlog.Error(<span class=\"hljs-string\">&quot;Failed to decode state object&quot;</span>, <span class=\"hljs-string\">&quot;addr&quot;</span>, addr, <span class=\"hljs-string\">&quot;err&quot;</span>, err)<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span><br>\t&#125;<br>\tobj := newObject(self, addr, data)<span class=\"hljs-comment\">//④</span><br>\tself.setStateObject(obj)<br>\t<span class=\"hljs-keyword\">return</span> obj<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>state.getStateObject(addr)方法，将返回指定账户的 StateObject，不存在时 nil。<br>state 的 stateObject Map 中记录这从实例化 State 到当下，所有访问过的账户的 StateObject。 因此，获取 StateObject 时先从 map 缓存中检查是否已打开 ①，如果存在则返回。** 如果是第一次使用，则以账户地址为 key 从树中查找读取账户状态数据<strong>②。读取到的数据，是被 RLP 序列化过的，因此，在读取到数据后，还需要进行反序列化 ③。为了降低 IO 和在内存中维护可能被修改的 Account 信息，会将其组装成 **StateObjec ④ 存储在 State 实例</strong>中。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">//core/state/state_object.go:108</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">newObject</span><span class=\"hljs-params\">(db *StateDB, address common.Address, data Account)</span> *<span class=\"hljs-title\">stateObject</span></span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> data.Balance == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\tdata.Balance = <span class=\"hljs-built_in\">new</span>(big.Int)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> data.CodeHash == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\tdata.CodeHash = emptyCodeHash<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> &amp;stateObject&#123;<br>\t\tdb:            db,<br>\t\taddress:       address,<br>\t\taddrHash:      crypto.Keccak256Hash(address[:]),<span class=\"hljs-comment\">//⑤</span><br>\t\tdata:          data,<br>\t\toriginStorage: <span class=\"hljs-built_in\">make</span>(Storage),<br>\t\tdirtyStorage:  <span class=\"hljs-built_in\">make</span>(Storage),<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>newObject 就是将对 Account 的操作进行辅助，其中记录了账户地址、地址哈希 ⑤ 等内容，最终你读写状态都经过 stateObject 完成。</p>\n<h2 id=\"StateDB-完成持久化\"><a href=\"#StateDB-完成持久化\" class=\"headerlink\" title=\"StateDB 完成持久化\"></a>StateDB 完成持久化</h2><p>在区块中，将交易作为输入条件，来根据一系列动作修改状态。<br>在完成区块挖矿前，只是获得在内存中的状态树的 Root 值。 StateDB 可视为一个内存数据库，状态数据先在内存数据库中完成修改，所有关于状态的计算都在内存中完成。 在将区块持久化时完成有内存到数据库的更新存储，此更新属于增量更新，仅仅修改涉及到被修改部分。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// core/state/statedb.go:680</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(s *StateDB)</span> <span class=\"hljs-title\">Commit</span><span class=\"hljs-params\">(deleteEmptyObjects <span class=\"hljs-keyword\">bool</span>)</span> <span class=\"hljs-params\">(root common.Hash, err error)</span></span> &#123;<br>\t<span class=\"hljs-keyword\">defer</span> s.clearJournalAndRefund()<br><br>\t<span class=\"hljs-keyword\">for</span> addr := <span class=\"hljs-keyword\">range</span> s.journal.dirties &#123;<span class=\"hljs-comment\">//①⑧⑨⑩</span><br>\t\ts.stateObjectsDirty[addr] = <span class=\"hljs-keyword\">struct</span>&#123;&#125;&#123;&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> addr, stateObject := <span class=\"hljs-keyword\">range</span> s.stateObjects &#123;<span class=\"hljs-comment\">//②</span><br>\t\t_, isDirty := s.stateObjectsDirty[addr]<br>\t\t<span class=\"hljs-keyword\">switch</span> &#123;<br>\t\t<span class=\"hljs-keyword\">case</span> stateObject.suicided || (isDirty &amp;&amp; deleteEmptyObjects &amp;&amp; stateObject.empty()):<br>\t\t\t<span class=\"hljs-comment\">//③</span><br>\t\t\ts.deleteStateObject(stateObject)<br>\t\t<span class=\"hljs-keyword\">case</span> isDirty:<br>\t\t\t<span class=\"hljs-keyword\">if</span> stateObject.code != <span class=\"hljs-literal\">nil</span> &amp;&amp; stateObject.dirtyCode &#123;<span class=\"hljs-comment\">//④</span><br>\t\t\t\ts.db.TrieDB().InsertBlob(common.BytesToHash(stateObject.CodeHash()), stateObject.code)<br>\t\t\t\tstateObject.dirtyCode = <span class=\"hljs-literal\">false</span><br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> err := stateObject.CommitTrie(s.db); err != <span class=\"hljs-literal\">nil</span> &#123;<span class=\"hljs-comment\">//⑤</span><br>\t\t\t\t<span class=\"hljs-keyword\">return</span> common.Hash&#123;&#125;, err<br>\t\t\t&#125;<br>\t\t\ts.updateStateObject(stateObject)<span class=\"hljs-comment\">//⑥</span><br>\t\t&#125;<br>\t\t<span class=\"hljs-built_in\">delete</span>(s.stateObjectsDirty, addr)<br>\t&#125;<br>\t<span class=\"hljs-comment\">//...</span><br>\troot, err = s.trie.Commit(<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(leaf []<span class=\"hljs-keyword\">byte</span>, parent common.Hash)</span> <span class=\"hljs-title\">error</span></span> &#123;<span class=\"hljs-comment\">//⑦</span><br>\t\t<span class=\"hljs-keyword\">var</span> account Account<br>\t\t<span class=\"hljs-keyword\">if</span> err := rlp.DecodeBytes(leaf, &amp;account); err != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span><br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> account.Root != emptyRoot &#123;<br>\t\t\ts.db.TrieDB().Reference(account.Root, parent)<br>\t\t&#125;<br>\t\tcode := common.BytesToHash(account.CodeHash)<br>\t\t<span class=\"hljs-keyword\">if</span> code != emptyCode &#123;<br>\t\t\ts.db.TrieDB().Reference(code, parent)<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span><br>\t&#125;)<br>\t<span class=\"hljs-keyword\">return</span> root, err<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1618664027914-80262f2e-9aaf-460f-9d7e-0452241d3a9c.png#clientId=u34e3a6f1-8d42-4&from=paste&height=506&id=ufcde743f&margin=%5Bobject%20Object%5D&originHeight=1012&originWidth=936&originalType=url&status=done&style=none&taskId=u9036f292-bba3-41a2-a09a-3566a7f7e94&width=468\"><br>如上图所示，上半部分均属于内存操作，仅仅在 stateDB.Commit()时才将状态通过树提交到 leveldb 中。</p>\n<h1 id=\"MPT-默克尔压缩前缀树\"><a href=\"#MPT-默克尔压缩前缀树\" class=\"headerlink\" title=\"MPT-默克尔压缩前缀树\"></a>MPT-默克尔压缩前缀树</h1><p>是一种经过改良的、融合了默克尔树和前缀树两种树结构优点的数据结构，是以太坊中用来组织管理账户数据、生成交易集合哈希的重要数据结构。一个非叶节点存储在 leveldb 关系型数据库中，数据库中的 key 是节点的 RLP 编码的 sha3 哈希，value 是节点的 RLP 编码。想要获得一个非叶节点的子节点，只需要根据子节点的 hash 访问数据库获得节点的 RLP 编码，然后解码就行了。<br>以太坊有四种前缀树：</p>\n<ol>\n<li><strong>世界状态树包括了从地址到账户状态之间的映射。</strong> 世界状态树的根节点哈希值由区块保存（在 stateRoot 字段），它标示了区块创建时的当前状态。<strong>整个网络中只有一个世界状态树。</strong></li>\n<li><strong>账户存储树保存了与某一智能合约相关的数据信息。</strong>由账户状态保存账户存储树的根节点哈希值（在 storageRoot 字段）。<strong>每个账户都有一个账户存储树。</strong></li>\n<li><strong>交易树包含了一个区块中的所有交易信息。</strong>由区块头（在 transactionsRoot 区域）保存交易树的根节点哈希值。<strong>每个区块都有一棵交易树。</strong></li>\n<li><strong>交易收据树包含了一个区块中所有交易的收据信息。</strong>同样由区块头（在 receiptsRoot 区域）保存交易收据树的根节点哈希值；<strong>每个区块都有对应的交易收据树。</strong></li>\n</ol>\n","more":"<h1 id=\"StateDB-世界状态\"><a href=\"#StateDB-世界状态\" class=\"headerlink\" title=\"StateDB-世界状态\"></a>StateDB-世界状态</h1><p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1618575710431-5b3c9d14-5230-49a7-95d4-045bca35bd54.png#clientId=u34e3a6f1-8d42-4&from=paste&height=136&id=u29593524&margin=%5Bobject%20Object%5D&originHeight=174&originWidth=955&originalType=url&status=done&style=none&taskId=ud67f5524-9e0a-474e-8ebf-a18abeb618d&width=747.5\"><br>从程序设计角度，StateDB 有多种用途：</p>\n<ol>\n<li>维护账户状态到世界状态的映射。</li>\n<li>支持修改、回滚、提交状态。</li>\n<li>支持持久化状态到数据库中。</li>\n<li>是状态进出默克尔树的媒介。</li>\n</ol>\n<p>实际上** StateDB <strong>充当</strong>状态（数据）<strong>、</strong>Trie(树)<strong>、</strong>LevelDB（存储）**的协调者。</p>\n<h2 id=\"实例化-StateDB\"><a href=\"#实例化-StateDB\" class=\"headerlink\" title=\"实例化 StateDB\"></a>实例化 StateDB</h2><p>在对状态的任何操作前，我们要先构建一个 StateDB 来操作状态。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">db: = state.NewDatabase(levelDB)<br>statedb, err := state.New(block.Root(), db)<br></code></pre></td></tr></table></figure>\n\n<p>首先，我们要告诉 StateDB ，我们要使用哪个状态。因此<strong>需要提供 StateRoot 作为默克尔树根去构建树</strong>。StateRoot 值相当于数据版本号，根据版本号可以明确的知道要使用使用哪个版本的状态。当然，数据内容并没在树中，<strong>需要到一个数据库中读取</strong>。因此在构建 State DB 时需要提供 stateRoot 和 db 才能完成构建。<br>任何实现 state.Database 接口的 db 都可以使用</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// core/state/database.go:42</span><br><span class=\"hljs-keyword\">type</span> Database <span class=\"hljs-keyword\">interface</span> &#123;<br>\tOpenTrie(root common.Hash) (Trie, error)<br>\tOpenStorageTrie(addrHash, root common.Hash) (Trie, error)<br>\tCopyTrie(Trie) Trie<br>\tContractCode(addrHash, codeHash common.Hash) ([]<span class=\"hljs-keyword\">byte</span>, error)<br>\tContractCodeSize(addrHash, codeHash common.Hash) (<span class=\"hljs-keyword\">int</span>, error)<br><br>\t<span class=\"hljs-comment\">// TrieDB retrieves the low level trie database used for data storage.</span><br>\tTrieDB() *trie.Database<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>通过 db 可以访问：</p>\n<ol>\n<li>OpenTrie: 打开指定状态版本(root)的含世界状态的顶层树。</li>\n<li>OpenStorageTrie: <strong>打开账户(addrHash)下</strong>指定状态版本(root)的<strong>账户数据存储树</strong>。</li>\n<li>CopyTrie: 深度拷贝树。</li>\n<li>ContractCode：获取账户（addrHash）的合约，必须和合约哈希(codeHash)匹配。</li>\n<li>ContractCodeSize 获取指定合约大小</li>\n<li>TrieDB：<strong>获得 Trie 底层的数据驱动 DB</strong>，如:** levedDB** 、<strong>内存数据库</strong>、远程数据库</li>\n</ol>\n<p>当前有两种类型的 DB 实现了 Database 接口，轻节点使用的 odrDatabase ，和正常节点端使用的带有缓存的 cachingDB 。 因为轻节点并不存储数据，需要通过向其他节点查询来获得数据，而 odrDatabase 就是这种数据读取方式的封装。一个普通节点已内置 levelDB，为了提高读写性能，使用 cachingDB 对其进行一次封装。<br>在实例化 StateDB 时，需要立即打开含有世界状态的 Trie 树。如果 root 对应的树不存在，则会实例化失败 ①。实例化的 StateDB 中将记录多种信息。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">//core/state/statedb.go:59</span><br><span class=\"hljs-keyword\">type</span> StateDB <span class=\"hljs-keyword\">struct</span> &#123;<br>\tdb   Database<br>\ttrie Trie<br>\tstateObjects      <span class=\"hljs-keyword\">map</span>[common.Address]*stateObject<br>\tstateObjectsDirty <span class=\"hljs-keyword\">map</span>[common.Address]<span class=\"hljs-keyword\">struct</span>&#123;&#125;<br>\tdbErr error<br>\trefund <span class=\"hljs-keyword\">uint64</span><br><br>\tthash, bhash common.Hash<br>\ttxIndex      <span class=\"hljs-keyword\">int</span><br>\tlogs         <span class=\"hljs-keyword\">map</span>[common.Hash][]*types.Log<br>\tlogSize      <span class=\"hljs-keyword\">uint</span><br><br>\tpreimages <span class=\"hljs-keyword\">map</span>[common.Hash][]<span class=\"hljs-keyword\">byte</span><br>\tjournal        *journal<br>\tvalidRevisions []revision<br>\tnextRevisionId <span class=\"hljs-keyword\">int</span><br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>db: 操作状态的<strong>底层数据库</strong>，在实例化 StateDB 时指定 ②。</li>\n<li>trie: 世界状态所在的树实例对象，现在只有以太坊改进的默克尔前缀压缩树。</li>\n<li>stateObjects: <strong>已账户地址为键的账户状态对象，能够在内存中维护使用过的账户</strong>。</li>\n<li>stateObjectsDirty： 标记被修改过的账户。</li>\n<li>journal： 是修改状态的日志流水，使用此日志流水可回滚状态。</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">//core/state/statedb.go:92</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">New</span><span class=\"hljs-params\">(root common.Hash, db Database)</span> <span class=\"hljs-params\">(*StateDB, error)</span></span> &#123;<br>\ttr, err := db.OpenTrie(root)<span class=\"hljs-comment\">//①</span><br>\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>, err<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> &amp;StateDB&#123;<br>\t\tdb:                db,<span class=\"hljs-comment\">//②</span><br>\t\ttrie:              tr,<br>\t\tstateObjects:      <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[common.Address]*stateObject),<br>\t\tstateObjectsDirty: <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[common.Address]<span class=\"hljs-keyword\">struct</span>&#123;&#125;),<br>\t\tlogs:              <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[common.Hash][]*types.Log),<br>\t\tpreimages:         <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[common.Hash][]<span class=\"hljs-keyword\">byte</span>),<br>\t\tjournal:           newJournal(),<br>\t&#125;, <span class=\"hljs-literal\">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面对的代码实例化了一个 statedb。</p>\n<h2 id=\"读写-StateDB-状态\"><a href=\"#读写-StateDB-状态\" class=\"headerlink\" title=\"读写 StateDB 状态\"></a>读写 StateDB 状态</h2><p>你所访问的任何数据必然属于某个账户下的状态，世界状态态仅仅是通过一颗树来建立安全的映射。因此你所访问的数据可以分为如下几种类型：</p>\n<ol>\n<li>访问账户基础属性：Balance、Nonce、Root、CodeHash</li>\n<li>读取合约账户代码</li>\n<li>读取合约账户中存储内容</li>\n</ol>\n<p>在代码实现中，为了便于账户隔离管理，使用不开放的 stateObject 来维护。 stateObject 注意代码如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> stateObject <span class=\"hljs-keyword\">struct</span> &#123;<br>\taddress  common.Address<span class=\"hljs-comment\">//对应的账户地址</span><br>\taddrHash common.Hash <span class=\"hljs-comment\">// 账户地址的哈希值</span><br>\tdata     Account <span class=\"hljs-comment\">//账户属性</span><br>\tdb       *StateDB <span class=\"hljs-comment\">//底层数据库</span><br><br>    <span class=\"hljs-comment\">//...</span><br>\t<span class=\"hljs-comment\">// 写缓存</span><br>\ttrie Trie <span class=\"hljs-comment\">// 存储树，第一次访问时初始化</span><br>\tcode Code <span class=\"hljs-comment\">// contract bytecode, which gets set when code is loaded</span><br>    <span class=\"hljs-comment\">//...</span><br>&#125;<br><span class=\"hljs-keyword\">type</span> Account <span class=\"hljs-keyword\">struct</span> &#123;<br>\tNonce    <span class=\"hljs-keyword\">uint64</span><br>\tBalance  *big.Int<br>\tRoot     common.Hash <span class=\"hljs-comment\">// merkle root of the storage trie</span><br>\tCodeHash []<span class=\"hljs-keyword\">byte</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>可以看到 stateObject 中维护关于某个账户的所有信息，涉及账户地址、账户地址哈希、账户属性、底层数据库、存储树等内容。<br>当你访问状态时，需要指定账户地址。比如获取账户合约，合约账户代码，均是通过账户地址，获得获得对应的账户的 stateObject。因此，当你访问某账户余额时，需要从世界状态树 Trie 中读取账户状态。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// core/state/statedb.go:408</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *StateDB)</span> <span class=\"hljs-title\">getStateObject</span><span class=\"hljs-params\">(addr common.Address)</span> <span class=\"hljs-params\">(stateObject *stateObject)</span></span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> obj := self.stateObjects[addr]; obj != <span class=\"hljs-literal\">nil</span> &#123;<span class=\"hljs-comment\">//①</span><br>\t\t<span class=\"hljs-keyword\">if</span> obj.deleted &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span><br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">return</span> obj<br>\t&#125;<br><br>\tenc, err := self.trie.TryGet(addr[:])<span class=\"hljs-comment\">//②</span><br>\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(enc) == <span class=\"hljs-number\">0</span> &#123;<br>\t\tself.setError(err)<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">var</span> data Account<br>\t<span class=\"hljs-keyword\">if</span> err := rlp.DecodeBytes(enc, &amp;data); err != <span class=\"hljs-literal\">nil</span> &#123;<span class=\"hljs-comment\">//③</span><br>\t\tlog.Error(<span class=\"hljs-string\">&quot;Failed to decode state object&quot;</span>, <span class=\"hljs-string\">&quot;addr&quot;</span>, addr, <span class=\"hljs-string\">&quot;err&quot;</span>, err)<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span><br>\t&#125;<br>\tobj := newObject(self, addr, data)<span class=\"hljs-comment\">//④</span><br>\tself.setStateObject(obj)<br>\t<span class=\"hljs-keyword\">return</span> obj<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>state.getStateObject(addr)方法，将返回指定账户的 StateObject，不存在时 nil。<br>state 的 stateObject Map 中记录这从实例化 State 到当下，所有访问过的账户的 StateObject。 因此，获取 StateObject 时先从 map 缓存中检查是否已打开 ①，如果存在则返回。** 如果是第一次使用，则以账户地址为 key 从树中查找读取账户状态数据<strong>②。读取到的数据，是被 RLP 序列化过的，因此，在读取到数据后，还需要进行反序列化 ③。为了降低 IO 和在内存中维护可能被修改的 Account 信息，会将其组装成 **StateObjec ④ 存储在 State 实例</strong>中。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">//core/state/state_object.go:108</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">newObject</span><span class=\"hljs-params\">(db *StateDB, address common.Address, data Account)</span> *<span class=\"hljs-title\">stateObject</span></span> &#123;<br>\t<span class=\"hljs-keyword\">if</span> data.Balance == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\tdata.Balance = <span class=\"hljs-built_in\">new</span>(big.Int)<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> data.CodeHash == <span class=\"hljs-literal\">nil</span> &#123;<br>\t\tdata.CodeHash = emptyCodeHash<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> &amp;stateObject&#123;<br>\t\tdb:            db,<br>\t\taddress:       address,<br>\t\taddrHash:      crypto.Keccak256Hash(address[:]),<span class=\"hljs-comment\">//⑤</span><br>\t\tdata:          data,<br>\t\toriginStorage: <span class=\"hljs-built_in\">make</span>(Storage),<br>\t\tdirtyStorage:  <span class=\"hljs-built_in\">make</span>(Storage),<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>newObject 就是将对 Account 的操作进行辅助，其中记录了账户地址、地址哈希 ⑤ 等内容，最终你读写状态都经过 stateObject 完成。</p>\n<h2 id=\"StateDB-完成持久化\"><a href=\"#StateDB-完成持久化\" class=\"headerlink\" title=\"StateDB 完成持久化\"></a>StateDB 完成持久化</h2><p>在区块中，将交易作为输入条件，来根据一系列动作修改状态。<br>在完成区块挖矿前，只是获得在内存中的状态树的 Root 值。 StateDB 可视为一个内存数据库，状态数据先在内存数据库中完成修改，所有关于状态的计算都在内存中完成。 在将区块持久化时完成有内存到数据库的更新存储，此更新属于增量更新，仅仅修改涉及到被修改部分。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// core/state/statedb.go:680</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(s *StateDB)</span> <span class=\"hljs-title\">Commit</span><span class=\"hljs-params\">(deleteEmptyObjects <span class=\"hljs-keyword\">bool</span>)</span> <span class=\"hljs-params\">(root common.Hash, err error)</span></span> &#123;<br>\t<span class=\"hljs-keyword\">defer</span> s.clearJournalAndRefund()<br><br>\t<span class=\"hljs-keyword\">for</span> addr := <span class=\"hljs-keyword\">range</span> s.journal.dirties &#123;<span class=\"hljs-comment\">//①⑧⑨⑩</span><br>\t\ts.stateObjectsDirty[addr] = <span class=\"hljs-keyword\">struct</span>&#123;&#125;&#123;&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> addr, stateObject := <span class=\"hljs-keyword\">range</span> s.stateObjects &#123;<span class=\"hljs-comment\">//②</span><br>\t\t_, isDirty := s.stateObjectsDirty[addr]<br>\t\t<span class=\"hljs-keyword\">switch</span> &#123;<br>\t\t<span class=\"hljs-keyword\">case</span> stateObject.suicided || (isDirty &amp;&amp; deleteEmptyObjects &amp;&amp; stateObject.empty()):<br>\t\t\t<span class=\"hljs-comment\">//③</span><br>\t\t\ts.deleteStateObject(stateObject)<br>\t\t<span class=\"hljs-keyword\">case</span> isDirty:<br>\t\t\t<span class=\"hljs-keyword\">if</span> stateObject.code != <span class=\"hljs-literal\">nil</span> &amp;&amp; stateObject.dirtyCode &#123;<span class=\"hljs-comment\">//④</span><br>\t\t\t\ts.db.TrieDB().InsertBlob(common.BytesToHash(stateObject.CodeHash()), stateObject.code)<br>\t\t\t\tstateObject.dirtyCode = <span class=\"hljs-literal\">false</span><br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> err := stateObject.CommitTrie(s.db); err != <span class=\"hljs-literal\">nil</span> &#123;<span class=\"hljs-comment\">//⑤</span><br>\t\t\t\t<span class=\"hljs-keyword\">return</span> common.Hash&#123;&#125;, err<br>\t\t\t&#125;<br>\t\t\ts.updateStateObject(stateObject)<span class=\"hljs-comment\">//⑥</span><br>\t\t&#125;<br>\t\t<span class=\"hljs-built_in\">delete</span>(s.stateObjectsDirty, addr)<br>\t&#125;<br>\t<span class=\"hljs-comment\">//...</span><br>\troot, err = s.trie.Commit(<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(leaf []<span class=\"hljs-keyword\">byte</span>, parent common.Hash)</span> <span class=\"hljs-title\">error</span></span> &#123;<span class=\"hljs-comment\">//⑦</span><br>\t\t<span class=\"hljs-keyword\">var</span> account Account<br>\t\t<span class=\"hljs-keyword\">if</span> err := rlp.DecodeBytes(leaf, &amp;account); err != <span class=\"hljs-literal\">nil</span> &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span><br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> account.Root != emptyRoot &#123;<br>\t\t\ts.db.TrieDB().Reference(account.Root, parent)<br>\t\t&#125;<br>\t\tcode := common.BytesToHash(account.CodeHash)<br>\t\t<span class=\"hljs-keyword\">if</span> code != emptyCode &#123;<br>\t\t\ts.db.TrieDB().Reference(code, parent)<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span><br>\t&#125;)<br>\t<span class=\"hljs-keyword\">return</span> root, err<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/1629942/1618664027914-80262f2e-9aaf-460f-9d7e-0452241d3a9c.png#clientId=u34e3a6f1-8d42-4&from=paste&height=506&id=ufcde743f&margin=%5Bobject%20Object%5D&originHeight=1012&originWidth=936&originalType=url&status=done&style=none&taskId=u9036f292-bba3-41a2-a09a-3566a7f7e94&width=468\"><br>如上图所示，上半部分均属于内存操作，仅仅在 stateDB.Commit()时才将状态通过树提交到 leveldb 中。</p>\n<h1 id=\"MPT-默克尔压缩前缀树\"><a href=\"#MPT-默克尔压缩前缀树\" class=\"headerlink\" title=\"MPT-默克尔压缩前缀树\"></a>MPT-默克尔压缩前缀树</h1><p>是一种经过改良的、融合了默克尔树和前缀树两种树结构优点的数据结构，是以太坊中用来组织管理账户数据、生成交易集合哈希的重要数据结构。一个非叶节点存储在 leveldb 关系型数据库中，数据库中的 key 是节点的 RLP 编码的 sha3 哈希，value 是节点的 RLP 编码。想要获得一个非叶节点的子节点，只需要根据子节点的 hash 访问数据库获得节点的 RLP 编码，然后解码就行了。<br>以太坊有四种前缀树：</p>\n<ol>\n<li><strong>世界状态树包括了从地址到账户状态之间的映射。</strong> 世界状态树的根节点哈希值由区块保存（在 stateRoot 字段），它标示了区块创建时的当前状态。<strong>整个网络中只有一个世界状态树。</strong></li>\n<li><strong>账户存储树保存了与某一智能合约相关的数据信息。</strong>由账户状态保存账户存储树的根节点哈希值（在 storageRoot 字段）。<strong>每个账户都有一个账户存储树。</strong></li>\n<li><strong>交易树包含了一个区块中的所有交易信息。</strong>由区块头（在 transactionsRoot 区域）保存交易树的根节点哈希值。<strong>每个区块都有一棵交易树。</strong></li>\n<li><strong>交易收据树包含了一个区块中所有交易的收据信息。</strong>同样由区块头（在 receiptsRoot 区域）保存交易收据树的根节点哈希值；<strong>每个区块都有对应的交易收据树。</strong></li>\n</ol>","categories":[],"tags":[]}