{"title":"排序","slug":"排序","date":"2021-06-18T07:20:40.000Z","updated":"2022-02-07T09:48:37.579Z","comments":true,"path":"api/articles/排序.json","realPath":null,"excerpt":"把各类排序做一遍梳理。","covers":["https://cdn.nlark.com/yuque/0/2021/gif/1629942/1624000947793-fff1bd3e-dd53-4884-bbc8-918dec271a9c.gif#height=387&id=u26cb77fa&margin=%5Bobject%20Object%5D&originHeight=538&originWidth=955&originalType=binary%E2%88%B6=1&status=done&style=none&width=687"],"cover":"https://cdn.nlark.com/yuque/0/2021/gif/1629942/1624000947793-fff1bd3e-dd53-4884-bbc8-918dec271a9c.gif#height=387&id=u26cb77fa&margin=%5Bobject%20Object%5D&originHeight=538&originWidth=955&originalType=binary%E2%88%B6=1&status=done&style=none&width=687","content":"<p>把各类排序做一遍梳理。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//bubble sort</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> num[])</span></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> length = <span class=\"hljs-keyword\">sizeof</span>(num)/<span class=\"hljs-keyword\">sizeof</span>(num[<span class=\"hljs-number\">0</span>]);<span class=\"hljs-comment\">//获取数组长度</span><br>    <span class=\"hljs-keyword\">int</span> temp;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i  = <span class=\"hljs-number\">0</span>;i &lt; length<span class=\"hljs-number\">-1</span>; i++)&#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j&lt; length<span class=\"hljs-number\">-1</span>-i; j++)&#123;<span class=\"hljs-comment\">//注意这里，每一轮j比前一轮到达的位置递减</span><br>            <span class=\"hljs-keyword\">if</span>(num[j] &gt; num[j+<span class=\"hljs-number\">1</span>])&#123;<br>                temp = num[j];<br>                num[j] = num[j+<span class=\"hljs-number\">1</span>];<br>                num[j+<span class=\"hljs-number\">1</span>] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>双层循环，时间复杂度是 O(n2)。</p>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p><strong>比如说给你一个有序的数组，或者是部分有序的数组，你怎么把它的运行时间降下来</strong><br>我们可以设置一个标记位，如果在某一轮中从来没有交换过前后两个数，我们认为此时就已经有序了，没必要再进行之后的循环了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">int</span> length = <span class=\"hljs-keyword\">sizeof</span>(num)/<span class=\"hljs-keyword\">sizeof</span>(num[<span class=\"hljs-number\">0</span>]);<span class=\"hljs-comment\">//注意，计算数组长度必须要在main函数里面，而不能将num做参数传递之后再计算。</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">OptimizeSort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> num[],<span class=\"hljs-keyword\">int</span> length)</span></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> temp;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; length - <span class=\"hljs-number\">1</span> ; i++)&#123;<br>        <span class=\"hljs-keyword\">bool</span> flag = <span class=\"hljs-literal\">true</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; length - <span class=\"hljs-number\">1</span> -i; j++)&#123;<br>            <span class=\"hljs-keyword\">if</span>(num[j] &gt; num[j+<span class=\"hljs-number\">1</span>])&#123;<br>                temp = num[j];<br>                num[j] = num[j+<span class=\"hljs-number\">1</span>];<br>                num[j+<span class=\"hljs-number\">1</span>] = temp;<br>                flag = <span class=\"hljs-literal\">false</span>;<br>            &#125;<br>        &#125;<br>          <span class=\"hljs-keyword\">if</span>(flag)&#123;<span class=\"hljs-comment\">//经过一轮后，flag标志没有改变，说明有序，可以退出循环</span><br>              <span class=\"hljs-keyword\">break</span>;<br>          &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>当将数组作为实参传递到另一个函数中时, 另一个函数的形参相当于一个指针变量, 因为将数组的名作为实参时, 就是<strong>将数字的首地址作为实参</strong>, 所以在 test 函数中输出的<strong>sizeof(arr)其实得到的是一个整型数组指针的长度</strong>(所占的字节数), 所以结果是 8, 再用其除以 int 所占的字节数(4), 结果就是 2。ps：这里 sizeof(&amp;arr)=8，sizeof(arr)=实际长度*4<br>要想用函数计算数组的长度，可以使用函数模板。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">count</span><span class=\"hljs-params\">(T&amp; x)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> s1 = <span class=\"hljs-keyword\">sizeof</span>(x);<br>    <span class=\"hljs-keyword\">int</span> s2 = <span class=\"hljs-keyword\">sizeof</span>(x[<span class=\"hljs-number\">0</span>]);<br>    <span class=\"hljs-keyword\">int</span> result = s1 / s2;<br>    <span class=\"hljs-keyword\">return</span> result;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> a[] = &#123; <span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span> &#125;;<br>    <span class=\"hljs-built_in\">cout</span> &lt;&lt; count(a);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>为什么可以呢？首先我们需要知道函数模板是什么。</p>\n<h3 id=\"函数模板\"><a href=\"#函数模板\" class=\"headerlink\" title=\"函数模板\"></a>函数模板</h3><p><strong>函数模板不是一个实在的函数，编译器不能为其生成可执行代码。定义函数模板后只是一个对函数功能框架的描述，当它具体执行时，将根据传递的实际参数决定其功能。</strong><br>C++ 语言支持模板。有了模板，可以只写一个 Swap 模板，编译器会根据 Swap 模板自动生成多个 Sawp 函数，用以交换不同类型变量的值。<br>函数模板的写法如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> 类型参数1, <span class=\"hljs-title\">class</span>类型参数2, ...&gt;</span><br><span class=\"hljs-class\">返回值类型  模板名(形参表)</span><br><span class=\"hljs-class\">&#123;</span><br>    函数体<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>具体示例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">T</span>&gt;</span><br><span class=\"hljs-class\"><span class=\"hljs-title\">void</span> <span class=\"hljs-title\">Swap</span>(<span class=\"hljs-title\">T</span> &amp; <span class=\"hljs-title\">x</span>, <span class=\"hljs-title\">T</span> &amp; <span class=\"hljs-title\">y</span>)</span><br><span class=\"hljs-class\">&#123;</span><br>    T tmp = x;<br>    x = y;<br>    y = tmp;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>就像这样，它用 T 代替了普通函数定义中的数据类型，代表一种泛化类型。<br>T 是类型参数，代表类型。<br>编译器由模板自动生成函数时，会用具体的类型名对模板中所有的类型参数进行替换，其他部分则原封不动地保留。同一个类型参数只能替换为同一种类型。编译器在编译到调用函数模板的语句时，会根据实参的类型判断该如何替换模板中的类型参数。</p>\n<h1 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h1><p>首先，找到数组中最小的元素，拎出来，将它和数组的第一个元素交换位置，第二步，在剩下的元素中继续寻找最小的元素，拎出来，和数组的第二个元素交换位置，如此循环，直到整个数组排序完成。<br><img src=\"https://cdn.nlark.com/yuque/0/2021/gif/1629942/1624000947793-fff1bd3e-dd53-4884-bbc8-918dec271a9c.gif#height=387&id=u26cb77fa&margin=%5Bobject%20Object%5D&originHeight=538&originWidth=955&originalType=binary%E2%88%B6=1&status=done&style=none&width=687\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"> <span class=\"hljs-keyword\">int</span> length = <span class=\"hljs-keyword\">sizeof</span>(num)/<span class=\"hljs-keyword\">sizeof</span>(num[<span class=\"hljs-number\">0</span>]);<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">SelectSort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> num[],<span class=\"hljs-keyword\">int</span> length)</span></span>&#123;<br><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; length;i++)&#123;<br>        <span class=\"hljs-keyword\">int</span> min = i;<span class=\"hljs-comment\">//只需要记录最小值的位置即可！</span><br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = i+<span class=\"hljs-number\">1</span>; j &lt; length;j++)&#123;<br>            <span class=\"hljs-keyword\">if</span> (num[min] &gt; num[j])&#123;<br>                min = j;<span class=\"hljs-comment\">//更新最小位置</span><br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span>(i!=min)&#123;<br>            <span class=\"hljs-keyword\">int</span> temp = num[min];<br>            num[min] = num[i];<br>            num[i] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>双层循环，时间复杂度和冒泡一模一样，都是 O(n2)。</p>\n<p>#</p>\n<h1 id=\"STL-库函数-sort\"><a href=\"#STL-库函数-sort\" class=\"headerlink\" title=\"STL 库函数 sort\"></a>STL 库函数 sort</h1><p>编写 C++经常需要使用 sort 进行排序，有可能是简单的数组、数字 vector 或者是复杂一点的存放对象的 vector。<br>C++为了满足用户的需求，在 algorithm 里面封装了 sort 泛型算法。所以使用时，必须<code>#include &lt; algorithm&gt;</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RandomAccessIterator</span>&gt;</span><br><span class=\"hljs-class\">\t<span class=\"hljs-title\">void</span> <span class=\"hljs-title\">sort</span> (<span class=\"hljs-title\">RandomAccessIterator</span> <span class=\"hljs-title\">first</span>, <span class=\"hljs-title\">RandomAccessIterator</span> <span class=\"hljs-title\">last</span>);</span><br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RandomAccessIterator</span>, <span class=\"hljs-title\">class</span> <span class=\"hljs-title\">Compare</span>&gt;</span><br><span class=\"hljs-class\">\t<span class=\"hljs-title\">void</span> <span class=\"hljs-title\">sort</span> (<span class=\"hljs-title\">RandomAccessIterator</span> <span class=\"hljs-title\">first</span>, <span class=\"hljs-title\">RandomAccessIterator</span> <span class=\"hljs-title\">last</span>, <span class=\"hljs-title\">Compare</span> <span class=\"hljs-title\">comp</span>);</span><br></code></pre></td></tr></table></figure>\n\n<p>可以看见，sort 原型分为两个，区别在于第一个函数有两个参数，第一个函数有三个参数。<br>其中两个函数都有的是 <code>RandomAccessIterator</code> 是随机访问迭代器，first 是初始位置，last 是末尾位置，默认使用迭代器引用的 <code>operator &lt; </code>进行排序。<br>第二个函数，前两个参数一样，也是用来说明从哪儿到哪儿排序。第三个参数是<code>Compare</code>，意思是使用 comp 这个“方法”对对象进行排序。<code>comp</code>可以是函数对象或者是函数指针。</p>\n<h2 id=\"默认情况\"><a href=\"#默认情况\" class=\"headerlink\" title=\"默认情况\"></a>默认情况</h2><ul>\n<li>两个参数</li>\n</ul>\n<p>使用两个参数这应该是最普遍也是最简单的情景，如果只有两个参数，默认使用 operator &lt; 对数组排序，结果为<strong>升序</strong>。</p>\n<h3 id=\"对数组排序\"><a href=\"#对数组排序\" class=\"headerlink\" title=\"对数组排序\"></a>对数组排序</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">int</span> arr[] = &#123; <span class=\"hljs-number\">9</span>,<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">1</span> &#125;;<br>sort(arr, arr + <span class=\"hljs-number\">9</span>);<br></code></pre></td></tr></table></figure>\n\n<p>需要注意的是，这里传入的是迭代器，所以要传入头指针和末尾指针（最后一个待排元素的后一个位置）,数组的话，变量名就是起始地址。</p>\n<h3 id=\"对-vector-排序\"><a href=\"#对-vector-排序\" class=\"headerlink\" title=\"对 vector 排序\"></a>对 vector 排序</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; arr;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">9</span>;i &gt;<span class=\"hljs-number\">0</span>;i--)&#123;<br>    arr.push_back(i);<br>&#125;<br>sort(arr.begin(),arr.end());<br></code></pre></td></tr></table></figure>\n\n<p>这里直接传入 vector 的 begin 和 end 两个迭代器就对整个 vector 完成了排序。</p>\n<h3 id=\"对对象排序\"><a href=\"#对对象排序\" class=\"headerlink\" title=\"对对象排序\"></a>对对象排序</h3><p>如果<strong>只使用两个参数的话</strong>，要对对象排序，那么<strong>只能依靠重载运算符</strong>来实现。而且必须<strong>重载的是 &lt; 关系运算符</strong>。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-keyword\">int</span> value;<br>    Test() : value(<span class=\"hljs-number\">0</span>) &#123;&#125;;<br>    Test(<span class=\"hljs-keyword\">int</span> x) : value(x) &#123;&#125;;<br><br>    <span class=\"hljs-comment\">// 重载运算符</span><br>    <span class=\"hljs-keyword\">bool</span> <span class=\"hljs-keyword\">operator</span> &lt; (<span class=\"hljs-keyword\">const</span> Test&amp; t) &#123;<br>        <span class=\"hljs-keyword\">if</span> (value &lt; t.value)<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br><br>\t<span class=\"hljs-built_in\">vector</span>&lt;Test&gt; arr;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">9</span>; i &gt; <span class=\"hljs-number\">0</span>; i--) &#123;<br>  \t  arr.push_back(Test(i));<br>\t&#125;<br>\tsort(arr.begin(), arr.end());<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i =<span class=\"hljs-number\">0</span>;i&lt;arr.size();i++)&#123;<br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d &quot;</span>,arr[i]);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这样，就根据 Test 类中 value 的值来升序排对象的顺序了。</p>\n<h3 id=\"三个参数排序\"><a href=\"#三个参数排序\" class=\"headerlink\" title=\"三个参数排序\"></a>三个参数排序</h3><p>先不写了</p>\n<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1><ol>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzI5MzYzMDAwNw==%E2%88%A3=2247486587&idx=1&sn=7becbafba2658a4c6bf901ee65dd5277&chksm=ec6e7523db19fc358cdaac6686d4d4c5c36309b69352c33f71ece38b90fef50394a5c004cb84&mpshare=1&scene=1&srcid=\">https://mp.weixin.qq.com/s?__biz=MzI5MzYzMDAwNw==∣=2247486587&amp;idx=1&amp;sn=7becbafba2658a4c6bf901ee65dd5277&amp;chksm=ec6e7523db19fc358cdaac6686d4d4c5c36309b69352c33f71ece38b90fef50394a5c004cb84&amp;mpshare=1&amp;scene=1&amp;srcid=</a></li>\n<li>视频 | 手撕九大经典排序算法，看我就够了！ - 力扣（LeetCode）的文章 - 知乎 <a href=\"https://zhuanlan.zhihu.com/p/52884590\">https://zhuanlan.zhihu.com/p/52884590</a></li>\n<li><a href=\"https://blog.csdn.net/qq_46018418/article/details/106341404\">https://blog.csdn.net/qq_46018418/article/details/106341404</a></li>\n<li><a href=\"https://www.cnblogs.com/scyq/p/13053177.html\">https://www.cnblogs.com/scyq/p/13053177.html</a></li>\n</ol>\n","more":"<h1 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//bubble sort</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> num[])</span></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> length = <span class=\"hljs-keyword\">sizeof</span>(num)/<span class=\"hljs-keyword\">sizeof</span>(num[<span class=\"hljs-number\">0</span>]);<span class=\"hljs-comment\">//获取数组长度</span><br>    <span class=\"hljs-keyword\">int</span> temp;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i  = <span class=\"hljs-number\">0</span>;i &lt; length<span class=\"hljs-number\">-1</span>; i++)&#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j&lt; length<span class=\"hljs-number\">-1</span>-i; j++)&#123;<span class=\"hljs-comment\">//注意这里，每一轮j比前一轮到达的位置递减</span><br>            <span class=\"hljs-keyword\">if</span>(num[j] &gt; num[j+<span class=\"hljs-number\">1</span>])&#123;<br>                temp = num[j];<br>                num[j] = num[j+<span class=\"hljs-number\">1</span>];<br>                num[j+<span class=\"hljs-number\">1</span>] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>双层循环，时间复杂度是 O(n2)。</p>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p><strong>比如说给你一个有序的数组，或者是部分有序的数组，你怎么把它的运行时间降下来</strong><br>我们可以设置一个标记位，如果在某一轮中从来没有交换过前后两个数，我们认为此时就已经有序了，没必要再进行之后的循环了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">int</span> length = <span class=\"hljs-keyword\">sizeof</span>(num)/<span class=\"hljs-keyword\">sizeof</span>(num[<span class=\"hljs-number\">0</span>]);<span class=\"hljs-comment\">//注意，计算数组长度必须要在main函数里面，而不能将num做参数传递之后再计算。</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">OptimizeSort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> num[],<span class=\"hljs-keyword\">int</span> length)</span></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> temp;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; length - <span class=\"hljs-number\">1</span> ; i++)&#123;<br>        <span class=\"hljs-keyword\">bool</span> flag = <span class=\"hljs-literal\">true</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; length - <span class=\"hljs-number\">1</span> -i; j++)&#123;<br>            <span class=\"hljs-keyword\">if</span>(num[j] &gt; num[j+<span class=\"hljs-number\">1</span>])&#123;<br>                temp = num[j];<br>                num[j] = num[j+<span class=\"hljs-number\">1</span>];<br>                num[j+<span class=\"hljs-number\">1</span>] = temp;<br>                flag = <span class=\"hljs-literal\">false</span>;<br>            &#125;<br>        &#125;<br>          <span class=\"hljs-keyword\">if</span>(flag)&#123;<span class=\"hljs-comment\">//经过一轮后，flag标志没有改变，说明有序，可以退出循环</span><br>              <span class=\"hljs-keyword\">break</span>;<br>          &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>当将数组作为实参传递到另一个函数中时, 另一个函数的形参相当于一个指针变量, 因为将数组的名作为实参时, 就是<strong>将数字的首地址作为实参</strong>, 所以在 test 函数中输出的<strong>sizeof(arr)其实得到的是一个整型数组指针的长度</strong>(所占的字节数), 所以结果是 8, 再用其除以 int 所占的字节数(4), 结果就是 2。ps：这里 sizeof(&amp;arr)=8，sizeof(arr)=实际长度*4<br>要想用函数计算数组的长度，可以使用函数模板。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">count</span><span class=\"hljs-params\">(T&amp; x)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> s1 = <span class=\"hljs-keyword\">sizeof</span>(x);<br>    <span class=\"hljs-keyword\">int</span> s2 = <span class=\"hljs-keyword\">sizeof</span>(x[<span class=\"hljs-number\">0</span>]);<br>    <span class=\"hljs-keyword\">int</span> result = s1 / s2;<br>    <span class=\"hljs-keyword\">return</span> result;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> a[] = &#123; <span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span> &#125;;<br>    <span class=\"hljs-built_in\">cout</span> &lt;&lt; count(a);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>为什么可以呢？首先我们需要知道函数模板是什么。</p>\n<h3 id=\"函数模板\"><a href=\"#函数模板\" class=\"headerlink\" title=\"函数模板\"></a>函数模板</h3><p><strong>函数模板不是一个实在的函数，编译器不能为其生成可执行代码。定义函数模板后只是一个对函数功能框架的描述，当它具体执行时，将根据传递的实际参数决定其功能。</strong><br>C++ 语言支持模板。有了模板，可以只写一个 Swap 模板，编译器会根据 Swap 模板自动生成多个 Sawp 函数，用以交换不同类型变量的值。<br>函数模板的写法如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> 类型参数1, <span class=\"hljs-title\">class</span>类型参数2, ...&gt;</span><br><span class=\"hljs-class\">返回值类型  模板名(形参表)</span><br><span class=\"hljs-class\">&#123;</span><br>    函数体<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>具体示例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">T</span>&gt;</span><br><span class=\"hljs-class\"><span class=\"hljs-title\">void</span> <span class=\"hljs-title\">Swap</span>(<span class=\"hljs-title\">T</span> &amp; <span class=\"hljs-title\">x</span>, <span class=\"hljs-title\">T</span> &amp; <span class=\"hljs-title\">y</span>)</span><br><span class=\"hljs-class\">&#123;</span><br>    T tmp = x;<br>    x = y;<br>    y = tmp;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>就像这样，它用 T 代替了普通函数定义中的数据类型，代表一种泛化类型。<br>T 是类型参数，代表类型。<br>编译器由模板自动生成函数时，会用具体的类型名对模板中所有的类型参数进行替换，其他部分则原封不动地保留。同一个类型参数只能替换为同一种类型。编译器在编译到调用函数模板的语句时，会根据实参的类型判断该如何替换模板中的类型参数。</p>\n<h1 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h1><p>首先，找到数组中最小的元素，拎出来，将它和数组的第一个元素交换位置，第二步，在剩下的元素中继续寻找最小的元素，拎出来，和数组的第二个元素交换位置，如此循环，直到整个数组排序完成。<br><img src=\"https://cdn.nlark.com/yuque/0/2021/gif/1629942/1624000947793-fff1bd3e-dd53-4884-bbc8-918dec271a9c.gif#height=387&id=u26cb77fa&margin=%5Bobject%20Object%5D&originHeight=538&originWidth=955&originalType=binary%E2%88%B6=1&status=done&style=none&width=687\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"> <span class=\"hljs-keyword\">int</span> length = <span class=\"hljs-keyword\">sizeof</span>(num)/<span class=\"hljs-keyword\">sizeof</span>(num[<span class=\"hljs-number\">0</span>]);<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">SelectSort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> num[],<span class=\"hljs-keyword\">int</span> length)</span></span>&#123;<br><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; length;i++)&#123;<br>        <span class=\"hljs-keyword\">int</span> min = i;<span class=\"hljs-comment\">//只需要记录最小值的位置即可！</span><br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = i+<span class=\"hljs-number\">1</span>; j &lt; length;j++)&#123;<br>            <span class=\"hljs-keyword\">if</span> (num[min] &gt; num[j])&#123;<br>                min = j;<span class=\"hljs-comment\">//更新最小位置</span><br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span>(i!=min)&#123;<br>            <span class=\"hljs-keyword\">int</span> temp = num[min];<br>            num[min] = num[i];<br>            num[i] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>双层循环，时间复杂度和冒泡一模一样，都是 O(n2)。</p>\n<p>#</p>\n<h1 id=\"STL-库函数-sort\"><a href=\"#STL-库函数-sort\" class=\"headerlink\" title=\"STL 库函数 sort\"></a>STL 库函数 sort</h1><p>编写 C++经常需要使用 sort 进行排序，有可能是简单的数组、数字 vector 或者是复杂一点的存放对象的 vector。<br>C++为了满足用户的需求，在 algorithm 里面封装了 sort 泛型算法。所以使用时，必须<code>#include &lt; algorithm&gt;</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RandomAccessIterator</span>&gt;</span><br><span class=\"hljs-class\">\t<span class=\"hljs-title\">void</span> <span class=\"hljs-title\">sort</span> (<span class=\"hljs-title\">RandomAccessIterator</span> <span class=\"hljs-title\">first</span>, <span class=\"hljs-title\">RandomAccessIterator</span> <span class=\"hljs-title\">last</span>);</span><br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RandomAccessIterator</span>, <span class=\"hljs-title\">class</span> <span class=\"hljs-title\">Compare</span>&gt;</span><br><span class=\"hljs-class\">\t<span class=\"hljs-title\">void</span> <span class=\"hljs-title\">sort</span> (<span class=\"hljs-title\">RandomAccessIterator</span> <span class=\"hljs-title\">first</span>, <span class=\"hljs-title\">RandomAccessIterator</span> <span class=\"hljs-title\">last</span>, <span class=\"hljs-title\">Compare</span> <span class=\"hljs-title\">comp</span>);</span><br></code></pre></td></tr></table></figure>\n\n<p>可以看见，sort 原型分为两个，区别在于第一个函数有两个参数，第一个函数有三个参数。<br>其中两个函数都有的是 <code>RandomAccessIterator</code> 是随机访问迭代器，first 是初始位置，last 是末尾位置，默认使用迭代器引用的 <code>operator &lt; </code>进行排序。<br>第二个函数，前两个参数一样，也是用来说明从哪儿到哪儿排序。第三个参数是<code>Compare</code>，意思是使用 comp 这个“方法”对对象进行排序。<code>comp</code>可以是函数对象或者是函数指针。</p>\n<h2 id=\"默认情况\"><a href=\"#默认情况\" class=\"headerlink\" title=\"默认情况\"></a>默认情况</h2><ul>\n<li>两个参数</li>\n</ul>\n<p>使用两个参数这应该是最普遍也是最简单的情景，如果只有两个参数，默认使用 operator &lt; 对数组排序，结果为<strong>升序</strong>。</p>\n<h3 id=\"对数组排序\"><a href=\"#对数组排序\" class=\"headerlink\" title=\"对数组排序\"></a>对数组排序</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">int</span> arr[] = &#123; <span class=\"hljs-number\">9</span>,<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">1</span> &#125;;<br>sort(arr, arr + <span class=\"hljs-number\">9</span>);<br></code></pre></td></tr></table></figure>\n\n<p>需要注意的是，这里传入的是迭代器，所以要传入头指针和末尾指针（最后一个待排元素的后一个位置）,数组的话，变量名就是起始地址。</p>\n<h3 id=\"对-vector-排序\"><a href=\"#对-vector-排序\" class=\"headerlink\" title=\"对 vector 排序\"></a>对 vector 排序</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-keyword\">int</span>&gt; arr;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">9</span>;i &gt;<span class=\"hljs-number\">0</span>;i--)&#123;<br>    arr.push_back(i);<br>&#125;<br>sort(arr.begin(),arr.end());<br></code></pre></td></tr></table></figure>\n\n<p>这里直接传入 vector 的 begin 和 end 两个迭代器就对整个 vector 完成了排序。</p>\n<h3 id=\"对对象排序\"><a href=\"#对对象排序\" class=\"headerlink\" title=\"对对象排序\"></a>对对象排序</h3><p>如果<strong>只使用两个参数的话</strong>，要对对象排序，那么<strong>只能依靠重载运算符</strong>来实现。而且必须<strong>重载的是 &lt; 关系运算符</strong>。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-keyword\">int</span> value;<br>    Test() : value(<span class=\"hljs-number\">0</span>) &#123;&#125;;<br>    Test(<span class=\"hljs-keyword\">int</span> x) : value(x) &#123;&#125;;<br><br>    <span class=\"hljs-comment\">// 重载运算符</span><br>    <span class=\"hljs-keyword\">bool</span> <span class=\"hljs-keyword\">operator</span> &lt; (<span class=\"hljs-keyword\">const</span> Test&amp; t) &#123;<br>        <span class=\"hljs-keyword\">if</span> (value &lt; t.value)<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br><br>\t<span class=\"hljs-built_in\">vector</span>&lt;Test&gt; arr;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">9</span>; i &gt; <span class=\"hljs-number\">0</span>; i--) &#123;<br>  \t  arr.push_back(Test(i));<br>\t&#125;<br>\tsort(arr.begin(), arr.end());<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i =<span class=\"hljs-number\">0</span>;i&lt;arr.size();i++)&#123;<br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d &quot;</span>,arr[i]);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这样，就根据 Test 类中 value 的值来升序排对象的顺序了。</p>\n<h3 id=\"三个参数排序\"><a href=\"#三个参数排序\" class=\"headerlink\" title=\"三个参数排序\"></a>三个参数排序</h3><p>先不写了</p>\n<h1 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h1><ol>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzI5MzYzMDAwNw==%E2%88%A3=2247486587&idx=1&sn=7becbafba2658a4c6bf901ee65dd5277&chksm=ec6e7523db19fc358cdaac6686d4d4c5c36309b69352c33f71ece38b90fef50394a5c004cb84&mpshare=1&scene=1&srcid=\">https://mp.weixin.qq.com/s?__biz=MzI5MzYzMDAwNw==∣=2247486587&amp;idx=1&amp;sn=7becbafba2658a4c6bf901ee65dd5277&amp;chksm=ec6e7523db19fc358cdaac6686d4d4c5c36309b69352c33f71ece38b90fef50394a5c004cb84&amp;mpshare=1&amp;scene=1&amp;srcid=</a></li>\n<li>视频 | 手撕九大经典排序算法，看我就够了！ - 力扣（LeetCode）的文章 - 知乎 <a href=\"https://zhuanlan.zhihu.com/p/52884590\">https://zhuanlan.zhihu.com/p/52884590</a></li>\n<li><a href=\"https://blog.csdn.net/qq_46018418/article/details/106341404\">https://blog.csdn.net/qq_46018418/article/details/106341404</a></li>\n<li><a href=\"https://www.cnblogs.com/scyq/p/13053177.html\">https://www.cnblogs.com/scyq/p/13053177.html</a></li>\n</ol>","categories":[{"name":"PAT","path":"api/categories/PAT.json"}],"tags":[]}